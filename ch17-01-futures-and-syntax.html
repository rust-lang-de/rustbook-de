<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Futures und die asynchrone Syntax - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris-d33b75bf.css">
        <link rel="stylesheet" href="theme/2018-edition-4e126c62.css">
        <link rel="stylesheet" href="theme/semantic-notes-9b5766c0.css">
        <link rel="stylesheet" href="theme/listing-cab26221.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5070249d.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h2 id="futures-und-die-asynchrone-syntax"><a class="header" href="#futures-und-die-asynchrone-syntax">Futures und die asynchrone Syntax</a></h2>
<p>Die Schlüsselelemente der asynchronen Programmierung in Rust sind <em>Futures</em> und
die Rust-Schlüsselwörter <code>async</code> und <code>await</code>.</p>
<p>Ein <em>Future</em> ist ein Wert, der vielleicht noch nicht verfügbar ist, aber
irgendwann in der Zukunft verfügbar sein wird. (Das gleiche Konzept taucht in
vielen Programmiersprachen auf, manchmal unter anderen Namen wie „task“ oder
„promise“.) Rust hat ein Merkmal <code>Future</code> als Baustein, sodass verschiedene
asynchrone Operationen mit verschiedenen Datenstrukturen, aber mit einer
gemeinsamen Schnittstelle implementiert werden können. In Rust sind Futures
Typen, die das Merkmal <code>Future</code> implementieren. Jedes Future hält seine eigenen
Informationen über den Fortschritt, der gemacht wurde und was „fertig“
bedeutet.</p>
<p>Das Schlüsselwort <code>async</code> kann auf Blöcke und Funktionen angewendet werden, um
anzugeben, dass sie unterbrochen und fortgesetzt werden können. Innerhalb eines
asynchronen Blocks oder einer asynchronen Funktion kannst du mit dem
Schlüsselwort <code>await</code> auf ein Future warten (d.h. warten bis es fertig ist).
Jede Stelle, an der du innerhalb eines asynchronen Blocks oder einer
asynchronen Funktion auf ein Future wartest, ist eine Stelle, an der der
Block oder die Funktion unterbrochen und fortgesetzt werden kann. Der Vorgang,
bei dem bei einem Future geprüft wird, ob sein Wert bereits verfügbar ist, wird
<em>polling</em> (engl. Abfragen) genannt.</p>
<p>Andere Sprachen wie C# und JavaScript verwenden ebenfalls die Schlüsselwörter
<code>async</code> und <code>await</code> für die asynchrone Programmierung. Wenn du mit diesen
Sprachen vertraut bist, wirst du vielleicht einige signifikante Unterschiede
bemerken, wie Rust die Syntax handhabt. Und das aus gutem Grund, wie wir sehen
werden!</p>
<p>Wenn wir asynchrones Rust schreiben, verwenden wir meistens die Schlüsselwörter
<code>async</code> und <code>await</code>. Rust kompiliert sie in äquivalenten Code unter Verwendung
des Merkmals <code>Future</code>, genauso wie es <code>for</code>-Schleifen in äquivalenten Code
unter Verwendung des Merkmals <code>Iterator</code> kompiliert. Da Rust das Merkmal
<code>Future</code> bereitstellt, kannst du es bei Bedarf auch für deine eigenen
Datentypen implementieren. Viele der Funktionen, die wir in diesem Kapitel
sehen werden, geben Typen mit ihren eigenen Implementierungen von <code>Future</code>
zurück. Wir werden am Ende des Kapitels noch einmal auf die Definition des
Merkmals zurückkommen und mehr darüber erfahren, wie es funktioniert. Aber das
sind vorerst genug Details, die wir brauchen.</p>
<p>Das mag sich alles ein wenig abstrakt anfühlen, lass uns daher unser erstes
asynchrones Programm schreiben: Einen kleinen Web Scraper. Wir geben zwei URLs
über die Befehlszeile ein, rufen beide gleichzeitig ab und geben das Ergebnis
desjenigen zurück, der zuerst fertig wird. Dieses Beispiel wird eine neue
Syntax verwenden, aber keine Sorge – wir erklären dir alles, was du zum
jeweiligen Zeitpunkt wissen musst.</p>
<h2 id="unser-erstes-asynchrones-programm"><a class="header" href="#unser-erstes-asynchrones-programm">Unser erstes asynchrones Programm</a></h2>
<p>Um dieses Kapitel auf das Erlernen von async zu beschränken, anstatt mit Teilen
des Ökosystems zu jonglieren, haben wir die Kiste <code>trpl</code> erstellt (<code>trpl</code> ist
die Abkürzung für „The Rust Programming Language“). Sie re-exportiert alle
Typen, Merkmale und Funktionen, die du benötigst, hauptsächlich aus den Kisten
<a href="https://crates.io/crates/futures"><code>futures</code></a> und <a href="https://tokio.rs"><code>tokio</code></a>. Die Kiste <code>futures</code> ist ein
offizielles Zuhause für Rust-Experimente mit asynchronem Code und ist
eigentlich der Ort, an dem das Merkmal <code>Future</code> ursprünglich entworfen wurde.
Tokio ist heute die am häufigsten verwendete asynchrone Laufzeitumgebung in
Rust, insbesondere für Webanwendungen. Es gibt noch andere großartige
Laufzeitumgebungen, die für deine Zwecke evtl. besser geeignet sind. Wir
verwenden unter der Haube die Kiste <code>tokio</code> für <code>trpl</code>, weil es gut getestet
und weit verbreitet ist.</p>
<p>In einigen Fällen nennt <code>trpl</code> die ursprünglichen APIs um oder umschließt sie,
damit wir uns auf die für dieses Kapitel relevanten Details konzentrieren
können. Wenn du verstehen willst, was die Kiste tut, empfehlen wir dir, sich
den <a href="https://github.com/rust-lang/book/tree/main/packages/trpl">trpl-Quellcode</a> anzusehen. Du wirst sehen können, aus
welcher Kiste jeder Re-Export stammt, und wir haben ausführliche Kommentare
angegeben, die erklären, was die Kiste tut.</p>
<p>Erstelle ein neues Binärprojekt mit dem Namen <code>hello-async</code> und füge die Kiste
<code>trpl</code> als Abhängigkeit hinzu:</p>
<pre><code class="language-console">$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
</code></pre>
<p>Jetzt können wir die verschiedenen von <code>trpl</code> bereitgestellten Teile verwenden,
um unser erstes asynchrones Programm zu schreiben. Wir werden ein kleines
Kommandozeilen-Werkzeug erstellen, das zwei Webseiten abruft, das
jeweilige <code>&lt;title&gt;</code>-Element ausliest und den Titel derjenigen Seite ausgibt,
die den Vorgang zuerst beendet hat.</p>
<h3 id="definieren-der-funktion-page_title"><a class="header" href="#definieren-der-funktion-page_title">Definieren der Funktion <code>page_title</code></a></h3>
<p>Beginnen wir mit dem Schreiben einer Funktion, die eine Seiten-URL als
Parameter entgegennimmt, eine Anfrage an diese stellt und den Text des
Elements <code>&lt;title&gt;</code> zurückgibt (siehe Codeblock 17-1).</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    // TODO: Wir fügen dies als nächstes hinzu!
</span><span class="boring">}
</span><span class="boring">
</span>use trpl::Html;

async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title| title.inner_html())
}</code></pre>
<p><span class="caption">Codeblock 17-1: Definieren einer asynchronen Funktion zum
Abrufen des Titelelements aus einer HTML-Seite</span></p>
<p>Zuerst definieren wir eine Funktion <code>page_title</code> und versehen sie mit dem
Schlüsselwort <code>async</code>. Dann verwenden wir die Funktion <code>trpl::get</code>, um die
übergebene URL abzurufen, und geben das Schlüsselwort <code>await</code> an, um auf die
Antwort zu warten. Um den Text aus <code>response</code> zu erhalten, rufen wir die
Methode <code>text</code> auf und warten erneut mit dem Schlüsselwort <code>await</code>. Diese
beiden Schritte sind asynchron. Bei der Funktion <code>get</code> müssen wir darauf
warten, dass der Server den ersten Teil seiner Antwort sendet, der den
HTTP-Header, Cookies und so weiter enthält. Dieser Teil der Antwort kann
getrennt vom Hauptteil der Anfrage übermittelt werden. Vor allem, wenn der
Textteil sehr umfangreich ist, kann es einige Zeit dauern, bis er vollständig
angekommen ist. Da wir auf das Eintreffen der <em>gesamten</em> Antwort warten müssen,
wird die Methode <code>text</code> ebenfalls als asynchron deklariert.</p>
<p>Wir müssen beide Futures explizit abwarten, weil Futures in Rust <em>faul</em> (lazy)
sind: Sie tun nichts, bis man sie mit dem Schlüsselwort <code>await</code> dazu
auffordert. (Tatsächlich zeigt Rust eine Compiler-Warnung an, wenn du keine
Futures verwendest.) Das dürfte dich an unsere Diskussion über Iteratoren in
<a href="ch13-02-iterators.html">„Eine Reihe von Elementen verarbeiten mit Iteratoren“</a> in
Kapitel 13 erinnern. Iteratoren tun nichts, es sei denn, du rufst ihre Methode
<code>next</code> auf – entweder direkt oder mit Hilfe von <code>for</code>-Schleifen
oder Methoden wie <code>map</code>, die <code>next</code> unter der Haube verwenden. Ebenso machen
Futures nichts, es sei denn, man bittet sie ausdrücklich darum. Diese Faulheit
erlaubt es Rust, die Ausführung von asynchronem Code zu vermeiden, bis er
tatsächlich benötigt wird.</p>
<blockquote>
<p>Anmerkung: Dies unterscheidet sich von dem Verhalten, das wir gesehen haben,
als wir <code>thread::spawn</code> im Abschnitt <a href="ch16-01-threads.html#erstellen-eines-neuen-strangs-mit-spawn">„Erstellen eines neuen Strangs mit
spawn“</a> in Kapitel 16 verwendet haben und der
Funktionsabschluss, den wir an einen anderen Strang übergeben haben, sofort
zu laufen begann. Es unterscheidet sich auch davon, wie viele andere Sprachen
die asynchrone Programmierung umsetzen! Aber es ist wichtig für Rust, dass es
seine Leistungsgarantien gewährleisten kann, genau wie bei Iteratoren.</p>
</blockquote>
<p>Sobald wir <code>response_text</code> haben, können wir ihn mit <code>Html::parse</code> in eine
Instanz des Typs <code>Html</code> einlesen. Anstelle einer rohen Zeichenkette haben wir
nun einen Datentyp, den wir verwenden können, um mit HTML als eine
reichhaltigere Datenstruktur zu arbeiten. Insbesondere können wir die Methode
<code>select_first</code> verwenden, um die erste Instanz eines bestimmten CSS-Selektors
zu finden. Durch Übergeben der Zeichenkette <code>"title"</code> erhalten wir das erste
<code>&lt;title&gt;</code>-Element im Dokument, wenn es eines gibt. Da möglicherweise kein
passendes Element vorhanden ist, gibt <code>select_first</code> eine <code>Option&lt;ElementRef&gt;</code>
zurück. Schließlich verwenden wir die Methode <code>Option::map</code>, die uns mit dem
Element in der <code>Option</code> arbeiten lässt, wenn es vorhanden ist, und nichts tut,
wenn es nicht vorhanden ist. (Wir könnten hier auch einen <code>match</code>-Ausdruck
verwenden, aber <code>map</code> ist idiomatischer.) Im Rumpf der Funktion, die wir an
<code>map</code> übergeben, rufen wir <code>inner_html</code> auf <code>title</code> auf, um dessen
Inhalt als <code>String</code> zu erhalten. Wenn alles erledigt ist, haben wir eine
<code>Option&lt;String&gt;</code>.</p>
<p>Beachte, dass das Rust-Schlüsselwort <code>await</code> <em>hinter</em> dem Ausdruck steht, auf
den du wartest, nicht vor ihm. Das heißt, es ist ein <em>Postfix</em>-Schlüsselwort.
Dies mag sich von dem unterscheiden, was du vielleicht gewohnt bist, wenn du
async in anderen Sprachen verwendet hast. Rust hat sich dafür entschieden, weil
es die Arbeit mit Methodenketten viel angenehmer macht. Als Ergebnis können wir
den Rumpf von <code>page_url_for</code> ändern, um die Funktionsaufrufe <code>trpl::get</code> und
<code>text</code> mit <code>await</code> dazwischen zu verketten, wie in Codeblock 17-2 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">use trpl::Html;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: Wir fügen dies als nächstes hinzu!
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span>    let response_text = trpl::get(url).await.text().await;
<span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-2: Verketten mit dem Schlüsselwort
<code>await</code></span></p>
<p>Damit haben wir erfolgreich unsere erste asynchrone Funktion geschrieben! Bevor
wir etwas Code in <code>main</code> schreiben, um sie aufzurufen, wollen wir uns ansehen,
was wir geschrieben haben und was es bedeutet.</p>
<p>Wenn Rust einen mit dem Schlüsselwort <code>async</code> markierten Block sieht,
kompiliert es ihn in einen eindeutigen, anonymen Datentyp, der das Merkmal
<code>Future</code> implementiert. Wenn Rust eine mit dem Schlüsselwort <code>async</code>
markierte Funktion sieht, kompiliert es sie zu einer nicht-asynchronen
Funktion, deren Rumpf ein asynchroner Block ist. Der Rückgabetyp einer
asynchronen Funktion ist der Typ des anonymen Datentyps, den der Compiler für
diesen asynchronen Block erstellt.</p>
<p>Die Angabe von <code>async fn</code> ist also gleichbedeutend mit dem Schreiben einer
Funktion, die ein <em>Future</em> des Rückgabetyps zurückgibt. Für den Compiler ist
eine Funktionsdefinition wie <code>async fn page_title</code> in Codeblock 17-1 fast
äquivalent zu einer nicht-asynchronen Funktion, die wie folgt definiert ist:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;
use trpl::Html;

fn page_title(url: &amp;str) -&gt; impl Future&lt;Output = Option&lt;String&gt;&gt; {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&amp;text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
<span class="boring">}</span></code></pre>
<p>Gehen wir die einzelnen Teile der umgewandelten Version durch:</p>
<ul>
<li>Sie verwendet die Syntax <code>impl Trait</code>, die wir bereits in <a href="ch10-02-traits.html#merkmale-als-parameter-verwenden">„Merkmale als
Parameter verwenden“</a> in Kapitel 10 besprochen haben.</li>
<li>Das zurückgegebene Wert implementiert das Merkmal <code>Future</code> mit dem
assoziierten Typ von <code>Output</code>. Beachte, dass der <code>Output</code>-Typ
<code>Option&lt;String&gt;</code> ist, was dem ursprünglichen Rückgabetyp der <code>async fn</code>-Version von <code>page_title</code> entspricht.</li>
<li>Der gesamte im Rumpf der ursprünglichen Funktion wird in einen <code>async move</code>-Block eingepackt. Denke daran, dass Blöcke Ausdrücke sind. Dieser ganze
Block ist der Ausdruck, der von der Funktion zurückgegeben wird.</li>
<li>Dieser asynchrone Block erzeugt einen Wert vom Typ <code>Option&lt;String&gt;</code>, wie eben
beschrieben. Dieser Wert entspricht dem Typ <code>Output</code> im Rückgabetyp. Dies ist
genau wie bei anderen Blöcken, die du gesehen hast.</li>
<li>Der neue Funktionsrumpf ist ein <code>async move</code>-Block, da er den Parameter <code>url</code>
verwendet. (Wir werden mehr über <code>async</code> versus <code>async move</code> später in diesem
Kapitel sprechen.)</li>
</ul>
<p>Jetzt können wir <code>page_title</code> in <code>main</code> aufrufen.</p>
<h2 id="ausführen-einer-asynchronen-funktion-mit-einer-laufzeitumgebung"><a class="header" href="#ausführen-einer-asynchronen-funktion-mit-einer-laufzeitumgebung">Ausführen einer asynchronen Funktion mit einer Laufzeitumgebung</a></h2>
<p>Zunächst holen wir uns den Titel für eine einzelne Seite, wie in Codeblock 17-3
gezeigt. Leider lässt sich dieser Code noch nicht kompilieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use trpl::Html;
</span><span class="boring">
</span>async fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    let url = &amp;args[1];
    match page_title(url).await {
        Some(title) =&gt; println!("Der Titel von {url} ist {title}"),
        None =&gt; println!("{url} hat keinen Titel"),
    }
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-3: Aufruf der Funktion <code>page_title</code> aus
<code>main</code> mit einem vom Benutzer angegebenen Argument</span></p>
<p>Wir folgen wir dem gleichen Muster, das wir zum Einlesen von
Kommandozeilenargumenten in <a href="ch12-01-accepting-command-line-arguments.html">„Kommandozeilenargumente
entgegennehmen“</a> in Kapitel 12 verwendet haben. Dann übergeben wir
die erste URL an <code>page_title</code> und warten das Ergebnis ab. Da der vom Future
erzeugte Wert ein <code>Option&lt;String&gt;</code> ist, verwenden wir einen <code>match</code>-Ausdruck,
um verschiedene Meldungen auszugeben, je nachdem ob die Seite einen <code>&lt;title&gt;</code>
hatte oder nicht.</p>
<p>Der einzige Ort, an dem wir das Schlüsselwort <code>await</code> verwenden können, ist in
asynchronen Funktionen oder Blöcken, und Rust lässt uns die spezielle Funktion
<code>main</code> nicht als <code>async</code> markieren.</p>
<pre><code class="language-text">error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p>Der Grund, warum <code>main</code> nicht mit <code>async</code> markiert werden kann, ist, dass
asynchroner Code eine <em>Laufzeitumgebung</em> benötigt: eine Rust-Kiste, die die
Details der Ausführung von asynchronem Code verwaltet. Die Funktion <code>main</code>
eines Programms kann eine Laufzeitumgebung <em>initialisieren</em>, aber sie ist
nicht <em>selbst</em> eine Laufzeitumgebung. (Warum das so ist, werden wir später
sehen.) Jedes Rust-Programm, das asynchronen Code ausführt, hat mindestens eine
Stelle, an der es eine Laufzeitumgebung einrichtet, die die Futures ausführt.</p>
<p>Die meisten Sprachen, die asynchrone Programmierung unterstützen, enthalten
eine Laufzeitumgebung, Rust hat das nicht. Stattdessen gibt es viele
verschiedene asynchrone Laufzeitumgebungen, von denen jede für den jeweiligen
Anwendungsfall unterschiedliche Kompromisse eingeht. Ein Webserver mit hohem
Durchsatz, vielen CPU-Kernen und einer großen Menge an RAM hat zum Beispiel
ganz andere Anforderungen als einen Mikrocontroller mit einem einzigen Kern,
einer kleinen Menge an RAM und keiner Möglichkeit, Haldenspeicher-Allokationen
(heap allocations) durchzuführen. Die Kisten, die diese Laufzeitumgebungen
bereitstellen, bieten oft auch asynchrone Versionen gängiger Funktionen wie
Datei- oder Netzwerkkommunikation.</p>
<p>Hier und im Rest dieses Kapitels werden wir die Funktion <code>block_on</code> aus der
Kiste <code>trpl</code> verwenden, die ein Future als Argument nimmt und den aktuellen
Strang blockiert, bis das Future zu Ende ausgeführt ist. Hinter den Kulissen
wird durch den Aufruf von <code>block_on</code> eine Laufzeitumgebung mit Hilfe der Kiste
<code>tokio</code> eingerichtet, die das übergebene Future ausführt. (Das Verhalten von
<code>block_on</code> in der Kiste <code>trpl</code> ähnelt dem der <code>block_on</code>-Funktionen anderer
Laufzeitumgebungs-Kisten.) Sobald das Future abgeschlossen ist, gibt <code>block_on</code>
den Wert zurück, den das Future erzeugt hat.</p>
<p>Wir könnten das von <code>page_title</code> zurückgegebene Future direkt an <code>block_on</code>
übergeben. Sobald es abgeschlossen ist, könnten wir die resultierende
<code>Option&lt;String&gt;</code> abgleichen, so wie wir es in Codeblock 17-3 versucht haben.
Für die meisten Beispiele in diesem Kapitel (und den meisten asynchronen Code
in der realen Welt!) werden wir jedoch mehr als nur einen asynchronen
Funktionsaufruf durchführen, also übergeben wir stattdessen einen <code>async</code>-Block
und warten explizit auf das Ergebnis des Aufrufs von <code>page_title</code>, wie in
Codeblock 17-4.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use trpl::Html;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::block_on(async {
        let url = &amp;args[1];
        match page_title(url).await {
            Some(title) =&gt; println!("Der Titel von {url} ist {title}"),
            None =&gt; println!("{url} hat keinen Titel"),
        }
    })
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-4: Warten auf einen asynchronen Block mit
<code>trpl::block_on</code></span></p>
<p>Wenn wir diesen Code ausführen, erhalten wir das Verhalten, das wir anfangs
erwartet haben:</p>
<pre><code class="language-console">$ cargo run -- "https://www.rust-lang.org"
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
Der Titel von https://www.rust-lang.org ist
            Rust Programming Language
</code></pre>
<p>Puh – wir haben endlich funktionierenden asynchronen Code! Bevor wir aber
den Code hinzufügen, um zwei Webseiten gegeneinander antreten zu lassen, wollen
wir uns noch einmal kurz der Funktionsweise von Futures zuwenden.</p>
<p>Jede Codestelle mit dem Schlüsselwort <code>await</code> stellt einen Punkt dar, an dem
die Kontrolle an die Laufzeitumgebung abgegeben wird. Damit das funktioniert,
muss Rust den Zustand des asynchronen Blocks verwalten, sodass die
Laufzeitumgebung eine andere Arbeit starten und dann zurückkommen kann, wenn
er bereit ist, diese Arbeit wieder fortzusetzen. Dies ist eine unsichtbare
Zustandsmaschine, so als ob du eine Aufzählung auf diese Weise geschrieben
hättest, um den aktuellen Zustand an jedem <code>await</code>-Punkt zu speichern:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum PageTitleFuture&lt;'a&gt; {
    Initial { url: &amp;'a str },
    GetAwaitPoint { url: &amp;'a str },
    TextAwaitPoint { response: trpl::Response },
}
<span class="boring">}</span></code></pre>
<p>Den Code für den Übergang zwischen den einzelnen Zuständen von Hand zu
schreiben, wäre allerdings mühsam und fehleranfällig, vor allem, wenn dem Code
später mehr Funktionalität und mehr Zustände hinzugefügt werden. Stattdessen
erstellt und verwaltet der Rust-Compiler die Zustandsmaschinen-Datenstrukturen
für asynchronen Code automatisch. Falls du dich wunderst: Ja, die normalen
Regeln für Ausleihen und die Eigentümerschaft von Datenstrukturen gelten auch
hier. Erfreulicherweise übernimmt der Compiler auch die Überprüfung dieser
Regeln für uns und gibt hilfreiche Fehlermeldungen aus. Ein paar davon werden
wir später im Kapitel durcharbeiten.</p>
<p>Letztendlich muss etwas diese Zustandsmaschine ausführen, und dieses Etwas ist
eine Laufzeitumgebung. (Aus diesem Grund wirst auf <em>Executors</em> stoßen, wenn du
dich mit Laufzeitumgebungen befasst: Ein Executor ist der Teil einer
Laufzeitumgebung, der für die Ausführung des asynchronen Codes verantwortlich
ist.)</p>
<p>Jetzt kannst du sehen, warum uns der Compiler in Codeblock 17-3 davon
abgehalten hat, <code>main</code> selbst zu einer asynchronen Funktion zu machen. Wäre
<code>main</code> eine asynchrone Funktion, müsste etwas anderes den Zustandsautomaten für
das Future verwalten, das <code>main</code> zurückgibt, aber <code>main</code> ist der Startpunkt des
Programms! Stattdessen haben wir die Funktion <code>trpl::block_on</code> in <code>main</code>
aufgerufen, um eine Laufzeitumgebung einzurichten und das vom <code>async</code>-Block
zurückgegebene Future auszuführen, bis es fertig ist.</p>
<blockquote>
<p>Hinweis: Einige Laufzeitumgebungen stellen Makros zur Verfügung, mit denen du
eine asynchrone Funktion <code>main</code> schreiben <em>kannst</em>. Diese Makros wandeln
<code>async fn main() { ... }</code> in eine normale <code>fn main</code> um, die dasselbe tut, was
wir in Codeblock 17-4 von Hand gemacht haben: Eine Funktion aufrufen, die ein
Future zu Ende ausführt, so wie <code>trpl::block_on</code> es macht.</p>
</blockquote>
<p>Fügen wir die Teile zusammen und sehen wir uns an, wie wir nebenläufigen Code
schreiben können.</p>
<h3 id="zwei-urls-nebenläufig-gegeneinander-antreten-lassen"><a class="header" href="#zwei-urls-nebenläufig-gegeneinander-antreten-lassen">Zwei URLs nebenläufig gegeneinander antreten lassen</a></h3>
<p>In Codeblock 17-5 rufen wir <code>page_title</code> mit zwei verschiedenen URLs auf, die
von der Befehlszeile übergeben werden, und lassen sie um die Wette laufen,
indem das zuerst fertig werdende Future ausgewählt wird.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use trpl::{Either, Html};

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::block_on(async {
        let title_fut_1 = page_title(&amp;args[1]);
        let title_fut_2 = page_title(&amp;args[2]);

        let (url, maybe_title) =
            match trpl::select(title_fut_1, title_fut_2).await {
                Either::Left(left) =&gt; left,
                Either::Right(right) =&gt; right,
            };

        println!("{url} wurde zuerst zurückgegeben");
        match maybe_title {
            Some(title) =&gt; println!("Der Titel ist: '{title}'"),
            None =&gt; println!("Hat keinen Titel."),
        }
    })
}

async fn page_title(url: &amp;str) -&gt; (&amp;str, Option&lt;String&gt;) {
    let text = trpl::get(url).await.text().await;
    let title = Html::parse(&amp;text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}</code></pre>
<p><span class="caption">Codeblock 17-5: Aufruf von <code>page_title</code> für zwei URLs, um
zu sehen, welche zuerst zurückgegeben wird</span></p>
<p>Wir beginnen mit dem Aufruf von <code>page_title</code> für jede der vom Benutzer
angegebenen URLs. Wir speichern die erhaltenen Futures als <code>title_fut_1</code> und
<code>title_fut_2</code>. Denke daran, dass diese noch nichts tun, denn Futures sind faul
und wir haben noch nicht auf sie gewartet. Dann übergeben wir die Futures an
<code>trpl::select</code>, das einen Wert zurückgibt, der anzeigt, welches der übergebenen
Futures zuerst fertig wurde.</p>
<blockquote>
<p>Anmerkung: Unter der Haube ist <code>trpl::select</code> auf der allgemeineren Funktion
<code>select</code> aufgebaut, die in der Kiste <code>futures</code> definiert ist. Die Funktion
<code>select</code> der Kiste <code>futures</code> kann viele Dinge tun, die die Funktion
<code>trpl::select</code> nicht kann, aber sie bringt auch zusätzliche Komplexität mit
sich, was wir hier jedoch vorerst außer Acht lassen können.</p>
</blockquote>
<p>Jedes Future kann legitimerweise „gewinnen“, also macht es keinen Sinn, ein
<code>Result</code> zurückzugeben. Stattdessen gibt <code>trpl::select</code> einen Typ zurück, den
wir noch nicht gesehen haben: <code>trpl::Either</code>. Der Typ <code>Either</code> ist einem
<code>Result</code> insofern ähnlich, als dass er zwei Fälle hat. Im Gegensatz zu <code>Result</code>
unterscheidet <code>Either</code> jedoch nicht zwischen Erfolg und Misserfolg.
Stattdessen werden <code>Left</code> und <code>Right</code> verwendet, um „das eine oder das andere“
anzuzeigen.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre>
<p>Die Funktion <code>select</code> gibt <code>Left</code> mit der Ausgabe des ersten Futures zurück, wenn
das erste Argument zuerst fertig ist, und <code>Right</code> mit der Ausgabe des zweiten
Futures, wenn dieses zuerst fertig ist. Dies entspricht der Reihenfolge, in der
die Argumente beim Aufruf der Funktion angegeben wurden: Das erste Argument
steht links vom zweiten Argument.</p>
<p>Wir aktualisieren auch <code>page_title</code>, um die gleiche URL zurückzugeben, die wir
übergeben haben. Auf diese Weise können wir eine aussagekräftige Meldung
ausgeben, wenn die Seite, die zuerst zurückkommt, keinen <code>&lt;title&gt;</code> hat, den wir
auslesen können. Mit diesen Informationen aktualisieren wir die Ausgabe von
<code>println!</code>, um anzugeben, welche URL als erste beendet wurde und was der
<code>&lt;title&gt;</code> der Webseite hinter dieser URL war, sofern vorhanden.</p>
<p>Du hast jetzt einen kleinen funktionierenden Web Scraper erstellt! Wähle ein
paar URLs aus und führe das Befehlszeilenwerkzeug aus. Du wirst möglicherweise
feststellen, dass einige Webseiten stets schneller sind als andere, während in
anderen Fällen die schnellere Webseite von Ausführung zu Ausführung
unterschiedlich ist. Noch wichtiger ist, dass du die Grundlagen der Arbeit mit
Futures gelernt hast, sodass wir uns jetzt noch mehr mit den Dingen befassen
können, die wir mit asynchroner Programmierung tun können.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-00-async-await.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="ch17-02-concurrency-with-async.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-00-async-await.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="ch17-02-concurrency-with-async.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris-2317480c.js"></script>



    </div>
    </body>
</html>
