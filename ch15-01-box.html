<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mit Box&lt;T&gt; auf Daten im Haldenspeicher zeigen - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="mit-boxt-auf-daten-im-haldenspeicher-heap-zeigen"><a class="header" href="#mit-boxt-auf-daten-im-haldenspeicher-heap-zeigen">Mit <code>Box&lt;T&gt;</code> auf Daten im Haldenspeicher (heap) zeigen</a></h2>
<p>Der einfachste intelligente Zeiger ist <em>Box</em>, deren Typ <code>Box&lt;T&gt;</code> lautet. In
Boxen kann man Daten statt auf dem Stapelspeicher (stack) im Haldenspeicher
(heap) speichern. Was auf dem Stapelspeicher verbleibt, ist der Zeiger auf die
Daten im Haldenspeicher. In Kapitel 4 findest du Informationen zum Unterschied
zwischen dem Stapelspeicher und dem Haldenspeicher.</p>
<p>Boxen haben keinen Performanz-Overhead, außer dass die Daten auf
den Haldenspeicher anstatt auf dem Stapelspeicher gespeichert werden, aber
sie haben auch nicht viele zusätzliche Funktionalitäten. Sie werden am
häufigsten in folgenden Situationen verwendet:</p>
<ul>
<li>Wenn man einen Typ hat, dessen Größe zum Zeitpunkt der Kompilierung nicht
bekannt ist, und man einen Wert dieses Typs in einem Kontext verwenden
möchte, für den eine genaue Größe erforderlich ist.</li>
<li>Wenn man über eine große Datenmenge verfügt und die Eigentümerschaft
(ownership) übertragen möchte und sicherstellen will, dass die Daten dabei
nicht kopiert werden.</li>
<li>Wenn man einen Wert besitzen und sich nur darum kümmern möchte, dass es sich
um einen Typ handelt, der ein bestimmtes Merkmal implementiert, anstatt den
Typ zu spezifizieren.</li>
</ul>
<p>Wir werden die erste Situation in <a href="#erm%C3%B6glichen-rekursiver-typen-mit-boxen">„Ermöglichen rekursiver Typen mit
Boxen“</a> zeigen. Im zweiten Fall kann
die Übertragung der Eigentümerschaft einer großen Datenmenge lange dauern, da
die Daten auf dem Stapelspeicher kopiert werden. Um die Performanz in dieser
Situation zu verbessern, können wir die große Datenmenge auf dem Haldenspeicher
in einer Box speichern. Dann wird nur die kleine Menge von Zeigerdaten auf dem
Stapelspeicher kopiert, während die Daten, auf die referenziert wird, im
Haldenspeicher an einer Stelle verbleiben. Der dritte Fall ist als
<em>Merkmalsobjekt</em> (trait object) bekannt, und <a href="ch18-02-trait-objects.html">„Merkmalsobjekte (trait objects)
die Werte unterschiedlicher Typen erlauben“</a> in Kapitel 18
widmet sich diesem Thema. Was du hier lernst, wirst du in diesem Abschnitt
erneut anwenden!</p>
<h3 id="boxt-verwenden-um-daten-im-haldenspeicher-zu-speichern"><a class="header" href="#boxt-verwenden-um-daten-im-haldenspeicher-zu-speichern"><code>Box&lt;T&gt;</code> verwenden um Daten im Haldenspeicher zu speichern</a></h3>
<p>Bevor wir den Haldenspeicher-Anwendungsfall für <code>Box&lt;T&gt;</code> besprechen, werden wir
die Syntax und die Interaktion mit Werten behandeln, die in einer <code>Box&lt;T&gt;</code>
gespeichert sind.</p>
<p>Codeblock 15-1 zeigt, wie man mit einer Box einen <code>i32</code>-Wert auf dem
Haldenspeicher speichert:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}</code></pre></pre>
<p><span class="caption">Codeblock 15-1: Speichern eines <code>i32</code>-Wertes in einer Box
im Haldenspeicher</span></p>
<p>Wir definieren die Variable <code>b</code> so, dass sie den den Wert einer <code>Box</code> hat die
auf den Wert <code>5</code> zeigt, der auf dem Haldenspeicher allokiert ist. Dieses
Programm gibt <code>b = 5</code> aus, in diesem Fall können wir auf die Daten in der Box
zugreifen, ähnlich als würden sich die Daten im Stapelspeicher befinden. Genau
wie bei Werten mit Eigentümerschaft wird auch eine Box freigegeben, wenn sie
den Gültigkeitsbereich verlässt, wie dies bei <code>b</code> am Ende von <code>main</code> der Fall
ist. Die Freigabe erfolgt sowohl für die Box (gespeichert im Stapelspeicher)
als auch für die Daten, auf die sie zeigt (gespeichert im Haldenspeicher).</p>
<p>Es ist nicht besonders hilfreich, einen einzelnen Wert im Haldenspeicher zu
speichern, daher verwendet man Boxen selten alleine. Meistens ist es besser,
Werte wie eine <code>i32</code> auf dem Stapelspeicher zu haben, wo sie standardmäßig
gespeichert werden. Sehen wir uns einen Fall an, in dem Boxen es uns
ermöglichen, Typen zu definieren, die wir nicht hätten, wenn es keine Boxen
gäbe.</p>
<h3 id="ermöglichen-rekursiver-typen-mit-boxen"><a class="header" href="#ermöglichen-rekursiver-typen-mit-boxen">Ermöglichen rekursiver Typen mit Boxen</a></h3>
<p>Ein Wert eines <em>rekursiven Typs</em> kann einen anderen Wert desselben Typs als
Teil von sich selbst haben. Rekursive Typen stellen ein Problem dar, weil Rust
zur Kompilierzeit wissen muss, wie viel Platz ein Typ einnimmt. Allerdings
könnte die Verschachtelung von Werten rekursiver Typen theoretisch unendlich
weitergehen, sodass Rust nicht wissen kann, wie viel Platz der Wert benötigt.
Da Boxen eine bekannte Größe haben, können wir rekursive Typen ermöglichen,
indem wir eine Box in die Definition des rekursiven Typs einfügen.</p>
<p>Als Beispiel für einen rekursiven Typ wollen wir uns die <em>Cons-Liste</em> ansehen.
Dies ist ein Datentyp, den man häufig in funktionalen Programmiersprachen
findet. Der Cons-Listen-Typ, den wir definieren werden, ist bis auf die
Rekursion einfach; daher werden die Konzepte in dem Beispiel, mit dem wir
arbeiten werden, immer dann nützlich sein, wenn du in komplexeren Situationen
mit rekursiven Typen arbeitest.</p>
<h4 id="weitere-informationen-zur-cons-liste"><a class="header" href="#weitere-informationen-zur-cons-liste">Weitere Informationen zur Cons-Liste</a></h4>
<p>Eine <em>Cons-Liste</em> ist eine Datenstruktur, die aus der Programmiersprache Lisp
und ihren Dialekten stammt und aus verschachtelten Paaren besteht. Sie ist die
Lisp-Version einer verketteten Liste. Ihr Name stammt von der Funktion <code>cons</code>
(Kurzform von „construct function“) in Lisp, die aus ihren beiden Argumenten
ein neues Paar konstruiert. Durch den Aufruf von <code>cons</code> für ein Paar, das aus
einem Wert und einem anderen Paar besteht, können wir Cons-Listen konstruieren,
die aus rekursiven Paaren bestehen.</p>
<p>Hier ist zum Beispiel eine Pseudocode-Darstellung einer Cons-Liste, die die
Liste <code>1, 2, 3</code> enthält, wobei jedes Paar in Klammern steht:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Jedes Element in einer Cons-Liste enthält zwei Elemente: Den Wert des aktuellen
Elements und das nächste Element. Das letzte Element in der Liste enthält nur
ein Element namens <code>Nil</code> ohne ein nächstes Element. Eine Cons-Liste wird durch
rekursives Aufrufen der Funktion <code>cons</code> erstellt. Der kanonische Name für den
Basisfall der Rekursion lautet <code>Nil</code>. Beachte, dass dies nicht mit dem Konzept
„null“ oder „nil“ in Kapitel 6 identisch ist, das einen fehlenden oder
ungültigen Wert darstellt.</p>
<p>Die Cons-Liste ist keine häufig verwendete Datenstruktur in Rust. Wenn man in
Rust eine Liste von Elementen hat, ist <code>Vec&lt;T&gt;</code> die bessere Wahl. Andere,
komplexere rekursive Datentypen sind in verschiedenen Situationen nützlich.
Wenn wir jedoch mit der Cons-Liste beginnen, können wir untersuchen, wie Boxen
es uns ermöglichen, ohne grosse Ablenkung einen rekursiven Datentyp zu
definieren.</p>
<p>Codeblock 15-2 enthält eine Aufzählungsdefinition (enum) für eine Cons-Liste.
Beachte, dass dieser Code nicht kompiliert werden kann, da der Typ <code>List</code> keine
bekannte Größe hat, wie wir nachfolgend sehen werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-2: Der erste Versuch eine Aufzählung zu
definieren, um eine Datenstruktur der Cons-Liste von <code>i32</code>-Werten
darzustellen</span></p>
<blockquote>
<p>Hinweis: Für dieses Beispiel implementieren wir eine Cons-Liste, die nur
<code>i32</code>-Werte enthält. Wir hätten sie mit generischen Typen implementieren
können wie wir es in Kapitel 10 besprochen haben, um eine Cons-Liste zu
erstellen, in der Werte eines beliebigen Typs gespeichert werden können.</p>
</blockquote>
<p>Die Verwendung des Typs <code>List</code>, um die Liste <code>1, 2, 3</code> zu speichern, würde wie
in Codeblock 15-3 aussehen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre></pre>
<p><span class="caption">Codeblock 15-3: Verwendung der <code>List</code>-Aufzählung um die
Liste <code>1, 2, 3</code> zu speichern</span></p>
<p>Der erste <code>Cons</code>-Wert enthält <code>1</code> und einen anderen <code>List</code>-Wert. Dieser
<code>List</code>-Wert ist ein weiterer <code>Cons</code>-Wert, der <code>2</code> und einen anderen <code>List</code>-Wert
enthält. Dieser <code>List</code>-Wert ist wiederum ein <code>Cons</code>-Wert, der <code>3</code> enthält und
ein <code>List</code>, das schließlich <code>Nil</code> ist – die nicht-rekursive Variante, die
das Ende der Liste signalisiert.</p>
<p>Wenn wir versuchen den Programmcode in Codeblock 15-3 zu kompilieren,
erhalten wir den Fehler der in Codeblock 15-4 gezeigt wird.</p>
<p><span class="filename">Dateiname: output.txt</span></p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
</code></pre>
<p><span class="caption">Codeblock 15-4: Der Fehler den wir erhalten wenn wir
versuchen eine rekursive Aufzählung zu definieren</span></p>
<p>Der Fehler zeigt, dass dieser Typ „unendlich groß“ ist. Der Grund dafür ist,
dass wir <code>List</code> mit einer rekursiven Variante definiert haben, sie enthält
direkt einen anderen Wert von sich selbst, daher kann Rust nicht herausfinden,
wie viel Speicherplatz zum Speichern eines Listenwerts erforderlich ist. Lass
uns zusammenfassen, warum wir diesen Fehler bekommen. Schauen wir uns zunächst
an, wie Rust ermittelt, wie viel Speicherplatz zum Speichern des Werts eines
nicht-rekursiven Typs benötigt wird.</p>
<h4 id="die-größe-eines-nicht-rekursiven-typs-berechnen"><a class="header" href="#die-größe-eines-nicht-rekursiven-typs-berechnen">Die Größe eines nicht-rekursiven Typs berechnen</a></h4>
<p>Erinnere dich an die in Codeblock 6-2 definierte <code>Message</code>-Aufzählung, als wir
die Definition von Aufzählungen in Kapitel 6 besprochen haben:</p>
<pre><pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Um zu bestimmen, wie viel Speicherplatz für einen <code>Message</code>-Wert benötigt wird,
analysiert Rust alle Varianten, um festzustellen, welche Variante den meisten
Speicherplatz benötigt. Rust erkennt, dass <code>Message::Quit</code> keinen Speicherplatz
benötigt, und <code>Message::Move</code> so viel Speicherplatz braucht um zwei <code>i32</code>-Werte
zu speichern, und so weiter. Da nur eine Variante verwendet wird, ist der
Speicherbedarf, den ein <code>Message</code>-Wert benötigt, gleich dem Speicherplatz, der
zum Speichern der größten Variante benötigt wird.</p>
<p>Übertrage das auf den Fall, bei dem Rust zu bestimmen versucht, wie viel
Speicherplatz ein rekursiver Typ wie die Aufzählung <code>List</code> in Codeblock 15-2
benötigt. Der Compiler betrachtet zunächst die Variante <code>Cons</code>, die einen Typ
<code>i32</code> und einen Wert vom Typ <code>List</code> enthält. Daher benötigt <code>Cons</code>
Speicherplatz, der der Größe eines <code>i32</code> plus der Größe einer <code>List</code>
entspricht. Um herauszufinden, wie viel Speicher der Typ <code>List</code> benötigt,
betrachtet der Compiler die Varianten, beginnend mit der Variante <code>Cons</code>. Die
Variante <code>Cons</code> enthält einen Typ <code>i32</code> und einen Wert vom Typ <code>List</code>. Dieser
Vorgang wird wie in Abbildung 15-1 dargestellt, unendlich fortgesetzt.</p>
<img alt="Eine unendliche Cons-Liste" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 15-1: Ein unendlicher <code>List</code>-Typ der aus
unendlichen <code>Cons</code>-Varianten besteht</span></p>
<h4 id="verwenden-von-boxt-um-einen-rekursiven-typ-mit-einer-bekannten-größe-zu-erhalten"><a class="header" href="#verwenden-von-boxt-um-einen-rekursiven-typ-mit-einer-bekannten-größe-zu-erhalten">Verwenden von <code>Box&lt;T&gt;</code>, um einen rekursiven Typ mit einer bekannten Größe zu erhalten</a></h4>
<p>Da Rust nicht herausfinden kann, wie viel Speicherplatz für rekursiv definierte
Typen reserviert werden muss, gibt der Compiler eine Fehlermeldung mit diesem
hilfreichen Vorschlag aus:</p>
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>In diesem Hinweis bedeutet „indirection“ (Umweg), dass die Datenstruktur den
Wert nicht direkt speichern soll, sondern indirekt, indem stattdessen ein
Zeiger auf den Wert gespeichert wird.</p>
<p>Da eine <code>Box&lt;T&gt;</code> ein Zeiger ist, weiß Rust immer, wie viel Platz eine <code>Box&lt;T&gt;</code>
benötigt: Die Größe eines Zeigers ändert sich nicht basierend auf der
Datenmenge, auf die er zeigt. Dies bedeutet, dass wir anstelle eines anderen
<code>List</code>-Wertes direkt eine <code>Box&lt;T&gt;</code> in die <code>Cons</code>-Variante einfügen können. Die
<code>Box&lt;T&gt;</code> zeigt auf den nächsten <code>List</code>-Wert, der sich auf dem Haldenspeicher
befindet und nicht in der <code>Cons</code>-Variante. Konzeptionell haben wir immer noch
eine Liste, die mit Listen erstellt wurde, die andere Listen enthalten. Diese
Implementierung ähnelt nun eher dem Platzieren der Elemente nebeneinander als
ineinander.</p>
<p>Wir können die Definition der Liste <code>List</code> in Codeblock 15-2 und die Verwendung
von <code>List</code> in Codeblock 15-3 in den Programmcode von Codeblock 15-5 ändern, der
kompilieren wird.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<p><span class="caption">Codeblock 15-5: Definition von <code>List</code>, die <code>Box&lt;T&gt;</code>
benutzt, um eine bekannte Größe zu haben</span></p>
<p>Die <code>Cons</code>-Variante benötigt die Größe eines <code>i32</code> plus Platz zum Speichern der
Zeigerdaten der Box. Die <code>Nil</code>-Variante speichert keine Werte und benötigt
daher weniger Speicher als die <code>Cons</code>-Variante. Wir wissen nun, dass jeder
<code>List</code>-Wert die Größe eines <code>i32</code> plus die Größe der Zeigerdaten einer Box
annimmt. Durch Verwenden einer Box haben wir die unendliche, rekursive Kette
unterbrochen, sodass der Compiler die Größe ermitteln kann, die zum Speichern
eines Listenwerts erforderlich ist. Abbildung 15-2 zeigt, wie die Variante
<code>Cons</code> jetzt aussieht.</p>
<img alt="Eine endliche Cons-Liste" src="img/trpl15-02.svg" class="center" style="width: 20%;" />
<p><span class="caption">Abbildung 15-2: Ein <code>List</code>-Typ, der keine unendliche
Größe hat, da <code>Cons</code> eine <code>Box</code> enthält</span></p>
<p>Boxen kümmern sich nur die Dereferenzierung und Speicherallokation auf dem
Haldenspeicher, haben aber keine weiteren speziellen Funktionalitäten, wie wir
sie bei anderen intelligenten Zeigertypen sehen werden. Sie haben aber auch
keinen Performanz-Overhead, der mit diesen zusätzlichen Funktionalitäten
verbunden ist. Daher können sie in Fällen wie der Cons-Liste nützlich sein, in
denen die Dereferenzierung die einzige Funktionalität ist, die wir benötigen.
Weitere Anwendungsfälle für Boxen werden wir uns auch in Kapitel 18 ansehen.</p>
<p>Der Typ <code>Box&lt;T&gt;</code> ist ein intelligenter Zeiger, da er das Merkmal <code>Deref</code>
implementiert, mit dem <code>Box&lt;T&gt;</code>-Werte wie Referenzen behandelt werden können.
Wenn ein <code>Box&lt;T&gt;</code>-Wert den Gültigkeitsbereich verlässt, werden die Daten am
Haldenspeicher, auf die die Box zeigt, aufgrund der Implementierung des
Merkmals <code>Drop</code> ebenfalls aufgeräumt. Diese beiden Merkmale sind für die
Funktionalität der anderen intelligenten Zeigertypen, die wir im restlichen
Kapitel erläutern, noch wichtiger. Lass uns diese beiden Merkmale genauer
untersuchen.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-00-smart-pointers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-02-deref.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-00-smart-pointers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-02-deref.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
