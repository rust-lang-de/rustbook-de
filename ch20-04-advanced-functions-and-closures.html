<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Erweiterte Funktionen und Funktionsabschlüsse (closures) - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="erweiterte-funktionen-und-funktionsabschlüsse-closures"><a class="header" href="#erweiterte-funktionen-und-funktionsabschlüsse-closures">Erweiterte Funktionen und Funktionsabschlüsse (closures)</a></h2>
<p>Dieser Abschnitt befasst sich mit fortgeschrittenen Funktionalitäten im
Zusammenhang mit Funktionen und Funktionsabschlüsse, einschließlich
Funktionszeigern und Zurückgeben von Funktionsabschlüssen.</p>
<h3 id="funktionszeiger"><a class="header" href="#funktionszeiger">Funktionszeiger</a></h3>
<p>Wir haben darüber gesprochen, wie man Funktionsabschlüsse an Funktionen
übergibt; man kann auch reguläre Funktionen an Funktionen übergeben! Diese
Technik ist nützlich, wenn du eine Funktion, die du bereits definiert hast,
übergeben willst, anstatt einen neuen Funktionsabschluss zu definieren.
Funktionen haben den Typ <code>fn</code> (mit kleinem <em>f</em>), nicht zu verwechseln mit dem
Funktionsabschlussmerkmal (closure trait) <code>Fn</code>. Der Typ <code>fn</code> wird
<em>Funktionszeiger</em> (function pointer) genannt. Die Übergabe von Funktionen mit
Funktionszeigern ermöglicht es dir, Funktionen als Argumente für andere
Funktionen zu verwenden.</p>
<p>Die Syntax für die Angabe, dass ein Parameter ein Funktionszeiger ist, ähnelt
der von Funktionsabschlüssen, wie in Codeblock 20-28 gezeigt, wo wir eine
Funktion <code>add_one</code> definiert haben, die ihrem Parameter 1 hinzufügt. Die
Funktion <code>do_twice</code> nimmt zwei Parameter entgegen: Einen Funktionszeiger auf
eine beliebige Funktion mit einem <code>i32</code>-Parameter und einem <code>i32</code>-Rückgabewert,
und einen <code>i32</code>-Parameter. Die Funktion <code>do_twice</code> ruft die Funktion <code>f</code>
zweimal auf, übergibt ihr den Wert <code>arg</code> und addiert dann die Ergebnisse der
beiden Funktionsaufrufe zusammen. Die Funktion <code>main</code> ruft <code>do_twice</code> mit den
Argumenten <code>add_one</code> und <code>5</code> auf.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("Die Antwort ist: {answer}");
}</code></pre></pre>
<p><span class="caption">Codeblock 20-28: Verwenden des Typs <code>fn</code> zum
Entgegennehmen eines Funktionszeigers als Argument</span></p>
<p>Dieser Code gibt <code>Die Antwort ist: 12</code> aus. Wir spezifizieren, dass der
Parameter <code>f</code> in <code>do_twice</code> ein <code>fn</code> ist, das einen Parameter vom Typ <code>i32</code>
nimmt und ein <code>i32</code> zurückgibt. Wir können dann <code>f</code> im Rumpf von <code>do_twice</code>
aufrufen. In <code>main</code> können wir den Funktionsnamen <code>add_one</code> als erstes Argument
an <code>do_twice</code> übergeben.</p>
<p>Im Gegensatz zu Funktionsabschlüssen ist <code>fn</code> ein Typ, nicht ein Merkmal, daher
spezifizieren wir <code>fn</code> direkt als Parametertyp, anstatt einen generischen
Typparameter mit einem Merkmal <code>Fn</code> als Merkmalsabgrenzung (trait bound) zu
deklarieren.</p>
<p>Funktionszeiger implementieren alle drei Funktionsabschlussmerkmale (<code>Fn</code>,
<code>FnMut</code> und <code>FnOnce</code>), was bedeutet, dass du immer einen Funktionszeiger als
Argument an eine Funktion übergeben kannst, die einen Funktionsabschluss
erwartet. Es ist am besten, Funktionen mit einem generischen Typ und einer der
Funktionsabschlussmerkmale zu schreiben, sodass deine Funktionen entweder
Funktionen oder Funktionsabschlüsse akzeptieren können.</p>
<p>Ein Beispiel, bei dem du nur <code>fn</code> und keine Funktionsabschlüsse akzeptieren
möchtest, ist die Schnittstelle zu externem Code, der keine Funktionsabschlüsse
hat: C-Funktionen können Funktionen als Argumente akzeptieren, aber C hat keine
Funktionsabschlüsse.</p>
<p>Als Beispiel dafür, wo du entweder einen inline definierten Funktionsabschluss
oder eine benannte Funktion verwenden könntest, sehen wir uns die Verwendung
der Methode <code>map</code> an, die vom Merkmal <code>Iterator</code> in der Standardbibliothek
bereitgestellt wird. Um die Methode <code>map</code> zu verwenden, um einen Vektor von
Zahlen in einen Vektor von Zeichenketten zu verwandeln, könnten wir einen
Funktionsabschluss verwenden, wie in Codeblock 20-29.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-29: Verwendung eines Funktionsabschlusses
mit der Methode <code>map</code> zur Umwandlung von Zahlen in Zeichenketten</span></p>
<p>Oder wir könnten eine Funktion als Argument für <code>map</code> angeben anstelle des
Funktionsabschlusses. Codeblock 20-30 zeigt, wie das aussehen würde.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-30: Verwenden der Methode
<code>String::to_string</code> zur Umwandlung von Zahlen in Zeichenketten</span></p>
<p>Beachte, dass wir die vollständig qualifizierte Syntax verwenden müssen, über
die wir iin <a href="ch20-02-advanced-traits.html">„Fortgeschrittene Merkmale (traits)“</a> gesprochen
haben, weil es mehrere Funktionen namens <code>to_string</code> gibt.</p>
<p>Hier verwenden wir die Funktion <code>to_string</code>, die im Merkmal <code>ToString</code>
definiert ist, welche die Standardbibliothek für jeden Typ implementiert hat,
der <code>Display</code> implementiert.</p>
<p>Aus <a href="ch06-01-defining-an-enum.html#werte-in-aufz%C3%A4hlungen">„Werte in Aufzählungen“</a> in Kapitel 6 wissen wir, dass der
Name jeder definierten Aufzählungsvariante auch eine Initialisierungsfunktion
ist. Wir können diese Initialisierungsfunktionen als Funktionszeiger verwenden,
die die Funktionsabschlussmerkmale implementieren, was bedeutet, dass wir die
Initialisierungsfunktionen als Argumente für Methoden angeben können, die
Funktionsabschlüsse nehmen, wie in Codeblock 20-32 zu sehen ist.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-31: Verwenden eines
Aufzählungs-Initialisierers mit der Methode <code>map</code> zum Erstellen einer
<code>Status</code>-Instanz aus Zahlen</span></p>
<p>Hier erzeugen wir <code>Status::Value</code>-Instanzen für die <code>u32</code>-Werte im Bereich, für
den <code>map</code> aufgerufen wird, indem wir die Initialisierungsfunktion von
<code>Status::Value</code> verwenden. Einige Leute bevorzugen diesen Stil und einige Leute
ziehen es vor, Funktionsabschlüsse zu verwenden. Sie kompilieren zum gleichen
Code, also verwende den Stil, der für dich am klarsten ist.</p>
<h3 id="zurückgeben-von-funktionsabschlüssen"><a class="header" href="#zurückgeben-von-funktionsabschlüssen">Zurückgeben von Funktionsabschlüssen</a></h3>
<p>Funktionsabschlüsse werden durch Merkmale repräsentiert, was bedeutet, dass du
Funktionsabschlüsse nicht direkt zurückgeben kannst. In den meisten Fällen, in
denen du ein Merkmal zurückgeben möchtest, kannst du stattdessen den konkreten
Typ, der das Merkmal implementiert, als Rückgabewert der Funktion verwenden.
Aber das kannst du bei Funktionsabschlüssen normalerweise nicht tun, weil sie
keinen konkreten Typ haben, den man zurückgeben kann. Es ist dir beispielsweise
nicht erlaubt, den Funktionszeiger <code>fn</code> als Rückgabetyp zu verwenden, wenn der
Funktionsabschluss irgendwelche Werte aus seinem Gültigkeitsbereich erfasst.</p>
<p>Stattdessen wirst du normalerweise die Syntax <code>impl Trait</code> verwenden, die wir
in Kapitel 10 kennengelernt haben. Du kannst jeden Funktionstyp zurückgeben,
indem du <code>Fn</code>, <code>FnOnce</code> und <code>FnMut</code> verwendest. Zum Beispiel wird der Code in
Codeblock 20-32 problemlos funktionieren.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-32: Rückgeben eines Funktionsabschlusses aus
einer Funktion unter Verwendung der Syntax <code>impl Trait</code></span></p>
<p>Wie wir jedoch in <a href="ch13-01-closures.html#funktionsabschluss-typinferenz-und-annotation">„Funktionsabschluss-Typinferenz und
Annotation“</a> in Kapitel 13 festgestellt haben, ist jeder
Funktionsabschluss auch ein eigener Typ. Wenn du mit mehreren Funktionen
arbeiten musst, die dieselbe Signatur, aber unterschiedliche Implementierungen
haben, musst du ein Merkmals-Objekt für sie verwenden. Überlege, was passiert,
wenn du einen Code wie in Codeblock 20-33 schreibst.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{output}");
    }
}

fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}

fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |x| x + init
}</code></pre></pre>
<p><span class="caption">Codeblock 20-33: Erstellen eines <code>Vec&lt;T&gt;</code> von
Funktionsabschlüssen, die durch Funktionen definiert sind, die <code>impl Fn</code>
zurückgeben</span></p>
<p>Hier haben wir zwei Funktionen <code>returns_closure</code> und
<code>returns_initialized_closure</code>, die beide <code>impl Fn(i32) -&gt; i32</code> zurückgeben. Man
beachte, dass die Funktionsabschlüsse, die sie zurückgeben, unterschiedlich
sind, obwohl sie den gleichen Typ implementieren. Wenn wir versuchen, dies zu
kompilieren, lässt uns Rust wissen, dass es nicht funktionieren wird:</p>
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
    error[E0308]: mismatched types
    --&gt; src/main.rs:4:9
       |
    4  |         returns_initialized_closure(123)
       |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different opaque type
    ...
    12 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
       |                         ------------------- the expected opaque type
    ...
    16 | fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
       |                                              ------------------- the found opaque type
       |
    = note: expected opaque type `impl Fn(i32) -&gt; i32` (opaque type at &lt;src/main.rs:12:25&gt;)
                found opaque type `impl Fn(i32) -&gt; i32` (opaque type at &lt;src/main.rs:16:46&gt;)
    = note: distinct uses of `impl Trait` result in different opaque types

    For more information about this error, try `rustc --explain E0308`.
    error: could not compile `functions-example` (bin "functions-example") due to 1 previous error
</code></pre>
<p>Die Fehlermeldung sagt uns, dass Rust jedes Mal, wenn wir ein <code>impl Trait</code>
zurückgeben, einen eindeutigen <em>undurchsichtigen Typ</em> (opaque type) erzeugt,
einen Typ, bei dem wir nicht in die Details dessen sehen können, was Rust für
uns konstruiert. Obwohl diese Funktionen also beide Funktionsabschlüsse
zurückgeben, die dasselbe Merkmal implementieren, nämlich <code>Fn(i32) -&gt; i32</code>,
sind die undurchsichtigen Typen, die Rust für jede Funktion erzeugt,
unterschiedlich. (Dies ist vergleichbar mit der Art und Weise, wie Rust
unterschiedliche konkrete Typen für verschiedene asynchrone Blöcke erzeugt,
selbst wenn sie denselben Ausgabetyp haben, wie wir in <a href="ch17-03-more-futures.html">„Arbeiten mit einer
beliebigen Anzahl von Futures“</a> in Kapitel 17 gesehen
haben. Eine Lösung für dieses Problem haben wir jetzt schon ein paar Mal
gesehen: Wir können ein Merkmals-Objekt verwenden, wie in Codeblock 20-34.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
</span><span class="boring">    for handler in handlers {
</span><span class="boring">        let output = handler(5);
</span><span class="boring">        println!("{output}");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(move |x| x + init)
}</code></pre></pre>
<p><span class="caption">Codeblock 20-34: Erstellen eines <code>Vec&lt;T&gt;</code> von
Funktionsabschlüssen, die durch Funktionen definiert sind, die <code>Box&lt;dyn Fn&gt;</code>
zurückgeben, damit sie denselben Typ haben</span></p>
<p>Dieser Code lässt sich sehr gut kompilieren. Weitere Informationen über
Merkmalsobjekte findest du im Abschnitt <a href="ch18-02-trait-objects.html">„Merkmalsobjekte (trait objects) die
Werte unterschiedlicher Typen erlauben“</a> in Kapitel 18.</p>
<p>Als nächstes wollen wir uns Makros ansehen!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-03-advanced-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-05-macros.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-03-advanced-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-05-macros.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
