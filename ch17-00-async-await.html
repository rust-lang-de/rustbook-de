<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Grundlagen der asynchronen Programmierung: Async, Await, Futures und Ströme - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="grundlagen-der-asynchronen-programmierung-async-await-futures-und-ströme"><a class="header" href="#grundlagen-der-asynchronen-programmierung-async-await-futures-und-ströme">Grundlagen der asynchronen Programmierung: Async, Await, Futures und Ströme</a></h1>
<p>Viele Operationen, die wir einen Computer ausführen lassen, können eine Weile
dauern, bis sie erledigt sind. Es wäre schön, wenn wir etwas anderes tun
könnten, während wir darauf warten, bis diese lang dauernden Prozesse
abgeschlossen sind. Moderne Computer bieten zwei Techniken, um mehr als einen
Vorgang gleichzeitig zu bearbeiten: Parallelität und Nebenläufigkeit. Sobald
wir jedoch anfangen, Programme zu schreiben, die parallele oder nebenläufige
Operationen beinhalten, stoßen wir schnell auf neue Herausforderungen, die mit
der <em>asynchronen Programmierung</em> verbunden sind, bei der Operationen nicht
unbedingt in der Reihenfolge beendet werden, in der sie begonnen wurden. Dieses
Kapitel baut auf der Verwendung von Strängen (threads) für Parallelität und
Nebenläufigkeit in Kapitel 16 auf, indem es einen alternativen Ansatz zur
asynchronen Programmierung vorstellt: Rusts Futures, Ströme (streams), die
unterstützende Syntax <code>async</code> und <code>await</code>, und die Werkzeuge für die Verwaltung
und Koordinierung zwischen asynchronen Operationen.</p>
<p>Schauen wir uns ein Beispiel an. Nehmen wir an, du exportierst ein Video, das
du von einer Familienfeier erstellt hast – ein Vorgang, der zwischen
Minuten und Stunden dauern kann. Der Videoexport wird so viel CPU- und
GPU-Leistung wie möglich beanspruchen. Wenn du nur einen CPU-Kern hast und dein
Betriebssystem den Export nicht anhält, bevor er abgeschlossen ist, d.h. wenn
es den Export <em>synchron</em> ausführt, kannst du während dieser Zeit nichts anderes
auf deinem Computer tun. Das wäre eine ziemlich frustrierende Erfahrung. Zum
Glück kann das Betriebssystem deines Computers den Export oft genug unsichtbar
unterbrechen, damit du gleichzeitig andere Arbeiten erledigen kannst.</p>
<p>Nehmen wir an, du lädst ein Video herunter, das von einer anderen Person
geteilt wurde, was ebenfalls eine Weile dauern kann, aber nicht so viel
CPU-Zeit in Anspruch nimmt. In diesem Fall muss die CPU warten, bis die Daten
aus dem Netzwerk eintreffen. Du kannst zwar mit dem Lesen der Daten beginnen,
sobald sie ankommen, aber es kann einige Zeit dauern, bis alle Daten
eingetroffen sind. Selbst wenn alle Daten angekommen sind, kann es bei einem
recht großen Video mindestens ein oder zwei Sekunden dauern, bis alles geladen
ist. Das hört sich vielleicht nicht nach viel an, aber für einen modernen
Prozessor, der jede Sekunde Milliarden von Operationen ausführen kann, ist das
eine sehr lange Zeit. Auch hier wird das Betriebssystem dein Programm
unsichtbar unterbrechen, damit die CPU andere Arbeiten ausführen kann, während
sie auf den Abschluss des Netzwerkvorgangs wartet.</p>
<p>Der Videoexport ist ein Beispiel für einen <em>CPU-gebundenen</em> (CPU-bound) oder
<em>rechengebunden</em> (compute-bound) Vorgang. Er ist durch die potenzielle
Datenverarbeitungsgeschwindigkeit der CPU oder GPU des Computers begrenzt und
dadurch, wie viel von dieser Geschwindigkeit er für den Vorgang nutzen kann.
Der Videodownload ist ein Beispiel für einen <em>E/A-gebunden</em> (IO-bound) Vorgang,
da er durch die Geschwindigkeit der <em>Eingabe und Ausgabe</em> des Computers
begrenzt ist; er kann nur so schnell sein, wie die Daten über das Netzwerk
gesendet werden können.</p>
<p>In beiden Beispielen stellen die unsichtbaren Unterbrechungen durch das
Betriebssystem eine Form der Nebenläufigkeit dar. Diese Nebenläufigkeit findet
allerdings nur auf der Ebene des gesamten Programms statt: Das Betriebssystem
unterbricht ein Programm, damit andere Programme ihre Arbeit erledigen können.
Da wir unsere Programme in vielen Fällen auf einer viel detaillierteren Ebene
verstehen als das Betriebssystem, können wir Möglichkeiten zur Nebenläufigkeit
sehen, die das Betriebssystem nicht erkennen kann.</p>
<p>Wenn wir beispielsweise ein Werkzeug zur Verwaltung von Dateidownloads
entwickeln, sollten wir unser Programm so schreiben können, dass das Starten
eines Downloads die Benutzeroberfläche nicht blockiert, und die Benutzer
sollten in der Lage sein, mehrere Downloads zur gleichen Zeit zu starten. Viele
Betriebssystem-APIs für die Interaktion mit dem Netzwerk sind jedoch
<em>blockierend</em>, d.h. sie blockieren den Programmfortschritt, bis die Daten, die
sie verarbeiten, vollständig verfügbar sind.</p>
<blockquote>
<p>Hinweis: So funktionieren die <em>meisten</em> Funktionsaufrufe, wenn du darüber
nachdenkst. Wir denken beim Begriff <em>blockierend</em> jedoch normalerweise an
Funktionsaufrufe, die mit Dateien, dem Netzwerk oder anderen Ressourcen auf
dem Computer interagieren, weil dies Stellen sind, an denen ein individuelles
Programm davon profitieren würde, wenn die Operation <em>nicht</em> blockierend
wäre.</p>
</blockquote>
<p>Wir könnten das Blockieren unseres Hauptstrangs (main thread) vermeiden, indem
wir für das Herunterladen jeder Datei einen eigenen Strang (thread) starten.
Der Overhead dieser Stränge würde jedoch irgendwann zu einem Problem werden. Es
wäre besser, wenn der Aufruf gar nicht erst blockiert würde. Es wäre auch
besser, wenn wir in demselben direkten Stil schreiben könnten, den wir in
blockierendem Code verwenden, ähnlich wie hier:</p>
<pre><code class="language-rust ignore does_not_compile">let data = fetch_data_from(url).await;
println!("{data}");</code></pre>
<p>Genau das bietet uns die <em>async</em> (kurz für <em>asynchronous</em>) Abstraktion von
Rust. In diesem Kapitel wirst du alles über async lernen, indem wir die
folgenden Themen behandeln:</p>
<ul>
<li>Wie man die Syntax <code>async</code> und <code>await</code> von Rust verwendet</li>
<li>Wie man das asynchrone Modell verwendet, um einige der gleichen
Herausforderungen zu lösen, die wir uns in Kapitel 16 angeschaut haben</li>
<li>Wie Mehrsträngigkeit (multithreading) und async komplementäre Lösungen
bieten, die man in vielen Fällen kombinieren kann</li>
</ul>
<p>Bevor wir uns jedoch ansehen, wie async in der Praxis funktioniert, müssen wir
einen kleinen Abstecher zu den Unterschieden zwischen Parallelität und
Nebenläufigkeit machen.</p>
<h3 id="parallelität-und-nebenläufigkeit"><a class="header" href="#parallelität-und-nebenläufigkeit">Parallelität und Nebenläufigkeit</a></h3>
<p>Bislang haben wir Parallelität und Nebenläufigkeit als weitgehend
gleichbedeutend behandelt. Jetzt müssen wir genauer zwischen ihnen
unterscheiden, denn die Unterschiede werden sich bei der Arbeit zeigen.</p>
<p>Es gibt verschiedene Möglichkeiten, wie ein Team die Arbeit an einem
Softwareprojekt aufteilen kann. Du könntest einem einzelnen Mitglied mehrere
Aufgaben zuweisen oder jedem Teammitglied genau eine Aufgabe oder eine Mischung
aus beiden Ansätzen verwenden.</p>
<p>Wenn eine Person an mehreren, verschiedenen Aufgaben arbeitet, bevor eine von
ihnen abgeschlossen ist, handelt es sich um <em>Nebenläufigkeit</em>. Vielleicht hast
du zwei verschiedene Projekte auf deinem Computer ausgecheckt, und wenn dir bei
einem Projekt langweilig wird oder du nicht weiterkommst, wechselst du zum
anderen. Da du nur eine Person bist, kannst du nicht an beiden Aufgaben
gleichzeitig arbeiten, aber du kannst an mehreren Aufgaben arbeiten, indem du
zwischen ihnen abwechselst (siehe Abbildung 17-1).</p>
<img alt="Nebenläufiger Arbeitsablauf" src="img/trpl17-01.svg" class="center" />
<p><span class="caption">Abbildung 17-1: Ein nebenläufiger Arbeitsablauf, der
zwischen Aufgabe A und Aufgabe B wechselt.</span></p>
<p>Wenn das Team eine Gruppe von Aufgaben aufteilt, indem jedes Mitglied eine
Aufgabe übernimmt und sie alleine bearbeitet, ist das <em>Parallelismus</em>. Jede
Person im Team kann genau zur gleichen Zeit Fortschritte machen (siehe
Abbildung 17-2).</p>
<img alt="Paralleler Arbeitsablauf" src="img/trpl17-02.svg" class="center" />
<p><span class="caption">Abbildung 17-2: Ein paralleler Arbeitsablauf, bei dem die
Arbeit an Aufgabe A und Aufgabe B unabhängig voneinander erfolgt.</span></p>
<p>Bei diesen beiden Arbeitsabläufen musst du dich möglicherweise zwischen
verschiedenen Aufgaben abstimmen. Vielleicht <em>dachtest</em> du, die einer Person
zugewiesene Aufgabe sei völlig unabhängig von der Arbeit der anderen, aber in
Wirklichkeit muss eine andere Person im Team ihre Aufgabe zuerst erledigen. Ein
Teil der Arbeit könnte parallel erledigt werden, aber ein Teil der Arbeit war
eigentlich <em>sequentiell</em>: Sie konnte nur nacheinander stattfinden, eine Aufgabe
nach der anderen, wie in Abbildung 17-3.</p>
<img alt="Nebenläufiger Arbeitsablauf" src="img/trpl17-03.svg" class="center" />
<p><span class="caption">Abbildung 17-3: Ein teilweise paralleler Arbeitsablauf,
bei dem die Arbeit an Aufgabe A und Aufgabe B unabhängig voneinander erfolgt,
bis Aufgabe A3 durch die Ergebnisse von Aufgabe B3 blockiert wird.</span></p>
<p>Ebenso könntest du feststellen, dass eine deiner eigenen Aufgaben von einer
anderen deiner Aufgaben abhängt. Jetzt ist deine nebenläufige Arbeit auch
sequentiell geworden.</p>
<p>Parallelität und Nebenläufigkeit können sich auch gegenseitig überschneiden.
Wenn du erfährst, dass ein Kollege nicht weiterkommt, bis du eine deiner
Aufgaben beendet hast, wirst du dich wahrscheinlich ganz auf diese Aufgabe
konzentrieren, um deinen Kollegen nicht weiter zu blockieren. Du und dein
Kollege können nicht mehr parallel arbeiten, und du könntest auch nicht mehr
nebenläufig an deinen eigenen Aufgaben arbeiten.</p>
<p>Die gleiche grundlegende Dynamik kommt bei Software und Hardware zum Tragen.
Auf einem Rechner mit einem einzigen CPU-Kern kann die CPU nur eine Operation
zur gleichen Zeit ausführen, aber sie kann dennoch nebenläufig arbeiten.
Mithilfe von Werkzeugen wie Strängen, Prozessen und async kann der Computer
eine Aktivität unterbrechen und zu einer anderen wechseln, bis er schließlich
wieder zur ersten Aktivität zurückkehrt. Auf einem Computer mit mehreren
CPU-Kernen kann er auch parallel arbeiten. Ein Kern kann eine Aufgabe
erledigen, während ein anderer Kern eine komplett unabhängige, andere Aufgabe
erledigt, und das sogar zur gleichen Zeit.</p>
<p>Wenn wir mit async in Rust arbeiten, haben wir es immer mit Nebenläufigkeit zu
tun. Abhängig von der Hardware, dem Betriebssystem und der verwendeten
asynchronen Laufzeitumgebung, die wir verwenden, kann die Nebenläufigkeit unter
der Haube auch Parallelität nutzen.</p>
<p>Jetzt wollen wir uns ansehen, wie die asynchrone Programmierung in Rust
tatsächlich funktioniert!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-04-extensible-concurrency-sync-and-send.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-01-futures-and-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-04-extensible-concurrency-sync-and-send.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-01-futures-and-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
