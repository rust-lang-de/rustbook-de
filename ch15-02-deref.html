<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) Deref - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="intelligente-zeiger-wie-normale-referenzen-behandeln-mit-dem-merkmal-trait-deref"><a class="header" href="#intelligente-zeiger-wie-normale-referenzen-behandeln-mit-dem-merkmal-trait-deref">Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) <code>Deref</code></a></h2>
<p>Durch die Implementierung des Merkmals <code>Deref</code> kann man das Verhalten des
<em>Dereferenzierungsoperators</em> (dereference operator) <code>*</code> (nicht zu verwechseln
mit dem Multiplikations- oder Stern-Operator (glob operator)) anpassen. Indem
du <code>Deref</code> so implementierst, dass ein intelligenter Zeiger wie eine reguläre
Referenz behandelt werden kann, kannst du Programmcode schreiben, der mit
Referenzen arbeitet, und diesen Programmcode auch mit intelligenten Zeigern
verwenden.</p>
<p>Schauen wir uns zunächst an, wie der Dereferenzierungsoperator mit regulären
Referenzen arbeitet. Dann werden wir versuchen, einen benutzerdefinierten Typ
zu definieren, der sich wie <code>Box&lt;T&gt;</code> verhält, und herausfinden, warum der
Dereferenzierungsoperator nicht wie eine Referenz für unseren neu definierten
Typ funktioniert. Wir werden untersuchen, wie die Implementierung des Merkmals
<code>Deref</code> es intelligenten Zeigern ermöglicht, auf ähnliche Weise wie Referenzen
zu funktionieren, dann sehen wir uns an wie wir mit Rusts <em>automatischer
Umwandlung</em> (deref coercion) mit Referenzen oder intelligenten Zeigern arbeiten
können.</p>
<blockquote>
<p>Hinweis: Es gibt einen großen Unterschied zwischen dem Typ <code>MyBox&lt;T&gt;</code>, den
wir gerade erstellen, und dem echten Typ <code>Box&lt;T&gt;</code>: Unsere Version speichert
ihre Daten nicht auf dem Haldenspeicher (heap). In diesem Beispiel
konzentrieren wir uns auf <code>Deref</code>, daher ist es weniger wichtig, wo die Daten
tatsächlich gespeichert sind als das zeigerähnliche Verhalten.</p>
</blockquote>
<h3 id="dem-zeiger-zum-wert-folgen"><a class="header" href="#dem-zeiger-zum-wert-folgen">Dem Zeiger zum Wert folgen</a></h3>
<p>Eine reguläre Referenz ist eine Art Zeiger, und eine Möglichkeit, sich einen
Zeiger als Pfeil vorzustellen, der auf einen Wert zeigt, der an einer anderen
Stelle gespeichert ist. In Codeblock 15-6 erstellen wir eine Referenz auf einen
<code>i32</code>-Wert und verwenden dann den Dereferenzierungsoperator, um der Referenz
zum Wert zu folgen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-6: Einen Dereferenzierungsoperator verwenden
um einer Referenz auf einen <code>i32</code>-Wert zu folgen </span></p>
<p>Die Variable <code>x</code> enthält den <code>i32</code>-Wert <code>5</code>. Wir weisen <code>y</code> eine Referenz auf
<code>x</code> zu. Wir können sicherstellen, dass <code>x</code> gleich <code>5</code> ist. Wenn wir jedoch eine
Aussage über den Wert <code>y</code> machen möchten, müssen wir <code>*y</code> verwenden, um der
Referenz auf den Wert zu folgen, auf den sie zeigt (daher <em>Dereferenzierung</em>).
Sobald wir <code>y</code> dereferenzieren, haben wir Zugriff auf den Zahlenwert, auf den
<code>y</code> zeigt, und können ihn mit <code>5</code> vergleichen.</p>
<p>Wenn wir stattdessen versuchen würden, <code>assert_eq!(5, y);</code> zu schreiben, würden
wir diesen Fehler beim Kompilieren erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider dereferencing here
 --&gt; file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/macros/mod.rs:46:35
  |
46|                 if !(*left_val == **right_val) {
  |                                   +

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>Das Vergleichen einer Zahl mit einer Referenz auf eine Zahl ist nicht zulässig,
da es sich um verschiedene Typen handelt. Wir müssen den
Dereferenzierungsoperator verwenden um der Referenz auf den Wert zu folgen, auf
den sie zeigt.</p>
<h3 id="boxt-wie-eine-referenz-verwenden"><a class="header" href="#boxt-wie-eine-referenz-verwenden"><code>Box&lt;T&gt;</code> wie eine Referenz verwenden</a></h3>
<p>Wir können den Programmcode in Codeblock 15-6 neu schreiben, um anstelle einer
Referenz <code>Box&lt;T&gt;</code> zu verwenden. Wie Codeblock 15-7 zeigt, funktioniert der
Dereferenzierungsoperator:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-7: Using the dereference operator on a
<code>Box&lt;i32&gt;</code></span></p>
<p>Der Hauptunterschied zwischen Codeblock 15-7 und 15-6 besteht darin, dass wir
hier <code>y</code> als Instanz einer <code>Box&lt;T&gt;</code> festlegen, das auf einen kopierten Wert von
<code>x</code> zeigt, und nicht als Referenz, die auf den Wert <code>x</code> zeigt. In der letzten
Zusicherung (assertion) können wir den Dereferenzierungsoperator verwenden um
dem Zeiger in <code>Box&lt;T&gt;</code> auf die gleiche Weise zu folgen, wie wir es getan haben,
als <code>y</code> eine Referenz war. Als Nächstes werden wir ergründen, was das Besondere
an <code>Box&lt;T&gt;</code> ist, wodurch der Dereferenzierungsoperator verwendet werden kann,
indem wir unseren eigenen Box-Typ definieren.</p>
<h3 id="einen-eigenen-intelligenten-zeiger-definieren"><a class="header" href="#einen-eigenen-intelligenten-zeiger-definieren">Einen eigenen intelligenten Zeiger definieren</a></h3>
<p>Erstellen wir einen intelligenten Zeiger, der dem von der Standardbibliothek
bereitgestellten Typ <code>Box&lt;T&gt;</code> ähnelt, um zu erfahren, wie sich intelligente
Zeiger standardmäßig anders als Referenzen verhalten. Anschließend sehen wir
uns an, wie man die Möglichkeit zur Verwendung des Dereferenzierungsoperators
hinzufügen kann.</p>
<p>Der Typ <code>Box&lt;T&gt;</code> wird letztendlich als Tupel-Struktur (tuple struct) mit einem
Element definiert. Codeblock 15-8 definiert den Typ <code>MyBox&lt;T&gt;</code> auf die gleiche
Weise. Wir werden auch eine Funktion <code>new</code> definieren, analog zu <code>Box&lt;T&gt;</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-8: Definition des Type <code>MyBox&lt;T&gt;</code></span></p>
<p>Wir definieren eine Struktur mit dem Namen <code>MyBox</code> und deklarieren einen
generischen Parameter <code>T</code>, da unser Typ Werte jedes beliebigen Typs enthalten
können soll. Der Typ <code>MyBox</code> ist eine Tupelstruktur mit einem Element vom Typ
<code>T</code>. Die Funktion <code>MyBox::new</code> verwendet einen Parameter vom Typ <code>T</code> und gibt
eine <code>MyBox</code>-Instanz zurück, die den übergebenen Wert enthält.</p>
<p>Versuchen wir, die Funktion <code>main</code> in Codeblock 15-7 zu Codeblock 15-8
hinzuzufügen und sie so zu ändern, dass der von uns definierte Typ <code>MyBox&lt;T&gt;</code>
anstelle von <code>Box&lt;T&gt;</code> verwendet wird. Der Programmcode in Codeblock 15-9 wird
nicht kompilieren, da Rust nicht weiß, wie er <code>MyBox</code> dereferenzieren kann.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring"> }
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-9: Versuch, <code>MyBox&lt;T&gt;</code> auf die gleiche Weise
wie <code>Box&lt;T&gt;</code> und Referenzen zu benutzen</span></p>
<p>Hier ist der Kompilierfehler den wir erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>Unser Typ <code>MyBox&lt;T&gt;</code> kann nicht dereferenziert werden, da wir diese Fähigkeit
für unseren Typ nicht implementiert haben. Um eine Dereferenzierung mit dem
Operator <code>*</code> zu ermöglichen, implementieren wir das Merkmal <code>Deref</code>.</p>
<h3 id="implementieren-des-merkmals-deref"><a class="header" href="#implementieren-des-merkmals-deref">Implementieren des Merkmals <code>Deref</code></a></h3>
<p>Wie in <a href="ch10-02-traits.html#ein-merkmal-f%C3%BCr-einen-typ-implementieren">„Ein Merkmal für einen Typ implementieren“</a> in Kapitel 10
beschrieben, müssen wir zur Implementierung eines Merkmals Implementierungen
für die erforderlichen Methoden des Merkmals bereitstellen. Das von der
Standardbibliothek bereitgestellte Merkmal <code>Deref</code> erfordert die
Implementierung einer Methode namens <code>deref</code>, die <code>self</code> ausleiht (borrow) und
eine Referenz auf die beinhalteten Daten zurückgibt. Codeblock 15-10 enthält
eine Implementierung von <code>Deref</code>, um die Definition von <code>MyBox</code> zu ergänzen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-10: <code>Deref</code> auf <code>MyBox&lt;T&gt;</code>
implementieren</span></p>
<p>Die Syntax <code>type Target = T;</code> definiert einen assoziierten Typ, den das Merkmal
<code>Deref</code> verwenden soll. Assoziierte Typen sind eine andere Art, einen
generischen Parameter zu deklarieren, aber darüber musst du dir vorerst noch
keine Gedanken machen; in Kapitel 20 werden wir sie ausführlicher behandeln.</p>
<p>Wir füllen den Rumpf der Methode <code>deref</code> mit <code>&amp;self.0</code>, damit <code>deref</code> eine
Referenz auf den Wert zurückgibt, auf den wir mit dem Operator <code>*</code> zugreifen
wollen. Erinnere dich an <a href="ch05-01-defining-structs.html#verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen">„Verwenden von Tupel-Strukturen ohne benannte Felder
um verschiedene Typen zu erzeugen“</a> in Kapitel 5, wo <code>.0</code> auf
den ersten Wert in einer Tupel-Struktur zugreift. Die Funktion <code>main</code> in
Codeblock 15-9, die <code>*</code> für den Wert <code>MyBox&lt;T&gt;</code> aufruft, kompiliert nun und die
Zusicherungen werden erfüllt!</p>
<p>Ohne das Merkmal <code>Deref</code> kann der Compiler nur <code>&amp;</code>-Referenzen dereferenzieren.
Die Methode <code>deref</code> gibt dem Compiler die Möglichkeit, einen Wert eines
beliebigen Typs zu verwenden, der <code>Deref</code> implementiert, und die Methode
<code>deref</code> aufzurufen, um eine <code>&amp;</code>-Referenz zu erhalten, die er dereferenzieren
kann.</p>
<p>Als wir in Codeblock 15-9 <code>*y</code> eingegeben haben, hat Rust hinter den Kulissen
tatsächlich diesen Programmcode ausgeführt:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust ersetzt den Operator <code>*</code> durch einen Aufruf der Methode <code>deref</code> und dann
durch eine einfache Dereferenzierung, sodass wir nicht darüber nachdenken
müssen, ob wir die Methode <code>deref</code> aufrufen müssen oder nicht. Mit dieser
Rust-Funktionalität können wir Code schreiben, der unabhängig davon
funktioniert, ob wir eine reguläre Referenz haben oder einen Typ, der <code>Deref</code>
implementiert.</p>
<p>Der Grund, warum die Methode <code>deref</code> eine Referenz auf einen Wert zurückgibt
und die einfache Dereferenzierung außerhalb der Klammern in <code>*(y.deref())</code>
weiterhin erforderlich ist, hat mit der Eigentümerschaft (ownership) zu tun.
Wenn die Methode <code>deref</code> den Wert direkt anstelle einer Referenz auf den Wert
zurückgibt, wird der Wert aus <code>self</code> herausverschoben. Wenn wir den
Dereferenzierungsoperator verwenden, wollen wir meistens, wie auch hier, nicht
die Eigentümerschaft des inneren Wertes von <code>MyBox&lt;T&gt;</code> übernehmen.</p>
<p>Beachte, dass der <code>*</code>-Operator durch einen Aufruf der Methode <code>deref</code> und dann
einem Aufruf des <code>*</code>-Operators ersetzt wird. Da die Ersetzung des <code>*</code>-Operators
nicht unendlich rekursiv ist, erhalten wir Daten vom Typ <code>i32</code>, die mit der <code>5</code>
in <code>assert_eq!</code> in Codeblock 15-9 übereinstimmen.</p>
<h3 id="implizite-automatische-umwandlung-mit-funktionen-und-methoden"><a class="header" href="#implizite-automatische-umwandlung-mit-funktionen-und-methoden">Implizite automatische Umwandlung mit Funktionen und Methoden</a></h3>
<p>Die <em>automatische Umwandlung</em> (deref coercion) wandelt eine Referenz auf einen
Typ, der das Merkmal <code>Deref</code> implementiert, in eine Referenz auf einen anderen
Typ um. Zum Beispiel kann die automatische Umwandlung <code>&amp;String</code> in <code>&amp;str</code>
konvertieren, da <code>String</code> das Merkmal <code>Deref</code> implementiert, sodass <code>&amp;str</code>
zurückgegeben wird. Die automatische Umwandlung ist eine Bequemlichkeit, die
Rust auf Argumente für Funktionen und Methoden anwendet, und funktioniert nur
bei Typen, die das Merkmal <code>Deref</code> implementieren. Die automatische Umwandlung
erfolgt automatisch, wenn wir eine Referenz auf den Wert eines bestimmten Typs
als Argument an eine Funktion oder Methode übergeben, die nicht dem
Parametertyp in der Funktion oder Methodendefinition übereinstimmt. Eine Folge
von Aufrufen der Methode <code>deref</code> konvertiert den von uns angegebenen Typ in den
Typ, den der Parameter benötigt.</p>
<p>Rust wurde um die automatische Umwandlung erweitert, damit Programmierer, die
Funktions- und Methodenaufrufe schreiben, nicht so viele explizite
Referenzierungen und Dereferenzierungen mit <code>&amp;</code> und <code>*</code> angeben müssen. Mit der
Funktionalität der automatischen Umwandlung können wir auch Programmcode
schreiben, der sowohl für Referenzen als auch für intelligente Zeiger geeignet
ist.</p>
<p>Um die automatische Umwandlung in Aktion zu sehen, verwenden wir den in
Codeblock 15-8 definierten Typ <code>MyBox&lt;T&gt;</code> sowie die Implementierung von
<code>Deref</code>, die wir in Codeblock 15-10 hinzugefügt haben. Codeblock 15-11 zeigt
die Definition einer Funktion mit einen Zeichenketten-Anteilstyp (string slice)
Parameter.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn hello(name: &amp;str) {
    println!("Hallo {name}!");
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-11: Eine Funktion <code>hello</code> mit dem Parameter
<code>name</code> vom Typ <code>&amp;str</code></span></p>
<p>Wir können die Funktion <code>hello</code> mit einem Zeichenketten-Anteilstyp als Argument
aufrufen, wie zum Beispiel <code>hello("Rust");</code>. Die automatischer Umwandlung
ermöglicht es, <code>hello</code> mit einer Referenz auf einen Wert vom Typ
<code>MyBox&lt;String&gt;</code> aufzurufen, wie Codeblock 15-12 zeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hallo {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;m);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-12: <code>hello</code> mit einer Referenz auf einen
<code>MyBox&lt;String&gt;</code>-Wert, der aufgrund automatischer Umwandlung funktioniert</span></p>
<p>Hier rufen wir die Funktion <code>hello</code> mit dem Argument <code>&amp;m</code> auf, das auf einen
<code>MyBox&lt;String&gt;</code>-Wert referenziert. Da wir in Codeblock 15-10 das Merkmal
<code>Deref</code> für <code>MyBox&lt;T&gt;</code> implementiert haben, kann Rust <code>&amp;MyBox&lt;String&gt;</code> durch
Aufrufen von <code>deref</code> in <code>&amp;String</code> verwandeln. Die Standardbibliothek bietet
eine Implementierung von <code>Deref</code> auf <code>String</code>, die einen
Zeichenketten-Anteilstyp zurückgibt. Dies kann man in der API-Dokumentation für
<code>Deref</code> nachlesen. Rust ruft erneut <code>deref</code> auf, um <code>&amp;String</code> in <code>&amp;str</code>
umzuwandeln, was der Definition der Funktion <code>hello</code> entspricht.</p>
<p>Wenn Rust keine automatische Umwandlung implementiert hätte, müssten wir den
Programmcode in Codeblock 15-13 anstelle des Programmcodes in 15-12 schreiben,
um <code>hello</code> mit einem Wert vom Typ <code>&amp;MyBox&lt;String&gt;</code> aufzurufen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hallo {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-13: Programmcode den wir schreiben
müssten wenn Rust keine automatische Umwandlung hätte</span></p>
<p>Das <code>(*m)</code> dereferenziert <code>Mybox&lt;String&gt;</code> zu einem <code>String</code>. Dann nehmen <code>&amp;</code>
und <code>[..]</code> einen Anteilstyp des <code>String</code>, der gleich der gesamten Zeichenkette
ist, um der Signatur von <code>hello</code> zu entsprechen. Der Programmcode ohne
automatische Umwandlung ist mit all den Symbolen schwerer zu lesen, zu
schreiben und zu verstehen. Durch die automatische Umwandlung kann Rust diese
Konvertierung automatisch für uns durchführen.</p>
<p>Wenn das Merkmal <code>Deref</code> für die beteiligten Typen definiert ist, analysiert
Rust die Typen und verwendet <code>Deref::deref</code> so oft wie nötig, um eine Referenz
zu erhalten, die dem Typ des Parameters entspricht. Wie oft <code>Deref::deref</code>
eingefügt werden muss, wird zur Kompilierzeit ermittelt, sodass zur Laufzeit
kein Nachteil durch die Nutzung der automatischen Umwandlung entsteht!</p>
<h3 id="wie-die-automatische-umwandlung-mit-veränderbarkeit-umgeht"><a class="header" href="#wie-die-automatische-umwandlung-mit-veränderbarkeit-umgeht">Wie die automatische Umwandlung mit Veränderbarkeit umgeht</a></h3>
<p>Ähnlich wie du das Merkmal <code>Deref</code> verwendest, um den <code>*</code>-Operator bei
unveränderbaren Referenzen zu überschreiben, kannst du das Merkmal <code>DerefMut</code>
verwenden, um den <code>*</code>-Operator bei veränderbaren Referenzen zu überschreiben.</p>
<p>Rust wendet die automatische Umwandlung bei Typen und Merkmalsimplementierungen
in folgenden drei Fällen an:</p>
<ol>
<li>Von <code>&amp;T</code> zu <code>&amp;U</code>, wenn <code>T: Deref&lt;Target=U&gt;</code></li>
<li>Von <code>&amp;mutT</code> zu <code>&amp;mutU</code>, wenn <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>Von <code>&amp;mutT</code> zu <code>&amp;U</code>, wenn <code>T: Deref&lt;Target=U&gt;</code></li>
</ol>
<p>Die ersten beiden Fälle sind identisch, mit der Ausnahme, dass der zweite die
Veränderbarkeit implementiert. Der erste Fall besagt, dass wenn man einen <code>&amp;T</code>
hat und <code>T</code> <code>Deref</code> für einen Typ <code>U</code> implementiert hat, man transparent <code>&amp;U</code>
erhalten kann. Der zweite Fall besagt, dass die gleiche automatische Umwandlung
bei veränderbaren Referenzen erfolgt.</p>
<p>Der dritte Fall ist schwieriger: Rust wird auch eine veränderbare Referenz in
eine unveränderbare umwandeln. Das Gegenteil ist jedoch <em>nicht</em> möglich:
Unveränderbare Referenzen werden niemals zu veränderbaren gemacht. Wenn man
eine veränderbare Referenz hat, muss diese veränderbare Referenz aufgrund der
Ausleihregeln (borrowing rules) die einzige Referenz auf diese Daten sein
(anderenfalls würde das Programm nicht kompilieren). Das Konvertieren einer
veränderbaren Referenz in eine unveränderbare verstößt niemals gegen die
Ausleihregeln. Das Konvertieren einer unveränderbaren Referenz in eine
veränderbare Referenz, würde erfordern, dass die ursprüngliche unveränderbare
Referenz die einzige unveränderbare Referenz auf diese Daten ist, aber die
Ausleihregeln garantieren dies nicht.
Daher kann Rust nicht davon ausgehen, dass die Konvertierung einer
unveränderbaren Referenz in eine veränderbare Referenz möglich ist.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-01-box.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-03-drop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-01-box.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-03-drop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
