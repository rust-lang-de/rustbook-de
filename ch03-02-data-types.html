<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Datentypen - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-√úbersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="datentypen"><a class="header" href="#datentypen">Datentypen</a></h2>
<p>Jeder Wert in Rust ist von einem bestimmten <em>Datentyp</em>, der Rust mitteilt,
welche Art von Daten angegeben wird, damit es wei√ü, wie es mit diesen Daten
arbeiten soll. Wir werden uns zwei Datentyp-Untermengen ansehen: Skalar (scalar) und
Verbund (compound).</p>
<p>Denk daran, dass Rust eine <em>statisch typisierte</em> Sprache ist, was bedeutet,
dass es die Typen von allen Variablen zur Kompilierzeit kennen muss. Der
Compiler kann normalerweise auf der Grundlage des Wertes und wie wir ihn
verwenden ableiten, welchen Typ wir verwenden wollen. Wenn mehrere Typen
m√∂glich sind, wie zum Beispiel als wir im Abschnitt <a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">‚ÄûVergleichen der Sch√§tzung
mit der Geheimzahl‚Äú</a> eine
Zeichenkette (<code>String</code>) mittels <code>parse</code> zu einem numerischen Typ umwandelten,
m√ºssen wir eine Typ-Annotation erg√§nzen, wie hier:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = "42".parse().expect("Keine Zahl!");
<span class="boring">}</span></code></pre></pre>
<p>Wenn wir diese Typ-Annotation nicht angeben, zeigt Rust den folgenden Fehler
an, was bedeutet, dass der Compiler mehr Informationen von uns ben√∂tigt, um
zu wissen welchen Typ wir verwenden wollen:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Keine Zahl!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Keine Zahl!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
</code></pre>
<p>F√ºr andere Datentypen wirst du andere Typ-Annotationen sehen.</p>
<h3 id="skalare-typen"><a class="header" href="#skalare-typen">Skalare Typen</a></h3>
<p>Ein <em>skalarer</em> Typ stellt einen einzelnen Wert dar. Rust hat vier prim√§re
skalare Typen: Ganze Zahlen, Flie√ükommazahlen, boolesche Werte (Wahrheitswerte)
und Zeichen. Du erkennst diese vielleicht aus anderen Programmiersprachen. Lass
uns dar√ºber sprechen, wie sie in Rust funktionieren.</p>
<h4 id="ganzzahl-typen"><a class="header" href="#ganzzahl-typen">Ganzzahl-Typen</a></h4>
<p>Eine <em>ganze Zahl</em> ist eine Zahl ohne Bruchteilkomponente. Wir verwendeten eine
ganze Zahl in Kapitel 2, den Typ <code>u32</code>. Diese Typdeklaration gibt an, dass der
Wert, dem sie zugeordnet ist, eine 32 Bit gro√üe ganze Zahl ohne Vorzeichen ist
(vorzeichenbehaftete Ganzzahl-Typen beginnen mit <code>i</code> anstatt <code>u</code>). Tabelle 3-1
zeigt die in Rust eingebauten Ganzzahl-Typen. Wir k√∂nnen jede dieser Varianten
verwenden, um den Typ eines ganzzahligen Wertes zu deklarieren.</p>
<p><span class="caption">Tabelle 3-1: Ganzzahlige Typen in Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">L√§nge</th><th>Vorzeichenbehaftet</th><th>Vorzeichenlos</th></tr></thead><tbody>
<tr><td style="text-align: right">8 Bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td style="text-align: right">16 Bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td style="text-align: right">32 Bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td style="text-align: right">64 Bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td style="text-align: right">128 Bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td style="text-align: right">arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Jede Variante kann entweder vorzeichenbehaftet oder vorzeichenlos sein und hat
eine explizite Gr√∂√üe. <em>Vorzeichenbehaftet</em> (signed) und <em>vorzeichenlos</em>
(unsigned) beziehen sich darauf, ob es m√∂glich ist, dass die Zahl negativ ist
‚Äì in anderen Worten, ob die Zahl ein Vorzeichen haben muss
(vorzeichenbehaftet) oder ob sie immer nur positiv sein wird und daher ohne
Vorzeichen dargestellt werden kann (vorzeichenlos). Es ist wie das Schreiben
von Zahlen auf Papier: Wenn das Vorzeichen eine Rolle spielt, wird die Zahl mit
einem Plus- oder Minuszeichen geschrieben; wenn man jedoch davon ausgehen kann,
dass die Zahl positiv ist, wird sie ohne Vorzeichen geschrieben.
Vorzeichenbehaftete Zahlen werden unter Verwendung der
<a href="https://de.wikipedia.org/wiki/Zweierkomplement">Zweierkomplementdarstellung</a> gespeichert.</p>
<p>Jede vorzeichenbehaftete Variante kann Zahlen von -(2<sup>n - 1</sup>) bis
einschlie√ülich 2<sup>n - 1</sup> - 1 speichern, wobei <em>n</em> die Anzahl an Bits
ist, die diese Variante benutzt. Ein <code>i8</code> kann also Zahlen von -(2<sup>7</sup>)
bis 2<sup>7</sup> - 1 speichern, was -128 bis 127 entspricht. Vorzeichenlose
Varianten k√∂nnen Zahlen von 0 bis 2<sup>n</sup> - 1 speichern, also kann ein
<code>u8</code> Zahlen von 0 bis 2<sup>8</sup> - 1 speichern, was 0 bis 255 entspricht.</p>
<p>Zus√§tzlich h√§ngen die Typen <code>isize</code> und <code>usize</code> von der Architektur des
Computers ab, auf dem dein Programm l√§uft, die in der Tabelle als ‚Äûarch‚Äú
bezeichnet wird: 64 Bit wenn du dich auf einer 64-Bit-Architektur befindest und
32 Bit auf einer 32-Bit-Architektur.</p>
<p>Du kannst ganzzahlige Literale in jeder der in Tabelle 3-2 gezeigten Formen
schreiben. Beachte, dass Zahlenliterale, die mehrere numerische Typen sein
k√∂nnen, ein Typ-Suffix wie <code>57u8</code> zur Bezeichnung des Typs erlauben.
Zahlenliterale k√∂nnen auch <code>_</code> als visuelles Trennzeichen verwenden, um die
Zahl leichter lesbar zu machen, z.B. <code>1_000</code>, das den gleichen Wert hat, wie
wenn du <code>1000</code> angegeben h√§ttest.</p>
<p><span class="caption">Tabelle 3-2: Ganzzahl-Literale in Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Ganzahl-Literal</th><th>Beispiel</th></tr></thead><tbody>
<tr><td>Dezimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Oktal</td><td><code>0o77</code></td></tr>
<tr><td>Bin√§r</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (nur <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Woher weist du also, welcher Ganzzahltyp zu verwenden ist? Wenn du dir unsicher
bist, sind Rusts Standards im Allgemeinen ein guter Ausgangspunkt: Ganzzahlige
Typen sind standardm√§√üig <code>i32</code>. Die prim√§re Situation, in der du <code>isize</code> oder
<code>usize</code> verwendest, ist beim Indizieren einer Art Sammlung.</p>
<blockquote>
<h5 id="ganzzahl√ºberlauf"><a class="header" href="#ganzzahl√ºberlauf">Ganzzahl√ºberlauf</a></h5>
<p>Nehmen wir an, du hast eine Variable vom Typ <code>u8</code>, die Werte zwischen 0 und
255 annehmen kann. Wenn du versuchst, die Variable auf einen Wert au√üerhalb
dieses Bereiches zu √§ndern, z.B. auf 256, tritt ein Ganzzahl√ºberlauf auf, was
zu einem von zwei Verhaltensweisen f√ºhren kann. Wenn du im Fehlersuchmodus
(debug mode) kompilierst, f√ºgt Rust Pr√ºfungen auf Ganzzahl√ºberl√§ufe ein, was
dazu f√ºhrt, dass dein Programm zur Laufzeit <em>abbricht</em> (panic), falls dieses
Verhalten auftritt. Rust verwendet den Begriff ‚Äûpanic‚Äú, wenn ein Programm
durch einen Fehler abgebrochen wird; wir werden Programmabbr√ºche im Abschnitt
<a href="ch09-01-unrecoverable-errors-with-panic.html">‚ÄûNicht behebbare Fehler mit <code>panic!</code>‚Äú</a> in
Kapitel 9 n√§her betrachten.</p>
<p>Wenn du mit dem Schalter <code>--release</code> im Freigabemodus (release mode)
kompilierst, f√ºgt Rust <em>keine</em> Pr√ºfungen auf Ganzzahl√ºberl√§ufe, die das
Programm abbrechen, ein. Wenn ein √úberlauf auftritt, f√ºhrt Rust stattdessen
einen <em>Zweier-Komplement-Umbruch</em> durch. Kurz gesagt, Werte die gr√∂√üer als
der Maximalwert den der Typ enthalten kann sind, werden umgebrochen zum
kleinsten Wert den der Typ enthalten kann. Im Falle eines <code>u8</code> wird der Wert
256 zu 0, der Wert 257 zu 1 und so weiter. Das Programm wird nicht abbrechen,
aber die Variable wird wahrscheinlich einen anderen Wert annehmen, als du
erwartest. Sich auf das Verhalten von Ganzzahl√ºberl√§ufen zu verlassen wird
als Fehler angesehen.</p>
<p>Um die M√∂glichkeit eines √úberlaufs explizit zu behandeln, kannst du diese
Methodenfamilien verwenden, die die Standardbibliothek f√ºr primitive
numerische Typen bereitstellt:</p>
<ul>
<li>Umbrechen (wrap) aller F√§lle mit den Methoden <code>wrapping_*</code>, z.B.
<code>wrapping_add</code></li>
<li>Zur√ºckgeben des Wertes <code>None</code>, wenn es einen √úberlauf mit einer Methode
<code>checked_*</code> gibt.</li>
<li>Zur√ºckgeben des Wertes und eines booleschen Wertes, der angibt, ob ein
√úberlauf mit einer Methode <code>overflowing_*</code> stattgefunden hat.</li>
<li>Gew√§hrleisten der Minimal- oder Maximalwerte des Wertes mit den Methoden
<code>saturating_*</code>.</li>
</ul>
</blockquote>
<h4 id="flie√ükomma-typen"><a class="header" href="#flie√ükomma-typen">Flie√ükomma-Typen</a></h4>
<p>Rust hat auch zwei primitive Typen f√ºr <em>Flie√ükommazahlen</em>, das sind Zahlen mit
Dezimalkomma. Die Flie√ükomma-Typen in Rust sind <code>f32</code> und <code>f64</code>, die 32 Bit
bzw. 64 Bit gro√ü sind. Der Standardtyp ist <code>f64</code>, da er auf modernen CPUs
ungef√§hr die gleiche Geschwindigkeit wie <code>f32</code> hat, aber eine h√∂here Pr√§zision
erm√∂glicht. Alle Flie√ükomma-Typen sind vorzeichenbehaftet.</p>
<p>Hier ist ein Beispiel, das Flie√ükommazahlen in Aktion zeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>Flie√ükommazahlen werden nach dem IEEE-754-Standard dargestellt.</p>
<h4 id="numerische-operationen"><a class="header" href="#numerische-operationen">Numerische Operationen</a></h4>
<p>Rust unterst√ºtzt grundlegende mathematische Operationen, die man bei allen
Zahlentypen erwartet: Addition, Subtraktion, Multiplikation, Division und
Restberechnung. Die Ganzzahldivision rundet auf die n√§chste Ganzzahl ab. Der
folgende Code zeigt, wie du die einzelnen Typen in einer <code>let</code>-Anweisung
verwenden w√ºrdest:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    // Addition
    let sum = 5 + 10;

    // Subtraktion
    let difference = 95.5 - 4.3;

    // Multiplikation
    let product = 4 * 30;

    // Division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Ergibt -1

    // Restberechnung
    let remainder = 43 % 5;
}</code></pre></pre>
<p>Jeder Ausdruck in diesen Anweisungen verwendet einen mathematischen Operator
und wird zu einem einzelnen Wert ausgewertet, der dann an eine Variable
gebunden wird. <a href="appendix-02-operators.html">Anhang B</a> enth√§lt eine Liste aller Operatoren, die
Rust anbietet.</p>
<h4 id="der-boolesche-typ"><a class="header" href="#der-boolesche-typ">Der boolesche Typ</a></h4>
<p>Wie in den meisten anderen Programmiersprachen hat ein boolescher Typ in Rust
zwei m√∂gliche Werte: <code>true</code> (wahr) und <code>false</code> (falsch). Boolesche Werte sind
ein Byte gro√ü. In Rust wird der boolesche Typ mit <code>bool</code> spezifiziert. Zum
Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let t = true;

    let f: bool = false; // mit expliziter Typ-Annotation
}</code></pre></pre>
<p>Haupts√§chlich werden boolesche Werte in Bedingungen verwendet, z.B. im
<code>if</code>-Ausdruck. Wie <code>if</code>-Ausdr√ºcke in Rust funktionieren werden wir im Abschnitt
<a href="ch03-05-control-flow.html">‚ÄûKontrollfluss‚Äú</a> erl√§utern.</p>
<h4 id="der-zeichen-typ"><a class="header" href="#der-zeichen-typ">Der Zeichen-Typ</a></h4>
<p>Rusts Typ <code>char</code> ist der primitivste alphabetische Typ der Sprache. Hier sind
einige Beispiele f√ºr die Deklaration von <code>char</code>-Werten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let c = 'z';
    let z: char = '‚Ñ§'; // mit expliziter Typannotation
    let heart_eyed_cat = 'üòª';
}</code></pre></pre>
<p>Beachte, dass wir <code>char</code>-Literale mit einfachen Anf√ºhrungszeichen angeben, im
Gegensatz zu Zeichenketten-Literalen, die doppelte Anf√ºhrungszeichen verwenden.
Der Typ <code>char</code> von Rust ist vier Bytes gro√ü und stellt einen Unicode-Skalarwert
dar, was bedeutet, dass er viel mehr als nur ASCII darstellen kann.
Akzentuierte Buchstaben, chinesische, japanische und koreanische Zeichen, Emoji
und Leerzeichen mit Null-Breite sind g√ºltige <code>char</code>-Werte in Rust.
Unicode-Skalarwerte reichen von <code>U+0000</code> bis <code>U+D7FF</code> und von <code>U+E000</code> bis
einschlie√ülich <code>U+10FFFF</code>. Ein ‚ÄûZeichen‚Äú ist jedoch nicht wirklich ein Konzept
in Unicode, deine menschliche Intuition daf√ºr, was ein ‚ÄûZeichen‚Äú ist, stimmt
m√∂glicherweise nicht mit dem √ºberein, was ein <code>char</code> in Rust ist. Wir werden
dieses Thema in <a href="ch08-02-strings.html">‚ÄûUTF-8-kodierten Text in Zeichenketten (strings)
ablegen‚Äú</a> in Kapitel 8 im Detail besprechen.</p>
<h3 id="verbund-typen"><a class="header" href="#verbund-typen">Verbund-Typen</a></h3>
<p><em>Verbund-Typen</em> (compound types) k√∂nnen mehrere Werte zu einem Typ gruppieren.
Rust hat zwei primitive Verbund-Typen: Tupel (tuples) und Arrays (arrays).</p>
<h4 id="der-tupel-typ"><a class="header" href="#der-tupel-typ">Der Tupel-Typ</a></h4>
<p>Ein <em>Tupel</em> ist eine allgemeine M√∂glichkeit, eine Reihe von Werten mit einer
Vielzahl von Typen zu einem Verbund-Typ zusammenzufassen. Tupel haben eine
feste L√§nge: Einmal deklariert, k√∂nnen sie weder wachsen noch schrumpfen.</p>
<p>Wir erzeugen ein Tupel, indem wir eine durch Kommata getrennte Liste von Werten
innerhalb von Klammern schreiben. Jede Position im Tupel hat einen Typ und die
Typen der verschiedenen Werte im Tupel m√ºssen nicht gleich sein. In diesem
Beispiel haben wir optionale Typ-Annotationen angegeben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>Die Variable <code>tup</code> bindet das gesamte Tupel, da ein Tupel als ein einziges
Verbundelement betrachtet wird. Um die einzelnen Werte aus einem Tupel
herauszubekommen, k√∂nnen wir den Musterabgleich verwenden, um einen Tupelwert
zu destrukturieren, etwa so:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("Der Wert von y ist: {y}");
}</code></pre></pre>
<p>Dieses Programm erzeugt zun√§chst ein Tupel und bindet es an die Variable <code>tup</code>.
Dann benutzt es ein Muster mit <code>let</code>, um <code>tup</code> zu nehmen und in drei separate
Variablen <code>x</code>, <code>y</code> und <code>z</code> umzuwandeln. Dies nennt man <em>destrukturieren</em>
(destructuring), weil es das einzelne Tupel in drei Teile zerlegt. Schlie√ülich
gibt das Programm den Wert von <code>y</code> aus, der <code>6.4</code> ist.</p>
<p>Wir k√∂nnen direkt auf ein Tupelelement zugreifen, indem wir einen Punkt (<code>.</code>)
gefolgt vom Index des Wertes, auf den wir zugreifen wollen, verwenden. Zum
Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>Dieses Programm erstellt das Tupel <code>x</code> und greift dann auf jedes Element des
Tupels √ºber die jeweiligen Indizes zu. Wie bei den meisten Programmiersprachen
ist der erste Index in einem Tupel 0.</p>
<p>Das Tupel ohne Werte hat einen speziellen Namen: <em>Einheitswert</em> (unit value).
Dieser Wert und der zugeh√∂rige Typ (<em>Einheitstyp</em> (unit type)) werden beide mit
<code>()</code> geschrieben und stellen einen leeren Wert oder einen leeren R√ºckgabetyp
dar. Ausdr√ºcke geben implizit den Einheitswert zur√ºck, wenn sie keinen anderen
Wert zur√ºckgeben.</p>
<h4 id="der-array-typ"><a class="header" href="#der-array-typ">Der Array-Typ</a></h4>
<p>Eine andere M√∂glichkeit, eine Kollektion mit mehreren Werten zu haben, ist mit
einem <em>Array</em>. Im Gegensatz zu einem Tupel muss jedes Element eines Arrays den
gleichen Typ haben. Anders als Arrays in einigen anderen Sprachen haben Arrays
in Rust eine feste L√§nge.</p>
<p>Wir schreiben die Werte in einem Array als kommagetrennte Liste in eckigen
Klammern:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>Arrays sind n√ºtzlich, wenn du deine Daten eher auf dem Stapelspeicher als im
Haldenspeicher abgelegt haben m√∂chtest, wie bei den anderen Typen, die wir
bisher gesehen haben, (auf den Stapelspeicher und den Haldenspeicher gehen wir
in <a href="ch04-01-what-is-ownership.html#stapelspeicher-stack-und-haldenspeicher-heap">Kapitel 4</a> n√§her ein) oder wenn du sicherstellen willst,
dass du immer eine feste Anzahl von Elementen hast. Ein Array ist jedoch nicht
so flexibel wie der Vektortyp. Ein <em>Vektor</em> ist ein √§hnlicher Kollektionstyp,
der von der Standardbibliothek zur Verf√ºgung gestellt wird und der in seiner
Gr√∂√üe wachsen oder schrumpfen kann. Wenn du dir nicht sicher bist, ob du ein
Array oder einen Vektor verwenden sollst, ist es wahrscheinlich, dass du einen
Vektor verwenden solltest. In <a href="ch08-01-vectors.html">Kapitel 8</a> werden Vektoren
ausf√ºhrlicher besprochen.</p>
<p>Arrays sind jedoch hilfreicher, wenn du wei√üt, dass sich die Anzahl der
Elemente nicht √§ndern wird. Wenn du z.B. die Monatsnamen in einem Programm
verwendest, w√ºrdest du wahrscheinlich eher ein Array als einen Vektor
verwenden, weil du wei√üt, dass es immer 12 Elemente enthalten wird:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["Januar", "Februar", "M√§rz", "April", "Mai", "Juni", "Juli",
              "August", "September", "Oktober", "November", "Dezember"];
<span class="boring">}</span></code></pre></pre>
<p>Der Typ eines Arrays wird in eckigen Klammern mit dem Typ der einzelnen
Elemente angegeben, ein Semikolon und dann die Anzahl der Elemente im Array,
etwa so:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Hier ist <code>i32</code> der Typ aller Elemente. Nach dem Semikolon gibt die Zahl <code>5</code> an,
dass das Array f√ºnf Elemente enth√§lt.</p>
<p>Du kannst ein Array auch so initialisieren, dass es f√ºr jedes Element denselben
Wert enth√§lt, indem du den Anfangswert, gefolgt von einem Semikolon, und dann
die L√§nge des Arrays in eckigen Klammern angibst, wie hier gezeigt:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p>Das Array mit dem Namen <code>a</code> wird <code>5</code> Elemente enthalten, die alle anf√§nglich
auf den Wert <code>3</code> gesetzt werden. Dies ist dasselbe wie das Schreiben von
<code>let a = [3, 3, 3, 3, 3];</code>, aber in einer pr√§gnanteren Weise.</p>
<h5 id="zugriff-auf-array-elemente"><a class="header" href="#zugriff-auf-array-elemente">Zugriff auf Array-Elemente</a></h5>
<p>Ein Array ist ein einzelner Speicherbereich mit einer bekannten, festen Gr√∂√üe,
der auf den Stapelspeicher gelegt wird. Du kannst auf Elemente eines Arrays mit
Hilfe der Indizierung wie folgt zugreifen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>In diesem Beispiel erh√§lt die Variable mit dem Namen <code>first</code> den Wert <code>1</code>, weil
das der Wert am Index <code>[0]</code> im Array ist. Die Variable mit dem Namen <code>second</code>
wird den Wert <code>2</code> vom Index <code>[1]</code> im Array erhalten.</p>
<h5 id="ung√ºltiger-array-element-zugriff"><a class="header" href="#ung√ºltiger-array-element-zugriff">Ung√ºltiger Array-Element-Zugriff</a></h5>
<p>Sehen wir uns an was passiert, wenn du versuchst, auf ein Element eines Arrays
zuzugreifen, das sich hinter dem Ende des Arrays befindet. Angenommen, du
f√ºhrst diesen Code aus, √§hnlich zum Ratespiel in Kapitel 2, um einen
Array-Index vom Benutzer zu erhalten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust panics edition2024">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Bitte gib einen Array-Index ein.");

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect("Fehler beim Lesen der Zeile");

    let index: usize = index
        .trim()
        .parse()
        .expect("Eingegebener Index war keine Zahl");

    let element = a[index];

    println!(
        "Der Wert von element beim Index {index} ist: {element}");
}</code></pre></pre>
<p>Dieser Code kompiliert erfolgreich. Wenn du diesen Code mit <code>cargo run</code>
ausf√ºhrst und <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> oder <code>4</code> eingibst, wird das Programm den
entsprechenden Wert an diesem Index im Array ausgeben. Wenn du stattdessen eine
Zahl hinter dem Ende des Arrays eingibst, z.B. <code>10</code>, erh√§ltst du eine Ausgabe
wie diese:</p>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Das Programm f√ºhrte zu einem <em>Laufzeitfehler</em> an der Stelle, an der ein
ung√ºltiger Wert in der Index-Operation verwendet wurde. Das Programm wurde mit
einer Fehlermeldung beendet und hat die abschlie√üende <code>println!</code>-Anweisung
nicht ausgef√ºhrt. Wenn du versuchst, mit Hilfe der Indizierung auf ein Element
zuzugreifen, pr√ºft Rust, ob der angegebene Index kleiner als die Array-L√§nge
ist. Wenn der Index gr√∂√üer oder gleich der L√§nge ist, wird Rust das Programm
abbrechen. Diese Pr√ºfung muss zur Laufzeit erfolgen, insbesondere in diesem
Fall, weil der Compiler unm√∂glich wissen kann, welchen Wert ein Benutzer sp√§ter
eingeben wird, wenn er den Code ausf√ºhrt.</p>
<p>Dies ist ein Beispiel f√ºr die Umsetzung der Speichersicherheitsprinzipien von
Rust. In vielen Low-Level-Sprachen wird diese Art der √úberpr√ºfung nicht
durchgef√ºhrt und wenn du einen falschen Index angibst, kann auf ung√ºltigen
Speicher zugegriffen werden. Rust sch√ºtzt dich vor dieser Art von Fehlern,
indem es das Programm sofort beendet, anstatt den Speicherzugriff zuzulassen
und fortzusetzen. Kapitel 9 behandelt die Fehlerbehandlung in Rust und wie du
lesbaren, sicheren Code schreiben kannst, der weder abst√ºrzt noch ung√ºltige
Speicherzugriffe zul√§sst.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-01-variables-and-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-03-how-functions-work.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-01-variables-and-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-03-how-functions-work.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
