<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refaktorierung-um-die-modularität-und-fehlerbehandlung-zu-verbessern"><a class="header" href="#refaktorierung-um-die-modularität-und-fehlerbehandlung-zu-verbessern">Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern</a></h2>
<p>Um unser Programm zu verbessern, werden wir vier Probleme beheben, die mit der
Struktur des Programms und dem Umgang mit potenziellen Fehlern zu tun haben.
Erstens erfüllt unsere Funktion <code>main</code> jetzt zwei Aufgaben: Sie parst Argumente
und liest Dateien. Für eine so kleine Funktion ist dies kein großes Problem.
Wenn wir jedoch unser Programm innerhalb der Funktion <code>main</code> weiter ausbauen,
wird die Anzahl der einzelnen Aufgaben, die die Funktion <code>main</code> bearbeitet,
zunehmen. In dem Maße, wie eine Funktion an Verantwortung hinzugewinnt, wird es
schwieriger sie zu verstehen, schwieriger sie zu testen und schwieriger sie zu
ändern, ohne dass eines ihrer Teile kaputtgeht. Am besten ist es, die
Funktionalität so aufzuteilen, dass jede Funktion für eine Aufgabe zuständig
ist.</p>
<p>Diese Frage hängt auch mit dem zweiten Problem zusammen: Obwohl <code>query</code> und
<code>file_path</code> Konfigurationsvariablen unseres Programms sind, werden Variablen
wie <code>contents</code> verwendet, um die Logik des Programms umzusetzen. Je länger
<code>main</code> wird, desto mehr Variablen müssen wir in den Gültigkeitsbereich bringen;
je mehr Variablen wir im Gültigkeitsbereich haben, desto schwieriger wird es,
den Zweck der einzelnen Variablen im Auge zu behalten. Es ist am besten, die
Konfigurationsvariablen in einer Struktur zu gruppieren, um ihren Zweck zu
verdeutlichen.</p>
<p>Das dritte Problem ist, dass wir <code>expect</code> benutzt haben, um eine Fehlermeldung
auszugeben, wenn das Lesen der Datei fehlschlägt, aber die Fehlermeldung gibt
nur <code>Sollte die Datei lesen können</code> aus. Das Lesen einer Datei kann
auf verschiedene Arten fehlschlagen: Zum Beispiel könnte die Datei fehlen oder
wir haben keine Berechtigung, sie zu öffnen. Im Moment würden wir unabhängig
von der Situation die Fehlermeldung „Etwas ging beim Lesen der Datei schief“
ausgeben, die dem Benutzer keinerlei Informationen geben würde!</p>
<p>Viertens verwenden wir <code>expect</code> erneut, um einen Fehler zu behandeln, und wenn
der Benutzer unser Programm ausführt, ohne genügend Argumente anzugeben, erhält
er einen <code>Index out of bounds</code>-Fehler von Rust, der das Problem nicht eindeutig
erklärt. Am besten wäre es, wenn sich der gesamte Fehlerbehandlungscode an
einer Stelle befände, sodass zukünftige Entwickler nur eine Stelle im Code
konsultieren bräuchten, falls sich die Fehlerbehandlungslogik ändern sollte.
Wenn sich der gesamte Fehlerbehandlungscode an einer Stelle befindet, wird auch
sichergestellt, dass wir Meldungen ausgeben, die für unsere Endbenutzer
aussagekräftig sind.</p>
<p>Lass uns diese vier Probleme angehen, indem wir unser Projekt refaktorieren.</p>
<h3 id="trennen-der-zuständigkeiten-bei-binärprojekten"><a class="header" href="#trennen-der-zuständigkeiten-bei-binärprojekten">Trennen der Zuständigkeiten bei Binärprojekten</a></h3>
<p>Das organisatorische Problem der Zuweisung der Verantwortung für mehrere
Aufgaben an die Funktion <code>main</code> ist vielen Binärprojekten gemein.
Infolgedessen hat die Rust-Gemeinschaft eine Richtlinie für die Aufteilung der
einzelnen Aufgaben eines Binärprogramms entwickelt, wenn die Funktion <code>main</code>
groß wird. Dieser Prozess umfasst die folgenden Schritte:</p>
<ul>
<li>Teile dein Programm in die Dateien <em>main.rs</em> und <em>lib.rs</em> auf und verschiebe
die Logik deines Programms in <em>lib.rs</em>.</li>
<li>Solange deine Kommandozeilen-Parselogik klein ist, kann sie in <em>main.rs</em>
bleiben.</li>
<li>Wenn die Kommandozeilen-Parselogik anfängt, kompliziert zu werden, extrahiere
sie aus <em>main.rs</em> und verschiebe sie in <em>lib.rs</em>.</li>
</ul>
<p>Die Verantwortlichkeiten, die nach diesem Prozess in der Funktion <code>main</code>
verbleiben, sollten sich auf Folgendes beschränken:</p>
<ul>
<li>Aufrufen der Kommandozeilen-Parselogik mit den Argumentwerten</li>
<li>Aufbauen weiterer Konfiguration</li>
<li>Aufrufen einer Funktion <code>run</code> in <em>lib.rs</em></li>
<li>Behandeln des Fehlers, wenn <code>run</code> einen Fehler zurückgibt</li>
</ul>
<p>Bei diesem Muster geht es darum, Verantwortlichkeiten zu trennen: <em>main.rs</em>
kümmert sich um die Ausführung des Programms und <em>lib.rs</em> kümmert sich um die
gesamte Logik der anstehenden Aufgabe. Da du die Funktion <code>main</code> nicht direkt
testen kannst, kannst du mit dieser Struktur die gesamte Logik deines Programms
testen, indem du sie in Funktionen in <em>lib.rs</em> verschiebst. Der Code, der in
<em>main.rs</em> verbleibt, wird klein genug sein, um seine Korrektheit durch Lesen zu
überprüfen. Lass uns unser Programm überarbeiten, indem wir diesem Prozess
folgen.</p>
<h4 id="extrahieren-des-argument-parsers"><a class="header" href="#extrahieren-des-argument-parsers">Extrahieren des Argument-Parsers</a></h4>
<p>Wir werden die Funktionalität für das Parsen von Argumenten in eine Funktion
extrahieren, die von <code>main</code> aufgerufen wird, um das Verschieben der
Kommandozeilen-Parselogik nach <em>src/lib.rs</em> vorzubereiten. Codeblock 12-5 zeigt
den neuen Anfang von <code>main</code>, der eine neue Funktion <code>parse_config</code> aufruft, die
wir vorerst in <em>src/main.rs</em> definieren werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --abschneiden--
<span class="boring">
</span><span class="boring">    println!("Suche nach {query}");
</span><span class="boring">    println!("In Datei {file_path}");
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect("Etwas ging beim Lesen der Datei schief");
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
<p><span class="caption">Codeblock 12-5: Extrahieren einer Funktion <code>parse_config</code>
aus <code>main</code></span></p>
<p>Wir sammeln immer noch die Kommandozeilenargumente in einem Vektor, aber
anstatt den Argumentwert am Index 1 der Variablen <code>query</code> und den Argumentwert
am Index 2 der Variablen <code>file_path</code> innerhalb der Funktion <code>main</code> zuzuweisen,
übergeben wir den gesamten Vektor an die Funktion <code>parse_config</code>. Die Funktion
<code>parse_config</code> enthält dann die Logik, die bestimmt, welches Argument in welche
Variable geht und die Werte an <code>main</code> zurückgibt. Wir erstellen immer noch die
Variablen <code>query</code> und <code>file_path</code> in <code>main</code>, aber <code>main</code> hat nicht mehr die
Verantwortung zu bestimmen, wie die Kommandozeilenargumente und Variablen
zusammenpassen.</p>
<p>Dieses Überarbeiten mag für unser kleines Programm übertrieben erscheinen, aber
wir führen die Refactoring-Maßnahmen in kleinen, inkrementellen Schritten
durch. Nachdem du diese Änderung vorgenommen hast, führe das Programm erneut
aus, um zu überprüfen, ob das Argumentparsen noch funktioniert. Es ist gut, den
Fortschritt oft zu überprüfen, um die Ursache von Problemen zu erkennen, wenn
sie auftreten.</p>
<h4 id="gruppieren-von-konfigurationswerten"><a class="header" href="#gruppieren-von-konfigurationswerten">Gruppieren von Konfigurationswerten</a></h4>
<p>Wir können einen weiteren kleinen Schritt tun, um die Funktion <code>parse_config</code>
weiter zu verbessern. Im Moment geben wir ein Tupel zurück, aber dann zerlegen
wir dieses Tupel sofort wieder in einzelne Teile. Das ist ein Zeichen dafür,
dass wir vielleicht noch nicht die richtige Abstraktion haben.</p>
<p>Ein weiterer Indikator, der zeigt, dass es Raum für Verbesserungen gibt, ist
der <code>config</code>-Teil von <code>parse_config</code>, der impliziert, dass die beiden von uns
zurückgegebenen Werte miteinander in Beziehung stehen und beide Teil eines
Konfigurationswertes sind. Diese Bedeutung vermitteln wir derzeit nur durch die
Gruppierung der beiden Werte in einem Tupel. Geben wir daher die beiden Werte
in einer Struktur an und geben jedem der Strukturfelder einen aussagekräftigen
Namen. Auf diese Weise wird es künftigen Entwicklern dieses Codes leichter
fallen, zu verstehen, wie die verschiedenen Werte miteinander in Beziehung
stehen und was ihr Zweck ist.</p>
<p>Codeblock 12-6 zeigt die Verbesserungen der Funktion <code>parse_config</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!("Suche nach {}", config.query);
    println!("In Datei {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Etwas ging beim Lesen der Datei schief");

    // --abschneiden--
<span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre></pre>
<p><span class="caption">Codeblock 12-6: Refactorieren von <code>parse_config</code> zur
Rückgabe einer Instanz einer <code>Config</code>-Struktur</span></p>
<p>Wir haben eine Struktur namens <code>Config</code> hinzugefügt, die so definiert ist, dass
sie Felder mit den Namen <code>query</code> und <code>file_path</code> enthält. Die Signatur von
<code>parse_config</code> zeigt nun an, dass sie einen <code>Config</code>-Wert zurückgibt. Im
Rumpf von <code>parse_config</code>, wo wir früher Zeichenkettenanteilstypen (string
slices) zurückgegeben haben, die auf <code>String</code>-Werte in <code>args</code> referenzieren,
definieren wir <code>Config</code> jetzt so, dass es aneigenbare (owned) <code>String</code>-Werte
enthält. Die <code>args</code>-Variable in <code>main</code> ist der Eigentümer der Argumentwerte und
lässt die Funktion <code>parse_config</code> diese nur ausleihen, was bedeutet, dass wir
Rusts Regeln für das Ausleihen verletzen würden, wenn <code>Config</code> versucht, die
Eigentümerschaft für die Werte in <code>args</code> zu nehmen.</p>
<p>Wir könnten die <code>String</code>-Daten auf verschiedene Weise verwalten, aber der
einfachste, wenn auch etwas ineffiziente Weg ist es, die Methode <code>clone</code> der
Werte aufzurufen. Dadurch wird eine vollständige Kopie der Daten erstellt, die
die <code>Config</code>-Instanz besitzen soll, was mehr Zeit und Speicherplatz in Anspruch
nimmt als das Speichern einer Referenz auf die Zeichenkettendaten. Das Klonen
der Daten macht unseren Code jedoch auch sehr unkompliziert, weil wir die
Lebensdauer der Referenzen nicht verwalten müssen; unter diesen Umständen ist
es ein lohnender Kompromiss, ein wenig Leistung aufzugeben, um Einfachheit zu
bekommen.</p>
<blockquote>
<h3 id="die-kompromisse-beim-verwenden-von-clone"><a class="header" href="#die-kompromisse-beim-verwenden-von-clone">Die Kompromisse beim Verwenden von <code>clone</code></a></h3>
<p>Viele Rust-Entwickler neigen dazu, das Verwenden von <code>clone</code> zur Lösung von
Eigentümerschaftsproblemen wegen der Laufzeitkosten zu vermeiden. In <a href="ch13-00-functional-features.html">Kapitel
13</a> erfährst du, wie du in solchen Situationen effizientere Methoden
einsetzen kannst. Aber für den Moment ist es in Ordnung, ein paar
Zeichenketten zu kopieren, um weiter voranzukommen, da du diese Kopien nur
einmal erstellen wirst und dein Dateipfad und deine Suchzeichenkette sehr
klein sind. Es ist besser, ein funktionierendes Programm zu haben, das ein
bisschen ineffizient ist, als zu versuchen, den Code beim ersten Durchgang zu
hyperoptimieren. Je mehr Erfahrung du mit Rust sammelst, desto einfacher wird
es, mit der effizientesten Lösung zu beginnen, aber im Moment ist es völlig
akzeptabel, <code>clone</code> aufzurufen.</p>
</blockquote>
<p>Wir haben <code>main</code> aktualisiert, sodass es die Instanz von <code>Config</code>, die von
<code>parse_config</code> zurückgegeben wird, in eine Variable namens <code>config</code> setzt, und
wir haben den Code aktualisiert, der vorher die separaten Variablen <code>query</code> und
<code>file_path</code> verwendet hat, sodass er jetzt stattdessen die Felder der
<code>Config</code>-Struktur verwendet.</p>
<p>Nun vermittelt unser Code deutlicher, dass <code>query</code> und <code>file_path</code> zueinander
gehören und dass ihr Zweck darin besteht, die Funktionsweise des Programms zu
konfigurieren. Jeder Code, der diese Werte verwendet, weiß, dass er sie in der
<code>config</code>-Instanz in den für ihren Zweck benannten Feldern findet.</p>
<h4 id="erstellen-eines-konstruktors-für-config"><a class="header" href="#erstellen-eines-konstruktors-für-config">Erstellen eines Konstruktors für <code>Config</code></a></h4>
<p>Bisher haben wir die Logik, die für das Parsen der Kommandozeilenargumente
verantwortlich ist, aus <code>main</code> extrahiert und in die Funktion <code>parse_config</code>
verschoben. Dies half uns zu erkennen, dass die Werte <code>query</code> und <code>file_path</code>
miteinander in Beziehung stehen und diese Beziehung in unserem Code vermittelt
werden sollte. Wir fügten dann eine <code>Config</code>-Struktur hinzu, um das
Zusammengehören von <code>query</code> und <code>file_path</code> zu benennen und um die Namen der
Werte als Feldnamen der Struktur von der Funktion <code>parse_config</code> zurückgeben zu
können.</p>
<p>Da nun der Zweck der Funktion <code>parse_config</code> darin besteht, eine
<code>Config</code>-Instanz zu erzeugen, können wir <code>parse_config</code> von einer einfachen
Funktion in eine Funktion namens <code>new</code> ändern, die mit der <code>Config</code>-Struktur
assoziiert ist. Durch diese Änderung wird der Code idiomatischer. Wir können
Instanzen von Typen in der Standardbibliothek erstellen, wie bei <code>String</code>,
indem wir <code>String::new</code> aufrufen. In ähnlicher Weise können wir durch Ändern
von <code>parse_config</code> in eine Funktion <code>new</code>, die mit <code>Config</code> assoziiert ist,
Instanzen von <code>Config</code> durch Aufrufen von <code>Config::new</code> erzeugen. Codeblock
12-7 zeigt die Änderungen, die wir vornehmen müssen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

<span class="boring">    println!("Suche nach {}", config.query);
</span><span class="boring">    println!("In Datei {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Etwas ging beim Lesen der Datei schief");
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span><span class="boring">
</span>    // --abschneiden--
}

// --abschneiden--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 12-7: Ändern von <code>parse_config</code> in
<code>Config::new</code></span></p>
<p>Wir haben <code>main</code> aktualisiert, wo wir <code>parse_config</code> aufgerufen haben, um
stattdessen <code>Config::new</code> aufzurufen. Wir haben den Namen von <code>parse_config</code> in
<code>new</code> geändert und ihn innerhalb eines <code>impl</code>-Blocks verschoben, der die
Funktion <code>new</code> mit <code>Config</code> assoziiert. Versuche, diesen Code erneut zu
kompilieren, um sicherzustellen, dass er funktioniert.</p>
<h3 id="korrigieren-der-fehlerbehandlung"><a class="header" href="#korrigieren-der-fehlerbehandlung">Korrigieren der Fehlerbehandlung</a></h3>
<p>Jetzt werden wir daran arbeiten, unsere Fehlerbehandlung zu korrigieren.
Erinnere dich, dass der Versuch, auf die Werte im <code>args</code>-Vektor bei Index 1
oder Index 2 zuzugreifen, das Programm zum Absturz bringt, wenn der Vektor
weniger als drei Elemente enthält. Versuche, das Programm ohne irgendwelche
Argumente laufen zu lassen; es wird so aussehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Die Zeile <code>index out of bounds: the len is 1 but the index is 1</code> ist eine für
Programmierer bestimmte Fehlermeldung. Sie wird unseren Endbenutzern nicht
helfen zu verstehen, was sie stattdessen tun sollten. Lass uns das jetzt
korrigieren.</p>
<h4 id="verbessern-der-fehlermeldung"><a class="header" href="#verbessern-der-fehlermeldung">Verbessern der Fehlermeldung</a></h4>
<p>In Codeblock 12-8 fügen wir eine Prüfung in der Funktion <code>new</code> hinzu, die
überprüft, ob der Anteilstyp lang genug ist, bevor auf Index 1 und Index 2
zugegriffen wird. Wenn der Anteilstyp nicht lang genug ist, stürzt das Programm
ab und zeigt eine bessere Fehlermeldung an.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Suche nach {}", config.query);
</span><span class="boring">    println!("In Datei {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Etwas ging beim Lesen der Datei schief");
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --abschneiden--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!("Nicht genügend Argumente");
        }
        // --abschneiden--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-8: Hinzufügen einer Prüfung für die Anzahl
der Argumente</span></p>
<p>Dieser Code ähnelt <a href="ch09-03-to-panic-or-not-to-panic.html#benutzerdefinierte-typen-f%C3%BCr-die-validierung-erstellen">der Funktion <code>Guess::new</code>, die wir in Codeblock
9-13</a> geschrieben haben, wo wir <code>panic!</code> aufgerufen haben,
wenn das Argument <code>value</code> außerhalb des gültigen Wertebereichs lag. Anstatt
hier auf einen Wertebereich zu prüfen, prüfen wir, ob die Länge von <code>args</code>
mindestens <code>3</code> beträgt und der Rest der Funktion unter der Annahme arbeiten
kann, dass diese Bedingung erfüllt ist. Wenn <code>args</code> weniger als drei Elemente
hat, wird diese Bedingung <code>true</code> und wir rufen das Makro <code>panic!</code> auf, um das
Programm sofort zu beenden.</p>
<p>Mit diesen zusätzlichen wenigen Zeilen Code in <code>new</code> lassen wir das Programm
ohne Argumente erneut laufen, um zu sehen, wie der Fehler jetzt aussieht:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:26:13:
Nicht genügend Argumente
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Diese Ausgabe ist besser: Wir haben jetzt eine vernünftige Fehlermeldung. Wir
haben jedoch auch irrelevante Informationen, die wir unseren Benutzern nicht
geben wollen. Vielleicht ist die Technik, die wir in Codeblock 9-13 verwendet
haben, hier nicht die beste: Das Aufrufen von <code>panic!</code> ist für ein
Programmierproblem besser geeignet als für ein Nutzungsproblem, <a href="ch09-03-to-panic-or-not-to-panic.html#richtlinien-zur-fehlerbehandlung">wie in Kapitel
9 besprochen</a>. Stattdessen können wir die andere Technik
verwenden, über die du in Kapitel 9 gelernt hast – <a href="ch09-02-recoverable-errors-with-result.html">Rückgabe eines
<code>Result</code></a> um entweder Erfolg oder einen Fehler anzuzeigen.</p>
<h4 id="zurückgeben-eines-result-anstatt-panic-aufzurufen"><a class="header" href="#zurückgeben-eines-result-anstatt-panic-aufzurufen">Zurückgeben eines <code>Result</code> anstatt <code>panic!</code> aufzurufen</a></h4>
<p>Wir können stattdessen einen <code>Result</code>-Wert zurückgeben, der im erfolgreichen
Fall eine <code>Config</code>-Instanz enthält und im Fehlerfall das Problem beschreibt.
Wir werden auch den Namen der Funktion von <code>new</code> in <code>build</code> ändern, weil viele
Programmierer erwarten, dass <code>new</code>-Funktionen niemals fehlschlagen. Wenn
<code>Config::build</code> mit <code>main</code> kommuniziert, können wir den <code>Result</code>-Typ verwenden,
um zu signalisieren, dass ein Problem aufgetreten ist. Dann können wir <code>main</code>
ändern, um eine <code>Err</code>-Variante in einen praktikableren Fehler für unsere
Benutzer umzuwandeln, ohne den umgebenden Text über <code>thread 'main'</code> und
<code>RUST_BACKTRACE</code>, den ein Aufruf von <code>panic!</code> verursacht.</p>
<p>Codeblock 12-9 zeigt die Änderungen, die wir am Rückgabewert der Funktion, die
nun <code>Config::build</code> aufruft, und am Funktionsrumpf vornehmen müssen, um ein
<code>Result</code> zurückzugeben. Beachte, dass dies nicht kompiliert werden kann, bis
wir auch <code>main</code> aktualisieren, was wir im nächsten Codeblock tun werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Suche nach {}", config.query);
</span><span class="boring">    println!("In Datei {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Etwas ging beim Lesen der Datei schief");
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("Nicht genügend Argumente");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
<p><span class="caption">Codeblock 12-9: Rückgabe eines <code>Result</code> von
<code>Config::build</code></span></p>
<p>Unsere Funktion <code>build</code> liefert ein <code>Result</code> mit einer <code>Config</code>-Instanz im
Erfolgsfall und ein Zeichenkettenliteral im Fehlerfall. Unsere Fehlerwerte
werden immer Zeichenketten-Literale sein, die eine <code>'static</code> Lebensdauer haben.</p>
<p>Wir haben zwei Änderungen im Rumpf der Funktion vorgenommen: Anstatt <code>panic!</code>
aufzurufen, wenn der Benutzer nicht genug Argumente übergibt, geben wir jetzt
einen <code>Err</code>-Wert zurück, und wir haben den <code>Config</code>-Rückgabewert in ein <code>Ok</code>
verpackt. Diese Änderungen machen die Funktion konform mit ihrer neuen
Typsignatur.</p>
<p>Die Rückgabe eines <code>Err</code>-Wertes aus <code>Config::build</code> erlaubt es der Funktion
<code>main</code>, den von der Funktion <code>build</code> zurückgegebenen <code>Result</code>-Wert zu verarbeiten
und den Prozess im Fehlerfall sauberer zu beenden.</p>
<h4 id="aufrufen-von-configbuild-und-behandeln-von-fehlern"><a class="header" href="#aufrufen-von-configbuild-und-behandeln-von-fehlern">Aufrufen von <code>Config::build</code> und Behandeln von Fehlern</a></h4>
<p>Um den Fehlerfall zu behandeln und eine benutzerfreundliche Meldung auszugeben,
müssen wir <code>main</code> aktualisieren, um das von <code>Config::build</code> zurückgegebene
<code>Result</code> zu behandeln, wie in Codeblock 12-10 gezeigt. Wir werden auch die
Verantwortung dafür übernehmen, das Kommandozeilenwerkzeug mit einem Fehlercode
ungleich Null wie bei <code>panic!</code> zu beenden und es von Hand zu implementieren.
Ein Exit-Status ungleich Null ist eine Konvention, um dem Prozess, der unser
Programm aufgerufen hat, zu signalisieren, dass das Programm mit einem
Fehlerstatus beendet wurde.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!("Fehler beim Parsen der Argumente: {err}");
        process::exit(1);
    });

    // --abschneiden--
<span class="boring">
</span><span class="boring">    println!("Suche nach {}", config.query);
</span><span class="boring">    println!("In Datei {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Etwas ging beim Lesen der Datei schief");
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-10: Beenden mit einem Fehlercode, wenn das
Erstellen einer <code>Config</code> fehlschlägt</span></p>
<p>In diesem Codeblock haben wir eine Methode verwendet, die wir bisher noch
nicht behandelt haben: <code>unwrap_or_else</code>, die in der Standardbibliothek unter
<code>Result&lt;T, E&gt;</code> definiert ist. Das Verwenden von <code>unwrap_or_else</code> erlaubt es
uns, eine benutzerdefinierte nicht-<code>panic!</code>-Fehlerbehandlung zu definieren.
Wenn das <code>Result</code> ein <code>Ok</code>-Wert ist, verhält sich diese Methode ähnlich wie
<code>unwrap</code>: Sie gibt den inneren Wert von <code>Ok</code> zurück. Wenn der Wert jedoch ein
<code>Err</code>-Wert ist, ruft diese Methode den Code im <em>Funktionsabschluss</em> (closure)
auf, die eine anonyme Funktion ist, die wir definieren und als Argument an
<code>unwrap_or_else</code> übergeben. Auf Funktionsabschlüsse gehen wir ausführlicher in
<a href="ch13-00-functional-features.html">Kapitel 13</a> ein. Im Moment musst du nur wissen, dass <code>unwrap_or_else</code>
den inneren Wert des <code>Err</code>, in diesem Fall die statische Zeichenkette <code>Nicht genügend Argumente</code>, die wir in Codeblock 12-9 hinzugefügt haben, an unseren
Funktionsabschluss im Argument <code>err</code>, das zwischen den senkrechten Strichen
erscheint, weitergibt. Der Code im Funktionsabschluss kann dann den <code>err</code>-Wert
verwenden, wenn sie ausgeführt wird.</p>
<p>Wir haben eine neue Zeile <code>use</code> hinzugefügt, um <code>process</code> aus der
Standardbibliothek in den Gültigkeitsbereich zu bringen. Der Code im
Funktionsabschluss, der im Fehlerfall ausgeführt wird, besteht nur aus zwei
Zeilen: Wir geben den <code>err</code>-Wert aus und rufen dann <code>process::exit</code> auf. Die
Funktion <code>process::exit</code> stoppt das Programm sofort und gibt die Zahl zurück,
die als Exit-Statuscode übergeben wurde. Dies ähnelt der <code>panic!</code>-basierten
Behandlung, die wir in Codeblock 12-8 verwendet haben, aber wir erhalten nicht
mehr die gesamte zusätzliche Ausgabe. Lass es uns versuchen:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Fehler beim Parsen der Argumente: Nicht genügend Argumente
</code></pre>
<p>Großartig! Diese Ausgabe ist viel benutzerfreundlicher.</p>
<h3 id="extrahieren-von-logik-aus-main"><a class="header" href="#extrahieren-von-logik-aus-main">Extrahieren von Logik aus <code>main</code></a></h3>
<p>Da wir mit dem Refaktorieren des Konfigurations-Parsers nun fertig sind, wollen
wir uns der Logik des Programms zuwenden. Wie wir in <a href="#trennen-der-zust%C3%A4ndigkeiten-bei-bin%C3%A4rprojekten">„Trennen der
Zuständigkeiten bei
Binärprojekten“</a> erklärt
haben, werden wir eine Funktion namens <code>run</code> extrahieren, die die gesamte Logik
enthält, die sich derzeit in der Funktion <code>main</code> befindet und nicht mit dem
Aufsetzen der Konfiguration oder dem Behandeln von Fehlern zu tun hat. Wenn wir
fertig sind, wird die Funktion <code>main</code> übersichtlich und leicht zu verifizieren
sein. Zudem werden wir in der Lage sein, Tests für all die andere Logik zu
schreiben.</p>
<p>Codeblock 12-11 zeigt die extrahierte Funktion <code>run</code>. Im Moment machen wir nur
die kleine, inkrementelle Verbesserung durch Extrahieren der Funktion. Wir sind
immer noch dabei, die Funktion in <em>src/main.rs</em> zu definieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --abschneiden--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Fehler beim Parsen der Argumente: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Suche nach {}", config.query);
    println!("In Datei {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("Etwas ging beim Lesen der Datei schief");

    println!("Mit text:\n{contents}");
}

// --abschneiden--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-11: Extrahieren einer Funktion <code>run</code>, die
den Rest der Programmlogik enthält</span></p>
<p>Die Funktion <code>run</code> enthält nun die gesamte restliche Logik von <code>main</code>,
beginnend mit dem Lesen der Datei. Die Funktion <code>run</code> nimmt die
<code>Config</code>-Instanz als Argument.</p>
<h4 id="rückgabe-von-fehlern-aus-der-funktion-run"><a class="header" href="#rückgabe-von-fehlern-aus-der-funktion-run">Rückgabe von Fehlern aus der Funktion <code>run</code></a></h4>
<p>Wenn die verbleibende Programmlogik in die Funktion <code>run</code> separiert wird,
können wir die Fehlerbehandlung verbessern, wie wir es mit <code>Config::build</code> in
Codeblock 12-9 getan haben. Anstatt das Programm durch den Aufruf von <code>expect</code>
abstürzen zu lassen, gibt die Funktion <code>run</code> ein <code>Result&lt;T, E&gt;</code> zurück, wenn
etwas schief läuft. Auf diese Weise können wir in <code>main</code> die Logik rund um den
Umgang mit Fehlern auf benutzerfreundliche Weise weiter konsolidieren.
Codeblock 12-12 zeigt die Änderungen, die wir an der Signatur und dem Rumpf von
<code>run</code> vornehmen müssen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --abschneiden--

<span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Fehler beim Parsen der Argumente: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Suche nach {}", config.query);
</span><span class="boring">    println!("In Datei {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!("Mit text:\n{contents}");

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-12: Ändern der Funktion <code>run</code>, um ein
<code>Result</code> zurückzugeben</span></p>
<p>Wir haben hier drei wesentliche Änderungen vorgenommen. Erstens haben wir den
Rückgabetyp der Funktion <code>run</code> in <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> geändert. Diese
Funktion gab zuvor den Einheitstyp <code>()</code> zurück und wir behalten diesen als
Rückgabewert im Fall <code>Ok</code> bei.</p>
<p>Für den Fehlertyp haben wir das <em>Merkmalsobjekt</em> (trait object) <code>Box&lt;dyn Error&gt;</code> verwendet (und wir haben <code>std::error::Error</code> mit einer <code>use</code>-Anweisung
am Anfang des Gültigkeitsbereichs eingebunden). Wir werden Merkmalsobjekte in
<a href="ch18-00-oop.html">Kapitel 18</a> behandeln. Für den Moment solltest du nur wissen, dass
<code>Box&lt;dyn Error&gt;</code> bedeutet, dass die Funktion einen Typ zurückgibt, der das
Merkmal <code>Error</code> implementiert, aber wir müssen nicht angeben, welcher bestimmte
Typ der Rückgabewert sein wird. Das gibt uns die Flexibilität, Fehlerwerte
zurückzugeben, die in verschiedenen Fehlerfällen von unterschiedlichem Typ sein
können. Das Schlüsselwort <code>dyn</code> ist die Abkürzung für <em>dynamisch</em>.</p>
<p>Zweitens haben wir den Aufruf von <code>expect</code> zugunsten des <code>?</code>-Operators
entfernt, wie wir in <a href="ch09-02-recoverable-errors-with-result.html#abk%C3%BCrzung-zum-weitergeben-von-fehlern-der-operator-">Kapitel 9</a> besprochen haben. Statt
<code>panic!</code> bei einem Fehler aufzurufen gibt <code>?</code> den Fehlerwert aus der aktuellen
Funktion zurück, den der Aufrufer behandeln muss.</p>
<p>Drittens gibt die Funktion <code>run</code> jetzt im Erfolgsfall einen <code>Ok</code>-Wert zurück.
Wir haben den Erfolgstyp der Funktion <code>run</code> mit <code>()</code> in der Signatur
deklariert, was bedeutet, dass wir den Wert des Einheitstyps in den Wert <code>Ok</code>
einpacken müssen. Diese Syntax <code>Ok(())</code> mag zunächst etwas merkwürdig
aussehen, aber wenn wir <code>()</code> so verwenden, ist das der idiomatische Weg, um
anzuzeigen, dass wir <code>run</code> nur wegen seiner Seiteneffekte aufrufen; es gibt
keinen Wert zurück, den wir brauchen.</p>
<p>Wenn du diesen Code ausführst, wird er kompiliert, aber es wird eine Warnung
angezeigt:</p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Suche nach the
In Datei poem.txt
Mit text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Rust sagt uns, dass unser Code den <code>Result</code>-Wert ignoriert hat, und der
<code>Result</code>-Wert könnte darauf hinweisen, dass ein Fehler aufgetreten ist. Aber
wir überprüfen nicht, ob ein Fehler aufgetreten ist oder nicht, und der
Compiler erinnert uns daran, dass wir wahrscheinlich gemeint haben, hier etwas
Fehlerbehandlungscode zu haben! Lass uns dieses Problem jetzt beheben.</p>
<h4 id="behandeln-von-fehlern-die-von-run-in-main-zurückgegeben-wurden"><a class="header" href="#behandeln-von-fehlern-die-von-run-in-main-zurückgegeben-wurden">Behandeln von Fehlern, die von <code>run</code> in <code>main</code> zurückgegeben wurden</a></h4>
<p>Wir werden nach Fehlern suchen und sie mit einer Technik behandeln, die ähnlich
der Technik ist, die wir mit <code>Config::build</code> in Codeblock 12-10 verwendet
haben, aber mit einem kleinen Unterschied:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --abschneiden--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Fehler beim Parsen der Argumente: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Suche nach {}", config.query);
    println!("In Datei {}", config.file_path);

    if let Err(e) = run(config) {
        println!("Anwendungsfehler: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>Wir benutzen <code>if let</code> statt <code>unwrap_or_else</code>, um zu prüfen, ob <code>run</code> einen
<code>Err</code>-Wert zurückgibt und rufen <code>process::exit(1)</code> auf, wenn dies der Fall ist.
Die Funktion <code>run</code> gibt keinen Wert zurück, den wir mit <code>unwrap</code> auspacken
wollen, auf die gleiche Weise, wie <code>Config::build</code> die <code>Config</code>-Instanz
zurückgibt. Da <code>run</code> im Erfolgsfall <code>()</code> zurückgibt, geht es uns nur darum,
einen Fehler zu entdecken, wir brauchen also nicht <code>unwrap_or_else</code>, um den
ausgepackten Wert zurückzugeben, der nur <code>()</code> wäre.</p>
<p>Die Rümpfe von <code>if let</code> und der <code>unwrap_or_else</code>-Funktionen sind in beiden
Fällen gleich: Wir geben den Fehler aus und beenden.</p>
<h3 id="code-in-eine-bibliothekskiste-aufteilen"><a class="header" href="#code-in-eine-bibliothekskiste-aufteilen">Code in eine Bibliothekskiste aufteilen</a></h3>
<p>Unser <code>minigrep</code>-Projekt sieht soweit gut aus! Jetzt teilen wir die Datei
<em>src/main.rs</em> auf und fügen etwas Code in die Datei <em>src/lib.rs</em> ein. Auf
diese Weise können wir den Code testen und haben eine Datei <em>src/main.rs</em> mit
weniger Verantwortlichkeiten.</p>
<p>Lass uns den ganzen Code, der nicht in der Funktion <code>main</code> ist, von
<em>src/main.rs</em> nach <em>src/lib.rs</em> verschieben:</p>
<ul>
<li>Die Definition der Funktion <code>run</code></li>
<li>Die relevanten <code>use</code>-Anweisungen</li>
<li>Die Definition von <code>Config</code></li>
<li>Die Funktionsdefinition <code>Config::build</code></li>
</ul>
<p>Der Inhalt von <em>src/lib.rs</em> sollte die in Codeblock 12-13 gezeigten Signaturen
haben (wir haben die Rümpfe der Funktionen der Kürze halber weggelassen).
Beachte, dass dies nicht kompiliert werden kann, bis wir <em>src/main.rs</em> in
Codeblock 12-14 modifiziert haben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --abschneiden--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --abschneiden--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Codeblock 12-13: Verschieben von <code>Config</code> und <code>run</code> in
<em>src/lib.rs</em></span></p>
<p>Wir haben das Schlüsselwort <code>pub</code> großzügig verwendet: Bei <code>Config</code>, bei seinen
Feldern und seiner Methode <code>build</code> und bei der Funktion <code>run</code>. Wir haben jetzt
eine Bibliothekskiste, die eine öffentliche API hat, die wir testen können!</p>
<p>Jetzt müssen wir den Code, den wir nach <em>src/lib.rs</em> verschoben haben, in den
Gültigkeitsbereich der Binärkiste in <em>src/main.rs</em> bringen, wie in Codeblock
12-14 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --abschneiden--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Fehler beim Parsen der Argumente: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Suche nach {}", config.query);
</span><span class="boring">    println!("In Datei {}", config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --abschneiden--
<span class="boring">        println!("Anwendungsfehler: {e}");
</span><span class="boring">        process::exit(1);
</span>    }
}</code></pre>
<p><span class="caption">Codeblock 12-14: Verwenden der
<code>minigrep</code>-Bibliothekskiste in <em>src/main.rs</em></span></p>
<p>Wir fügen eine Zeile <code>use minigrep::Config</code> hinzu, um den Typ <code>Config</code> aus der
Bibliothekskiste in den Gültigkeitsbereich der Binärkiste zu bringen, und wir
stellen der Funktion <code>run</code> unseren Kistennamen voran. Nun sollte die gesamte
Funktionalität verbunden sein und funktionieren. Starte das Programm mit <code>cargo run</code> und stelle sicher, dass alles korrekt funktioniert.</p>
<p>Puh! Das war eine Menge Arbeit, aber wir haben uns für den Erfolg in der
Zukunft gerüstet. Jetzt ist es viel einfacher, mit Fehlern umzugehen, und wir
haben den Code modularer gestaltet. Fast unsere gesamte Arbeit wird von nun an
in <em>src/lib.rs</em> durchgeführt.</p>
<p>Lass uns diese neu gewonnene Modularität nutzen, indem wir etwas tun, was mit
dem alten Code schwierig gewesen wäre, mit dem neuen Code aber einfach ist: Wir
schreiben ein paar Tests!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-02-reading-a-file.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-02-reading-a-file.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
