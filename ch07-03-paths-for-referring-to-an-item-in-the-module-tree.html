<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mit Pfaden auf ein Element im Modulbaum verweisen - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="mit-pfaden-auf-ein-element-im-modulbaum-verweisen"><a class="header" href="#mit-pfaden-auf-ein-element-im-modulbaum-verweisen">Mit Pfaden auf ein Element im Modulbaum verweisen</a></h2>
<p>Um Rust zu zeigen, wo ein Element in einem Modulbaum zu finden ist, verwenden
wir einen Pfad, auf gleiche Weise wie beim Navigieren durch ein Dateisystem.
Um eine Funktion aufzurufen, müssen wir ihren Pfad kennen.</p>
<p>Ein Pfad kann zwei Formen annehmen:</p>
<ul>
<li>Ein <em>absoluter Pfad</em> ist der vollständige Pfad ausgehend von einer
Kistenwurzel; für Code aus einer externen Kiste beginnt der absolute Pfad mit
der Kistenwurzel, und für Code aus der aktuellen Kiste beginnt er mit dem
Literal <code>crate</code>.</li>
<li>Ein <em>relativer Pfad</em> startet beim aktuellen Modul und benutzt <code>self</code>, <code>super</code>
oder einen Bezeichner im aktuellen Modul.</li>
</ul>
<p>Sowohl absolute als auch relative Pfade bestehen aus einem oder mehreren
Bezeichnern, die durch doppelte Doppelpunkte (<code>::</code>) getrennt sind.</p>
<p>Um zu Codeblock 7-1 zurückzukehren, nehmen wir an, wir wollen die Funktion
<code>add_to_waitlist</code> aufrufen. Das ist dasselbe wie die Frage, wie der Pfad der
Funktion <code>add_to_waitlist</code> ist. Codeblock 7-3 enthält Codeblock 7-1, wobei
einige Module und Funktionen entfernt wurden.</p>
<p>Wir zeigen zwei Möglichkeiten, wie die Funktion <code>add_to_waitlist</code> von einer
neuen Funktion <code>eat_at_restaurant</code> aus aufgerufen werden kann, die in der
Kistenwurzel definiert ist. Diese Pfade sind korrekt, aber es gibt noch ein
weiteres Problem, das verhindert, dass dieses Beispiel in dieser Form
kompiliert. Wir werden gleich erklären, warum.</p>
<p>Die Funktion <code>eat_at_restaurant</code> ist Teil der öffentlichen
Programmierschnittstelle (API) unserer Bibliothekskiste, daher markieren wir
sie mit dem Schlüsselwort <code>pub</code>. Im Abschnitt <a href="#pfade-mit-dem-schl%C3%BCsselwort-pub-%C3%B6ffentlich-machen">„Pfade mit dem Schlüsselwort
<code>pub</code> öffentlich machen“</a> gehen wir näher auf <code>pub</code> ein.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absoluter Pfad
    crate::front_of_house::hosting::add_to_waitlist();

    // Relativer Pfad
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-3: Aufruf der Funktion <code>add_to_waitlist</code>
mittels absoluter und relativer Pfade</span></p>
<p>Beim ersten Aufruf der Funktion <code>add_to_waitlist</code> in <code>eat_at_restaurant</code>
verwenden wir einen absoluten Pfad. Die Funktion <code>add_to_waitlist</code> ist in der
gleichen Kiste definiert wie <code>eat_at_restaurant</code>, daher können wir das
Schlüsselwort <code>crate</code> verwenden, um einen absoluten Pfad zu beginnen. Dann
geben wir jedes der aufeinanderfolgenden Module an, bis wir <code>add_to_waitlist</code>
erreichen. Du kannst dir ein Dateisystem mit der gleichen Struktur vorstellen:
Wir würden den Pfad <code>/front_of_house/hosting/add_to_waitlist</code> angeben, um das
Programm <code>add_to_waitlist</code> auszuführen; das Verwenden des Namens <code>crate</code>, um
von der Kistenwurzel aus zu beginnen, ist analog zu <code>/</code>, um vom
Dateisystem-Wurzelverzeichnis in deinem Terminal aus zu beginnen.</p>
<p>Beim zweiten Aufruf von <code>add_to_waitlist</code> in <code>eat_at_restaurant</code> verwenden wir
einen relativen Pfad. Der Pfad beginnt mit <code>front_of_house</code>, dem Namen des
Moduls, das auf der gleichen Ebene des Modulbaums definiert ist wie
<code>eat_at_restaurant</code>. Hier wäre das Dateisystem-Äquivalent die Verwendung des
Pfades <code>front_of_house/hosting/add_to_waitlist</code>. Mit einem Modulnamen zu
beginnen bedeutet, dass der Pfad relativ ist.</p>
<p>Die Überlegung, ob ein relativer oder absoluter Pfad verwendet wird, ist eine
Entscheidung, die du auf Basis deines Projekts treffen wirst, und hängt davon
ab, ob du den Code für die Elementdefinition eher separat oder zusammen mit dem
Code ablegen möchtest, der das Element verwendet. Wenn wir zum Beispiel das
Modul <code>front_of_house</code> und die Funktion <code>eat_at_restaurant</code> in ein Modul namens
<code>customer_experience</code> verschieben, müssten wir den absoluten Pfad in
<code>add_to_waitlist</code> ändern, aber der relative Pfad wäre immer noch gültig. Wenn
wir jedoch die Funktion <code>eat_at_restaurant</code> in ein separates Modul namens
<code>dining</code> verschieben würden, würde der absolute Pfad beim Aufruf
<code>add_to_waitlist</code> gleich bleiben, aber der relative Pfad müsste aktualisiert
werden. Wir bevorzugen generell die Angabe absoluter Pfade, da es
wahrscheinlicher ist, dass Codedefinitionen und Elementaufrufe unabhängig
voneinander verschoben werden.</p>
<p>Lass uns versuchen, Codeblock 7-3 zu kompilieren, und herausfinden, warum er
sich noch nicht kompilieren lässt! Die Fehler, die wir erhalten, sind in
Codeblock 7-4 zu sehen.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<p><span class="caption">Codeblock 7-4: Kompilierfehler im Code in Codeblock
7-3</span></p>
<p>Die Fehlermeldungen besagen, dass das Modul <code>hosting</code> privat ist. Mit anderen
Worten, wir haben die korrekten Pfade für das Modul <code>hosting</code> und die Funktion
<code>add_to_waitlist</code> angegeben, aber Rust lässt sie uns nicht nutzen, weil es
keinen Zugriff auf die privaten Abschnitte hat. In Rust sind alle Elemente
(Funktionen, Methoden, Strukturen, Aufzählungen, Module und Konstanten)
standardmäßig privat für übergeordnete Module. Wenn du ein Element wie eine
Funktion oder Struktur privat machen willst, setze es in ein Modul.</p>
<p>Objekte in einem übergeordneten Modul können die privaten Objekte in
untergeordneten Modulen nicht verwenden, aber Objekte in untergeordneten
Modulen können die Objekte in ihren übergeordneten Modulen verwenden. Der Grund
dafür ist, dass untergeordnete Module ihre Implementierungsdetails ein- und
ausblenden, aber die untergeordneten Module können den Gültigkeitsbereich
sehen, in dem sie definiert sind. Um mit unserer Metapher fortzufahren, stelle
dir die Datenschutzregeln wie das Backoffice eines Restaurants vor: Was dort
drinnen passiert, ist für Restaurantkunden privat, aber Büroleiter können alles
im Restaurant, in dem sie arbeiten, sehen und tun.</p>
<p>Rust entschied sich dafür, das Modulsystem auf diese Weise funktionieren zu
lassen, sodass das Ausblenden innerer Implementierungsdetails die Vorgabe ist.
Auf diese Weise weißt du, welche Teile des inneren Codes du ändern kannst, ohne
den äußeren Code zu brechen. Rust gibt dir jedoch die Möglichkeit, innere Teile
des Codes von Kindmodulen für äußere Vorgängermodule offenzulegen, indem du das
Schlüsselwort <code>pub</code> verwendest, um ein Element öffentlich zu machen.</p>
<h3 id="pfade-mit-dem-schlüsselwort-pub-öffentlich-machen"><a class="header" href="#pfade-mit-dem-schlüsselwort-pub-öffentlich-machen">Pfade mit dem Schlüsselwort <code>pub</code> öffentlich machen</a></h3>
<p>Kehren wir zum Fehler in Codeblock 7-4 zurück, der uns sagte, das Modul
<code>hosting</code> sei privat. Wir wollen, dass die Funktion <code>eat_at_restaurant</code> im
übergeordneten Modul Zugriff auf die Funktion <code>add_to_waitlist</code> im
untergeordneten Modul hat, also markieren wir das Modul <code>hosting</code> mit dem
Schlüsselwort <code>pub</code>, wie in Codeblock 7-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absoluter Pfad
    crate::front_of_house::hosting::add_to_waitlist();

    // Relativer Pfad
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-5: Deklarieren des Moduls <code>hosting</code> als
<code>pub</code>, um es von <code>eat_at_restaurant</code> aus zu benutzen</span></p>
<p>Leider führt der Code in Codeblock 7-5 immer noch zu Kompilierfehlern, wie
Codeblock 7-6 zeigt.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<p><span class="caption">Codeblock 7-6: Kompilierfehler im Code in Codeblock
7-5</span></p>
<p>Was ist passiert? Das Hinzufügen des Schlüsselworts <code>pub</code> vor <code>mod hosting</code>
macht das Modul öffentlich. Wenn wir auf <code>front_of_house</code> zugreifen können,
können wir mit dieser Änderung auch auf <code>hosting</code> zugreifen. Aber die <em>Inhalte</em>
von <code>hosting</code> sind immer noch privat; das Modul öffentlich zu machen, macht
seinen Inhalt nicht öffentlich. Das Schlüsselwort <code>pub</code> für ein Modul erlaubt
es dem Code in seinen Vorgängermodulen nur, auf das Modul zu referenzieren,
nicht aber auf seinen inneren Code zuzugreifen. Da Module Container sind,
können wir nicht viel tun, indem wir nur das Modul öffentlich machen; wir
müssen weiter gehen und eines oder mehrere der Elemente innerhalb des Moduls
ebenfalls öffentlich machen.</p>
<p>Die Fehler in Codeblock 7-6 besagen, dass die Funktion <code>add_to_waitlist</code> privat
ist. Die Datenschutzregeln gelten für Strukturen, Aufzählungen, Funktionen und
Methoden sowie für Module.</p>
<p>Lass uns auch die Funktion <code>add_to_waitlist</code> öffentlich machen, indem wir das
Schlüsselwort <code>pub</code> vor ihre Definition hinzufügen, wie in Codeblock 7-7.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absoluter Pfad
    crate::front_of_house::hosting::add_to_waitlist();

    // Relativer Pfad
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Codeblock 7-7: Das Hinzufügen des Schlüsselworts <code>pub</code> zu
<code>mod hosting</code> und <code>fn add_to_waitlist</code> lässt uns die Funktion in
<code>eat_at_restaurant</code> aufrufen</span></p>
<p>Jetzt kompiliert der Code! Um zu sehen, warum das Hinzufügen des Schlüsselworts
<code>pub</code> uns erlaubt, diese Pfade in <code>eat_at_restaurant</code> im Hinblick auf die
Datenschutzregeln zu verwenden, sehen wir uns die absoluten und relativen Pfade
an.</p>
<p>Auf dem absoluten Pfad beginnen wir mit <code>crate</code>, der Wurzel des Modulbaums
unserer Kiste. Dann wird das Modul <code>front_of_house</code> in der Kistenwurzel
definiert. Während das Modul <code>front_of_house</code> nicht öffentlich ist, weil die
Funktion <code>eat_at_restaurant</code> im gleichen Modul wie <code>front_of_house</code> definiert
ist (d.h. <code>eat_at_restaurant</code> und <code>front_of_house</code> sind Geschwister), können
wir auf <code>front_of_house</code> von <code>eat_at_restaurant</code> aus zugreifen. Als nächstes
wird das Modul <code>hosting</code> mit <code>pub</code> gekennzeichnet. Wir können auf das
übergeordnete Modul von <code>hosting</code> zugreifen, also können wir auf <code>hosting</code>
zugreifen. Schließlich wird die Funktion <code>add_to_waitlist</code> mit <code>pub</code> markiert
und wir können auf ihr Elternmodul zugreifen, sodass dieser Funktionsaufruf
klappt!</p>
<p>Beim relativen Pfad ist die Logik die gleiche wie beim absoluten Pfad, mit
Ausnahme des ersten Schritts: Anstatt von der Kistenwurzel auszugehen, beginnt
der Pfad mit <code>front_of_house</code>. Das Modul <code>front_of_house</code> wird innerhalb
desselben Moduls wie <code>eat_at_restaurant</code> definiert, sodass der relative Pfad
ausgehend vom Modul, in dem <code>eat_at_restaurant</code> definiert ist, funktioniert.
Weil <code>hosting</code> und <code>add_to_waitlist</code> nun mit <code>pub</code> markiert sind, funktioniert
der Rest des Pfades, und dieser Funktionsaufruf ist gültig!</p>
<p>Wenn du vorhast, deine Bibliothekskiste weiterzugeben, damit andere Projekte
deinen Code verwenden können, ist deine öffentliche API deine Übereinkunft mit den
Benutzern deiner Kiste, die festlegt, wie sie mit deinem Code interagieren
können. Es gibt viele Überlegungen zum Umgang mit Änderungen an deiner
öffentlichen API, um es für andere einfacher zu machen, sich auf deine Kiste zu
verlassen. Diese Überlegungen gehen über den Rahmen dieses Buches hinaus; wenn
du an diesem Thema interessiert bist, lies die <a href="https://rust-lang.github.io/api-guidelines/">Rust API
Guidelines</a>.</p>
<blockquote>
<h4 id="bewährte-praktiken-für-pakete-mit-einer-binärdatei-und-einer-bibliothek"><a class="header" href="#bewährte-praktiken-für-pakete-mit-einer-binärdatei-und-einer-bibliothek">Bewährte Praktiken für Pakete mit einer Binärdatei und einer Bibliothek</a></h4>
<p>Wir haben bereits erwähnt, dass ein Paket sowohl eine Binärkistenwurzel
<em>src/main.rs</em> als auch eine Bibliothekskistenwurzel <em>src/lib.rs</em> enthalten
kann, und beide Kisten tragen standardmäßig den Paketnamen. Normalerweise
haben Pakete mit diesem Muster, die sowohl eine Bibliothek als auch eine
Binärkiste enthalten, gerade genug Code in der Binärkiste, um eine
ausführbare Datei zu starten, die Code aus der Bibliothekskiste aufruft.
Dadurch können andere Projekte von den meisten Funktionen des Pakets
profitieren, da der Code der Bibliothekskiste gemeinsam genutzt werden kann.</p>
<p>Der Modulbaum sollte in <em>src/lib.rs</em> definiert werden. Dann können alle
öffentlichen Elemente in der Binärkiste verwendet werden, indem die Pfade
mit dem Namen des Pakets beginnen. Die binäre Kiste wird zu einem Benutzer
der Bibliothekskiste, so wie eine vollständig externe Kiste die
Bibliothekskiste verwenden würde: Sie kann nur die öffentliche API
verwenden. Dies hilft dir, eine gute API zu entwerfen; Du bist nicht nur der
Autor, sondern auch ein Kunde!</p>
<p>In <a href="ch12-00-an-io-project.html">Kapitel 12</a> werden wir diese organisatorische Praxis anhand eines
Befehlszeilenprogramms demonstrieren, das sowohl eine Binärkiste als auch
eine Bibliothekskiste enthält.</p>
</blockquote>
<h3 id="relative-pfade-mit-super-beginnen"><a class="header" href="#relative-pfade-mit-super-beginnen">Relative Pfade mit <code>super</code> beginnen</a></h3>
<p>Wir können relative Pfade konstruieren, die im übergeordneten Modul beginnen
und nicht im aktuellen Modul oder der Kistenwurzel, indem wir <code>super</code> am Anfang
des Pfades verwenden. Dies ist so, als würde man einen Dateisystempfad mit der
Syntax <code>..</code> beginnen. Das Verwenden von <code>super</code> erlaubt es uns, auf ein Element
zu referenzieren, von dem wir wissen, dass es sich im übergeordneten Modul
befindet, was die Neuordnung des Modulbaums erleichtern kann, wenn das Modul
eng mit dem übergeordneten Modul verwandt ist, aber das übergeordnete Modul
eines Tages an eine andere Stelle im Modulbaum verschoben werden könnte.</p>
<p>Betrachte den Code in Codeblock 7-8, der die Situation nachbildet, in der ein
Koch eine falsche Bestellung korrigiert und persönlich zum Kunden bringt. Die
Funktion <code>fix_incorrect_order</code>, die im Modul <code>back_of_house</code> definiert ist,
ruft die im übergeordneten Modul definierte Funktion <code>deliver_order</code> auf, indem
sie den Pfad zu <code>deliver_order</code> angibt, der mit <code>super</code> beginnt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-8: Aufrufen einer Funktion unter Verwendung
eines relativen Pfades, der mit <code>super</code> beginnt</span></p>
<p>Die Funktion <code>fix_incorrect_order</code> befindet sich im Modul <code>back_of_house</code>,
sodass wir <code>super</code> benutzen können, um zum Elternmodul von <code>back_of_house</code> zu
gelangen, was in diesem Fall die Wurzel <code>crate</code> ist. Von dort aus suchen wir
nach <code>deliver_order</code> und finden es. Erfolg! Wir denken, dass das Modul
<code>back_of_house</code> und die Funktion <code>deliver_order</code> wahrscheinlich in der gleichen Beziehung zueinander stehen und zusammen verschoben werden, sollten wir uns dazu
entschließen, den Modulbaum der Kiste neu zu organisieren. Deshalb haben wir
<code>super</code> verwendet, sodass wir in Zukunft weniger Codestellen zu aktualisieren
haben, wenn dieser Code in ein anderes Modul verschoben wird.</p>
<h3 id="strukturen-und-aufzählungen-öffentlich-machen"><a class="header" href="#strukturen-und-aufzählungen-öffentlich-machen">Strukturen und Aufzählungen öffentlich machen</a></h3>
<p>Wir können auch <code>pub</code> verwenden, um Strukturen und Aufzählungen als öffentlich
zu kennzeichnen, aber es gibt ein paar zusätzliche Details zur Verwendung von
<code>pub</code> mit Strukturen und Aufzählungen. Wenn wir <code>pub</code> vor einer
Struktur-Definition verwenden, machen wir die Struktur öffentlich, aber die
Felder der Struktur sind immer noch privat. Wir können jedes Feld von Fall zu
Fall öffentlich machen oder auch nicht. In Codeblock 7-9 haben wir eine
öffentliche Struktur <code>back_of_house::Breakfast</code> mit einem öffentlichen Feld
<code>toast</code>, aber einem privaten Feld <code>seasonal_fruit</code> definiert. Dies ist der Fall
in einem Restaurant, in dem der Kunde die Brotsorte auswählen kann, die zu
einer Mahlzeit gehört, aber der Küchenchef entscheidet, welche Früchte die
Mahlzeit begleiten, je nach Saison und Vorrat. Das verfügbare Obst ändert sich
schnell, sodass die Kunden nicht wählen oder gar sehen können, welches Obst sie
bekommen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("Pfirsiche"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Bestelle im Sommer ein Frühstück mit Roggentoast
    let mut meal = back_of_house::Breakfast::summer("Roggen");
    // Ändere unsere Meinung darüber, welche Brotsorte wir gerne hätten
    meal.toast = String::from("Weizen");
    println!("Ich möchte {}-Toast", meal.toast);

    // Die nächste Zeile lässt sich nicht kompilieren, wenn wir sie nicht
    // auskommentieren; wir dürfen die Früchte der Saison, die wir mit der
    // Mahlzeit bekommen, weder sehen noch verändern.
    // meal.seasonal_fruit = String::from("Heidelbeeren");
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-9: Eine Struktur mit öffentlichen und
privaten Feldern</span></p>
<p>Da das Feld <code>toast</code> in der Struktur <code>back_of_house::Breakfast</code> öffentlich ist,
können wir in <code>eat_at_restaurant</code> in das Feld <code>toast</code> schreiben und lesen,
indem wir die Punktnotation verwenden. Beachte, dass wir das Feld
<code>seasonal_fruit</code> in <code>eat_at_restaurant</code> nicht verwenden können, weil
<code>seasonal_fruit</code> privat ist. Versuche, die Kommentarzeichen in der Zeile, die
den Feldwert <code>seasonal_fruit</code> modifiziert, zu entfernen, um zu sehen, welchen
Fehler du erhältst!</p>
<p>Beachte auch, dass, weil <code>back_of_house::Breakfast</code> ein privates Feld hat, die
Struktur eine öffentliche Funktion (hier haben wir sie <code>summer</code> genannt) zum
Erzeugen einer Instanz von <code>Breakfast</code> bereitstellen muss. Wenn <code>Breakfast</code>
keine solche Funktion hätte, könnten wir keine Instanz von <code>Breakfast</code> in
<code>eat_at_restaurant</code> erzeugen, weil wir den Wert des privaten Feldes
<code>seasonal_fruit</code> in <code>eat_at_restaurant</code> nicht setzen könnten.</p>
<p>Wenn wir dagegen eine Aufzählung veröffentlichen, dann sind alle ihre
Varianten öffentlich. Wir brauchen nur das Schlüsselwort <code>pub</code> vor dem
Schlüsselwort <code>enum</code>, wie in Codeblock 7-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-10: Kennzeichnen einer Aufzählung als
öffentlich macht alle ihre Varianten öffentlich</span></p>
<p>Da wir die Aufzählung <code>Appetizer</code> öffentlich gemacht haben, können wir die
Varianten <code>Soup</code> und <code>Salad</code> in <code>eat_at_restaurant</code> verwenden.</p>
<p>Aufzählungen wären ohne öffentliche Varianten nicht sehr nützlich; es wäre
ärgerlich, alle Aufzählungs-Varianten stets mit <code>pub</code> annotieren zu müssen,
daher sind die Aufzählungs-Varianten standardmäßig öffentlich. Strukturen sind
auch ohne öffentliche Felder nützlich, daher folgen Strukturfelder
standardmäßig der allgemeinen Regel, dass alles privat ist, es sei denn, es
wird mit <code>pub</code> annotiert.</p>
<p>Es gibt noch eine weitere Situation mit <code>pub</code>, die wir noch nicht behandelt
haben, und das ist unser letztes Modulsystem-Feature: Das Schlüsselwort <code>use</code>.
Zuerst werden wir <code>use</code> an sich behandeln, und dann zeigen wir, wie man <code>pub</code>
und <code>use</code> kombiniert.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
