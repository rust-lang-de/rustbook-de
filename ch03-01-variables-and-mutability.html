<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Variablen und Veränderbarkeit - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="variablen-und-veränderbarkeit"><a class="header" href="#variablen-und-veränderbarkeit">Variablen und Veränderbarkeit</a></h2>
<p>Wie im Abschnitt <a href="ch02-00-guessing-game-tutorial.html#speichern-von-werten-mit-variablen">„Speichern von Werten mit
Variablen“</a> erwähnt, sind Variablen
standardmäßig unveränderbar. Dies ist einer der vielen Stupser, die Rust dir
gibt, um deinen Code so zu schreiben, dass du die Vorteile von Sicherheit
(safety) und einfacher Nebenläufigkeit (easy concurrency) nutzt, die Rust
bietet. Du hast jedoch immer noch die Möglichkeit, deine Variablen veränderbar
(mutable) zu machen. Lass uns untersuchen, wie und warum Rust dich dazu
ermutigt, die Unveränderbarkeit (immutability) zu bevorzugen, und warum du
manchmal vielleicht davon abweichen möchtest.</p>
<p>Wenn eine Variable unveränderbar ist, kannst du deren Wert nicht mehr ändern,
sobald ein Wert gebunden ist. Um dies zu veranschaulichen, lege ein neues
Projekt namens <em>variables</em> in deinem <em>projects</em>-Verzeichnis an, indem du
<code>cargo new variables</code> aufrufst.</p>
<p>Öffne dann in deinem neuen Verzeichnis <em>variables</em> die Datei <em>src/main.rs</em> und
ersetze dessen Code durch folgenden Code, der sich sich noch nicht kompilieren
lässt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = 5;
    println!("Der Wert von x ist: {x}");
    x = 6;
    println!("Der Wert von x ist: {x}");
}</code></pre></pre>
<p>Speichere und starte das Programm mit <code>cargo run</code>. Du solltest eine
Fehlermeldung über einen Unveränderbarkeitsfehler erhalten, wie in dieser
Ausgabe gezeigt:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("Der Wert von x ist: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>Dieses Beispiel zeigt, wie der Compiler dir hilft, Fehler in deinen Programmen
zu finden. Kompilierfehler können frustrierend sein, aber eigentlich bedeuten
sie nur, dass dein Programm noch nicht sicher das tut, was du willst; sie
bedeuten <em>nicht</em>, dass du kein guter Programmierer bist! Erfahrene
Rust-Entwickler bekommen ebenfalls noch Kompilierfehler.</p>
<p>Du hast die Fehlermeldung <code>cannot assign twice to immutable variable x</code>
erhalten, weil du versucht hast, der unveränderbaren Variablen <code>x</code> einen
zweiten Wert zuzuweisen.</p>
<p>Es ist wichtig, dass wir Kompilierzeitfehler erhalten, wenn wir versuchen,
einen Wert zu ändern, der als unveränderbar gekennzeichnet ist, denn genau
diese Situation kann zu Fehlern führen. Wenn ein Teil unseres Codes von der
Annahme ausgeht, dass sich ein Wert niemals ändern wird, und ein anderer Teil
unseres Codes diesen Wert ändert, ist es möglich, dass der erste Teil des Codes
nicht das tut, wozu er entwickelt wurde. Die Ursache für diese Art von Fehler
kann im Nachhinein schwer aufzuspüren sein, besonders wenn das zweite Stück
Code den Wert nur <em>gelegentlich</em> ändert. In Rust garantiert der Compiler, dass
sich ein Wert tatsächlich nicht ändert, wenn du angibst, dass er sich nicht
ändern darf, du musst also nicht selbst darauf achten. Dein Code ist somit
leichter zu durchschauen.</p>
<p>Veränderbarkeit kann jedoch sehr nützlich sein und das Erstellen von Code
erleichtern. Obwohl Variablen standardmäßig unveränderbar sind, kannst du sie
veränderbar machen, indem du vor den Variablennamen <code>mut</code> angibst, wie du es
in <a href="ch02-00-guessing-game-tutorial.html#speichern-von-werten-mit-variablen">Kapitel 2</a> getan hast. Das Hinzufügen von
<code>mut</code> vermittelt den zukünftigen Lesern des Codes die Absicht, dass andere
Teile des Codes den Wert dieser Variablen ändern werden.</p>
<p>Lass uns zum Beispiel <em>src/main.rs</em> wie folgt ändern:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!("Der Wert von x ist: {x}");
    x = 6;
    println!("Der Wert von x ist: {x}");
}</code></pre></pre>
<p>Wenn wir das Programm jetzt ausführen, bekommen wir dies:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
Der Wert von x ist: 5
Der Wert von x ist: 6
</code></pre>
<p>Wir dürfen den Wert, an den sich <code>x</code> bindet, von <code>5</code> auf <code>6</code> ändern, wenn <code>mut</code>
verwendet wird. Letztendlich ist es deine Entscheidung, ob du Veränderbarkeit
einsetzen willst oder nicht, und es hängt davon ab, was du in der jeweiligen
Situation für am sinnvollsten hältst.</p>
<h3 id="konstanten"><a class="header" href="#konstanten">Konstanten</a></h3>
<p>Wie unveränderbare Variablen sind <em>Konstanten</em> Werte, die an einen Namen
gebunden sind und sich nicht ändern dürfen, aber es gibt einige Unterschiede
zwischen Konstanten und Variablen.</p>
<p>Erstens ist es dir nicht erlaubt, <code>mut</code> mit Konstanten zu verwenden. Konstanten
sind nicht nur von vornherein unveränderbar – sie sind immer
unveränderbar. Du deklarierst Konstanten mit dem Schlüsselwort <code>const</code>
anstelle des Schlüsselworts <code>let</code> und der Typ des Wertes <em>muss</em> annotiert
werden. Wir sind dabei, Typen und Typ-Annotationen im nächsten Abschnitt
<a href="ch03-02-data-types.html">„Datentypen“</a> zu behandeln, also mach dir jetzt keine Gedanken
über die Details. Du musst nur wissen, dass du den Typ immer annotieren musst.</p>
<p>Konstanten können in jedem Gültigkeitsbereich deklariert werden, auch im
globalen Gültigkeitsbereich, was sie für Werte nützlich macht, über die viele
Teile des Codes Bescheid wissen müssen.</p>
<p>Der letzte Unterschied besteht darin, dass Konstanten nur auf einen konstanten
Ausdruck gesetzt werden dürfen, nicht auf einen Wert, der nur zur Laufzeit
berechnet werden könnte.</p>
<p>Hier ist ein Beispiel für eine Konstantendeklaration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>Der Name der Konstante lautet <code>THREE_HOURS_IN_SECONDS</code> und ihr Wert wird auf
das Ergebnis der Multiplikation von 60 (die Anzahl der Sekunden in einer
Minute) mal 60 (die Anzahl der Minuten in einer Stunde) mal 3 (die Anzahl der
Stunden, die wir in diesem Programm zählen wollen). Die Namenskonvention von
Rust für Konstanten ist die Verwendung von Großbuchstaben mit Unterstrichen
zwischen den Wörtern. Der Compiler ist in der Lage, eine begrenzte Anzahl von
Operationen zur Kompilierzeit auszuwerten, was uns die Möglichkeit gibt, diesen
Wert so zu schreiben, dass er leichter zu verstehen und zu überprüfen ist, als
wenn diese Konstante auf den Wert 10.800 gesetzt wäre. Siehe die
<a href="https://doc.rust-lang.org/reference/const_eval.html">Rust-Referenz, Abschnitt über die Auswertung von Konstanten</a> für
weitere Informationen darüber, welche Operationen bei der Deklaration von
Konstanten verwendet werden können.</p>
<p>Konstanten sind für die gesamte Laufzeit eines Programms in dem
Gültigkeitsbereich gültig, in dem sie deklariert wurden. Damit sind sie eine
nützliche Wahl für Werte in deiner Anwendungsdomäne, über die mehrere Teile des
Programms Bescheid wissen müssen, z.B. die maximale Punktzahl, die jeder
Spieler eines Spiels erhalten darf, oder die Lichtgeschwindigkeit.</p>
<p>Hartkodierte Werte, die im gesamten Programm als Konstanten verwendet werden,
sollten benannt werden, damit zukünftigen Entwicklern die Bedeutung dieses
Wertes vermittelt wird. Zudem ist es hilfreich, nur eine Codestelle ändern zu
müssen, sollte der hartkodierte Wert irgendwann zu ändern sein.</p>
<h3 id="verschatten-shadowing"><a class="header" href="#verschatten-shadowing">Verschatten (shadowing)</a></h3>
<p>Wie du in der Anleitung zum Ratespiel in <a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">Kapitel
2</a> gesehen hast, kannst du eine neue
Variable mit dem gleichen Namen wie eine vorherige Variable deklarieren. Die
Rust-Entwickler sagen, dass die erste Variable von der zweiten <em>verschattet</em>
(shadowed) wird, was bedeutet, dass die zweite Variable das ist, was der
Compiler sieht, wenn du den Namen der Variable verwendest. Die zweite Variable
verschattet die erste und nimmt alle Verwendungen des Variablennamens auf sich,
bis sie entweder selbst verschattet wird oder der Gültigkeitsbereich endet. Wir
können eine Variable verschatten, indem wir denselben Variablenamen verwenden
und das Schlüsselwort <code>let</code> wie folgt wiederholen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("Der Wert von x im inneren Gültigkeitsbereich ist: {x}");
    }

    println!("Der Wert von x ist: {x}");
}</code></pre></pre>
<p>Dieses Programm bindet zunächst <code>x</code> an den Wert <code>5</code>. Dann wird eine neue
Variable <code>x</code> erzeugt, indem <code>let x =</code> wiederholt wird, wobei der ursprüngliche
Wert genommen und <code>1</code> hinzugefügt wird, sodass der Wert von <code>x</code> dann <code>6</code> ist.
Innerhalb eines inneren Gültigkeitsbereichs, der durch die geschweiften
Klammern geschaffen wird, verschattet die dritte <code>let</code>-Anweisung dann ebenfalls
<code>x</code> und erzeugt eine neue Variable, wobei der vorherige Wert mit <code>2</code>
multipliziert wird, um <code>x</code> einen Wert von <code>12</code> zu geben. Wenn dieser
Gültigkeitsbereich zu Ende ist, endet die innere Verschattung und <code>x</code> wird
wieder zu <code>6</code>. Wenn wir dieses Programm ausführen, wird es folgendes ausgeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
Der Wert von x im inneren Gültigkeitsbereich ist: 12
Der Wert von x ist: 6
</code></pre>
<p>Verschatten unterscheidet sich vom Markieren einer Variable mit <code>mut</code>, weil wir
einen Kompilierfehler erhalten, wenn wir versehentlich versuchen, diese
Variable neu zuzuweisen, ohne das Schlüsselwort <code>let</code> zu verwenden. Durch das
Verwenden von <code>let</code> können wir einige wenige Transformationen an einem Wert
durchführen, aber die Variable ist unveränderbar, nachdem diese
Transformationen abgeschlossen sind.</p>
<p>Der andere Unterschied zwischen <code>mut</code> und Verschatten besteht darin, dass wir,
weil wir effektiv eine neue Variable erstellen, wenn wir das Schlüsselwort
<code>let</code> erneut verwenden, den Typ des Wertes ändern können, aber denselben Namen
wiederverwenden. Nehmen wir zum Beispiel an, unser Programm bittet einen
Benutzer, durch Eingeben von Leerzeichen zu zeigen, wie viele Leerzeichen er
zwischen irgendeinem Text haben möchte, und wir möchten diese Eingabe als Zahl
speichern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spaces = "   ";
let spaces = spaces.len();
<span class="boring">}</span></code></pre></pre>
<p>Die erste Variable <code>spaces</code> ist ein String-Typ und die zweite Variable <code>spaces</code>
ist ein Zahlentyp Integer. Das Verschatten erspart es uns also, uns verschiedene
Namen auszudenken, z.B. <code>spaces_str</code> und <code>spaces_num</code>; stattdessen können wir
den einfacheren Namen <code>spaces</code> wiederverwenden. Wenn wir jedoch versuchen,
dafür <code>mut</code> zu verwenden, wie hier gezeigt, erhalten wir einen Kompilierfehler:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut spaces = "   ";
spaces = spaces.len();

<span class="boring">}</span></code></pre></pre>
<p>Der Fehler besagt, dass es uns nicht erlaubt ist, den Typ einer Variable zu
mutieren:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>Nachdem wir nun untersucht haben, wie Variablen funktionieren, wollen wir uns
weitere Datentypen ansehen, die sie haben können.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-02-data-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-00-common-programming-concepts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-02-data-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
