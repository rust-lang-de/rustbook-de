<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) Send und Sync - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="erweiterbare-nebenläufigkeit-mit-den-merkmalen-traits-send-und-sync"><a class="header" href="#erweiterbare-nebenläufigkeit-mit-den-merkmalen-traits-send-und-sync">Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) <code>Send</code> und <code>Sync</code></a></h2>
<p>Interessanterweise war fast jede Nebenläufigkeitsfunktionalität, über die wir
bisher in diesem Kapitel gesprochen haben, Teil der Standardbibliothek, nicht
der Sprache. Deine Möglichkeiten für den Umgang mit Nebenläufigkeit sind nicht
auf die Sprache oder die Standardbibliothek beschränkt; du kannst deine eigenen
Nebenläufigkeitsfunktionalitäten schreiben oder die von anderen geschriebenen
verwenden.</p>
<p>Zu den wichtigsten Nebenläufigkeitskonzepten, die in die Sprache und nicht in
die Standardbibliothek eingebettet sind, gehören jedoch die Merkmale <code>Send</code> und
<code>Sync</code> in <code>std::marker</code>.</p>
<h3 id="erlauben-der-eigentümerschaftübertragung-zwischen-strängen-mit-send"><a class="header" href="#erlauben-der-eigentümerschaftübertragung-zwischen-strängen-mit-send">Erlauben der Eigentümerschaftübertragung zwischen Strängen mit <code>Send</code></a></h3>
<p>Das Markierungsmerkmal (marker trait) <code>Send</code> zeigt an, dass die
Eigentümerschaft an Werten des Typs, der <code>Send</code> implementiert, zwischen
Strängen (threads) übertragen werden kann. Fast jeder Rust-Typ implementiert
<code>Send</code>, aber es gibt einige Ausnahmen, einschließlich <code>Rc&lt;T&gt;</code>: Dieser kann
nicht <code>Send</code> sein, denn wenn du einen <code>Rc&lt;T&gt;</code>-Wert geklont hast und versucht
hast, die Eigentümerschaft am Klon auf einen anderen Strang zu übertragen,
könnten beide Stränge gleichzeitig den Referenzzähler aktualisieren. Aus diesem
Grund ist <code>Rc&lt;T&gt;</code> für die Verwendung in einsträngigen Situationen
implementiert, in denen du nicht die Strang-sichere Performanzeinbuße zahlen
willst.</p>
<p>Daher stellen das Typsystem und die Merkmalsabgrenzungen (trait bounds) von
Rust sicher, dass du niemals versehentlich einen <code>Rc&lt;T&gt;</code>-Wert unsicher zwischen
Strängen senden kannst. Als wir dies in Codeblock 16-14 versuchten, erhielten
wir folgenden Fehler: Das Merkmal <code>Send</code> ist für <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> nicht
implementiert. Als wir zu <code>Arc&lt;T&gt;</code> wechselten, das <code>Send</code> implementiert, ließ
sich der Code kompilieren.</p>
<p>Jeder Typ, der vollständig aus <code>Send</code>-Typen besteht, wird automatisch auch als
<code>Send</code> markiert. Fast alle primitiven Typen implementieren <code>Send</code>, abgesehen
von Roh-Zeigern, die wir in Kapitel 20 besprechen werden.</p>
<h3 id="erlauben-des-zugriffs-von-mehreren-strängen-mit-sync"><a class="header" href="#erlauben-des-zugriffs-von-mehreren-strängen-mit-sync">Erlauben des Zugriffs von mehreren Strängen mit <code>Sync</code></a></h3>
<p>Das Markierungsmerkmal <code>Sync</code> zeigt an, dass es sicher ist, den Typ, der <code>Sync</code>
implementiert, von mehreren Strängen zu referenzieren. Mit anderen Worten,
jeder Typ <code>T</code> implementiert <code>Sync</code>, wenn <code>&amp;T</code> (eine unveränderbare Referenz auf
<code>T</code>) <code>Send</code> implementiert, was bedeutet, dass die Referenz sicher an einen
anderen Strang gesendet werden kann. Ähnlich wie bei <code>Send</code> implementieren
primitive Typen <code>Sync</code>, und Typen, die vollständig aus Typen bestehen, die
<code>Sync</code> implementieren, implementieren ebenfalls <code>Sync</code>.</p>
<p>Der intelligente Zeiger <code>Rc&lt;T&gt;</code> implementiert ebenfalls nicht <code>Sync</code>, aus
denselben Gründen, warum er nicht <code>Send</code> implementiert. Der Typ <code>RefCell&lt;T&gt;</code>
(über den wir in Kapitel 15 gesprochen haben) und die Familie der verwandten
<code>Cell&lt;T&gt;</code>-Typen implementieren nicht <code>Sync</code>. Die Implementierung der
Ausleihenprüfung (borrow checking), die <code>RefCell&lt;T&gt;</code> zur Laufzeit durchführt,
ist nicht Strang-sicher. Der intelligente Zeiger <code>Mutex&lt;T&gt;</code> implementiert
<code>Sync</code> und kann verwendet werden, um den Zugriff mit mehreren Strängen zu
teilen, wie du in <a href="ch16-03-shared-state.html#gemeinsames-nutzen-eines-mutext-von-mehreren-str%C3%A4ngen">„Gemeinsames Nutzen eines <code>Mutex&lt;T&gt;</code> von mehreren
Strängen“</a> gesehen hast.</p>
<h3 id="manuelles-implementieren-von-send-und-sync-ist-unsicher"><a class="header" href="#manuelles-implementieren-von-send-und-sync-ist-unsicher">Manuelles Implementieren von <code>Send</code> und <code>Sync</code> ist unsicher</a></h3>
<p>Da Typen, die sich ausschließlich aus Typen zusammensetzen, die die Merkmale
<code>Send</code> und <code>Sync</code> implementieren, automatisch auch <code>Send</code> und <code>Sync</code>
implementieren, müssen wir diese Merkmale nicht manuell implementieren. Als
Markierungsmerkmale haben sie noch nicht einmal irgendwelche Methoden, um sie
zu implementieren. Sie sind nur nützlich, um Invarianten in Bezug auf die
Nebenläufigkeit zu erzwingen.</p>
<p>Das manuelle Implementieren dieser Merkmale beinhaltet das Schreiben von
unsicherem Rust-Code. Wir werden über das Verwenden von unsicherem Rust-Code in
Kapitel 20 sprechen; für den Moment ist die wichtige Information, dass das
Erstellen neuer nebenläufiger Typen, die nicht aus <code>Send</code>- und <code>Sync</code>-Teilen
bestehen, sorgfältige Überlegungen erfordert, um die Sicherheitsgarantien
aufrechtzuerhalten. <a href="https://doc.rust-lang.org/nomicon/index.html">„Das Rustonomicon“</a> enthält weitere
Informationen über diese Garantien und wie man sie aufrechterhalten kann.</p>
<h2 id="zusammenfassung"><a class="header" href="#zusammenfassung">Zusammenfassung</a></h2>
<p>Dies ist nicht das letzte Mal, dass du in diesem Buch der Nebenläufigkeit
begegnest: Das nächste Kapitel befasst sich mit asynchroner Programmierung, und
das Projekt in Kapitel 21 wird die Konzepte in diesem Kapitel in einer
realistischeren Situation anwenden als die hier besprochenen kleineren
Beispiele.</p>
<p>Wie bereits erwähnt, ist nur sehr wenig davon, wie Rust mit Nebenläufigkeit
umgeht, Teil der Sprache; viele Nebenläufigkeitslösungen sind in Kisten
(crates) implementiert. Diese entwickeln sich schneller als die
Standardbibliothek. Stelle also sicher, dass du online nach den aktuellen,
hochmodernen Kisten suchst, die in mehrsträngigen Situationen verwendet werden
können.</p>
<p>Die Rust-Standardbibliothek bietet Kanäle (channels) für die
Nachrichtenübermittlung und intelligente Zeigertypen wie <code>Mutex&lt;T&gt;</code> und
<code>Arc&lt;T&gt;</code>, die sicher in nebenläufigen Kontexten verwendet werden können. Das
Typsystem und der Ausleihenprüfer stellen sicher, dass der Code, der diese
Lösungen verwendet, nicht mit Daten-Wettlaufsituationen (data races) oder
ungültigen Referenzen endet. Sobald du deinen Code zum Kompilieren gebracht
hast, kannst du sicher sein, dass er problemlos mit mehreren Strängen läuft,
ohne die schwer aufspürbaren Fehler, die in anderen Sprachen üblich sind.
Nebenläufige Programmierung ist kein Konzept mehr, vor dem man sich fürchten
muss: Gehe hinaus und mache deine Programme nebenläufig – furchtlos!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-03-shared-state.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-00-async-await.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-03-shared-state.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-00-async-await.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
