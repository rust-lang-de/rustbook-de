<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fortgeschrittene Merkmale (traits) - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris-d33b75bf.css">
        <link rel="stylesheet" href="theme/2018-edition-4e126c62.css">
        <link rel="stylesheet" href="theme/semantic-notes-9b5766c0.css">
        <link rel="stylesheet" href="theme/listing-cab26221.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5070249d.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h2 id="fortgeschrittene-merkmale-traits"><a class="header" href="#fortgeschrittene-merkmale-traits">Fortgeschrittene Merkmale (traits)</a></h2>
<p>Merkmale behandelten wir als Erstes im Abschnitt <a href="ch10-02-traits.html">„Gemeinsames Verhalten
definieren mit Merkmalen (traits)“</a> in Kapitel 10, aber wir haben die
fortgeschrittenen Details nicht besprochen. Jetzt, da du mehr über Rust weißt,
können wir zum Kern der Sache kommen.</p>
<h3 id="merkmale-mit-assoziierten-typen-definieren"><a class="header" href="#merkmale-mit-assoziierten-typen-definieren">Merkmale mit assoziierten Typen definieren</a></h3>
<p><em>Assoziierte Typen</em> (associated types) verbinden einen Typ-Platzhalter mit
einem Merkmal, sodass die Definitionen der Merkmalsmethoden diese
Platzhaltertypen in ihren Signaturen verwenden können. Der Implementierer eines
Merkmals gibt den konkreten Typ an, der anstelle des Platzhaltertyps für die
jeweilige Implementierung verwendet werden soll. Auf diese Weise können wir ein
Merkmal definieren, das einige Typen verwendet, ohne dass wir genau wissen
müssen, um welche Typen es sich dabei handelt, bis das Merkmal implementiert
ist.</p>
<p>Wir haben die meisten der fortgeschrittenen Funktionalitäten in diesem Kapitel
als selten benötigt beschrieben. Assoziierte Typen liegen irgendwo dazwischen:
Sie werden seltener verwendet als die im Rest des Buches erläuterten
Funktionalitäten, aber häufiger als viele der anderen in diesem Kapitel
besprochenen Funktionalitäten.</p>
<p>Ein Beispiel für ein Merkmal mit einem assoziierten Typ ist das Merkmal
<code>Iterator</code>, das die Standardbibliothek zur Verfügung stellt. Der assoziierte
Typ wird <code>Item</code> genannt und steht für den Typ der Werte, über die der Typ, der
das Merkmal <code>Iterator</code> implementiert, iteriert. Die Definition des Merkmals
<code>Iterator</code> ist in Codeblock 20-13 zu sehen.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 20-13: Definition des Merkmals <code>Iterator</code>, das
einen assoziierten Typ <code>Item</code> hat</span></p>
<p>Der Typ <code>Item</code> ist ein Platzhalter und die Definition der Methode <code>next</code> zeigt,
dass sie Werte vom Typ <code>Option&lt;Self::Item&gt;</code> zurückgibt. Implementierungen des
Merkmals <code>Iterator</code> geben den konkreten Typ für <code>Item</code> an und die Methode
<code>next</code> gibt eine <code>Option</code> zurück, die einen Wert dieses konkreten Typs enthält.</p>
<p>Assoziierte Typen scheinen ein ähnliches Konzept wie generische Datentypen
(generics) zu sein, da letztere es uns ermöglichen, eine Funktion zu
definieren, ohne anzugeben, welche Typen sie handhaben kann. Um den Unterschied
zwischen den beiden Konzepten zu untersuchen, betrachten wir eine
Implementierung des Merkmals <code>Iterator</code> für einen Typ namens <code>Counter</code>, der
angibt, dass der <code>Item</code>-Typ <code>u32</code> ist:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --abschneiden--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre>
<p>Diese Syntax scheint mit der von generischen Datentypen vergleichbar zu sein.
Warum also nicht einfach das Merkmal <code>Iterator</code> mit generischen Datentypen
definieren, wie in Codeblock 20-14 gezeigt?</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 20-14: Eine hypothetische Definition des
Merkmals <code>Iterator</code> unter Verwendung eines generischen Datentyps</span></p>
<p>Der Unterschied ist, dass wir beim Verwenden von generischen Datentypen, wie in
Codeblock 20-14, die Typen in jeder Implementierung annotieren müssen; da wir
auch <code>Iterator&lt;String&gt; for Counter</code> oder jeden anderen Typ implementieren
können, könnten wir mehrere Implementierungen von <code>Iterator</code> für <code>Counter</code>
haben. Mit anderen Worten, wenn ein Merkmal einen generischen Parameter hat,
kann es für einen Typ mehrfach implementiert werden, wobei die konkreten Typen
der generischen Typparameter jedes Mal geändert werden können. Wenn wir die
Methode <code>next</code> auf <code>Counter</code> verwenden, müssten wir Typ-Annotationen
bereitstellen, um anzugeben, welche Implementierung des <code>Iterators</code> wir
verwenden wollen.</p>
<p>Bei assoziierten Typen brauchen wir Typen nicht zu annotieren, weil wir ein
Merkmal auf einem Typ nicht mehrfach implementieren können. In Codeblock 20-13
mit der Definition, die assoziierte Typen verwendet, können wir nur einmal
wählen, was der Typ von <code>Item</code> sein wird, weil es nur einen <code>impl Iterator for Counter</code> geben kann. Wir müssen nicht angeben, dass wir einen Iterator von
<code>u32</code>-Werten überall dort haben wollen, wo wir <code>next</code> auf <code>Counter</code> aufrufen.</p>
<p>Assoziierte Typen werden auch Teil des Merkmal-Vertrags: Implementierer des
Merkmals müssen einen Typ bereitstellen, der für den Platzhalter des
assoziierten Typs steht. Assoziierte Typen haben oft einen Namen, der
beschreibt, wie der Typ verwendet werden soll, und das Dokumentieren des
assoziierten Typs in der API-Dokumentation ist eine gute Praxis.</p>
<h3 id="generische-standardparameter-und-operatorüberladung-verwenden"><a class="header" href="#generische-standardparameter-und-operatorüberladung-verwenden">Generische Standardparameter und Operatorüberladung verwenden</a></h3>
<p>Wenn wir generische Typparameter verwenden, können wir einen konkreten
Standardtyp für den generischen Typ angeben. Dadurch entfällt die Notwendigkeit
für Implementierer des Merkmals, einen konkreten Typ anzugeben, wenn der
Standardtyp passt. Du gibst einen Standardtyp an, wenn du einen generischen Typ
mit der Syntax <code>&lt;PlaceholderType=ConcreteType&gt;</code> deklarierst.</p>
<p>Ein gutes Beispiel für eine Situation, in der diese Technik nützlich ist, ist
die <em>Operatorüberladung</em> (operator overloading), bei der du das Verhalten eines
Operators (wie <code>+</code>) in bestimmten Situationen anpasst.</p>
<p>Rust erlaubt es dir nicht, eigene Operatoren zu erstellen oder beliebige
Operatoren zu überladen. Aber du kannst die in <code>std::ops</code> aufgeführten
Operationen und entsprechenden Merkmale überladen, indem du die mit dem
Operator assoziierten Merkmale implementierst. Beispielsweise überladen wir in
Codeblock 20-15 den Operator <code>+</code>, um zwei <code>Point</code>-Instanzen zu addieren. Wir
tun dies, indem wir das Merkmal <code>Add</code> auf eine <code>Point</code>-Struktur implementieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre>
<p><span class="caption">Codeblock 20-15: Implementieren des Merkmals <code>Add</code>, um
den Operator <code>+</code> für <code>Point</code>-Instanzen zu überladen</span></p>
<p>Die Methode <code>add</code> addiert die <code>x</code>-Werte zweier <code>Point</code>-Instanzen und die
<code>y</code>-Werte zweier <code>Point</code>-Instanzen, um einen neuen <code>Point</code> zu erzeugen. Das
Merkmal <code>Add</code> hat einen assoziierten Typ namens <code>Output</code>, der den von der
Methode <code>add</code> zurückgegebenen Typ bestimmt.</p>
<p>Der generische Standardtyp in diesem Code befindet sich innerhalb des Merkmals
<code>Add</code>. Hier ist seine Definition:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre>
<p>Dieser Code sollte allgemein bekannt aussehen: Ein Merkmal mit einer Methode
und einem assoziierten Typ. Der neue Teil ist <code>Rhs=Self</code>: Diese Syntax heißt
<em>Standardtypparameter</em> (default type parameters). Der generische Typparameter
<code>Rhs</code> (kurz für „right hand side“, engl. „rechte Seite“) definiert den Typ des
Parameters <code>rhs</code> in der Methode <code>add</code>. Wenn wir keinen konkreten Typ für <code>Rhs</code>
angeben, wenn wir das Merkmal <code>Add</code> implementieren, wird der Typ <code>Rhs</code>
standardmäßig auf <code>Self</code> gesetzt, was der Typ sein wird, auf dem wir <code>Add</code>
implementieren.</p>
<p>Als wir <code>Add</code> für <code>Point</code> implementiert haben, haben wir den Standardwert für
<code>Rhs</code> verwendet, weil wir zwei <code>Point</code>-Instanzen addieren wollten. Schauen wir
uns ein Beispiel für die Implementierung des Merkmals <code>Add</code> an, bei dem wir den
Typ <code>Rhs</code> anpassen wollen, anstatt den Standardwert zu verwenden.</p>
<p>Wir haben zwei Strukturen <code>Millimeters</code> und <code>Meters</code>, die Werte in
verschiedenen Einheiten enthalten. Diese dünne Umhüllung eines bestehenden Typs
in einer anderen Struktur ist als <em>Newtype-Muster</em> bekannt, das wir im
Abschnitt <a href="#externe-merkmale-mit-dem-newtype-muster-implementieren">„Externe Merkmale mit dem Newtype-Muster implementieren“</a>
ausführlicher beschreiben. Wir wollen Werte in Millimeter zu Werten in Meter
addieren und die Implementierung von <code>Add</code> die Umrechnung korrekt durchführen
lassen. Wir können <code>Add</code> für <code>Millimeters</code> mit <code>Meters</code> als <code>Rhs</code>
implementieren, wie in Codeblock 20-16 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 20-16: Implementieren des Merkmals <code>Add</code> auf
<code>Millimeters</code>, um <code>Millimeters</code> zu <code>Meters</code> zu addieren</span></p>
<p>Um <code>Millimeters</code> und <code>Meters</code> zu addieren, geben wir <code>impl Add&lt;Meters&gt;</code> an, um
den Wert des Parameters vom Typ <code>Rhs</code> zu setzen, anstatt den Standardwert
<code>Self</code> zu verwenden.</p>
<p>Du wirst Standardtypparameter auf zwei Arten verwenden:</p>
<ol>
<li>Um einen Typ zu erweitern, ohne bestehenden Code zu brechen.</li>
<li>Um eine Anpassung in bestimmten Fällen zu ermöglichen, die die meisten
Benutzer nicht benötigen.</li>
</ol>
<p>Das Merkmal <code>Add</code> der Standardbibliothek ist ein Beispiel für den zweiten
Zweck: Normalerweise addierst du zwei ähnliche Typen, aber das Merkmal <code>Add</code>
bietet die Möglichkeit, darüber hinausgehende Anpassungen vorzunehmen. Das
Verwenden eines Standardtypparameters in der Merkmalsdefinition <code>Add</code> bedeutet,
dass du den zusätzlichen Parameter die meiste Zeit nicht angeben musst. Mit
anderen Worten kann etwas Implementierungscode eingespart werden, was das
Verwenden des Merkmals erleichtert.</p>
<p>Der erste Zweck ist ähnlich zum zweiten, nur umgekehrt: Wenn du einem
vorhandenen Merkmal einen Typparameter hinzufügen möchtest, kannst du ihm einen
Standardwert geben, um eine Erweiterung der Funktionalität des Merkmals zu
ermöglichen, ohne den vorhandenen Implementierungscode zu brechen.</p>
<h3 id="eindeutiger-aufruf-von-methoden-mit-identischen-namen"><a class="header" href="#eindeutiger-aufruf-von-methoden-mit-identischen-namen">Eindeutiger Aufruf von Methoden mit identischen Namen</a></h3>
<p>Nichts in Rust hindert ein Merkmal daran, eine Methode mit demselben Namen wie
die Methode eines anderen Merkmals zu haben, und Rust hindert dich auch nicht
daran, beide Merkmale auf einem Typ zu implementieren. Es ist auch möglich,
eine Methode direkt auf dem Typ mit dem gleichen Namen wie Methoden von
Merkmalen zu implementieren.</p>
<p>Wenn du Methoden mit dem gleichen Namen aufrufst, musst du Rust mitteilen,
welche du verwenden willst. Betrachte den Code in Codeblock 20-17, wo wir zwei
Merkmale <code>Pilot</code> und <code>Wizard</code> definiert haben, die beide eine Methode namens
<code>fly</code> haben. Wir implementieren dann beide Merkmale auf einem Typ <code>Human</code>, der
bereits eine Methode namens <code>fly</code> implementiert hat. Jede Methode <code>fly</code> macht
etwas anderes.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("Hier spricht Ihr Kapitän.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("Hoch!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*Wütend mit den Armen wedeln*");
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p><span class="caption">Codeblock 20-17: Zwei Merkmale sind so definiert, dass
sie eine Methode <code>fly</code> haben und auf dem Typ <code>Human</code> implementiert sind, und
eine Methode <code>fly</code> ist direkt auf dem Typ <code>Human</code> implementiert</span></p>
<p>Wenn wir <code>fly</code> auf einer Instanz von <code>Human</code> aufrufen, ruft der Compiler
standardmäßig die Methode auf, die direkt auf dem Typ implementiert ist, wie in
Codeblock 20-18 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Hier spricht Ihr Kapitän.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Hoch!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*Wütend mit den Armen wedeln*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre>
<p><span class="caption">Codeblock 20-18: Aufrufen von <code>fly</code> auf einer Instanz von
<code>Human</code></span></p>
<p>Wenn man diesen Code ausführt, wird <code>*Wütend mit den Armen wedeln*</code> ausgegeben,
was zeigt, dass Rust die Methode <code>fly</code>, die direkt auf <code>Human</code> implementiert
wurde, aufgerufen hat.</p>
<p>Um die Methoden <code>fly</code> entweder vom Merkmal <code>Pilot</code> oder vom Merkmal <code>Wizard</code>
aufzurufen, müssen wir eine explizitere Syntax verwenden, um anzugeben, welche
Methode <code>fly</code> wir meinen. Codeblock 20-19 demonstriert diese Syntax.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Hier spricht Ihr Kapitän.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Hoch!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*Wütend mit den Armen wedeln*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre>
<p><span class="caption">Codeblock 20-19: Angeben, welche Methode <code>fly</code> wir
aufrufen wollen</span></p>
<p>Das Angeben des Merkmalsnamens vor dem Methodennamen verdeutlicht Rust, welche
Implementierung von <code>fly</code> wir aufrufen wollen. Wir könnten auch
<code>Human::fly(&amp;person)</code> schreiben, was äquivalent zu <code>person.fly()</code> ist, das wir
in Codeblock 20-19 verwendet haben, aber das ist etwas länger zu schreiben, wenn
wir nicht vereindeutigen müssen.</p>
<p>Beim Ausführen dieses Codes wird Folgendes ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
Hier spricht Ihr Kapitän.
Hoch!
*Wütend mit den Armen wedeln*
</code></pre>
<p>Da die Methode <code>fly</code> einen Parameter <code>self</code> benötigt, könnte Rust, wenn wir
zwei <em>Typen</em> hätten, die beide ein <em>Merkmal</em> implementieren, herausfinden,
welche Implementierung eines Merkmals basierend auf dem Typ von <code>self</code> zu
verwenden ist.</p>
<p>Assoziierte Funktionen, die keine Methoden sind, haben jedoch keinen
<code>self</code>-Parameter. Wenn es mehrere Typen oder Merkmale gibt, die
Nicht-Methodenfunktionen mit demselben Funktionsnamen definieren, weiß Rust
nicht immer, welchen Typ du meinst, es sei denn, du verwendest eine
voll-qualifizierte Syntax. In Codeblock 20-20 erstellen wir zum Beispiel ein
Merkmal für ein Tierheim, das alle Hundebabys Spot nennen möchte. Wir erstellen
ein Merkmal <code>Animal</code> mit einer assoziierten Nicht-Methodenfunktion <code>baby_name</code>.
Das Merkmal <code>Animal</code> ist für die Struktur <code>Dog</code> implementiert, für die wir auch
direkt eine assoziierte Nicht-Methodenfunktionen <code>baby_name</code> bereitstellen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("Welpe")
    }
}

fn main() {
    println!("Ein Hundebaby wird {} genannt.", Dog::baby_name());
}</code></pre>
<p><span class="caption">Codeblock 20-20: Ein Merkmal mit einer assoziierten
Funktion und ein Typ mit einer assoziierten Funktion desselben Namens, der das
Merkmal ebenfalls implementiert</span></p>
<p>Wir implementieren den Code für die Benennung aller Welpen Spot in der
assoziierten Funktion <code>baby_name</code>, die auf <code>Dog</code> definiert ist. Der Typ <code>Dog</code>
implementiert auch das Merkmal <code>Animal</code>, das Charakteristiken beschreibt, die
alle Tiere haben. Hundebabys werden Welpen genannt und das drückt sich in der
Implementierung des Merkmals <code>Animal</code> auf <code>Dog</code> in der Funktion <code>baby_name</code>
aus, die mit dem Merkmal <code>Animal</code> assoziiert ist.</p>
<p>In <code>main</code> rufen wir die Funktion <code>Dog::baby_name</code> auf, die die assoziierte
Funktion, die auf <code>Dog</code> definiert ist, direkt aufruft. Dieser Code gibt
Folgendes aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
Ein Hundebaby wird Spot genannt.
</code></pre>
<p>Diese Ausgabe ist nicht das, was wir wollten. Wir wollen die Funktion
<code>baby_name</code> aufrufen, die Teil des Merkmals <code>Animal</code> ist, das wir auf <code>Dog</code>
implementiert haben, sodass der Code <code>Ein Hundebaby wird Welpe genannt</code>
ausgibt. Die Technik der Angabe des Merkmalsnamens, die wir in Codeblock 20-19
verwendet haben, hilft hier nicht weiter; wenn wir <code>main</code> in den Code in
Codeblock 20-21 ändern, erhalten wir einen Kompilierfehler.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Welpe")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("Ein Hundebaby wird {} genannt.", Animal::baby_name());
}
</code></pre>
<p><span class="caption">Codeblock 20-21: Versuch, die Funktion <code>baby_name</code> des
Merkmals <code>Animal</code> aufzurufen, aber Rust weiß nicht, welche Implementierung es
verwenden soll</span></p>
<p>Da <code>Animal::baby_name</code> keinen <code>self</code>-Parameter hat, und es andere Typen geben
könnte, die das Merkmal <code>Animal</code> implementieren, kann Rust nicht herausfinden,
welche Implementierung von <code>Animal::baby_name</code> wir wollen. Wir werden diesen
Kompilierfehler erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
 2 |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("Ein Hundebaby wird {} genannt.", Animal::baby_name());
   |                                                ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("Ein Hundebaby wird {} genannt.", &lt;Dog as Animal&gt;::baby_name());
   |                                                +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
</code></pre>
<p>Um zu vereindeutigen und Rust zu sagen, dass wir die Implementierung von
<code>Animal</code> für <code>Dog</code> verwenden wollen und nicht die Implementierung von <code>Animal</code>
für einen anderen Typ, müssen wir eine vollständig qualifizierte Syntax
verwenden. Codeblock 20-22 zeigt, wie man eine vollständig qualifizierte Syntax
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Welpe")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("Ein Hundebaby wird {} genannt.", &lt;Dog as Animal&gt;::baby_name());
}</code></pre>
<p><span class="caption">Codeblock 20-22: Verwenden einer vollständig
qualifizierten Syntax, um anzugeben, dass wir die Funktion <code>baby_name</code> des
Merkmals <code>Animal</code> aufrufen wollen, wie sie auf <code>Dog</code> implementiert ist</span></p>
<p>Wir geben Rust mit einer Typ-Annotation innerhalb spitzer Klammern an, dass wir
die Methode <code>baby_name</code> des Merkmals <code>Animal</code>, die auf <code>Dog</code> implementiert ist,
aufrufen wollen, indem wir sagen, dass wir den Typ <code>Dog</code> für diesen
Funktionsaufruf als <code>Animal</code> behandeln wollen. Dieser Code wird nun ausgeben,
was wir wollen:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
Ein Hundebaby wird Welpe genannt.
</code></pre>
<p>Im Allgemeinen wird die vollständig qualifizierte Syntax wie folgt definiert:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>Für assoziierte Funktionen, die keine Methoden sind, gäbe es keinen <code>receiver</code>:
Es gäbe nur die Liste der anderen Argumente. Du könntest eine vollständig
qualifizierte Syntax überall dort verwenden, wo du Funktionen oder Methoden
aufrufst. Du darfst jedoch jeden Teil dieser Syntax weglassen, den Rust aus
anderen Informationen im Programm herausfinden kann. Du musst diese
ausführlichere Syntax nur in Fällen verwenden, in denen es mehrere
Implementierungen gibt, die denselben Namen verwenden, und Rust Hilfe benötigt,
um herauszufinden, welche Implementierung du aufrufen möchtest.</p>
<h3 id="verwenden-von-supermerkmalen"><a class="header" href="#verwenden-von-supermerkmalen">Verwenden von Supermerkmalen</a></h3>
<p>Manchmal kann es vorkommen, dass man eine Merkmals-Definition schreibt, die von
einem anderen Merkmal abhängt: Damit ein Typ das erste Merkmal implementieren
kann, muss dieser Typ auch das zweite Merkmal implementieren. Du würdest dies
tun, damit deine Merkmalsdefinition die zugehörigen Elemente des zweiten
Merkmals verwenden kann. Das Merkmal, auf das sich deine Merkmalsdefinition
stützt, wird als <em>Supermerkmal</em> (supertrait) deines Merkmals bezeichnet.</p>
<p>Nehmen wir zum Beispiel an, wir wollen ein Merkmal <code>OutlinePrint</code> mit einer
Methode <code>outline_print</code> erstellen, das einen bestimmten Wert so formatiert,
dass er in Sternchen eingerahmt ausgegeben wird. Das heißt, wenn wir eine
Struktur <code>Point</code> haben, die <code>Display</code> so implementiert, dass sie <code>(x, y)</code>
ausgibt, dann gibt der Aufruf von <code>outline_print</code> einer <code>Point</code>-Instanz, die
<code>1</code> für <code>x</code> und <code>3</code> für <code>y</code> hat, folgendes aus:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>Bei der Implementierung der Methode <code>outline_print</code> wollen wir die
Funktionalität des Merkmals <code>Display</code> nutzen. Daher müssen wir festlegen, dass
das Merkmal <code>OutlinePrint</code> nur bei Typen funktioniert, die auch <code>Display</code>
implementieren und die Funktionalität bieten, die <code>OutlinePrint</code> benötigt. Wir
können dies in der Merkmalsdefinition tun, indem wir <code>OutlinePrint: Display</code>
angeben. Diese Technik ähnelt dem Angeben einer Merkmalsabgrenzung (trait
bound) bei einem Merkmal. Codeblock 20-23 zeigt eine Implementierung des
Merkmals <code>OutlinePrint</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p><span class="caption">Codeblock 20-23: Implementieren des Merkmals
<code>OutlinePrint</code>, das die Funktionalität von <code>Display</code> erfordert</span></p>
<p>Da wir festgelegt haben, dass <code>OutlinePrint</code> das Merkmal <code>Display</code> erfordert,
können wir die Funktion <code>to_string</code> verwenden, die automatisch für jeden Typ
implementiert wird, der <code>Display</code> implementiert. Wenn wir versuchen würden,
<code>to_string</code> zu verwenden, ohne einen Doppelpunkt und das Merkmal <code>Display</code> nach
dem Merkmalsnamen anzugeben, würden wir eine Fehlermeldung erhalten, die
besagt, dass keine Methode mit dem Namen <code>to_string</code> für den Typ <code>&amp;Self</code> im
aktuellen Gültigkeitsbereich gefunden wurde.</p>
<p>Lass uns sehen, was passiert, wenn wir versuchen, <code>OutlinePrint</code> auf einem Typ
zu implementieren, der <code>Display</code> nicht implementiert, z.B. die Struktur
<code>Point</code>:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
<p>Wir erhalten einen Fehler, der besagt, dass <code>Display</code> erforderlich, aber nicht
implementiert ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
</code></pre>
<p>Um dies zu beheben, implementieren wir <code>Display</code> auf <code>Point</code> und erfüllen die
Bedingung, die <code>OutlinePrint</code> erfordert, in etwa so:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
<p>Dann wird die Implementierung des Merkmals <code>OutlinePrint</code> auf <code>Point</code>
erfolgreich kompilieren und wir können <code>outline_print</code> auf einer
<code>Point</code>-Instanz aufrufen, um sie in Sternchen eingerahmt anzuzeigen.</p>
<h3 id="externe-merkmale-mit-dem-newtype-muster-implementieren"><a class="header" href="#externe-merkmale-mit-dem-newtype-muster-implementieren">Externe Merkmale mit dem Newtype-Muster implementieren</a></h3>
<p>In <a href="ch10-02-traits.html#ein-merkmal-für-einen-typ-implementieren">„Ein Merkmal für einen Typ implementieren“</a>
in Kapitel 10 erwähnten wir die Waisenregel, bei der wir ein Merkmal nur dann
auf einem Typ implementieren dürfen, wenn entweder das Merkmal oder der Typ
oder beides lokal in unserer Kiste (crate) vorhanden ist. Es ist möglich, diese
Einschränkung zu umgehen, indem man das <em>Newtype-Muster</em> (newtype pattern)
verwendet, bei dem ein neuer Typ in einer Tupelstruktur erzeugt wird. (Wir
haben Tupelstrukturen in <a href="ch05-01-defining-structs.html#mit-tupel-strukturen-verschiedene-typen-erzeugen">„Mit Tupel-Strukturen verschiedene Typen
erzeugen“</a> in Kapitel 5 behandelt.) Die Tupelstruktur wird ein
Feld haben und eine dünne Verpackung um den Typ sein, für den wir ein Merkmal
implementieren wollen. Dann ist der Verpackungstyp lokal in unserer Kiste und
wir können das Merkmal auf dem Verpackungstyp (wrapper type) implementieren.
<em>Newtype</em> ist ein Begriff, der aus der Programmiersprache Haskell stammt. Beim
Verwenden dieses Musters gibt es keine Beeinträchtigung der Laufzeitperformanz
und der Verpackungstyp wird zur Kompilierzeit elidiert.</p>
<p>Nehmen wir als Beispiel an, wir wollen <code>Display</code> auf <code>Vec&lt;T&gt;</code> implementieren,
was uns die Waisenregel direkt verbietet, weil das Merkmal <code>Display</code> und der
Typ <code>Vec&lt;T&gt;</code> außerhalb unserer Kiste definiert sind. Wir können eine Struktur
<code>Wrapper</code> erstellen, die eine Instanz von <code>Vec&lt;T&gt;</code> enthält; dann können wir
<code>Display</code> auf <code>Wrapper</code> implementieren und den Wert <code>Vec&lt;T&gt;</code> verwenden, wie in
Codeblock 20-24 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("Hallo"), String::from("Welt")]);
    println!("w = {w}");
}</code></pre>
<p><span class="caption">Codeblock 20-24: Erstellen eines Typs <code>Wrapper</code> um
<code>Vec&lt;String&gt;</code> zur Implementierung von <code>Display</code></span></p>
<p>Die Implementierung von <code>Display</code> verwendet <code>self.0</code>, um auf den inneren
<code>Vec&lt;T&gt;</code> zuzugreifen, da <code>Wrapper</code> eine Tupelstruktur ist und <code>Vec&lt;T&gt;</code> das
Element mit dem Index 0 im Tupel ist. Dann können wir die Funktionalität des
<code>Display</code>-Typs auf <code>Wrapper</code> verwenden.</p>
<p>Der Nachteil der Verwendung dieser Technik ist, dass <code>Wrapper</code> ein neuer Typ
ist, sodass er nicht die Methoden des Wertes hat, den er hält. Wir müssten alle
Methoden von <code>Vec&lt;T&gt;</code> direkt auf <code>Wrapper</code> implementieren, sodass die Methoden
an <code>self.0</code> delegieren, was uns erlauben würde, <code>Wrapper</code> genau wie einen
<code>Vec&lt;T&gt;</code> zu behandeln. Wenn wir wollten, dass der neue Typ jede Methode des
inneren Typs hat, wäre die Implementierung des Merkmals <code>Deref</code> auf dem
<code>Wrapper</code> eine Lösung, um den inneren Typ zurückzugeben (wir haben die
Implementierung des Merkmals <code>Deref</code> in <a href="ch15-02-deref.html">„Intelligente Zeiger wie normale
Referenzen behandeln“</a> in Kapitel 15 besprochen). Wenn wir
nicht wollten, dass der <code>Wrapper</code>-Typ alle Methoden des inneren Typs hat
– zum Beispiel, um das Verhalten des <code>Wrapper</code>-Typs einzuschränken
– müssten wir nur die Methoden, die wir wollen, manuell implementieren.</p>
<p>Dieses Newtype-Muster ist auch dann nützlich, wenn keine Merkmale beteiligt
sind. Wechseln wir den Fokus und schauen wir uns einige fortgeschrittene
Möglichkeiten an, mit dem Typsystem von Rust zu interagieren.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-01-unsafe-rust.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="ch20-03-advanced-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-01-unsafe-rust.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="ch20-03-advanced-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris-2317480c.js"></script>



    </div>
    </body>
</html>
