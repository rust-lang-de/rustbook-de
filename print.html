<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Die Programmiersprache Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="die-programmiersprache-rust"><a class="header" href="#die-programmiersprache-rust">Die Programmiersprache Rust</a></h1>
<p><em>von Steve Klabnik, Carol Nichols und Chris Krycho, unter Mitarbeit der
Rust-Gemeinschaft;</em>
<em>übersetzt ins Deutsche durch die Rust-Gemeinschaft</em></p>
<p>Diese Version des Textes geht davon aus, dass du Rust 1.85.0 (veröffentlicht am
2025-02-17) oder neuer mit <code>edition = "2024"</code> in der Cargo.toml-Datei aller
Projekte verwendest, damit sie die Idiome der Rust 2024 Edition verwenden.
Siehe <a href="ch01-01-installation.html">Abschnitt „Installation“ in Kapitel 1</a> zum Installieren und
Aktualisieren von Rust.</p>
<p>Die HTML-Version ist online verfügbar unter
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
(englisches Original) und unter
<a href="https://rust-lang-de.github.io/rustbook-de/">https://rust-lang-de.github.io/rustbook-de/</a>
(deutsche Übersetzung). Die englische Fassung ist zudem offline in
Rust-Installationen, die mit <code>rustup</code> installiert wurden, verfügbar; führe
<code>rustup docs --book</code> aus um sie zu öffnen.</p>
<p>Es sind weitere <a href="appendix-06-translation.html">Gemeinschaftsübersetzungen</a> verfügbar.</p>
<p>Der englische Text ist als <a href="https://nostarch.com/rust-programming-language-2nd-edition">Taschenbuch und E-Book bei No Starch
Press</a> erhältlich, den deutschen Text gibt es ebenfalls als
<a href="https://rust-lernen.de/">Taschenbuch und E-Book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vorwort"><a class="header" href="#vorwort">Vorwort</a></h1>
<p>Es war nicht immer so klar, aber bei der Programmiersprache Rust geht es im
Grunde um <em>Befähigung</em>: Egal, welche Art von Code du jetzt schreibst, Rust
befähigt dich dazu, weiter zu gehen, mit Vertrauen in einer größeren Vielfalt
von Bereichen zu programmieren, als du es zuvor getan hast.</p>
<p>Denken wir zum Beispiel an systemnahe Arbeiten, bei denen Details wie
Speicherverwaltung, Datenrepräsentation und Nebenläufigkeit wichtig sind.
Traditionellerweise gilt dieser Bereich der Programmierung als geheimnisvoll
und nur wenigen Auserwählten zugänglich, die die erforderliche Erfahrung
gesammelt haben, um berüchtigte Fallstricke vermeiden zu können. Und selbst
diejenigen, die damit arbeiten, tun dies mit Sorgfalt, damit ihr Code nicht
angreifbar ist, abstürzt oder fehlerhaft ist.</p>
<p>Rust baut diese Barrieren ab, indem es die alten Fallstricke beseitigt und ein
freundliches, ausgefeiltes Instrumentarium zur Verfügung stellt, das dich auf
deinem Weg unterstützt. Programmierer, die in die systemnahen Kontrollebenen
„eintauchen“ müssen, können dies mit Rust tun, ohne das übliche Risiko von
Abstürzen oder Sicherheitslücken einzugehen und ohne die Finessen einer
wankelmütigen Werkzeugkette erlernen zu müssen. Besser noch, die Sprache ist so
konzipiert, dass sie dich auf natürliche Weise zu zuverlässigem Code führt, der
effizient in Bezug auf Geschwindigkeit und Speichernutzung ist.</p>
<p>Programmierer, die bereits mit systemnahem Code arbeiten, können Rust nutzen,
um ihre Ambitionen zu steigern. Beispielsweise ist die Einführung von
Parallelität in Rust ein relativ risikoarmes Unterfangen: Der Compiler fängt
die klassischen Fehler für dich ab. Und du kannst aggressivere Optimierungen in
deinem Code wagen mit der Gewissheit, keine versehentlichen Abstürze oder
Verwundbarkeiten einzuführen.</p>
<p>Aber Rust ist nicht auf systemnahe Programmierung beschränkt. Es ist
ausdrucksstark und ergonomisch genug, um das Schreiben von
Kommandozeilen-Anwendungen, Webservern und vielen anderen Arten an Code recht
angenehm zu machen – du wirst später in diesem Buch einfache Beispiele
dazu finden. Die Arbeit mit Rust ermöglicht es dir, Fähigkeiten zu entwickeln,
die von einer Domäne auf eine andere übertragen werden können; du kannst Rust
durch Schreiben einer Webanwendung erlernen und dann diese Fähigkeiten auf
deinem Raspberry Pi anwenden.</p>
<p>In diesem Buch wird das Potenzial von Rust zur Befähigung seiner Nutzer voll
ausgeschöpft. Es ist ein freundlicher und zugänglicher Text, der dir helfen
soll, nicht nur dein Wissen über Rust zu erweitern, sondern auch deine
Reichweite und dein Selbstvertrauen als Programmierer im Allgemeinen. Also
tauche ein, mach dich bereit zum Lernen – und willkommen in der
Rust-Gemeinschaft!</p>
<p>– Nicholas Matsakis und Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="einführung"><a class="header" href="#einführung">Einführung</a></h1>
<p>Willkommen bei <em>Die Programmiersprache Rust</em>, einem einführenden Buch über
Rust. Die Programmiersprache Rust hilft dir, schnellere und zuverlässigere
Software zu schreiben. Ergonomie und systemnahe Kontrolle stehen beim Entwurf
von Programmiersprachen oft im Widerspruch – Rust stellt sich diesem
Konflikt. Durch den Ausgleich zwischen leistungsstarken, technischen
Möglichkeiten und einer großartigen Entwicklererfahrung bietet dir Rust die
Möglichkeit, Details systemnah (z. B. Speichernutzung) zu kontrollieren, ohne
den ganzen Ärger, der damit typischerweise einhergeht.</p>
<h2 id="für-wen-rust-ist"><a class="header" href="#für-wen-rust-ist">Für wen Rust ist</a></h2>
<p>Rust ist für viele Menschen aus einer Vielzahl von Gründen ideal. Schauen wir
uns einige der wichtigsten Nutzergruppen an.</p>
<h3 id="entwicklerteams"><a class="header" href="#entwicklerteams">Entwicklerteams</a></h3>
<p>Rust erweist sich als produktives Werkzeug in der Zusammenarbeit großer
Entwicklerteams mit unterschiedlichem Kenntnisstand in der
Systemprogrammierung. Systemnaher Code ist anfällig für eine Vielzahl subtiler
Fehler, die in den meisten anderen Sprachen nur durch ausgiebige Tests und
sorgfältige Überprüfung des Codes durch erfahrene Entwickler erkannt werden
können. In Rust spielt der Compiler eine Art Pförtnerrolle, indem er Code
mit diesen schwer fassbaren Fehlern verweigert zu kompilieren, darunter auch
Nebenläufigkeitsfehler. Mit der Arbeit an der Seite des Compilers kann sich
das Team auf die Programmlogik konzentrieren, anstatt Fehler zu suchen.</p>
<p>Rust bringt auch zeitgemäße Entwicklerwerkzeuge in die Welt der
Systemprogrammierung:</p>
<ul>
<li>Cargo, das mitgelieferte Abhängigkeitsmanagement- und Bau-Werkzeug, macht das
Hinzufügen, Kompilieren und Verwalten von Abhängigkeiten im gesamten
Rust-Ökosystem schmerzlos und konsistent.</li>
<li>Das Formatierungstool Rustfmt sorgt für einen einheitlichen Codierstil bei
den Entwicklern.</li>
<li>Der rust-analyzer ermöglicht Codevervollständigung und im Code angezeigte
Fehlermeldungen innerhalb der Entwicklungsumgebung (IDE).</li>
</ul>
<p>Durch den Einsatz dieser und anderer Werkzeuge des Rust-Ökosystems können
Entwickler produktiv arbeiten, während sie Code auf Systemebene schreiben.</p>
<h3 id="studenten"><a class="header" href="#studenten">Studenten</a></h3>
<p>Rust ist für Studenten und alle, die sich für Systemkonzepte interessieren. Mit
Rust haben viele Menschen etwas über Themen wie die Entwicklung von
Betriebssystemen gelernt. Die Gemeinschaft ist sehr einladend und beantwortet
gerne Fragen der Studenten. Durch Bemühungen wie dieses Buch will das Rust-Team
Systemkonzepte mehr Menschen zugänglich machen, insbesondere denen, die neu in
der Programmierung sind.</p>
<h3 id="unternehmen"><a class="header" href="#unternehmen">Unternehmen</a></h3>
<p>Hunderte von Unternehmen, große und kleine, setzen Rust für eine Vielzahl von
Aufgaben in der Produktion ein, dazu gehören Kommandozeilenwerkzeuge,
Webdienste, DevOps-Werkzeuge, eingebettete Geräte, Audio- und Videoanalyse und
-transkodierung, Kryptowährungen, Bioinformatik, Suchmaschinen, Anwendungen für
das Internet der Dinge, maschinelles Lernen und sogar wesentliche Teile des
Webbrowsers Firefox.</p>
<h3 id="open-source-entwickler"><a class="header" href="#open-source-entwickler">Open-Source-Entwickler</a></h3>
<p>Rust ist für Menschen, die die Programmiersprache Rust, die Gemeinschaft,
Entwickler-Werkzeuge und Bibliotheken aufbauen möchten. Wir würden uns freuen,
wenn du zur Programmiersprache Rust beiträgst.</p>
<h3 id="menschen-die-geschwindigkeit-und-stabilität-schätzen"><a class="header" href="#menschen-die-geschwindigkeit-und-stabilität-schätzen">Menschen, die Geschwindigkeit und Stabilität schätzen</a></h3>
<p>Rust ist für Menschen, die sich nach Geschwindigkeit und Stabilität einer
Sprache sehnen. Mit Geschwindigkeit meinen wir sowohl die Geschwindigkeit, mit
der Rust-Code ausgeführt werden kann, als auch die Geschwindigkeit, mit der du
mit Rust Programme schreiben kannst. Die Prüfungen des Rust-Compilers
gewährleisten Stabilität während du neue Funktionen hinzufügst und deinen Code
änderst. Dies steht im Gegensatz zu brüchigen Code-Altlasten in Sprachen ohne
diese Prüfungen, die Entwickler sich oft scheuen zu verändern. Durch das
Streben nach kostenneutralen Abstraktionen, also Funktionalität auf höherer
Ebene, die zu genauso schnellem Code wie manuell geschriebener Code auf
niedrigerer Ebene kompiliert, bemüht sich Rust, sicheren Code auch zu schnellem
Code zu machen.</p>
<p>Die Sprache Rust hofft, auch viele andere Nutzer zu unterstützen; die hier
genannten sind nur einige der größten Interessensgruppen. Insgesamt ist es
Rusts größtes Bestreben, den Zielkonflikt zu beseitigen, den Programmierer
jahrzehntelang hingenommen haben, wenn sie Sicherheit <em>und</em> Produktivität bzw.
Geschwindigkeit <em>und</em> Ergonomie erreichen wollten. Versuche es mit Rust und
finde heraus, ob dessen Möglichkeiten für dich geeignet sind.</p>
<h2 id="für-wen-dieses-buch-gedacht-ist"><a class="header" href="#für-wen-dieses-buch-gedacht-ist">Für wen dieses Buch gedacht ist</a></h2>
<p>In diesem Buch wird davon ausgegangen, dass du bereits Code in einer anderen
Programmiersprache geschrieben hast, es spielt aber keine Rolle in welcher. Wir
haben versucht, das Material einem breiten Publikum mit unterschiedlichem
Programmierhintergrund zugänglich zu machen. Wir verbringen nicht viel Zeit
damit, darüber zu sprechen, was Programmieren <em>ist</em> oder wie man darüber denkt.
Wenn Programmieren für dich ganz neu ist, wäre es besser, wenn du ein Buch
speziell zur Einführung in die Programmierung liest.</p>
<h2 id="wie-man-dieses-buch-verwendet"><a class="header" href="#wie-man-dieses-buch-verwendet">Wie man dieses Buch verwendet</a></h2>
<p>Im Allgemeinen geht dieses Buch davon aus, dass du es der Reihe nach von vorne
nach hinten liest. Spätere Kapitel bauen auf den Konzepten früherer Kapitel
auf. Frühere Kapitel gehen möglicherweise nicht auf die Einzelheiten eines
Themas ein, denn in der Regel werden wir es in einem späteren Kapitel erneut
aufgreifen.</p>
<p>Du findest in diesem Buch zwei Kapitelarten: Konzeptkapitel und
Projektkapitel. In Konzeptkapiteln erfährst du etwas über einen Aspekt von
Rust. In Projektkapiteln schreiben wir gemeinsam kleine Programme und wenden
das bisher Gelernte an. Die Kapitel 2, 12 und 21 sind Projektkapitel; die
übrigen sind Konzeptkapitel.</p>
<p>Kapitel 1 erklärt, wie man Rust installiert, wie man ein „Hallo Welt“-Programm
schreibt und wie man Cargo, den Paketmanager und das Bauwerkzeug von Rust,
benutzt. Kapitel 2 ist eine praktische Einführung in die Sprache Rust. Hier
werden Konzepte auf hohem Niveau behandelt, spätere Kapitel werden zusätzliche
Einzelheiten liefern. Wenn du dir schon jetzt die Hände schmutzig machen
willst, dann ist Kapitel 2 der richtige Ort dafür. Zunächst willst du
vielleicht sogar Kapitel 3 überspringen, in dem es um Rust-Funktionen geht, die
denen anderer Programmiersprachen ähneln, und direkt zu Kapitel 4 übergehen, um
mehr über den Eigentümerschaftsansatz von Rust zu erfahren. Wenn du jedoch ein
besonders akribischer Lerner bist, der lieber erst jedes Detail lernen will,
bevor er zum nächsten übergeht, willst du vielleicht Kapitel 2 überspringen und
direkt zu Kapitel 3 gehen und danach zu Kapitel 2 zurückkehren, um dann an
einem Projekt zu arbeiten und die gelernten Details anzuwenden.</p>
<p>Kapitel 5 bespricht Strukturen und Methoden, und Kapitel 6 behandelt
Aufzählungen, <code>match</code>-Ausdrücke und das <code>if let</code>-Kontrollflusskonstrukt. Du
wirst Strukturen und Aufzählungen verwenden, um benutzerdefinierte Typen in
Rust zu erstellen.</p>
<p>In Kapitel 7 erfährst du mehr über das Modulsystem von Rust und über die
Datenschutzregeln zum Organisieren deines Codes und dessen öffentlich
zugängliche Programmierschnittstelle (API). In Kapitel 8 werden einige gängige
Kollektionsdatenstrukturen, die die Standardbibliothek zur Verfügung stellt,
behandelt, z. B. Vektoren, Zeichenketten und Hashtabellen. Kapitel 9 befasst
sich mit Rusts Philosophie und Techniken der Fehlerbehandlung.</p>
<p>Kapitel 10 vertieft generische Datentypen, Merkmale und Lebensdauern, die dir
die Möglichkeit geben, Code zu schreiben, der für mehrere Typen passt. In
Kapitel 11 dreht sich alles um das Testen, das selbst mit den
Sicherheitsgarantien von Rust erforderlich ist, um eine korrekte Logik deines
Programms sicherzustellen. In Kapitel 12 werden wir unsere eigene
Implementierung für eine Teilfunktionalität des Kommandozeilenwerkzeugs <code>grep</code>
schreiben, das nach Text in Dateien sucht. Dazu werden wir viele Konzepte
anwenden, die wir in den vorangegangenen Kapiteln kennengelernt haben.</p>
<p>Kapitel 13 befasst sich mit Funktionsabschlüssen und Iteratoren, also
Sprachmerkmalen, die von funktionalen Programmiersprachen stammen. In Kapitel
14 werden wir einen genaueren Blick auf Cargo werfen und über bewährte
Vorgehensweisen beim Bereitstellen deiner Bibliotheken für andere sprechen. In
Kapitel 15 werden intelligente Zeiger, die die Standardbibliothek bereitstellt,
und Merkmale, die ihre Funktionalität ermöglichen, erörtert.</p>
<p>In Kapitel 16 gehen wir durch verschiedene Modelle der nebenläufigen
Programmierung und sprechen darüber, wie Rust dir hilft, furchtlos mit mehreren
Strängen zu programmieren. In Kapitel 17 bauen wir darauf auf, indem wir die
async- und await-Syntax von Rust zusammen mit Aufgaben (tasks), Futures und
Strömen (streams) und dem leichtgewichtigen Nebenläufigkeitsmodell, das sie
ermöglichen, untersuchen.</p>
<p>Kapitel 18 befasst sich mit dem Vergleich von Rust-Idiomen mit
objektorientierten Programmierprinzipien, mit denen du vielleicht vertraut
bist. Kapitel 19 ist ein Nachschlagewerk zu Muster und Musterabgleich, einem
mächtigen Mittel zum Ausdrücken von Ideen in Rust-Programmen. Kapitel 20
enthält ein Sammelsurium an interessanten fortgeschrittenen Themen, darunter
unsicheres Rust, Makros und mehr zu Lebensdauer, Merkmalen, Typen, Funktionen
und Funktionsabschlüssen.</p>
<p>In Kapitel 21 werden wir ein Projekt abschließen, bei dem wir einen
systemnahen, nebenläufigen Webdienst implementieren!</p>
<p>Schließlich enthalten einige Anhänge nützliche Informationen über die Sprache
in einem eher referenzartigen Format. <strong>Anhang A</strong> enthält die Schlüsselwörter
von Rust, <strong>Anhang B</strong> die Operatoren und Symbole von Rust, <strong>Anhang C</strong>
ableitbare Merkmalen, die von der Standardbibliothek mitgebracht werden,
<strong>Anhang D</strong> nützliche Entwicklungswerkzeuge und <strong>Anhang E</strong> erläutert die
Rust-Ausgaben. In <strong>Anhang F</strong> findest du Übersetzungen des Buches, und in
*<em>Anhang G</em> erfährst du, wie Rust erstellt wird und was nächtliches (nightly)
Rust ist.</p>
<p>Es gibt keinen falschen Weg, dieses Buch zu lesen: Wenn du was überspringen
willst, nur zu! Möglicherweise musst du zu früheren Kapiteln zurückkehren, wenn
du irritiert bist. Aber tue, was immer für dich passt.</p>
<p><span id="ferris"></span></p>
<p>Ein wichtiger Teil beim Lernen von Rust ist das Verstehen der Fehlermeldungen,
die der Compiler anzeigt: Diese leiten dich zum funktionierenden Code. Daher
werden wir viele Beispiele bringen, die nicht kompilieren, zusammen mit der
jeweiligen Fehlermeldung des Compilers. Wenn du also ein zufälliges Beispiel
eingibst und ausführen willst, lässt es sich möglicherweise nicht kompilieren!
Stelle sicher, dass du den umgebenden Text liest, um zu wissen, ob das
Beispiel, das du ausführen willst, für einen Fehler gedacht ist. Ferris gibt
dir einen Hinweis bei Code, der nicht funktionieren soll:</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>Bedeutung</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris mit Fragezeichen" /></td><td>Dieser Code lässt sich nicht kompilieren!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris reißt die Hände hoch" /></td><td>Dieser Code bricht ab (panic)!</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris mit einer Kralle nach oben, achselzuckend" /></td><td>Dieser Code liefert nicht das gewünschte Verhalten.</td></tr>
</tbody></table>
</div>
<p>In den meisten Situationen führen wir dich zu einer funktionierenden
Codeversion, wenn er sich nicht kompilieren lässt.</p>
<h2 id="quellcode"><a class="header" href="#quellcode">Quellcode</a></h2>
<p>Die Quelldateien, aus denen dieses Buch generiert wird, findest du unter
<a href="https://github.com/rust-lang-de/rustbook-de/">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erste-schritte"><a class="header" href="#erste-schritte">Erste Schritte</a></h1>
<p>Lass uns mit Rust loslegen! Es gibt viel zu lernen, aber irgendwo muss man
bekanntlich anfangen. In diesem Kapitel geht es um folgende Themen:</p>
<ul>
<li>Installieren von Rust unter Linux, macOS und Windows</li>
<li>Schreiben eines Programms, das <code>Hallo Welt!</code> ausgibt</li>
<li>Verwenden von <code>cargo</code>, Rusts Paketmanager und Bauwerkzeug</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Der erste Schritt ist, Rust zu installieren. Wir werden Rust mittels <code>rustup</code>
herunterladen, einem Kommandozeilenwerkzeug für die Verwaltung von
Rust-Versionen und dazugehörigen Werkzeugen. Du wirst eine Internetverbindung
für den Download benötigen.</p>
<blockquote>
<p>Anmerkung: Falls du <code>rustup</code> aus irgendeinem Grund nicht verwenden möchtest,
schaue bitte auf der Seite <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">„Andere
Rust-Installationsmethoden“</a> nach weiteren Möglichkeiten.</p>
</blockquote>
<p>Die folgenden Schritte installieren die neueste stabile Version des
Rust-Compilers. Rust garantiert Stabilität und stellt somit sicher, dass alle
kompilierbaren Beispiele in diesem Buch auch mit neueren Rust-Versionen
kompilierbar bleiben werden. Die Ausgabe der Beispiele kann sich zwischen
Versionen leicht unterscheiden, weil Rust oft Fehlermeldungen und Warnungen
verbessert. Anders ausgedrückt, jede neuere stabile Version von Rust, die du
mithilfe dieser Schritte installierst, sollte wie erwartet mit dem Inhalt
dieses Buchs funktionieren.</p>
<blockquote>
<h3 id="kommandozeilen-schreibweise"><a class="header" href="#kommandozeilen-schreibweise">Kommandozeilen-Schreibweise</a></h3>
<p>In diesem Kapitel und im ganzen Buch werden wir einige Befehle auf dem
Terminal zeigen. Alle Zeilen, die du in das Terminal eingeben sollst,
beginnen mit <code>$</code>. Du brauchst das <code>$</code>-Zeichen nicht einzugeben;
es weist nur auf den Beginn jedes Befehls hin. Zeilen, die nicht mit
<code>$</code> beginnen, zeigen normalerweise die Ausgabe eines vorherigen Befehls.
PowerShell-spezifische Beispiele werden außerdem <code>&gt;</code> anstelle von <code>$</code>
verwenden.</p>
</blockquote>
<h3 id="installation-von-rustup-unter-linux-und-macos"><a class="header" href="#installation-von-rustup-unter-linux-und-macos">Installation von <code>rustup</code> unter Linux und macOS</a></h3>
<p>Falls du Linux oder macOS verwendest, öffne ein Terminalfenster und gib den
folgenden Befehl ein:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Dieser Befehl lädt ein Skript herunter und startet die Installation
von <code>rustup</code>, welches die neueste stabile Version von Rust installiert.
Du wirst ggf. aufgefordert, dein Passwort einzugeben. Nach erfolgreicher
Installation erscheint folgende Zeile:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Außerdem benötigst du einen <em>Programmbinder</em> (linker), ein Programm, das Rust
verwendet, um die kompilierten Ausgaben in eine Datei zusammenzuführen.
Wahrscheinlich hast du bereits einen. Wenn du Linker-Fehler erhältst, solltest
du einen C-Compiler installieren, der in der Regel auch einen Linker enthält.
Ein C-Compiler ist auch deshalb nützlich, weil einige gängige Rust-Pakete von
C-Code abhängen und daher einen C-Compiler benötigen.</p>
<p>Unter macOS erhältst du einen C-Compiler, indem du folgendes ausführst:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Linux-Benutzer sollten in der Regel GCC oder Clang installieren, je nach
Dokumentation ihrer Distribution. Wenn du zum Beispiel Ubuntu verwendest,
kannst du das Paket <code>build-essential</code> installieren.</p>
<h3 id="installation-von-rustup-unter-windows"><a class="header" href="#installation-von-rustup-unter-windows">Installation von <code>rustup</code> unter Windows</a></h3>
<p>Rufe <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> auf und folge den
Anweisungen, um Rust unter Windows zu installieren. Während der Installation
wirst du aufgefordert, Visual Studio zu installieren. Dieses enthält einen
Linker und die nativen Bibliotheken, die zum Kompilieren von Programmen
benötigt werden. Wenn du an dieser Stelle weitere Hilfe brauchst, gehe zu
<a href="https://rust-lang.github.io/rustup/installation/windows-msvc.html">https://rust-lang.github.io/rustup/installation/windows-msvc.html</a>.</p>
<p>Der Rest dieses Buchs verwendet Befehle, die sowohl in <em>cmd.exe</em> als auch
in der PowerShell funktionieren. Falls es spezifische Unterschiede geben sollte,
werden wir diese erläutern.</p>
<h3 id="fehlersuche"><a class="header" href="#fehlersuche">Fehlersuche</a></h3>
<p>Um zu überprüfen, ob du Rust korrekt installiert hast, öffne ein
Terminal und gib folgende Zeile ein:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Du solltest die Versionsnummer, den Commit-Hash und das Commit-Datum für die
letzte stabile Version, die veröffentlicht wurde, in folgendem Format sehen:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc jjjj-mm-tt)
</code></pre>
<p>Wenn du diese Information siehst, hast du Rust erfolgreich installiert! Wenn du
diese Information nicht siehst, überprüfe, ob Rust in deiner Systemvariable
<code>%PATH%</code> wie folgt enthalten ist.</p>
<p>In Windows CMD verwende:</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>In PowerShell verwende:</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>In Linux und macOS verwende:</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>Wenn das alles korrekt ist und Rust immer noch nicht funktioniert, gibt es
mehrere Stellen, an denen du Hilfe bekommen kannst. Wie du mit anderen
Rust-Entwicklern in Kontakt treten kannst, erfährst du auf der
<a href="https://www.rust-lang.org/community">Gemeinschafts-Seite</a>.</p>
<h3 id="aktualisieren-und-deinstallieren"><a class="header" href="#aktualisieren-und-deinstallieren">Aktualisieren und Deinstallieren</a></h3>
<p>Nachdem du Rust mithilfe von <code>rustup</code> installiert hast, ist es einfach, auf die
neueste Version zu aktualisieren. Führe folgenden Befehl im Terminal aus:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Um Rust und <code>rustup</code> zu deinstallieren, führe folgenden Befehl aus:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="lokale-dokumentation"><a class="header" href="#lokale-dokumentation">Lokale Dokumentation</a></h3>
<p>Die Rust-Installation enthält auch eine lokale Kopie der Dokumentation, sodass
du sie ohne Internetverbindung lesen kannst. Führe <code>rustup doc</code> aus, um die
lokale Dokumentation in deinem Browser zu öffnen.</p>
<p>Falls du dir nicht sicher bist, wie du einen Typ oder eine Funktion aus der
Standardbibliothek verwenden sollst, dann schau in der API-Dokumentation nach!</p>
<h3 id="texteditoren-und-integrierte-entwicklungsumgebungen"><a class="header" href="#texteditoren-und-integrierte-entwicklungsumgebungen">Texteditoren und integrierte Entwicklungsumgebungen</a></h3>
<p>Dieses Buch macht keine Annahmen darüber, welche Werkzeuge du für die
Erstellung von Rust-Code verwendest. So gut wie jeder Texteditor ist dafür
ausreichend! Viele Texteditoren und integrierte Entwicklungsumgebungen (IDEs)
haben jedoch integrierte Unterstützung für Rust. Eine aktuelle Liste von
Editoren und IDEs findest du auf der <a href="https://www.rust-lang.org/tools">Tools-Seite</a> der Rust-Website.</p>
<h3 id="offline-mit-diesem-buch-arbeiten"><a class="header" href="#offline-mit-diesem-buch-arbeiten">Offline mit diesem Buch arbeiten</a></h3>
<p>In mehreren Beispielen werden wir Rust-Pakete außerhalb der Standardbibliothek
verwenden. Um diese Beispiele durchzuarbeiten, benötigst du entweder eine
Internetverbindung oder du musst diese Abhängigkeiten im Voraus heruntergeladen
haben. Um die Abhängigkeiten im Voraus herunterzuladen, kannst du die folgenden
Befehle ausführen. (Wir werden später im Detail erklären, was <code>cargo</code> ist und
was jeder dieser Befehle tut.)</p>
<pre><code class="language-console">$ cargo new get-dependencies
$ cd get-dependencies
$ cargo add rand@0.8.5 trpl@0.2.0
</code></pre>
<p>Dadurch werden die Downloads für diese Pakete zwischengespeichert, sodass du
sie später nicht erneut herunterladen musst. Sobald du diesen Befehl ausgeführt
hast, musst du den Ordner <code>get-dependencies</code> nicht mehr behalten. Wenn du
diesen Befehl ausgeführt hast, kannst du den Parameter <code>--offline</code> mit allen
<code>cargo</code>-Befehlen im Rest des Buches verwenden, um diese zwischengespeicherten
Versionen zu verwenden, anstatt sie aus dem Internet zu holen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hallo-welt"><a class="header" href="#hallo-welt">Hallo Welt</a></h2>
<p>Nachdem du Rust installiert hast, lass uns dein erstes Rust-Programm schreiben.
Wenn man eine neue Sprache lernt, ist es üblich, ein kleines Programm zu
schreiben, das den Text <code>Hallo Welt!</code> auf dem Bildschirm ausgibt, also werden
wir hier das gleiche tun!</p>
<blockquote>
<p>Hinweis: Dieses Buch setzt grundlegende Vertrautheit mit der Kommandozeile
voraus. Rust stellt keine besonderen Anforderungen an deine Textbearbeitung
oder Werkzeuge oder an den Ort, an dem dein Code lebt. Wenn du also lieber
eine integrierte Entwicklungsumgebung (IDE) statt der Kommandozeile verwenden
möchtest, kannst du deine bevorzugte IDE verwenden. Viele IDEs bieten
mittlerweile einen gewissen Grad an Rust-Unterstützung; Einzelheiten findest
du in der Dokumentation der IDE. Das Rust-Team hat sich darauf konzentriert,
eine großartige IDE-Unterstützung mittels <code>rust-analyzer</code> zu ermöglichen.
Siehe <a href="appendix-04-useful-development-tools.html">Anhang D</a> für weitere Details.</p>
</blockquote>
<h3 id="erstellen-eines-projektverzeichnisses"><a class="header" href="#erstellen-eines-projektverzeichnisses">Erstellen eines Projektverzeichnisses</a></h3>
<p>Du beginnst damit, ein Verzeichnis zum Speichern deines Rust-Codes zu
erstellen. Es ist Rust egal, wo dein Code lebt, aber für die Übungen und
Projekte in diesem Buch schlagen wir vor, ein Verzeichnis <em>projects</em> in deinem
Hauptverzeichnis anzulegen und all deine Projekte dort abzulegen.</p>
<p>Öffne ein Terminal und gib die folgenden Befehle ein, um ein Verzeichnis
<em>projects</em> und ein Verzeichnis für das Projekt „Hallo Welt!“ innerhalb des
Verzeichnisses <em>projects</em> zu erstellen.</p>
<p>Gib dies bei Linux, macOS und PowerShell unter Windows ein:</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Bei Windows CMD gib dies ein:</p>
<pre><code class="language-cmd">&gt; mkdir "%USERPROFILE%\projects"
&gt; cd /d "%USERPROFILE%\projects"
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="schreiben-und-ausführen-eines-rust-programms"><a class="header" href="#schreiben-und-ausführen-eines-rust-programms">Schreiben und Ausführen eines Rust-Programms</a></h3>
<p>Als nächstes erstelle eine neue Quelldatei und nenne sie <em>main.rs</em>.
Rust-Dateien enden immer mit der Erweiterung <em>.rs</em>. Wenn du mehr als ein Wort
in deinem Dateinamen verwendest, verwende einen Unterstrich, um sie zu trennen.
Verwende zum Beispiel <em>hello_world.rs</em> statt <em>helloworld.rs</em>.</p>
<p>Öffne nun die Datei <em>main.rs</em>, die du gerade erstellt hast, und gib den Code in
Codeblock 1-1 ein.</p>
<p><span class="filename">Dateiname: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    println!("Hallo Welt!");
}</code></pre></pre>
<p><span class="caption">Codeblock 1-1: Ein Programm, das <code>Hallo Welt!</code>
ausgibt</span></p>
<p>Speichere die Datei und gehe zurück zu deinem Terminalfenster im Verzeichnis
<em>~/projects/hello_world</em>. Gib unter Linux oder MacOS die folgenden Befehle ein,
um die Datei zu kompilieren und auszuführen:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hallo Welt!
</code></pre>
<p>Unter Windows gib den Befehl <code>.\main.exe</code> anstelle von <code>./main</code> ein:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hallo Welt!
</code></pre>
<p>Unabhängig von deinem Betriebssystem sollte die Zeichenfolge <code>Hallo Welt!</code> im
Terminal ausgegeben werden. Wenn du diese Ausgabe nicht siehst, lies im
Abschnitt <a href="ch01-01-installation.html#fehlersuche">„Fehlersuche“</a> des Installationsabschnitts nach,
wie du Hilfe erhalten kannst.</p>
<p>Wenn <code>Hallo Welt!</code> ausgegeben wurde, herzlichen Glückwunsch! Du hast offiziell
ein Rust-Programm geschrieben. Das macht dich zu einem Rust-Programmierer
– willkommen!</p>
<h3 id="anatomie-eines-rust-programms"><a class="header" href="#anatomie-eines-rust-programms">Anatomie eines Rust-Programms</a></h3>
<p>Lass uns im Detail Revue passieren, was gerade in deinem „Hallo Welt!“-Programm
passiert ist. Hier ist das erste Teil des Puzzles:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {

}</code></pre></pre>
<p>Diese Zeilen definieren eine Funktion namens <code>main</code> in Rust. Die Funktion
<code>main</code> ist eine Besonderheit: Sie ist immer der erste Code, der in jedem
ausführbaren Rust-Programm ausgeführt wird. In diesem Fall deklariert die erste
Zeile eine Funktion mit dem namen <code>main</code>, die keine Parameter hat und nichts
zurückgibt. Wenn es Parameter gäbe, würden sie innerhalb der Klammern <code>()</code>
stehen.</p>
<p>Der Funktionsrumpf in geschweifte Klammern <code>{}</code> eingehüllt. Rust erfordert
diese um alle Funktionsrümpfe. Es ist guter Stil, die öffnende geschweifte
Klammer in dieselbe Zeile wie die Funktionsdeklaration zu platzieren und
dazwischen ein Leerzeichen einzufügen.</p>
<blockquote>
<p>Hinweis: Wenn du einen Standardstil für alle Rust-Projekte verwenden
möchtest, kannst du ein automatisches Formatierungswerkzeug namens <code>rustfmt</code>
verwenden, um deinen Code in einem bestimmten Stil zu formatieren (mehr über
<code>rustfmt</code> im <a href="appendix-04-useful-development-tools.html">Anhang D</a>). Das Rust-Team hat dieses Tool wie <code>rustc</code>
in die Standard-Rust-Distribution aufgenommen, es sollte also bereits auf
deinem Computer installiert sein!</p>
</blockquote>
<p>Innerhalb der Funktion <code>main</code> befindet sich der folgende Code:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Hallo Welt!");
<span class="boring">}</span></code></pre></pre>
<p>Diese Zeile erledigt die ganze Arbeit in diesem kleinen Programm: Sie gibt Text
auf dem Bildschirm aus. Hier gibt es drei wichtige Details zu beachten.</p>
<p>Erstens ruft <code>println!</code> ein Rust-Makro auf. Wenn es stattdessen eine Funktion
aufrufte, würde diese als <code>println</code> (ohne <code>!</code>) angegeben werden. Wir werden die
Rust-Makros in Kapitel 19 ausführlicher besprechen. Im Moment musst du nur
wissen, dass die Verwendung eines <code>!</code> bedeutet, dass du ein Makro anstelle
einer normalen Funktion aufrufst und dass Makros nicht immer denselben Regeln
folgen wie Funktionen.</p>
<p>Zweitens siehst du die Zeichenkette <code>"Hallo Welt!"</code>. Wir übergeben diese
Zeichenkette als Argument an <code>println!</code>, und die Zeichenkette wird auf dem
Bildschirm ausgegeben.</p>
<p>Drittens beenden wir die Zeile mit einem Semikolon (<code>;</code>), was anzeigt, dass
dieser Ausdruck beendet ist und der nächste beginnen kann. Die meisten Zeilen
eines Rust-Codes enden mit einem Semikolon.</p>
<h3 id="kompilieren-und-ausführen-sind-getrennte-schritte"><a class="header" href="#kompilieren-und-ausführen-sind-getrennte-schritte">Kompilieren und Ausführen sind getrennte Schritte</a></h3>
<p>Du hast gerade ein neu erstelltes Programm ausgeführt, also lass uns jeden
Schritt in diesem Prozess untersuchen.</p>
<p>Bevor du ein Rust-Programm ausführst, musst du es mit dem Rust-Compiler
kompilieren, indem du den Befehl <code>rustc</code> eingibst und ihm den Namen deiner
Quelldatei übergibst, so wie hier:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>Wenn du einen C- oder C++-Hintergrund hast, wirst du feststellen, dass dies
ähnlich wie <code>gcc</code> oder <code>clang</code> ist. Nach erfolgreicher Kompilierung gibt Rust
eine ausführbare Binärdatei aus.</p>
<p>Unter Linux, MacOS und PowerShell unter Windows kannst du die ausführbare Datei
sehen, indem du den Befehl <code>ls</code> in deinem Terminal eingibst:</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>Unter Linux und MacOS siehst du zwei Dateien. Mit PowerShell unter Windows
siehst du die gleichen drei Dateien, die du mit CMD sehen würdest. Bei CMD
unter Windows würdest du folgendes eingeben:</p>
<pre><code class="language-cmd">&gt; dir /B %= die Option /B bewirkt, dass nur die Dateinamen angezeigt werden =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Dies zeigt die Quellcodedatei mit der Erweiterung <em>.rs</em>, die ausführbare Datei
(<em>main.exe</em> unter Windows, aber <em>main</em> auf allen anderen Plattformen) und, bei
Verwendung von Windows, eine Datei mit Debugging-Informationen mit der
Erweiterung <em>.pdb</em>. Von hier aus führst du die Datei <em>main</em> oder <em>main.exe</em>
aus, so wie hier:</p>
<pre><code class="language-console">$ ./main # oder .\main.exe unter Windows
</code></pre>
<p>Wenn <em>main.rs</em> dein „Hallo Welt!“-Programm wäre, würde diese Zeile „Hallo
Welt!“ in deinem Terminal ausgeben.</p>
<p>Wenn du mit einer dynamischen Sprache wie Ruby, Python oder JavaScript besser
vertraut bist, bist du es möglicherweise nicht gewohnt, ein Programm in
getrennten Schritten zu kompilieren und auszuführen. Rust ist eine <em>vorab
kompilierte</em> (ahead-of-time compiled) Sprache, d.h. du kannst ein Programm
kompilieren und die ausführbare Datei an jemand anderen weitergeben, und dieser
kann das Programm auch ohne Installation von Rust ausführen. Wenn du jemandem
eine <em>.rb</em>-, <em>.py</em>- oder <em>.js</em>-Datei gibst, muss er eine Ruby-, Python- bzw.
JavaScript-Implementierung installiert haben. Aber in diesen Sprachen benötigst
du nur einen Befehl, um dein Programm zu kompilieren und auszuführen. Beim
Sprachdesign ist alles ein Kompromiss.</p>
<p>Einfach mit <code>rustc</code> zu kompilieren ist für einfache Programme in Ordnung, aber
wenn dein Projekt wächst, wirst du alle Optionen verwalten und es einfach
machen wollen, deinen Code weiterzugeben. Als Nächstes stellen wir dir das
Cargo-Tool vor, das dir beim Schreiben von Rust-Programmen aus der realen Welt
helfen wird.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hallo-cargo"><a class="header" href="#hallo-cargo">Hallo Cargo</a></h2>
<p>Cargo ist das Bau-System (build system) und der Paketmanager von Rust. Die
meisten Rust-Entwickler verwenden dieses Werkzeug, um ihre Rust-Projekte zu
verwalten, weil Cargo viele Aufgaben für dich erledigt, z.B. Bauen deines
Codes, Herunterladen der Bibliotheken, von denen dein Code abhängt, und das
Bauen dieser Bibliotheken. (Wir nennen Bibliotheken, die dein Code benötigt,
<em>Abhängigkeiten</em> (dependencies).)</p>
<p>Die einfachsten Rust-Programme, wie das, das wir bisher geschrieben haben,
haben keine Abhängigkeiten. Wenn wir also das „Hallo Welt!“-Projekt mit Cargo
gebaut hätten, würde es nur den Teil von Cargo verwenden, der für das Bauen
deines Codes zuständig ist. Wenn du komplexere Rust-Programme schreibst, wirst
du Abhängigkeiten hinzufügen, und wenn du ein Projekt mit Cargo beginnst, wird
das Hinzufügen von Abhängigkeiten viel einfacher sein.</p>
<p>Da die überwiegende Mehrheit der Rust-Projekte Cargo verwendet, geht der Rest
dieses Buches davon aus, dass auch du Cargo verwendest. Cargo wird mit Rust
installiert, wenn du die offiziellen Installationsprogramme verwendet hast, die
im Abschnitt <a href="ch01-01-installation.html">„Installation“</a> besprochen werden. Wenn du Rust auf
eine andere Weise installiert hast, prüfe, ob Cargo installiert ist, indem du
Folgendes in dein Terminal eingibst:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>Wenn du eine Versionsnummer siehst, hast du es! Wenn du einen Fehler siehst,
z.B. <code>command not found</code>, schaue in der Dokumentation zu deiner
Installationsmethode nach, um festzustellen, wie du Cargo separat installieren
kannst.</p>
<h3 id="projekt-mit-cargo-erstellen"><a class="header" href="#projekt-mit-cargo-erstellen">Projekt mit Cargo erstellen</a></h3>
<p>Lass uns mit Cargo ein neues Projekt erstellen und uns ansehen, wie es sich von
unserem ursprünglichen „Hallo Welt!“-Projekt unterscheidet. Navigiere zurück zu
deinem <em>projects</em>-Verzeichnis (oder wo auch immer du dich entschieden hast,
deinen Code zu speichern). Führe dann auf einem beliebigen Betriebssystem die
folgenden Schritte aus:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>Der erste Befehl erstellt ein neues Verzeichnis und ein Projekt namens
<em>hello_cargo</em>. Wir haben unser Projekt <em>hello_cargo</em> genannt und Cargo
erstellt seine Dateien in einem Verzeichnis mit demselben Namen.</p>
<p>Gehe in das Verzeichnis <em>hello_cargo</em> und liste die Dateien auf. Du wirst
sehen, dass Cargo zwei Dateien und ein Verzeichnis für uns generiert hat: Eine
Datei <em>Cargo.toml</em> und ein Verzeichnis <em>src</em> mit einer Datei <em>main.rs</em> darin.</p>
<p>Es hat auch ein neues Git-Repository zusammen mit einer Datei <em>.gitignore</em>
initialisiert. Git-Dateien werden nicht erzeugt, wenn du <code>cargo new</code> innerhalb
eines existierenden Git-Repositories ausführst; du kannst dieses Verhalten
überschreiben, indem du <code>cargo new --vcs=git</code> verwendest.</p>
<blockquote>
<p>Hinweis: Git ist ein gebräuchliches Versionskontrollsystem. Du kannst <code>cargo new</code> anpassen, um ein anderes Versionskontrollsystem oder kein
Versionskontrollsystem zu verwenden, indem du das Flag <code>--vcs</code> verwendest.
Führe <code>cargo new --help</code> aus, um die verfügbaren Optionen zu sehen.</p>
</blockquote>
<p>Öffne <em>Cargo.toml</em> in einem Texteditor deiner Wahl. Es sollte ähnlich wie der
Code in Codeblock 1-2 aussehen.</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
<p><span class="caption">Codeblock 1-2: Inhalt von <em>Cargo.toml</em> erzeugt durch
<code>cargo new</code></span></p>
<p>Diese Datei liegt im Format <a href="https://toml.io"><em>TOML</em></a> (<em>Tom's Obvious, Minimal
Language</em>) vor, welches das Konfigurationsformat von Cargo ist.</p>
<p>Die erste Zeile <code>[package]</code> ist eine Abschnittsüberschrift, die anzeigt, dass
die folgenden Anweisungen ein Paket konfigurieren. Wenn wir weitere
Informationen zu dieser Datei hinzufügen, werden wir weitere Abschnitte
hinzufügen.</p>
<p>Die nächsten drei Zeilen legen die Konfigurationsinformationen fest, die Cargo
benötigt, um dein Programm zu kompilieren: Den Namen, die Version und die zu
verwendende Rust-Ausgabe. Über den Schlüssel <code>edition</code> sprechen wir in <a href="appendix-05-editions.html">Anhang
E</a>.</p>
<p>Die letzte Zeile <code>[dependencies]</code> ist der Anfang eines Abschnitts, in dem du
alle Abhängigkeiten deines Projekts auflisten kannst. In Rust werden
Code-Pakete als <em>Kisten</em> (crates) bezeichnet. Wir werden keine anderen Kisten
für dieses Projekt benötigen, aber wir werden es im ersten Projekt in Kapitel 2
tun, also werden wir dann diesen Abhängigkeits-Abschnitt verwenden.</p>
<p>Öffne nun <em>src/main.rs</em> und wirf einen Blick darauf:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Cargo hat für dich ein „Hello, world!“-Programm generiert, genau wie das, das
wir in Codeblock 1-1 geschrieben haben! Die Unterschiede zwischen unserem
Projekt und dem Projekt, das Cargo generiert hat, bestehen bisher darin, dass
Cargo den Code im Verzeichnis <em>src</em> abgelegt hat, und wir haben eine
Konfigurationsdatei <em>Cargo.toml</em> im obersten Verzeichnis.</p>
<p>Cargo erwartet, dass deine Quelldateien innerhalb des <em>src</em>-Verzeichnisses
liegen. Das Projektverzeichnis der obersten Ebene ist nur für README-Dateien,
Lizenzinformationen, Konfigurationsdateien und alles andere, was nicht mit
deinem Code zusammenhängt. Das Verwenden von Cargo hilft dir, deine Projekte zu
organisieren. Es gibt einen Platz für alles und alles ist an seinem Platz.</p>
<p>Wenn du ein Projekt begonnen hast, das Cargo nicht verwendet, wie wir es mit
dem Projekt „Hallo Welt!“ getan haben, kannst du es in ein Projekt umwandeln,
das Cargo verwendet. Verschiebe den Projektcode in das Verzeichnis <em>src</em> und
erstelle eine entsprechende <em>Cargo.toml</em>-Datei. Eine einfache Möglichkeit, die
Datei <em>Cargo.toml</em> zu erstellen, besteht darin, <code>cargo init</code> auszuführen.</p>
<h3 id="bauen-und-ausführen-eines-cargo-projekts"><a class="header" href="#bauen-und-ausführen-eines-cargo-projekts">Bauen und Ausführen eines Cargo-Projekts</a></h3>
<p>Schauen wir uns nun an, was anders ist, wenn wir das „Hello, world!“-Programm
mit Cargo bauen und ausführen. Von deinem <em>hello_cargo</em>-Verzeichnis aus baust
du dein Projekt, indem du den folgenden Befehl eingibst:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Dieser Befehl erzeugt eine ausführbare Datei in <em>target/debug/hello_cargo</em>
(oder <em>target\debug\hello_cargo.exe</em> unter Windows) und nicht in deinem
aktuellen Verzeichnis. Da standardmäßig für den Debug-Modus gebaut wird, legt
Cargo die Binärdatei in einem Verzeichnis namens <em>debug</em> ab. Mit diesem Befehl
kannst du die ausführbare Datei ausführen:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # oder .\target\debug\hello_cargo.exe unter Windows
Hello, world!
</code></pre>
<p>Wenn alles gut geht, sollte <code>Hello, world!</code> im Terminal ausgegeben werden. Wenn
<code>cargo build</code> zum ersten Mal ausgeführt wird, erzeugt Cargo auch eine neue
Datei auf der obersten Ebene: <em>Cargo.lock</em>. Diese Datei verfolgt die genauen
Versionen der Abhängigkeiten in deinem Projekt. Dieses Projekt hat keine
Abhängigkeiten, daher ist die Datei etwas spärlich. Du musst diese Datei
niemals manuell ändern; Cargo verwaltet ihren Inhalt für dich.</p>
<p>Wir haben gerade ein Projekt mit <code>cargo build</code> gebaut und es mit
<code>./target/debug/hello_cargo</code> ausgeführt, aber wir können auch <code>cargo run</code>
verwenden, um den Code zu kompilieren und dann die resultierende ausführbare
Datei mit einem einzigen Befehl auszuführen:</p>
<pre><code class="language-console">$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Das Verwenden von <code>cargo run</code> ist bequemer, als sich daran erinnern zu müssen,
<code>cargo build</code> auszuführen und dann den gesamten Pfad zur Binärdatei zu
verwenden, daher verwenden die meisten Entwickler <code>cargo run</code>.</p>
<p>Beachte, dass wir diesmal keine Ausgabe gesehen haben, die darauf hinweist,
dass Cargo <code>hello_cargo</code> kompiliert hat. Cargo fand heraus, dass sich die
Dateien nicht geändert hatten, also hat es nicht neu gebaut, sondern ließ
einfach die Binärdatei laufen. Wenn du deinen Quellcode geändert hättest, hätte
Cargo das Projekt vor der Ausführung neu kompiliert, und du hättest diese
Ausgabe gesehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo bietet auch einen Befehl namens <code>cargo check</code>. Dieser Befehl überprüft
schnell deinen Code, um sicherzustellen, dass er kompiliert, erzeugt aber keine
ausführbare Datei:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>Warum willst du keine ausführbare Datei? Häufig ist <code>cargo check</code> viel
schneller als <code>cargo build</code>, weil es den Schritt der Erstellung einer
ausführbaren Datei überspringt. Wenn du deine Arbeit während des Schreibens des
Codes ständig überprüfst, wird das Verwenden von <code>cargo check</code> den Prozess
beschleunigen! Daher führen viele Rust-Entwickler während des Schreibens ihres
Programms regelmäßig <code>cargo check</code> aus, um sicherzustellen, dass das Programm
kompiliert. Dann lassen sie <code>cargo build</code> laufen, wenn sie bereit sind, die
ausführbare Datei zu benutzen.</p>
<p>Lasse uns zusammenfassen, was wir bisher über Cargo gelernt haben:</p>
<ul>
<li>Wir können ein Projekt mit <code>cargo new</code> erstellen.</li>
<li>Wir können ein Projekt mit <code>cargo build</code> bauen.</li>
<li>Wir können ein Projekt mit <code>cargo run</code> in einem Schritt bauen und ausführen.</li>
<li>Wir können ein Projekt mit <code>cargo check</code> bauen, ohne eine Binärdatei zu
erzeugen, um auf Fehler zu prüfen.</li>
<li>Anstatt das Ergebnis des Bauvorgangs im selben Verzeichnis wie unser Code
abzulegen, legt Cargo es im Verzeichnis <em>target/debug</em> ab.</li>
</ul>
<p>Ein zusätzlicher Vorteil der Verwendung von Cargo ist, dass die Befehle
unabhängig vom Betriebssystem sind, mit dem du arbeitest. Daher werden wir an
dieser Stelle keine spezifischen Anweisungen für Linux und macOS gegenüber
Windows mehr geben.</p>
<h3 id="bauen-einer-freigabe-release"><a class="header" href="#bauen-einer-freigabe-release">Bauen einer Freigabe (release)</a></h3>
<p>Wenn dein Projekt schließlich zur Freigabe bereit ist, kannst du <code>cargo build --release</code> verwenden, um es mit Optimierungen zu kompilieren. Dieser Befehl
erzeugt eine ausführbare Datei in <em>target/release</em> anstelle von <em>target/debug</em>.
Durch die Optimierungen läuft dein Rust-Code schneller, aber wenn du sie
einschaltest, verlängert sich die Zeit, die dein Programm zum Kompilieren
benötigt. Aus diesem Grund gibt es zwei verschiedene Profile: Eines für die
Entwicklung, wenn du schnell und oft neu bauen willst, und ein anderes für das
Erstellen des endgültigen Programms, das du einem Benutzer gibst, das nicht
wiederholt neu gebaut wird und das so schnell wie möglich läuft. Wenn du einen
Laufzeit-Benchmark deines Codes durchführst, stelle sicher, dass du <code>cargo build --release</code> ausführst und den Benchmark mit der ausführbaren Datei in
<em>target/release</em> durchführst.</p>
<h3 id="cargo-als-konvention"><a class="header" href="#cargo-als-konvention">Cargo als Konvention</a></h3>
<p>Bei einfachen Projekten bietet Cargo nicht viel mehr Wert als das bloße
Verwenden von <code>rustc</code>, aber es wird sich in dem Maße bewähren, wie deine
Programme immer komplizierter werden. Sobald Programme auf mehrere Dateien
anwachsen oder eine Abhängigkeit benötigen, ist es viel einfacher, Cargo den
Bauvorgang koordinieren zu lassen.</p>
<p>Auch wenn das Projekt <code>hello_cargo</code> einfach ist, so verwendet es jetzt einen
Großteil der realen Werkzeuge, die du im Rest deiner Rust-Karriere verwenden
wirst. Tatsächlich kannst du, um an bestehenden Projekten zu arbeiten, die
folgenden Befehle verwenden, um den Code mit Git auszuchecken, in das
Verzeichnis dieses Projekts zu wechseln und zu bauen:</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Weitere Informationen über Cargo findest du in seiner
<a href="https://doc.rust-lang.org/cargo/">Dokumentation</a>.</p>
<h2 id="zusammenfassung"><a class="header" href="#zusammenfassung">Zusammenfassung</a></h2>
<p>Du hast deine Rust-Reise bereits gut begonnen! In diesem Kapitel hast du
gelernt, wie es geht:</p>
<ul>
<li>Installiere die neueste stabile Version von Rust mit <code>rustup</code>.</li>
<li>Aktualisiere auf eine neuere Rust-Version.</li>
<li>Öffne die lokal installierte Dokumentation.</li>
<li>Schreibe und führe ein „Hallo Welt!“-Programm aus, direkt mittels <code>rustc</code>.</li>
<li>Schreibe und führe ein neues Projekt aus mittels Cargo-Konventionen.</li>
</ul>
<p>Dies ist ein guter Zeitpunkt, ein umfangreicheres Programm zu erstellen, um
sich an das Lesen und Schreiben von Rust-Code zu gewöhnen. In Kapitel 2 werden
wir also ein Ratespielprogramm erstellen. Wenn du lieber damit beginnen
möchtest, zu lernen, wie gängige Programmierkonzepte in Rust funktionieren,
lies Kapitel 3 und kehre dann zu Kapitel 2 zurück.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ein-ratespiel-programmieren"><a class="header" href="#ein-ratespiel-programmieren">Ein Ratespiel programmieren</a></h1>
<p>Lass uns den Sprung in Rust wagen, indem wir gemeinsam ein praktisches Projekt
durcharbeiten! Dieses Kapitel führt dich in einige gängige Rust-Konzepte ein,
indem es dir zeigt, wie du diese in einem realen Programm verwenden kannst. Du
lernst <code>let</code>, <code>match</code>, Methoden, assoziierte Funktionen, externe Kisten
(crates) und mehr kennen! In den folgenden Kapiteln werden wir diese Ideen
ausführlicher behandeln. In diesem Kapitel wirst du nur die Grundlagen üben.</p>
<p>Wir werden ein klassisches Programmierproblem für Anfänger implementieren: Ein
Ratespiel. Und so funktioniert es: Das Programm erzeugt eine zufällige ganze
Zahl zwischen 1 und 100. Dann wird es den Spieler auffordern, eine Schätzung
einzugeben. Nachdem eine Schätzung eingegeben wurde, zeigt das Programm an, ob
die Schätzung zu niedrig oder zu hoch ist. Wenn die Schätzung korrekt ist, gibt
das Spiel eine Glückwunschnachricht aus und beendet sich.</p>
<h2 id="aufsetzen-eines-neuen-projekts"><a class="header" href="#aufsetzen-eines-neuen-projekts">Aufsetzen eines neuen Projekts</a></h2>
<p>Um ein neues Projekt aufzusetzen, gehe in das Verzeichnis <em>projects</em>, das du in
Kapitel 1 erstellt hast, und erstelle ein neues Projekt mit Cargo, wie folgt:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>Der erste Befehl <code>cargo new</code> nimmt den Namen des Projekts (<code>guessing_game</code>) als
erstes Argument. Der zweite Befehl wechselt in das Verzeichnis des neuen
Projekts.</p>
<p>Schaue dir die generierte Datei <em>Cargo.toml</em> an:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
<p>Wie du in Kapitel 1 gesehen hast, generiert <code>cargo new</code> ein „Hello,
world!“-Programm für dich. Sieh dir die Datei <em>src/main.rs</em> an:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Kompilieren wir nun dieses „Hello, world!“-Programm und führen es im gleichen
Schritt aus mit dem Befehl <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Der Befehl <code>run</code> ist praktisch, wenn du ein Projekt schnell iterieren musst,
wie wir es in diesem Spiel tun werden, indem du jede Iteration schnell testest,
bevor du zur nächsten übergehst.</p>
<p>Öffne die Datei <em>src/main.rs</em> erneut. Du wirst den gesamten Code in diese Datei
schreiben.</p>
<h2 id="verarbeiten-einer-schätzung"><a class="header" href="#verarbeiten-einer-schätzung">Verarbeiten einer Schätzung</a></h2>
<p>Der erste Teil des Ratespielprogramms fragt nach einer Benutzereingabe,
verarbeitet diese Eingabe und überprüft, ob die Eingabe in der erwarteten Form
vorliegt. Zu Beginn erlauben wir dem Spieler, eine Schätzung einzugeben. Gib
den Code aus Codeblock 2-1 in <em>src/main.rs</em> ein.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("Rate die Zahl!");

    println!("Bitte gib deine Schätzung ein.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Fehler beim Lesen der Zeile");

    println!("Du hast geschätzt: {guess}");
}</code></pre>
<p><span class="caption">Codeblock 2-1: Code, der eine Schätzung vom Benutzer
erhält und ausgibt</span></p>
<p>Dieser Code enthält eine Menge Informationen, also gehen wir ihn Zeile für
Zeile durch. Um eine Benutzereingabe zu erhalten und das Ergebnis dann als
Ausgabe auszugeben, müssen wir die Bibliothek <code>io</code> (input/output) in den
Gültigkeitsbereich bringen. Die <code>io</code>-Bibliothek stammt aus der
Standardbibliothek, bekannt als <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    println!("Bitte gib deine Schätzung ein.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Fehler beim Lesen der Zeile");
</span><span class="boring">
</span><span class="boring">    println!("Du hast geschätzt: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Standardmäßig hat Rust einige Elemente in der Standardbibliothek definiert,
die es in den Gültigkeitsbereich jedes Programms bringt. Diese Menge wird
<em>Präludium</em> genannt, und du kannst deren Inhalt <a href="https://doc.rust-lang.org/std/prelude/index.html">in der Dokumentation der
Standardbibliothek</a> sehen.</p>
<p>Wenn ein Typ, den du verwenden willst, nicht im Präludium enthalten ist, musst
du diesen Typ explizit mit einer <code>use</code>-Anweisung in den Gültigkeitsbereich
bringen. Das Verwenden der Bibliothek <code>std::io</code> bietet dir eine Reihe von
nützlichen Funktionalitäten, einschließlich der Möglichkeit, Benutzereingaben
entgegenzunehmen.</p>
<p>Wie du in Kapitel 1 gesehen hast, ist die Funktion <code>main</code> der Einstiegspunkt in
das Programm:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    println!("Bitte gib deine Schätzung ein.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Fehler beim Lesen der Zeile");
</span><span class="boring">
</span><span class="boring">    println!("Du hast geschätzt: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Die Syntax <code>fn</code> deklariert eine neue Funktion; die Klammern <code>()</code> zeigen an,
dass es keine Parameter gibt; und die geschweifte Klammer <code>{</code> beginnt den Rumpf
der Funktion.</p>
<p>Wie du auch in Kapitel 1 gelernt hast, ist <code>println!</code> ein Makro, das eine
Zeichenkette auf dem Bildschirm ausgibt:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("Rate die Zahl!");

    println!("Bitte gib deine Schätzung ein.");
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Fehler beim Lesen der Zeile");
</span><span class="boring">
</span><span class="boring">    println!("Du hast geschätzt: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Dieser Code gibt eine Eingabeaufforderung aus, die angibt, um was für ein Spiel
es sich handelt, und den Benutzer zur Eingabe auffordert.</p>
<h3 id="speichern-von-werten-mit-variablen"><a class="header" href="#speichern-von-werten-mit-variablen">Speichern von Werten mit Variablen</a></h3>
<p>Als Nächstes erstellen wir eine <em>Variable</em>, um die Benutzereingabe zu
speichern, wie hier:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    println!("Bitte gib deine Schätzung ein.");
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Fehler beim Lesen der Zeile");
</span><span class="boring">
</span><span class="boring">    println!("Du hast geschätzt: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Jetzt wird das Programm interessant! Es ist viel los in dieser kleinen Zeile.
Wir verwenden eine <code>let</code>-Anweisung, um eine Variable zu erzeugen. Hier ist ein
weiteres Beispiel:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>Diese Zeile erzeugt eine neue Variable namens <code>apples</code> und bindet sie an den
Wert 5. In Rust sind Variablen standardmäßig unveränderbar (immutable), das
heißt, sobald wir der Variablen einen Wert gegeben haben, wird sich der Wert
nicht mehr ändern. Wir werden dieses Konzept im Abschnitt <a href="ch03-01-variables-and-mutability.html">„Variablen und
Veränderbarkeit“</a> in Kapitel 3 ausführlich
besprechen. Um eine Variable veränderbar zu machen, ergänzen wir <code>mut</code> vor dem
Variablennamen:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let apples = 5; // unveränderbar
let mut bananas = 5; // veränderbar
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Anmerkung: Die Syntax <code>//</code> beginnt einen Kommentar, der bis zum Ende der
Zeile weitergeht. Rust ignoriert alles in Kommentaren. Diese werden in
Kapitel 3 ausführlicher besprochen.</p>
</blockquote>
<p>Zurück zum Programm des Ratespiels. Du weißt jetzt, dass <code>let mut guess</code> eine veränderbare Variable namens <code>guess</code> einführt. Das
Gleichheitszeichen (<code>=</code>) sagt Rust, dass wir jetzt etwas an die Variable binden
wollen. Auf der rechten Seite des Gleichheitszeichens steht der Wert, an den
<code>guess</code> gebunden ist, was das Ergebnis des Aufrufs von <code>String::new</code> ist, einer
Funktion, die eine neue Instanz eines <code>String</code> zurückgibt. <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>
ist ein von der Standardbibliothek bereitgestellter Zeichenketten-Typ, der ein
wachstumsfähiges, UTF-8-kodiertes Stück Text ist.</p>
<p>Die Syntax <code>::</code> in der Zeile <code>::new</code> zeigt an, dass <code>new</code> eine assoziierte
Funktion (associated function) vom Typ <code>String</code> ist. Eine <em>assoziierte
Funktion</em> ist eine Funktion, die auf einem Typ, in diesem Fall <code>String</code>,
implementiert ist. Diese Funktion <code>new</code> erzeugt eine neue, leere Zeichenkette.
Du wirst eine Funktion <code>new</code> bei vielen Typen finden, weil es ein
gebräuchlicher Name für eine Funktion ist, die einen neuen Wert irgendeiner Art
erzeugt.</p>
<p>Insgesamt hat die Zeile <code>let mut guess = String::new();</code> eine veränderbare
Variable erzeugt, die derzeit an eine neue, leere Instanz eines <code>String</code>
gebunden ist. Uff!</p>
<h3 id="empfangen-von-benutzereingaben"><a class="header" href="#empfangen-von-benutzereingaben">Empfangen von Benutzereingaben</a></h3>
<p>Erinnere dich, dass wir die Ein-/Ausgabefunktionalität aus der
Standardbibliothek mit <code>use std::io;</code> in der ersten Zeile des Programms
eingebunden haben. Jetzt rufen wir die Funktion <code>stdin</code> aus dem Modul <code>io</code> auf,
die es uns ermöglichen wird, Benutzereingaben zu verarbeiten.</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    println!("Bitte gib deine Schätzung ein.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("Fehler beim Lesen der Zeile");
</span><span class="boring">
</span><span class="boring">    println!("Du hast geschätzt: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Hätten wir die Bibliothek <code>io</code> nicht am Anfang des Programms mit <code>use std::io;</code>
importiert, könnten wir die Funktion trotzdem verwenden, indem wir den
Funktionsaufruf als <code>std::io::stdin</code> schreiben. Die Funktion <code>stdin</code> gibt eine
Instanz von <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a> zurück, was ein Typ ist, der eine
Standardeingaberessource (handle to the standard input) für dein Terminal
darstellt.</p>
<p>Die nächste Zeile <code>.read_line(&amp;mut guess)</code> ruft die Methode
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a> der Standardeingaberessource auf, um eine Eingabe vom
Benutzer zu erhalten. Wir übergeben auch das Argument <code>&amp;mut guess</code> an
<code>read_line</code>, um ihm mitzuteilen, in welche Zeichenfolge es die Benutzereingabe
speichern soll. Die Aufgabe von <code>read_line</code> ist es, alles, was der Benutzer in
die Standardeingabe eingibt, an eine Zeichenkette anzuhängen (ohne deren Inhalt
zu überschreiben), daher übergeben wir diese Zeichenkette als Argument. Das
Zeichenketten-Argument muss veränderbar sein, damit die Methode den Inhalt der
Zeichenkette ändern kann.</p>
<p>Das <code>&amp;</code> zeigt an, dass es sich bei diesem Argument um eine <em>Referenz</em> handelt,
die dir eine Möglichkeit bietet, mehrere Teile deines Codes auf einen Datenteil
zugreifen zu lassen, ohne dass du diese Daten mehrfach in den Speicher kopieren
musst. Referenzen sind eine komplexe Funktionalität, und einer der
Hauptvorteile von Rust ist, wie sicher und einfach es ist, Referenzen zu
verwenden. Du musst nicht viele dieser Details kennen, um dieses Programm
fertigzustellen. Im Moment musst du nur wissen, dass Referenzen wie Variablen
standardmäßig unveränderbar sind. Daher musst du <code>&amp;mut guess</code> anstatt <code>&amp;guess</code>
schreiben, um sie veränderbar zu machen. (In Kapitel 4 werden Referenzen
ausführlicher erklärt.)</p>
<h3 id="behandeln-potentieller-fehler-mit-result"><a class="header" href="#behandeln-potentieller-fehler-mit-result">Behandeln potentieller Fehler mit <code>Result</code></a></h3>
<p>Wir arbeiten noch immer an dieser Codezeile. Wir besprechen jetzt eine dritte
Textzeile, aber beachte, dass sie immer noch Teil einer einzigen logischen
Codezeile ist. Der nächste Teil ist diese Methode:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    println!("Bitte gib deine Schätzung ein.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("Fehler beim Lesen der Zeile");
<span class="boring">
</span><span class="boring">    println!("Du hast geschätzt: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Wir hätten diesen Code auch so schreiben können:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("Fehler beim Lesen der Zeile");</code></pre>
<p>Eine lange Zeile ist jedoch schwer zu lesen, daher ist es am besten, sie
aufzuteilen. Es ist oft ratsam, einen Zeilenumbruch und andere Leerzeichen
einzufügen, um lange Zeilen aufzubrechen, wenn du eine Methode mit der
Syntax <code>.method_name()</code> aufrufst. Lass uns nun besprechen, was diese Zeile
bewirkt.</p>
<p>Wie bereits erwähnt, schreibt <code>read_line</code> die Benutzereingabe in die übergebene
Zeichenketten-Variable, gibt aber darüber hinaus auch einen <code>Result</code>-Wert
zurück. <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> ist eine <a href="ch06-00-enums.html"><em>Aufzählung</em></a> (enumeration, oder
kurz enum), die einen Datentyp darstellt, der einem von mehreren möglichen
Zuständen annehmen kann. Wir nennen jeden möglichen Zustand eine <em>Variante</em>.</p>
<p>In Kapitel 6 werden <a href="ch06-00-enums.html">Aufzählungen</a> ausführlicher behandelt. Der Zweck
dieser <code>Result</code>-Typen ist es, Informationen zur Fehlerbehandlung zu kodieren.</p>
<p>Die Varianten von <code>Result</code> sind <code>Ok</code> und <code>Err</code>. Die Variante <code>Ok</code> gibt an, dass
die Operation erfolgreich war, und enthält den erfolgreich generierten Wert.
Die Variante <code>Err</code> bedeutet, dass die Operation fehlgeschlagen ist, und enthält
Informationen darüber, wie oder warum die Operation fehlgeschlagen ist.</p>
<p>Für Werte vom Typ <code>Result</code> sind, wie für Werte jedes Typs, Methoden definiert.
Eine Instanz von <code>Result</code> hat eine <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">Methode <code>expect</code></a>, die du
aufrufen kannst. Wenn diese <code>io::Result</code>-Instanz ein <code>Err</code>-Wert ist, wird
<code>expect</code> das Programm zum Absturz bringen und die Meldung anzeigen, die du als
Argument an <code>expect</code> übergeben hast. Wenn die Methode <code>read_line</code> ein <code>Err</code>
zurückgibt, ist dies wahrscheinlich das Ergebnis eines Fehlers, der vom
zugrundeliegenden Betriebssystem herrührt. Wenn diese <code>io::Result</code>-Instanz ein
<code>Ok</code>-Wert ist, wird <code>expect</code> den Wert, den <code>Ok</code> hält, als Rückgabewert
verwenden, damit du ihn verwenden kannst. In diesem Fall ist dieser Wert die
Anzahl der Bytes, die der Benutzer in die Standardeingabe eingegeben hat.</p>
<p>Wenn du nicht <code>expect</code> aufrufst, wird das Programm kompiliert, aber du erhältst
eine Warnung:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust warnt, dass du den von <code>read_line</code> zurückgegebenen <code>Result</code>-Wert nicht
verwendet hast, was darauf hinweist, dass das Programm einen möglichen Fehler
nicht behandelt hat.</p>
<p>Der richtige Weg, die Warnung zu unterdrücken, ist eine Fehlerbehandlung zu
schreiben, aber da wir dieses Programm einfach nur abstürzen lassen wollen,
wenn ein Problem auftritt, können wir <code>expect</code> verwenden. In <a href="ch09-02-recoverable-errors-with-result.html">Kapitel
9</a> erfährst du, wie man sich von Fehlern erholt.</p>
<h3 id="ausgeben-von-werten-mit-println-platzhaltern"><a class="header" href="#ausgeben-von-werten-mit-println-platzhaltern">Ausgeben von Werten mit <code>println!</code>-Platzhaltern</a></h3>
<p>Abgesehen von der schließenden geschweiften Klammer gibt es in dem bisher
hinzugefügten Code nur noch eine weitere Zeile zu besprechen:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    println!("Bitte gib deine Schätzung ein.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Fehler beim Lesen der Zeile");
</span><span class="boring">
</span>    println!("Du hast geschätzt: {guess}");
<span class="boring">}</span></code></pre>
<p>Diese Zeile gibt die Zeichenkette aus, die jetzt die Eingabe des Benutzers
enthält. Der Satz geschweifte Klammern <code>{}</code> ist ein Platzhalter:
Stelle dir <code>{}</code> wie kleine Krebszangen vor, die einen Wert an Ort und Stelle
halten. Wenn du den Wert einer Variablen ausgibst, kann der Variablenname
innerhalb der geschweiften Klammern stehen. Wenn du das Ergebnis der Auswertung
eines Ausdrucks ausgeben willst, füge leere geschweifte Klammern in die
Formatierungszeichenkette ein und gib dann nach der Formatierungszeichenkette
eine durch Komma getrennte Liste von Ausdrücken ein, die in jedem leeren
geschweiften Klammerplatzhalter in derselben Reihenfolge ausgegeben werden
sollen. Das Ausgeben einer Variablen und des Ergebnisses eines Ausdrucks in
einem Aufruf von <code>println!</code> würde wie folgt aussehen:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} und y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code würde <code>x = 5 und y + 2 = 12</code> ausgeben.</p>
<h3 id="testen-des-ersten-teils"><a class="header" href="#testen-des-ersten-teils">Testen des ersten Teils</a></h3>
<p>Testen wir den ersten Teil des Ratespiels. Führe ihn mit <code>cargo run</code> aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Rate die Zahl!
Bitte gib deine Schätzung ein.
6
Du hast geschätzt: 6
</code></pre>
<p>An diesem Punkt ist der erste Teil des Spiels abgeschlossen: Wir erhalten
eine Eingabe über die Tastatur und geben sie dann aus.</p>
<h2 id="generieren-einer-geheimzahl"><a class="header" href="#generieren-einer-geheimzahl">Generieren einer Geheimzahl</a></h2>
<p>Als Nächstes müssen wir eine Geheimzahl generieren, die der Benutzer versucht
zu erraten. Die Geheimzahl sollte jedes Mal anders sein, damit das Spiel mehr als
einmal Spaß macht. Wir werden eine Zufallszahl zwischen 1 und 100 verwenden,
damit das Spiel nicht zu schwierig wird. Rust enthält noch keine
Zufallszahl-Funktionalität in seiner Standardbibliothek. Das Rust-Team stellt
jedoch eine <a href="https://crates.io/crates/rand">Kiste <code>rand</code></a> mit besagter Funktionalität zur
Verfügung.</p>
<h3 id="verwenden-einer-kiste-um-mehr-funktionalität-zu-erhalten"><a class="header" href="#verwenden-einer-kiste-um-mehr-funktionalität-zu-erhalten">Verwenden einer Kiste, um mehr Funktionalität zu erhalten</a></h3>
<p>Denke daran, dass eine Kiste eine Sammlung von Rust-Quellcode-Dateien ist. Unser
Projekt "Ratespiel" ist eine <em>binäre Kiste</em> (binary crate), die eine
ausführbare Datei ist. Die Kiste <code>rand</code> ist eine <em>Bibliotheks-Kiste</em> (library
crate), die Code enthält, der in anderen Programmen verwendet werden soll.</p>
<p>Das Koordinieren von externen Kisten ist der Bereich, in dem Cargo glänzt.
Bevor wir Code schreiben können, der <code>rand</code> benutzt, müssen wir die Datei
<em>Cargo.toml</em> so modifizieren, dass die Kiste <code>rand</code> als Abhängigkeit
eingebunden wird. Öffne jetzt diese Datei und füge die folgende Zeile unten
unter der Überschrift des Abschnitts <code>[dependencies]</code> hinzu, den Cargo für dich
erstellt hat. Stelle sicher, dass du <code>rand</code> genau so angibst, wie wir es hier
getan haben, andernfalls funktionieren die Codebeispiele in dieser Anleitung
möglicherweise nicht.</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>In der Datei <em>Cargo.toml</em> ist alles, was nach einer Überschrift folgt, Teil
dieses Abschnitts, der so lange andauert, bis ein anderer Abschnitt beginnt. Im
Abschnitt <code>[dependencies]</code> teilst du Cargo mit, von welchen externen Kisten
dein Projekt abhängt und welche Versionen dieser Kisten du benötigst. In diesem
Fall spezifizieren wir die Kiste <code>rand</code> mit dem semantischen
Versionsspezifikator <code>0.8.5</code>. Cargo versteht <a href="https://semver.org/lang/de/">semantische
Versionierung</a> (manchmal auch <em>SemVer</em> genannt), was ein Standard zum
Schreiben von Versionsnummern ist. Die Angabe <code>0.8.5</code> ist eigentlich die
Abkürzung für <code>^0.8.5</code>, was für alle Versionen ab <code>0.8.5</code> und kleiner als
<code>0.9.0</code> steht.</p>
<p>Cargo geht davon aus, dass die öffentliche API dieser Versionen kompatibel zur
Version 0.8.5 ist und diese Angabe stellt sicher, dass du die neueste
Patch-Version erhältst, die noch mit dem Code in diesem Kapitel kompiliert
werden kann. Ab Version <code>0.9.0</code> ist nicht garantiert, dass die API mit der in
den folgenden Beispielen verwendeten übereinstimmt.</p>
<p>Lass uns nun, ohne den Code zu ändern, das Projekt bauen, wie in Codeblock 2-2
gezeigt.</p>
<pre><code class="language-console">$ cargo build
  Updating crates.io index
   Locking 15 packages to latest Rust 1.85.0 compatible versions
    Adding rand v0.8.5 (available: v0.9.0)
 Compiling proc-macro2 v1.0.93
 Compiling unicode-ident v1.0.17
 Compiling libc v0.2.170
 Compiling cfg-if v1.0.0
 Compiling byteorder v1.5.0
 Compiling getrandom v0.2.15
 Compiling rand_core v0.6.4
 Compiling quote v1.0.38
 Compiling syn v2.0.98
 Compiling zerocopy-derive v0.7.35
 Compiling zerocopy v0.7.35
 Compiling ppv-lite86 v0.2.20
 Compiling rand_chacha v0.3.1
 Compiling rand v0.8.5
 Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s
</code></pre>
<p><span class="caption">Codeblock 2-2: Die Ausgabe beim Ausführen von <code>cargo build</code> nach dem Hinzufügen der Kiste rand als Abhängigkeit</span></p>
<p>Möglicherweise siehst du unterschiedliche Versionsnummern (aber dank SemVer
sind sie alle mit dem Code kompatibel!) und unterschiedliche Zeilen (je nach
Betriebssystem), und die Zeilen können in einer anderen Reihenfolge erscheinen.</p>
<p>Wenn wir eine externe Abhängigkeit einfügen, holt Cargo die neuesten
Versionen von allem was die Abhängigkeit aus der <em>Registry</em> benötigt, was eine
Kopie der Daten von <a href="https://crates.io/">Crates.io</a> ist. Crates.io ist der Ort, an dem
die Menschen im Rust-Ökosystem ihre Open-Source-Rustprojekte für andere zur
Nutzung bereitstellen.</p>
<p>Nach dem Aktualisieren der Registry überprüft Cargo den Abschnitt
<code>[dependencies]</code> und lädt alle aufgelisteten Kisten herunter, die noch nicht
heruntergeladen wurden. Obwohl wir nur <code>rand</code> als Abhängigkeit aufgelistet
haben, hat sich Cargo in diesem Fall auch andere Kisten geschnappt, von denen
<code>rand</code> abhängig ist, um zu funktionieren. Nachdem die Kisten heruntergeladen
wurden, kompiliert Rust sie und kompiliert dann das Projekt mit den verfügbaren
Abhängigkeiten.</p>
<p>Wenn du gleich wieder <code>cargo build</code> ausführst, ohne irgendwelche Änderungen
vorzunehmen, erhältst du keine Ausgabe außer der Zeile <code>Finished</code>. Cargo weiß,
dass es die Abhängigkeiten bereits heruntergeladen und kompiliert hat, und du
hast in deiner Datei <em>Cargo.toml</em> nichts daran geändert. Cargo weiß auch, dass
du nichts an deinem Code geändert hast, also wird dieser auch nicht neu
kompiliert. Ohne etwas zu tun zu haben, wird es einfach beendet.</p>
<p>Wenn du die Datei <em>src/main.rs</em> öffnest, eine triviale Änderung vornimmst und
sie dann speicherst und neu baust, siehst du nur zwei Zeilen Ausgabe:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Diese Zeilen zeigen, dass Cargo nur den Build mit deiner winzigen Änderung an
der Datei <em>src/main.rs</em> aktualisiert. Deine Abhängigkeiten haben sich nicht
geändert, sodass Cargo weiß, dass es wiederverwenden kann, was es bereits
heruntergeladen und kompiliert hat.</p>
<h4 id="sicherstellen-reproduzierbarer-builds-mit-der-datei-cargolock"><a class="header" href="#sicherstellen-reproduzierbarer-builds-mit-der-datei-cargolock">Sicherstellen reproduzierbarer Builds mit der Datei <em>Cargo.lock</em></a></h4>
<p>Cargo verfügt über einen Mechanismus, der sicherstellt, dass du jedes Mal, wenn
du oder jemand anderes deinen Code baut, dasselbe Artefakt neu erstellen
kannst: Cargo wird nur die Versionen der von dir angegebenen Abhängigkeiten
verwenden, bis du etwas anderes angibst. Nehmen wir beispielsweise an, dass
nächste Woche Version 0.8.6 der Kiste <code>rand</code> herauskommt und eine wichtige
Fehlerkorrektur enthält, aber auch eine Regression, die deinen Code bricht. Um
dies zu handhaben, erstellt Rust die Datei <em>Cargo.lock</em> beim ersten Mal, wenn
du <code>cargo build</code> ausführst, die nun im <em>guessing_game</em>-Verzeichnis liegt.</p>
<p>Wenn du ein Projekt zum ersten Mal baust, ermittelt Cargo alle Versionen der
Abhängigkeiten, die den Kriterien entsprechen, und schreibt sie dann in die
Datei <em>Cargo.lock</em>. Wenn du dein Projekt in der Zukunft baust, wird Cargo
sehen, dass die Datei <em>Cargo.lock</em> existiert und die dort angegebenen Versionen
verwenden, anstatt die ganze Arbeit der Versionsfindung erneut zu machen. Auf
diese Weise erhältst du automatisch einen reproduzierbaren Build. Mit anderen
Worten, dein Projekt bleibt dank der Datei <em>Cargo.lock</em> auf 0.8.5, bis du
explizit die Versionsnummer erhöhst. Da die Datei <em>Cargo.lock</em> für das
reproduzierbare Bauen wichtig ist, wird sie oft zusammen mit dem restlichen
Code deines Projekts in die Versionskontrolle eingecheckt.</p>
<h4 id="aktualisieren-einer-kiste-um-eine-neue-version-zu-erhalten"><a class="header" href="#aktualisieren-einer-kiste-um-eine-neue-version-zu-erhalten">Aktualisieren einer Kiste, um eine neue Version zu erhalten</a></h4>
<p>Wenn du eine Kiste aktualisieren <em>willst</em>, bietet Cargo den Befehl <code>update</code> an,
der die Datei <em>Cargo.lock</em> ignoriert und alle neuesten Versionen, die deinen
Spezifikationen entsprechen, in <em>Cargo.toml</em> herausfindet. Cargo schreibt diese
Versionen dann in die Datei <em>Cargo.lock</em>. In diesem Fall wird Cargo nur nach
Versionen größer als 0.8.5 und kleiner als 0.9.0 suchen. Wenn die Kiste <code>rand</code>
zwei neue Versionen 0.8.6 und 0.9.0 veröffentlicht hat, würdest du folgendes
sehen, wenn du <code>cargo update</code> ausführst:</p>
<pre><code class="language-console">$ cargo update
    Updating crates.io index
     Locking 1 package to latest Rust 1.85.0 compatible version
    Updating rand v0.8.5 -&gt; v0.8.6 (available: v0.9.0)
</code></pre>
<p>Cargo ignoriert die Version 0.9.0. An diesem Punkt würdest du auch eine
Änderung in deiner Datei <em>Cargo.lock</em> bemerken, die feststellt, dass die
Version der Kiste <code>rand</code>, die du jetzt benutzt, 0.8.6 ist. Um die
<code>rand</code>-Version 0.9.0 oder irgendeine Version aus der 0.9.<em>x</em>-Serie zu
verwenden, müsstest du stattdessen die Datei <em>Cargo.toml</em> anpassen, damit sie
wie folgt aussieht:</p>
<pre><code class="language-toml">[dependencies]
rand = "0.9.0"
</code></pre>
<p>Wenn du das nächste Mal <code>cargo build</code> ausführst, wird Cargo die Registry der
verfügbaren Kisten aktualisieren und deine <code>rand</code>-Anforderungen entsprechend
der von dir angegebenen neuen Version neu bewerten.</p>
<p>Es gibt noch viel mehr über <a href="https://doc.rust-lang.org/cargo/">Cargo</a> und <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">seinem
Ökosystem</a> zu sagen, das wir in Kapitel 14 besprechen werden, aber
für den Moment ist das alles, was du wissen musst. Cargo macht es sehr einfach,
Bibliotheken wiederzuverwenden, sodass die Rust-Entwickler in der Lage sind,
kleinere Projekte zu schreiben, die aus einer Reihe von Paketen
zusammengestellt werden.</p>
<h3 id="generieren-einer-zufallszahl"><a class="header" href="#generieren-einer-zufallszahl">Generieren einer Zufallszahl</a></h3>
<p>Beginnen wir mit <code>rand</code>, um eine Zahl zum Raten zu erzeugen. Der nächste
Schritt ist <em>src/main.rs</em> zu ändern, wie in Codeblock 2-3 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!("Rate die Zahl!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("Die Geheimzahl ist: {secret_number}");

    println!("Bitte gib deine Schätzung ein.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Fehler beim Lesen der Zeile");

    println!("Du hast geschätzt: {guess}");
}</code></pre>
<p><span class="caption">Codeblock 2-3: Hinzufügen von Code zum Generieren einer
Zufallszahl</span></p>
<p>Zuerst fügen wir die Zeile <code>use rand::Rng;</code> hinzu. Das Merkmal (trait)
<code>Rng</code> definiert Methoden, die Zufallszahlengeneratoren implementieren, und
dieses Merkmal muss im Gültigkeitsbereich sein, damit wir diese Methoden
verwenden können. In Kapitel 10 werden Merkmale im Detail behandelt.</p>
<p>Als nächstes fügen wir zwei Zeilen in der Mitte hinzu. In der ersten Zeile
rufen wir die Funktion <code>rand::thread_rng</code> auf, die uns den speziellen
Zufallszahlengenerator zurückgibt, den wir verwenden werden: Einen, der lokal
zum aktuellen Ausführungsstrang (thread) ist und vom Betriebssystem
initialisiert (seeded) wird. Dann rufen wir die Methode <code>gen_range</code> des
Zufallszahlengenerators auf. Diese Methode wird durch das Merkmal <code>Rng</code>
definiert, das wir mit der Anweisung <code>use rand::Rng;</code> in den Gültigkeitsbereich
gebracht haben. Die Methode <code>gen_range</code> nimmt einen Bereichsausdruck als
Argument und generiert eine Zufallszahl in diesem Bereich. Ein Bereichsausdruck
hat die Form <code>start..=end</code> und er beinhaltet die Untergrenze und die
Obergrenze, sodass wir <code>1..=100</code> angeben müssen, um eine Zahl zwischen 1 und 100
zu erhalten.</p>
<blockquote>
<p>Hinweis: Du wirst nicht immer wissen, welche Merkmale du verwenden sollst und
welche Methoden und Funktionen einer Kiste du aufrufen musst, daher hat jede
Kiste eine Dokumentation mit einer Anleitungen zur Verwendung der Kiste.
Eine weitere nette Funktionalität von Cargo ist, dass das Ausführen des
Kommandos <code>cargo doc --open</code> die von all deinen Abhängigkeiten
bereitgestellte Dokumentation lokal zusammenstellt und in deinem Browser
öffnet. Wenn du an anderen Funktionen der Kiste <code>rand</code> interessiert bist,
führe zum Beispiel <code>cargo doc --open</code> aus und klicke auf <code>rand</code> in der
Seitenleiste links.</p>
</blockquote>
<p>Die zweite neue Zeile gibt die Geheimzahl aus. Das ist hilfreich während wir
das Programm entwickeln, um es testen zu können, aber wir werden es aus der
finalen Version entfernen. Es ist kein echtes Spiel, wenn das Programm die
Antwort ausgibt, sobald es startet!</p>
<p>Versuche, das Programm einige Male auszuführen:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 7
Bitte gib deine Schätzung ein.
4
Du hast geschätzt: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 83
Bitte gib deine Schätzung ein.
5
Du hast geschätzt: 5
</code></pre>
<p>Du solltest verschiedene Zufallszahlen erhalten und sie sollten alle zwischen 1
und 100 sein. Großartige Arbeit!</p>
<h2 id="vergleichen-der-schätzung-mit-der-geheimzahl"><a class="header" href="#vergleichen-der-schätzung-mit-der-geheimzahl">Vergleichen der Schätzung mit der Geheimzahl</a></h2>
<p>Jetzt, da wir eine Benutzereingabe und eine Zufallszahl haben, können wir sie
vergleichen. Dieser Schritt ist in Codeblock 2-4 dargestellt. Beachte, dass
sich dieser Code noch nicht ganz kompilieren lässt, wie wir erklären werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --abschneiden--
<span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Die Geheimzahl ist: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Bitte gib deine Schätzung ein.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Fehler beim Lesen der Zeile");
</span>
    println!("Du hast geschätzt: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Zu klein!"),
        Ordering::Greater =&gt; println!("Zu groß!"),
        Ordering::Equal =&gt; println!("Du hast gewonnen!"),
    }
}</code></pre>
<p><span class="caption">Codeblock 2-4: Behandeln der möglichen Rückgabewerte beim
Vergleich zweier Zahlen</span></p>
<p>Zuerst fügen wir eine weitere <code>use</code>-Anweisung hinzu, die einen Typ namens
<code>std::cmp::Ordering</code> aus der Standardbibliothek in den Gültigkeitsbereich
bringt. Der Typ <code>Ordering</code> ist eine weitere Aufzählung und hat die Varianten
<code>Less</code>, <code>Greater</code> und <code>Equal</code>. Dies sind die drei Ergebnisse, die möglich sind,
wenn man zwei Werte vergleicht.</p>
<p>Dann fügen wir unten fünf neue Zeilen hinzu, die den Typ <code>Ordering</code> verwenden.
Die Methode <code>cmp</code> vergleicht zwei Werte und kann auf alles, was verglichen
werden kann, angewendet werden. Sie braucht eine Referenz auf das, was du
vergleichen willst: Hier wird <code>guess</code> mit <code>secret_number</code> verglichen. Dann gibt
sie eine Variante der <code>Ordering</code>-Aufzählung zurück, die wir mit der
<code>use</code>-Anweisung in den Gültigkeitsbereich gebracht haben. Wir verwenden einen
<a href="ch06-02-match.html"><code>match</code></a>-Ausdruck, um zu entscheiden, was als nächstes zu tun ist,
basierend darauf, welche <code>Ordering</code>-Variante vom Aufruf von <code>cmp</code> mit den
Werten in <code>guess</code> und <code>secret_number</code> zurückgegeben wurde.</p>
<p>Ein <code>match</code>-Ausdruck besteht aus <em>Zweigen</em> (arms). Ein Zweig besteht aus einem
<em>Muster</em> (pattern) und dem Code, der ausgeführt werden soll, wenn der Wert, der
am Anfang des <code>match</code>-Ausdrucks steht, zum Muster dieses Zweigs passt. Rust
nimmt den Wert, der bei <code>match</code> angegeben wurde, und schaut nacheinander durch
das Muster jedes Zweigs. Das <code>match</code>-Konstrukt und die Muster sind mächtige
Funktionalitäten in Rust, mit denen du eine Vielzahl von Situationen ausdrücken
kannst, auf die dein Code stoßen könnte, und die sicherstellen, dass du sie
alle behandelst. Diese Funktionalitäten werden ausführlich in Kapitel 6 bzw.
Kapitel 18 behandelt.</p>
<p>Gehen wir ein Beispiel dafür durch, was mit dem hier verwendeten
<code>match</code>-Ausdruck geschehen würde. Angenommen, der Benutzer hat 50 geschätzt und
die zufällig generierte Geheimzahl ist diesmal 38.</p>
<p>Wenn der Code 50 mit 38 vergleicht, gibt die Methode <code>cmp</code> <code>Ordering::Greater</code>
zurück, weil 50 größer als 38 ist. Der <code>match</code>-Ausdruck erhält den Wert
<code>Ordering::Greater</code> und beginnt mit der Überprüfung des Musters jedes Zweigs.
Er schaut auf das Muster <code>Ordering::Less</code> des ersten Zweigs und sieht, dass der
Wert <code>Ordering::Greater</code> nicht mit <code>Ordering::Less</code> übereinstimmt, also
ignoriert er den Code in diesem Zweig und geht zum nächsten Zweig über. Das
Muster <code>Ordering::Greater</code> des nächsten Zweigs <em>passt</em> zu <code>Ordering::Greater</code>!
Der dazugehörige Code in diesem Zweig wird ausgeführt und <code>Zu groß!</code> auf den
Bildschirm ausgegeben. Der <code>match</code>-Ausdruck endet nach der ersten erfolgreichen
Übereinstimmung, sodass der letzte Zweig in diesem Szenario nicht
berücksichtigt wird.</p>
<p>Der Code in Codeblock 2-4 lässt sich jedoch noch nicht kompilieren. Lass es uns
versuchen:</p>
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: method defined here
  --&gt; /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/core/src/cmp.rs:814:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>Die Kernbotschaft des Fehlers besagt, dass es <em>nicht übereinstimmende Typen</em>
(mismatched types) gibt. Rust hat ein starkes, statisches Typsystem. Es hat jedoch
auch eine Typ-Inferenz. Als wir <code>let mut guess = String::new()</code> schrieben, konnte
Rust daraus schließen, dass <code>guess</code> ein <code>String</code> sein sollte, und zwang uns
nicht, den Typ anzugeben. Die <code>secret_number</code> hingegen ist ein Zahlentyp.
Einige Zahlentypen können einen Wert zwischen 1 und 100 haben: <code>i32</code>, eine
32-Bit-Zahl; <code>u32</code>, eine 32-Bit-Zahl ohne Vorzeichen; <code>i64</code>, eine 64-Bit-Zahl;
sowie andere. Solange nicht anders angegeben, verwendet Rust standardmäßig
<code>i32</code>, was der Typ von <code>secret_number</code> ist, es sei denn, du fügst an anderer
Stelle Typinformationen hinzu, die Rust veranlassen würden, auf einen anderen
numerischen Typ zu schließen. Der Grund für den Fehler liegt darin, dass Rust
eine Zeichenkette und einen Zahlentyp nicht vergleichen kann.</p>
<p>Letztendlich wollen wir den <code>String</code>, den das Programm als Eingabe liest, in
einen Zahlentyp umwandeln, damit wir ihn numerisch mit der Geheimzahl
vergleichen können. Das tun wir, indem wir folgendes zum <code>main</code>-Funktionsrumpf
hinzufügen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Die Geheimzahl ist: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Bitte gib deine Schätzung ein.");
</span><span class="boring">
</span>    // --abschneiden--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Fehler beim Lesen der Zeile");

    let guess: u32 = guess.trim().parse().expect("Bitte gib eine Zahl ein!");

    println!("Du hast geschätzt: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Zu klein!"),
        Ordering::Greater =&gt; println!("Zu groß!"),
        Ordering::Equal =&gt; println!("Du hast gewonnen!"),
    }
}</code></pre>
<p>Die Zeile lautet:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("Bitte gib eine Zahl ein!");</code></pre>
<p>Wir erstellen eine Variable mit dem Namen <code>guess</code>. Aber warte, hat das Programm
nicht bereits eine Variable namens <code>guess</code>? Ja, aber Rust erlaubt uns, den
vorherigen Wert von <code>guess</code> mit einem neuen Wert zu verschatten (shadow). Durch
das <em>Verschatten</em> können wir den Variablennamen <code>guess</code> wiederverwenden, anstatt
uns zu zwingen, zwei eindeutige Variablen zu erstellen, z.B. <code>guess_str</code> und
<code>guess</code>. Wir werden dies in <a href="ch03-01-variables-and-mutability.html#verschatten-shadowing">Kapitel 3</a> ausführlicher behandeln,
aber für den Moment solltst du wissen, dass diese Funktionalität oft verwendet
wird, wenn du einen Wert von einem Typ in einen anderen Typ konvertieren
willst.</p>
<p>Wir binden <code>guess</code> an den Ausdruck <code>guess.trim().parse()</code>. Das <code>guess</code> im
Ausdruck bezieht sich auf das ursprüngliche <code>guess</code>, das ein <code>String</code> mit der
Eingabe darin war. Die Methode <code>trim</code> der <code>String</code>-Instanz wird alle
Leerzeichen am Anfang und am Ende entfernen. Obwohl <code>u32</code> nur numerische
Zeichen enthalten kann, muss der Benutzer die <span
class="keystroke">Eingabetaste</span> drücken, um <code>read_line</code>
zufriedenzustellen. Wenn der Benutzer die <span
class="keystroke">Eingabetaste</span> drückt, wird der Zeichenkette ein
Zeilenumbruchszeichen (newline character) hinzugefügt. Wenn der Benutzer z.B.
<span class="keystroke">5</span> eingibt und die <span
class="keystroke">Eingabetaste</span> drückt, sieht <code>guess</code> wie folgt aus:
<code>5\n</code>. Das <code>\n</code> steht für „Zeilenumbruch“ (newline), das Ergebnis des Drückens
der <span class="keystroke">Eingabetaste</span>. (Unter Windows ergibt das
Drücken der <span class="keystroke">Eingabetaste</span> einen Wagenrücklauf
(carriage return) und einen Zeilenumbruch (newline): <code>\r\n</code>) Die Methode <code>trim</code>
entfernt <code>\n</code> und <code>\r\n</code>, was nur <code>5</code> ergibt.</p>
<p>Die <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">Methode <code>parse</code> für Zeichenketten</a> konvertiert eine Zeichenkette in
einen anderen Typ. Hier verwenden wir sie, um eine Zeichenkette in eine Zahl
umzuwandeln. Wir müssen Rust den genauen Zahlentyp mitteilen, den wir wollen,
indem wir <code>let guess: u32</code> verwenden. Der Doppelpunkt (<code>:</code>) nach <code>guess</code> sagt
Rust, dass wir den Typ der Variablen annotieren werden. Rust hat ein paar
eingebaute Zahlentypen; <code>u32</code>, das du hier siehst, ist eine vorzeichenlose
32-Bit-Ganzzahl. Es ist eine gute Standardwahl für eine kleine positive Zahl.
Über andere Zahlentypen erfährst du in <a href="ch03-02-data-types.html#ganzzahl-typen">Kapitel 3</a>.</p>
<p>Zusätzlich bedeuten die Annotation <code>u32</code> in diesem Beispielprogramm und der
Vergleich mit <code>secret_number</code>, dass Rust daraus ableiten wird, dass
<code>secret_number</code> ebenfalls ein <code>u32</code> sein sollte. Nun wird also der Vergleich
zwischen zwei Werten desselben Typs durchgeführt!</p>
<p>Die Methode <code>parse</code> funktioniert nur bei Zeichen, die logisch in Zahlen
umgewandelt werden können und kann daher leicht Fehler verursachen. Wenn die
Zeichenkette zum Beispiel <code>A👍%</code> enthielte, gäbe es keine Möglichkeit, dies in
eine Zahl umzuwandeln. Da dies fehlschlagen könnte, gibt die Methode <code>parse</code>
einen <code>Result</code>-Typ zurück, ähnlich wie die Methode <code>read_line</code> (weiter oben in
<a href="ch02-00-guessing-game-tutorial.html#behandeln-potentieller-fehler-mit-result">„Behandeln potentieller Fehler mit
<code>Result</code>“</a>). Wir werden dieses
<code>Result</code> auf die gleiche Weise behandeln, indem wir erneut <code>expect</code> verwenden.
Wenn <code>parse</code> eine <code>Err</code>-Variante von <code>Result</code> zurückgibt, weil es keine Zahl
aus der Zeichenkette erzeugen konnte, wird der <code>expect</code>-Aufruf das Spiel zum
Absturz bringen und die Nachricht ausgeben, die wir ihm geben. Wenn <code>parse</code> die
Zeichenkette erfolgreich in eine Zahl umwandeln kann, gibt es die <code>Ok</code>-Variante
von <code>Result</code> zurück, und <code>expect</code> gibt die Zahl zurück, die wir vom <code>Ok</code>-Wert
erwarten.</p>
<p>Lassen wir das Programm jetzt laufen:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 58
Bitte gib deine Schätzung ein.
  76
Du hast geschätzt: 76
Zu groß!
</code></pre>
<p>Schön! Auch wenn vor der Schätzung Leerzeichen eingegeben wurden, fand das
Programm dennoch heraus, dass der Benutzer 76 geschätzt hat. Führe das Programm
einige Male aus, um das unterschiedliche Verhalten bei verschiedenen
Eingabearten zu überprüfen: Schätze die Zahl richtig, schätze eine zu große Zahl
und schätze eine zu kleine Zahl.</p>
<p>Der Großteil des Spiels funktioniert jetzt, aber der Benutzer kann nur <em>eine</em>
Schätzung anstellen. Ändern wir das, indem wir eine Schleife hinzufügen!</p>
<h2 id="zulassen-mehrerer-schätzungen-mittels-schleife"><a class="header" href="#zulassen-mehrerer-schätzungen-mittels-schleife">Zulassen mehrerer Schätzungen mittels Schleife</a></h2>
<p>Das Schlüsselwort <code>loop</code> erzeugt eine Endlosschleife. Wir fügen jetzt eine
Schleife hinzu, um den Benutzern mehr Chancen zu geben, die Zahl zu erraten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --abschneiden--

    println!("Die Geheimzahl ist: {secret_number}");

    loop {
        println!("Bitte gib deine Schätzung ein.");

        // --abschneiden--

<span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Fehler beim Lesen der Zeile");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Bitte gib eine Zahl ein!");
</span><span class="boring">
</span><span class="boring">        println!("Du hast geschätzt: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Zu klein!"),
            Ordering::Greater =&gt; println!("Zu groß!"),
            Ordering::Equal =&gt; println!("Du hast gewonnen!"),
        }
    }
}</code></pre>
<p>Wie du sehen kannst, haben wir alles ab der Eingabeaufforderung für die
Schätzung in eine Schleife verschoben. Achte darauf, die Zeilen innerhalb der
Schleife jeweils um weitere vier Leerzeichen einzurücken und das Programm
erneut auszuführen. Beachte, dass es ein neues Problem gibt, weil das Programm
genau das tut, was wir ihm gesagt haben: Frage für immer nach einer weiteren
Schätzung! Es sieht nicht so aus, als könne der Benutzer das Programm beenden!</p>
<p>Der Benutzer könnte das Programm jederzeit mit dem Tastaturkürzel
<kbd>Strg</kbd>+<kbd>c</kbd> unterbrechen. Aber es gibt noch eine andere
Möglichkeit, diesem unersättlichen Monster zu entkommen, wie in der
<code>parse</code>-Diskussion in <a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">„Vergleichen der Schätzung mit der
Geheimzahl“</a> erwähnt: Wenn der
Benutzer eine Antwort ohne Zahl eingibt, stürzt das Programm ab. Wir können das
ausnutzen, um dem Benutzer zu erlauben das Programm zu beenden, wie hier
gezeigt:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 59
Bitte gib deine Schätzung ein.
45
Du hast geschätzt: 45
Zu klein!
Bitte gib deine Schätzung ein.
60
Du hast geschätzt: 60
Zu groß!
Bitte gib deine Schätzung ein.
59
Du hast geschätzt: 59
Du hast gewonnen!
Bitte gib deine Schätzung ein.
quit

thread 'main' panicked at src/main.rs:28:47:
Please type a number!: ParseIntError { kind: InvalidDigit }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Mit der Eingabe von <code>quit</code> wird das Spiel beendet, aber das gilt
auch für alle anderen Eingaben, die keine Zahlen sind. Dies ist jedoch, gelinde
gesagt, suboptimal. Wir wollen, dass das Spiel automatisch beendet wird, wenn
die richtige Zahl erraten wird.</p>
<h3 id="beenden-nach-einer-korrekten-schätzung"><a class="header" href="#beenden-nach-einer-korrekten-schätzung">Beenden nach einer korrekten Schätzung</a></h3>
<p>Programmieren wir das Spiel so, dass es beendet wird, wenn der Benutzer
gewinnt, indem wir eine <code>break</code>-Anweisung hinzufügen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Die Geheimzahl ist: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Bitte gib deine Schätzung ein.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Fehler beim Lesen der Zeile");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Bitte gib eine Zahl ein!");
</span><span class="boring">
</span><span class="boring">        println!("Du hast geschätzt: {guess}");
</span><span class="boring">
</span>        // --abschneiden--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Zu klein!"),
            Ordering::Greater =&gt; println!("Zu groß!"),
            Ordering::Equal =&gt; {
                println!("Du hast gewonnen!");
                break;
            }
        }
    }
}</code></pre>
<p>Das Hinzufügen der <code>break</code>-Zeile nach <code>Du hast gewonnen!</code> bewirkt, dass das
Programm die Schleife verlässt, wenn der Benutzer die Geheimzahl richtig errät.
Die Schleife zu verlassen bedeutet auch, das Programm zu beenden, da die
Schleife der letzte Teil von <code>main</code> ist.</p>
<h3 id="behandeln-ungültiger-eingaben"><a class="header" href="#behandeln-ungültiger-eingaben">Behandeln ungültiger Eingaben</a></h3>
<p>Um das Verhalten des Spiels weiter zu verfeinern, sollten wir das Programm
nicht abstürzen lassen, wenn der Benutzer keine gültige Zahl eingibt, sondern
dafür sorgen, dass das Spiel ungültige Zahlen ignoriert, damit der Benutzer
weiter raten kann. Das können wir erreichen, indem wir die Zeile ändern, in der
<code>guess</code> von <code>String</code> in <code>u32</code> umgewandelt wird, wie in Codeblock 2-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Die Geheimzahl ist: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Bitte gib deine Schätzung ein.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --abschneiden--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Fehler beim Lesen der Zeile");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("Du hast geschätzt: {guess}");

        // --abschneiden--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Zu klein!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Zu groß!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("Du hast gewonnen!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 2-5: Ignorieren einer ungültigen Zahl und
Auffordern zu einer weiteren Schätzung, anstatt das Programm zum Absturz zu
bringen</span></p>
<p>Das Umstellen von einem <code>expect</code>-Aufruf zu einem <code>match</code>-Ausdruck ist eine
Möglichkeit für den Übergang vom Absturz bei einem Fehler zur Behandlung des
Fehlers. Denke daran, dass <code>parse</code> einen <code>Result</code>-Typ zurückgibt und <code>Result</code>
eine Aufzählung ist, die die Varianten <code>Ok</code> und <code>Err</code> hat. Wir benutzen hier
einen <code>match</code>-Ausdruck, wie wir es mit dem <code>Ordering</code>-Ergebnis der Methode
<code>cmp</code> getan haben.</p>
<p>Wenn <code>parse</code> in der Lage ist, die Zeichenkette erfolgreich in eine Zahl
umzuwandeln, gibt es einen <code>Ok</code>-Wert zurück, der die resultierende Zahl
enthält. Dieser <code>Ok</code>-Wert wird mit dem Muster des ersten Zweigs übereinstimmen
und der <code>match</code>-Ausdruck wird nur den <code>num</code>-Wert zurückgeben, der durch <code>parse</code>
erzeugt und in den <code>Ok</code>-Wert eingefügt wurde. Diese Zahl wird in der neuen
<code>guess</code>-Variable, die wir erzeugen, genau dort landen, wo wir sie haben wollen.</p>
<p>Wenn <code>parse</code> <em>nicht</em> in der Lage ist, die Zeichenkette in eine Zahl
umzuwandeln, gibt es einen <code>Err</code>-Wert zurück, der mehr Informationen über den
Fehler enthält. Der <code>Err</code>-Wert stimmt nicht mit dem <code>Ok(num)</code>-Muster im ersten
<code>match</code>-Zweig überein, aber er stimmt mit dem <code>Err(_)</code>-Muster im zweiten Zweig
überein. Der Unterstrich <code>_</code> ist ein Auffangwert; in diesem Beispiel sagen
wir, dass alle <code>Err</code>-Werte übereinstimmen sollen, egal welche Informationen sie
enthalten. Das Programm wird also den Code <code>continue</code> des zweiten Zweigs
ausführen, der das Programm anweist, zur nächsten <code>loop</code>-Iteration zu gehen und
nach einer weiteren Schätzung zu fragen. Effektiv ignoriert das Programm also
alle Fehler, die bei <code>parse</code> auftreten könnten!</p>
<p>Jetzt sollte alles im Programm wie erwartet funktionieren. Lass es uns
versuchen:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 61
Bitte gib deine Schätzung ein.
10
Du hast geschätzt: 10
Zu klein!
Bitte gib deine Schätzung ein.
99
Du hast geschätzt: 99
Zu groß!
Bitte gib deine Schätzung ein.
foo
Bitte gib deine Schätzung ein.
61
Du hast geschätzt: 61
Du hast gewonnen!
</code></pre>
<p>Fantastisch! Mit einem winzigen letzten Feinschliff beenden wir das Ratespiel.
Denke daran, dass das Programm immer noch die Geheimzahl ausgibt. Das hat beim
Testen gut funktioniert, aber es ruiniert das Spiel. Löschen wir das
<code>println!</code>, das die Geheimzahl ausgibt. Codeblock 2-6 zeigt den finalen Code.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Rate die Zahl!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Bitte gib deine Schätzung ein.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Fehler beim Lesen der Zeile");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("Du hast geschätzt: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Zu klein!"),
            Ordering::Greater =&gt; println!("Zu groß!"),
            Ordering::Equal =&gt; {
                println!("Du hast gewonnen!");
                break;
            }
        }
    }
}</code></pre>
<p><span class="caption">Codeblock 2-6: Vollständiger Code des
Ratespiels</span></p>
<p>An diesem Punkt hast du das Ratespiel erfolgreich aufgebaut. Herzlichen
Glückwunsch!</p>
<h2 id="zusammenfassung-1"><a class="header" href="#zusammenfassung-1">Zusammenfassung</a></h2>
<p>Dieses Projekt war eine praktische Möglichkeit, dich mit vielen neuen
Rust-Konzepten vertraut zu machen: <code>let</code>, <code>match</code>, Funktionen, das Verwenden
von externen Kisten und mehr. In den nächsten Kapiteln erfährst du mehr über
diese Konzepte. Kapitel 3 behandelt Konzepte, über die die meisten
Programmiersprachen verfügen, z.B. Variablen, Datentypen und Funktionen, und
zeigt, wie man sie in Rust verwendet. Kapitel 4 untersucht die
Eigentümerschaft, eine Funktionalität, die Rust von anderen Sprachen
unterscheidet. In Kapitel 5 werden Strukturen (structs) und die Methodensyntax
besprochen und in Kapitel 6 wird die Funktionsweise von Aufzählungen erläutert.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allgemeine-programmierkonzepte"><a class="header" href="#allgemeine-programmierkonzepte">Allgemeine Programmierkonzepte</a></h1>
<p>Dieses Kapitel behandelt Konzepte, die in fast jeder Programmiersprache
vorkommen, und wie sie in Rust funktionieren. Viele Programmiersprachen haben
in ihrem Kern viel gemeinsam. Keines der in diesem Kapitel vorgestellten
Konzepte ist einzigartig für Rust, aber wir werden sie im Kontext von Rust
besprechen und die Konventionen beim Verwenden dieser Konzepte erklären.</p>
<p>Insbesondere lernst du etwas über Variablen, Basistypen (basic types),
Funktionen, Kommentare und Kontrollfluss (control flow). Diese Grundlagen
werden in jedem Rust-Programm vorhanden sein, und wenn du sie früh lernst,
erhältst du eine starke Basis, auf der du aufbauen kannst.</p>
<blockquote>
<h4 id="schlüsselwörter"><a class="header" href="#schlüsselwörter">Schlüsselwörter</a></h4>
<p>Die Sprache Rust hat eine Reihe von <em>Schlüsselwörtern</em> (keywords), die wie in
anderen Sprachen nur der Sprache selbst vorbehalten sind. Denke daran, dass
du diese Wörter nicht als Namen von Variablen oder Funktionen verwenden
kannst. Die meisten der Schlüsselwörter haben spezielle Bedeutungen und du
wirst sie für verschiedene Aufgaben in deinen Rust-Programmen verwenden;
einige wenige haben aktuell noch keine Funktionalität, die mit ihnen
verbunden ist, sondern wurden für Funktionalität reserviert, die in Zukunft
zu Rust hinzugefügt werden könnte. Eine Liste der Schlüsselwörter findest du
in <a href="appendix-01-keywords.html">Anhang A</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="variablen-und-veränderbarkeit"><a class="header" href="#variablen-und-veränderbarkeit">Variablen und Veränderbarkeit</a></h2>
<p>Wie im Abschnitt <a href="ch02-00-guessing-game-tutorial.html#speichern-von-werten-mit-variablen">„Speichern von Werten mit
Variablen“</a> erwähnt, sind Variablen
standardmäßig unveränderbar. Dies ist einer der vielen Stupser, die Rust dir
gibt, um deinen Code so zu schreiben, dass du die Vorteile von Sicherheit
(safety) und einfacher Nebenläufigkeit (easy concurrency) nutzt, die Rust
bietet. Du hast jedoch immer noch die Möglichkeit, deine Variablen veränderbar
(mutable) zu machen. Lass uns untersuchen, wie und warum Rust dich dazu
ermutigt, die Unveränderbarkeit (immutability) zu bevorzugen, und warum du
manchmal vielleicht davon abweichen möchtest.</p>
<p>Wenn eine Variable unveränderbar ist, kannst du deren Wert nicht mehr ändern,
sobald ein Wert gebunden ist. Um dies zu veranschaulichen, lege ein neues
Projekt namens <em>variables</em> in deinem <em>projects</em>-Verzeichnis an, indem du
<code>cargo new variables</code> aufrufst.</p>
<p>Öffne dann in deinem neuen Verzeichnis <em>variables</em> die Datei <em>src/main.rs</em> und
ersetze dessen Code durch folgenden Code, der sich sich noch nicht kompilieren
lässt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let x = 5;
    println!("Der Wert von x ist: {x}");
    x = 6;
    println!("Der Wert von x ist: {x}");
}</code></pre></pre>
<p>Speichere und starte das Programm mit <code>cargo run</code>. Du solltest eine
Fehlermeldung über einen Unveränderbarkeitsfehler erhalten, wie in dieser
Ausgabe gezeigt:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("Der Wert von x ist: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>Dieses Beispiel zeigt, wie der Compiler dir hilft, Fehler in deinen Programmen
zu finden. Kompilierfehler können frustrierend sein, aber eigentlich bedeuten
sie nur, dass dein Programm noch nicht sicher das tut, was du willst; sie
bedeuten <em>nicht</em>, dass du kein guter Programmierer bist! Erfahrene
Rust-Entwickler bekommen ebenfalls noch Kompilierfehler.</p>
<p>Du hast die Fehlermeldung <code>cannot assign twice to immutable variable x</code>
erhalten, weil du versucht hast, der unveränderbaren Variablen <code>x</code> einen
zweiten Wert zuzuweisen.</p>
<p>Es ist wichtig, dass wir Kompilierzeitfehler erhalten, wenn wir versuchen,
einen Wert zu ändern, der als unveränderbar gekennzeichnet ist, denn genau
diese Situation kann zu Fehlern führen. Wenn ein Teil unseres Codes von der
Annahme ausgeht, dass sich ein Wert niemals ändern wird, und ein anderer Teil
unseres Codes diesen Wert ändert, ist es möglich, dass der erste Teil des Codes
nicht das tut, wozu er entwickelt wurde. Die Ursache für diese Art von Fehler
kann im Nachhinein schwer aufzuspüren sein, besonders wenn das zweite Stück
Code den Wert nur <em>gelegentlich</em> ändert. In Rust garantiert der Compiler, dass
sich ein Wert tatsächlich nicht ändert, wenn du angibst, dass er sich nicht
ändern darf, du musst also nicht selbst darauf achten. Dein Code ist somit
leichter zu durchschauen.</p>
<p>Veränderbarkeit kann jedoch sehr nützlich sein und das Erstellen von Code
erleichtern. Obwohl Variablen standardmäßig unveränderbar sind, kannst du sie
veränderbar machen, indem du vor den Variablennamen <code>mut</code> angibst, wie du es
in <a href="ch02-00-guessing-game-tutorial.html#speichern-von-werten-mit-variablen">Kapitel 2</a> getan hast. Das Hinzufügen von
<code>mut</code> vermittelt den zukünftigen Lesern des Codes die Absicht, dass andere
Teile des Codes den Wert dieser Variablen ändern werden.</p>
<p>Lass uns zum Beispiel <em>src/main.rs</em> wie folgt ändern:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut x = 5;
    println!("Der Wert von x ist: {x}");
    x = 6;
    println!("Der Wert von x ist: {x}");
}</code></pre></pre>
<p>Wenn wir das Programm jetzt ausführen, bekommen wir dies:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
Der Wert von x ist: 5
Der Wert von x ist: 6
</code></pre>
<p>Wir dürfen den Wert, an den sich <code>x</code> bindet, von <code>5</code> auf <code>6</code> ändern, wenn <code>mut</code>
verwendet wird. Letztendlich ist es deine Entscheidung, ob du Veränderbarkeit
einsetzen willst oder nicht, und es hängt davon ab, was du in der jeweiligen
Situation für am sinnvollsten hältst.</p>
<h3 id="konstanten"><a class="header" href="#konstanten">Konstanten</a></h3>
<p>Wie unveränderbare Variablen sind <em>Konstanten</em> Werte, die an einen Namen
gebunden sind und sich nicht ändern dürfen, aber es gibt einige Unterschiede
zwischen Konstanten und Variablen.</p>
<p>Erstens ist es dir nicht erlaubt, <code>mut</code> mit Konstanten zu verwenden. Konstanten
sind nicht nur von vornherein unveränderbar – sie sind immer
unveränderbar. Du deklarierst Konstanten mit dem Schlüsselwort <code>const</code>
anstelle des Schlüsselworts <code>let</code> und der Typ des Wertes <em>muss</em> annotiert
werden. Wir sind dabei, Typen und Typ-Annotationen im nächsten Abschnitt
<a href="ch03-02-data-types.html">„Datentypen“</a> zu behandeln, also mach dir jetzt keine Gedanken
über die Details. Du musst nur wissen, dass du den Typ immer annotieren musst.</p>
<p>Konstanten können in jedem Gültigkeitsbereich deklariert werden, auch im
globalen Gültigkeitsbereich, was sie für Werte nützlich macht, über die viele
Teile des Codes Bescheid wissen müssen.</p>
<p>Der letzte Unterschied besteht darin, dass Konstanten nur auf einen konstanten
Ausdruck gesetzt werden dürfen, nicht auf einen Wert, der nur zur Laufzeit
berechnet werden könnte.</p>
<p>Hier ist ein Beispiel für eine Konstantendeklaration:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>Der Name der Konstante lautet <code>THREE_HOURS_IN_SECONDS</code> und ihr Wert wird auf
das Ergebnis der Multiplikation von 60 (die Anzahl der Sekunden in einer
Minute) mal 60 (die Anzahl der Minuten in einer Stunde) mal 3 (die Anzahl der
Stunden, die wir in diesem Programm zählen wollen). Die Namenskonvention von
Rust für Konstanten ist die Verwendung von Großbuchstaben mit Unterstrichen
zwischen den Wörtern. Der Compiler ist in der Lage, eine begrenzte Anzahl von
Operationen zur Kompilierzeit auszuwerten, was uns die Möglichkeit gibt, diesen
Wert so zu schreiben, dass er leichter zu verstehen und zu überprüfen ist, als
wenn diese Konstante auf den Wert 10.800 gesetzt wäre. Siehe die
<a href="https://doc.rust-lang.org/reference/const_eval.html">Rust-Referenz, Abschnitt über die Auswertung von Konstanten</a> für
weitere Informationen darüber, welche Operationen bei der Deklaration von
Konstanten verwendet werden können.</p>
<p>Konstanten sind für die gesamte Laufzeit eines Programms in dem
Gültigkeitsbereich gültig, in dem sie deklariert wurden. Damit sind sie eine
nützliche Wahl für Werte in deiner Anwendungsdomäne, über die mehrere Teile des
Programms Bescheid wissen müssen, z.B. die maximale Punktzahl, die jeder
Spieler eines Spiels erhalten darf, oder die Lichtgeschwindigkeit.</p>
<p>Hartkodierte Werte, die im gesamten Programm als Konstanten verwendet werden,
sollten benannt werden, damit zukünftigen Entwicklern die Bedeutung dieses
Wertes vermittelt wird. Zudem ist es hilfreich, nur eine Codestelle ändern zu
müssen, sollte der hartkodierte Wert irgendwann zu ändern sein.</p>
<h3 id="verschatten-shadowing"><a class="header" href="#verschatten-shadowing">Verschatten (shadowing)</a></h3>
<p>Wie du in der Anleitung zum Ratespiel in <a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">Kapitel
2</a> gesehen hast, kannst du eine neue
Variable mit dem gleichen Namen wie eine vorherige Variable deklarieren. Die
Rust-Entwickler sagen, dass die erste Variable von der zweiten <em>verschattet</em>
(shadowed) wird, was bedeutet, dass die zweite Variable das ist, was der
Compiler sieht, wenn du den Namen der Variable verwendest. Die zweite Variable
verschattet die erste und nimmt alle Verwendungen des Variablennamens auf sich,
bis sie entweder selbst verschattet wird oder der Gültigkeitsbereich endet. Wir
können eine Variable verschatten, indem wir denselben Variablenamen verwenden
und das Schlüsselwort <code>let</code> wie folgt wiederholen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("Der Wert von x im inneren Gültigkeitsbereich ist: {x}");
    }

    println!("Der Wert von x ist: {x}");
}</code></pre></pre>
<p>Dieses Programm bindet zunächst <code>x</code> an den Wert <code>5</code>. Dann wird eine neue
Variable <code>x</code> erzeugt, indem <code>let x =</code> wiederholt wird, wobei der ursprüngliche
Wert genommen und <code>1</code> hinzugefügt wird, sodass der Wert von <code>x</code> dann <code>6</code> ist.
Innerhalb eines inneren Gültigkeitsbereichs, der durch die geschweiften
Klammern geschaffen wird, verschattet die dritte <code>let</code>-Anweisung dann ebenfalls
<code>x</code> und erzeugt eine neue Variable, wobei der vorherige Wert mit <code>2</code>
multipliziert wird, um <code>x</code> einen Wert von <code>12</code> zu geben. Wenn dieser
Gültigkeitsbereich zu Ende ist, endet die innere Verschattung und <code>x</code> wird
wieder zu <code>6</code>. Wenn wir dieses Programm ausführen, wird es folgendes ausgeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
Der Wert von x im inneren Gültigkeitsbereich ist: 12
Der Wert von x ist: 6
</code></pre>
<p>Verschatten unterscheidet sich vom Markieren einer Variable mit <code>mut</code>, weil wir
einen Kompilierfehler erhalten, wenn wir versehentlich versuchen, diese
Variable neu zuzuweisen, ohne das Schlüsselwort <code>let</code> zu verwenden. Durch das
Verwenden von <code>let</code> können wir einige wenige Transformationen an einem Wert
durchführen, aber die Variable ist unveränderbar, nachdem diese
Transformationen abgeschlossen sind.</p>
<p>Der andere Unterschied zwischen <code>mut</code> und Verschatten besteht darin, dass wir,
weil wir effektiv eine neue Variable erstellen, wenn wir das Schlüsselwort
<code>let</code> erneut verwenden, den Typ des Wertes ändern können, aber denselben Namen
wiederverwenden. Nehmen wir zum Beispiel an, unser Programm bittet einen
Benutzer, durch Eingeben von Leerzeichen zu zeigen, wie viele Leerzeichen er
zwischen irgendeinem Text haben möchte, und wir möchten diese Eingabe als Zahl
speichern:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spaces = "   ";
let spaces = spaces.len();
<span class="boring">}</span></code></pre></pre>
<p>Die erste Variable <code>spaces</code> ist ein String-Typ und die zweite Variable <code>spaces</code>
ist ein Zahlentyp Integer. Das Verschatten erspart es uns also, uns verschiedene
Namen auszudenken, z.B. <code>spaces_str</code> und <code>spaces_num</code>; stattdessen können wir
den einfacheren Namen <code>spaces</code> wiederverwenden. Wenn wir jedoch versuchen,
dafür <code>mut</code> zu verwenden, wie hier gezeigt, erhalten wir einen Kompilierfehler:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut spaces = "   ";
spaces = spaces.len();

<span class="boring">}</span></code></pre></pre>
<p>Der Fehler besagt, dass es uns nicht erlaubt ist, den Typ einer Variable zu
mutieren:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>Nachdem wir nun untersucht haben, wie Variablen funktionieren, wollen wir uns
weitere Datentypen ansehen, die sie haben können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="datentypen"><a class="header" href="#datentypen">Datentypen</a></h2>
<p>Jeder Wert in Rust ist von einem bestimmten <em>Datentyp</em>, der Rust mitteilt,
welche Art von Daten angegeben wird, damit es weiß, wie es mit diesen Daten
arbeiten soll. Wir werden uns zwei Datentyp-Untermengen ansehen: Skalar (scalar) und
Verbund (compound).</p>
<p>Denk daran, dass Rust eine <em>statisch typisierte</em> Sprache ist, was bedeutet,
dass es die Typen von allen Variablen zur Kompilierzeit kennen muss. Der
Compiler kann normalerweise auf der Grundlage des Wertes und wie wir ihn
verwenden ableiten, welchen Typ wir verwenden wollen. Wenn mehrere Typen
möglich sind, wie zum Beispiel als wir im Abschnitt <a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">„Vergleichen der Schätzung
mit der Geheimzahl“</a> eine
Zeichenkette (<code>String</code>) mittels <code>parse</code> zu einem numerischen Typ umwandelten,
müssen wir eine Typ-Annotation ergänzen, wie hier:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = "42".parse().expect("Keine Zahl!");
<span class="boring">}</span></code></pre></pre>
<p>Wenn wir diese Typ-Annotation nicht angeben, zeigt Rust den folgenden Fehler
an, was bedeutet, dass der Compiler mehr Informationen von uns benötigt, um
zu wissen welchen Typ wir verwenden wollen:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Keine Zahl!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Keine Zahl!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
</code></pre>
<p>Für andere Datentypen wirst du andere Typ-Annotationen sehen.</p>
<h3 id="skalare-typen"><a class="header" href="#skalare-typen">Skalare Typen</a></h3>
<p>Ein <em>skalarer</em> Typ stellt einen einzelnen Wert dar. Rust hat vier primäre
skalare Typen: Ganze Zahlen, Fließkommazahlen, boolesche Werte (Wahrheitswerte)
und Zeichen. Du erkennst diese vielleicht aus anderen Programmiersprachen. Lass
uns darüber sprechen, wie sie in Rust funktionieren.</p>
<h4 id="ganzzahl-typen"><a class="header" href="#ganzzahl-typen">Ganzzahl-Typen</a></h4>
<p>Eine <em>ganze Zahl</em> ist eine Zahl ohne Bruchteilkomponente. Wir verwendeten eine
ganze Zahl in Kapitel 2, den Typ <code>u32</code>. Diese Typdeklaration gibt an, dass der
Wert, dem sie zugeordnet ist, eine 32 Bit große ganze Zahl ohne Vorzeichen ist
(vorzeichenbehaftete Ganzzahl-Typen beginnen mit <code>i</code> anstatt <code>u</code>). Tabelle 3-1
zeigt die in Rust eingebauten Ganzzahl-Typen. Wir können jede dieser Varianten
verwenden, um den Typ eines ganzzahligen Wertes zu deklarieren.</p>
<p><span class="caption">Tabelle 3-1: Ganzzahlige Typen in Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Länge</th><th>Vorzeichenbehaftet</th><th>Vorzeichenlos</th></tr></thead><tbody>
<tr><td style="text-align: right">8 Bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td style="text-align: right">16 Bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td style="text-align: right">32 Bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td style="text-align: right">64 Bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td style="text-align: right">128 Bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td style="text-align: right">arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Jede Variante kann entweder vorzeichenbehaftet oder vorzeichenlos sein und hat
eine explizite Größe. <em>Vorzeichenbehaftet</em> (signed) und <em>vorzeichenlos</em>
(unsigned) beziehen sich darauf, ob es möglich ist, dass die Zahl negativ ist
– in anderen Worten, ob die Zahl ein Vorzeichen haben muss
(vorzeichenbehaftet) oder ob sie immer nur positiv sein wird und daher ohne
Vorzeichen dargestellt werden kann (vorzeichenlos). Es ist wie das Schreiben
von Zahlen auf Papier: Wenn das Vorzeichen eine Rolle spielt, wird die Zahl mit
einem Plus- oder Minuszeichen geschrieben; wenn man jedoch davon ausgehen kann,
dass die Zahl positiv ist, wird sie ohne Vorzeichen geschrieben.
Vorzeichenbehaftete Zahlen werden unter Verwendung der
<a href="https://de.wikipedia.org/wiki/Zweierkomplement">Zweierkomplementdarstellung</a> gespeichert.</p>
<p>Jede vorzeichenbehaftete Variante kann Zahlen von -(2<sup>n - 1</sup>) bis
einschließlich 2<sup>n - 1</sup> - 1 speichern, wobei <em>n</em> die Anzahl an Bits
ist, die diese Variante benutzt. Ein <code>i8</code> kann also Zahlen von -(2<sup>7</sup>)
bis 2<sup>7</sup> - 1 speichern, was -128 bis 127 entspricht. Vorzeichenlose
Varianten können Zahlen von 0 bis 2<sup>n</sup> - 1 speichern, also kann ein
<code>u8</code> Zahlen von 0 bis 2<sup>8</sup> - 1 speichern, was 0 bis 255 entspricht.</p>
<p>Zusätzlich hängen die Typen <code>isize</code> und <code>usize</code> von der Architektur des
Computers ab, auf dem dein Programm läuft, die in der Tabelle als „arch“
bezeichnet wird: 64 Bit wenn du dich auf einer 64-Bit-Architektur befindest und
32 Bit auf einer 32-Bit-Architektur.</p>
<p>Du kannst ganzzahlige Literale in jeder der in Tabelle 3-2 gezeigten Formen
schreiben. Beachte, dass Zahlenliterale, die mehrere numerische Typen sein
können, ein Typ-Suffix wie <code>57u8</code> zur Bezeichnung des Typs erlauben.
Zahlenliterale können auch <code>_</code> als visuelles Trennzeichen verwenden, um die
Zahl leichter lesbar zu machen, z.B. <code>1_000</code>, das den gleichen Wert hat, wie
wenn du <code>1000</code> angegeben hättest.</p>
<p><span class="caption">Tabelle 3-2: Ganzzahl-Literale in Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Ganzahl-Literal</th><th>Beispiel</th></tr></thead><tbody>
<tr><td>Dezimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Oktal</td><td><code>0o77</code></td></tr>
<tr><td>Binär</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (nur <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Woher weist du also, welcher Ganzzahltyp zu verwenden ist? Wenn du dir unsicher
bist, sind Rusts Standards im Allgemeinen ein guter Ausgangspunkt: Ganzzahlige
Typen sind standardmäßig <code>i32</code>. Die primäre Situation, in der du <code>isize</code> oder
<code>usize</code> verwendest, ist beim Indizieren einer Art Sammlung.</p>
<blockquote>
<h5 id="ganzzahlüberlauf"><a class="header" href="#ganzzahlüberlauf">Ganzzahlüberlauf</a></h5>
<p>Nehmen wir an, du hast eine Variable vom Typ <code>u8</code>, die Werte zwischen 0 und
255 annehmen kann. Wenn du versuchst, die Variable auf einen Wert außerhalb
dieses Bereiches zu ändern, z.B. auf 256, tritt ein Ganzzahlüberlauf auf, was
zu einem von zwei Verhaltensweisen führen kann. Wenn du im Fehlersuchmodus
(debug mode) kompilierst, fügt Rust Prüfungen auf Ganzzahlüberläufe ein, was
dazu führt, dass dein Programm zur Laufzeit <em>abbricht</em> (panic), falls dieses
Verhalten auftritt. Rust verwendet den Begriff „panic“, wenn ein Programm
durch einen Fehler abgebrochen wird; wir werden Programmabbrüche im Abschnitt
<a href="ch09-01-unrecoverable-errors-with-panic.html">„Nicht behebbare Fehler mit <code>panic!</code>“</a> in
Kapitel 9 näher betrachten.</p>
<p>Wenn du mit dem Schalter <code>--release</code> im Freigabemodus (release mode)
kompilierst, fügt Rust <em>keine</em> Prüfungen auf Ganzzahlüberläufe, die das
Programm abbrechen, ein. Wenn ein Überlauf auftritt, führt Rust stattdessen
einen <em>Zweier-Komplement-Umbruch</em> durch. Kurz gesagt, Werte die größer als
der Maximalwert den der Typ enthalten kann sind, werden umgebrochen zum
kleinsten Wert den der Typ enthalten kann. Im Falle eines <code>u8</code> wird der Wert
256 zu 0, der Wert 257 zu 1 und so weiter. Das Programm wird nicht abbrechen,
aber die Variable wird wahrscheinlich einen anderen Wert annehmen, als du
erwartest. Sich auf das Verhalten von Ganzzahlüberläufen zu verlassen wird
als Fehler angesehen.</p>
<p>Um die Möglichkeit eines Überlaufs explizit zu behandeln, kannst du diese
Methodenfamilien verwenden, die die Standardbibliothek für primitive
numerische Typen bereitstellt:</p>
<ul>
<li>Umbrechen (wrap) aller Fälle mit den Methoden <code>wrapping_*</code>, z.B.
<code>wrapping_add</code></li>
<li>Zurückgeben des Wertes <code>None</code>, wenn es einen Überlauf mit einer Methode
<code>checked_*</code> gibt.</li>
<li>Zurückgeben des Wertes und eines booleschen Wertes, der angibt, ob ein
Überlauf mit einer Methode <code>overflowing_*</code> stattgefunden hat.</li>
<li>Gewährleisten der Minimal- oder Maximalwerte des Wertes mit den Methoden
<code>saturating_*</code>.</li>
</ul>
</blockquote>
<h4 id="fließkomma-typen"><a class="header" href="#fließkomma-typen">Fließkomma-Typen</a></h4>
<p>Rust hat auch zwei primitive Typen für <em>Fließkommazahlen</em>, das sind Zahlen mit
Dezimalkomma. Die Fließkomma-Typen in Rust sind <code>f32</code> und <code>f64</code>, die 32 Bit
bzw. 64 Bit groß sind. Der Standardtyp ist <code>f64</code>, da er auf modernen CPUs
ungefähr die gleiche Geschwindigkeit wie <code>f32</code> hat, aber eine höhere Präzision
ermöglicht. Alle Fließkomma-Typen sind vorzeichenbehaftet.</p>
<p>Hier ist ein Beispiel, das Fließkommazahlen in Aktion zeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>Fließkommazahlen werden nach dem IEEE-754-Standard dargestellt.</p>
<h4 id="numerische-operationen"><a class="header" href="#numerische-operationen">Numerische Operationen</a></h4>
<p>Rust unterstützt grundlegende mathematische Operationen, die man bei allen
Zahlentypen erwartet: Addition, Subtraktion, Multiplikation, Division und
Restberechnung. Die Ganzzahldivision rundet auf die nächste Ganzzahl ab. Der
folgende Code zeigt, wie du die einzelnen Typen in einer <code>let</code>-Anweisung
verwenden würdest:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    // Addition
    let sum = 5 + 10;

    // Subtraktion
    let difference = 95.5 - 4.3;

    // Multiplikation
    let product = 4 * 30;

    // Division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Ergibt -1

    // Restberechnung
    let remainder = 43 % 5;
}</code></pre></pre>
<p>Jeder Ausdruck in diesen Anweisungen verwendet einen mathematischen Operator
und wird zu einem einzelnen Wert ausgewertet, der dann an eine Variable
gebunden wird. <a href="appendix-02-operators.html">Anhang B</a> enthält eine Liste aller Operatoren, die
Rust anbietet.</p>
<h4 id="der-boolesche-typ"><a class="header" href="#der-boolesche-typ">Der boolesche Typ</a></h4>
<p>Wie in den meisten anderen Programmiersprachen hat ein boolescher Typ in Rust
zwei mögliche Werte: <code>true</code> (wahr) und <code>false</code> (falsch). Boolesche Werte sind
ein Byte groß. In Rust wird der boolesche Typ mit <code>bool</code> spezifiziert. Zum
Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let t = true;

    let f: bool = false; // mit expliziter Typ-Annotation
}</code></pre></pre>
<p>Hauptsächlich werden boolesche Werte in Bedingungen verwendet, z.B. im
<code>if</code>-Ausdruck. Wie <code>if</code>-Ausdrücke in Rust funktionieren werden wir im Abschnitt
<a href="ch03-05-control-flow.html">„Kontrollfluss“</a> erläutern.</p>
<h4 id="der-zeichen-typ"><a class="header" href="#der-zeichen-typ">Der Zeichen-Typ</a></h4>
<p>Rusts Typ <code>char</code> ist der primitivste alphabetische Typ der Sprache. Hier sind
einige Beispiele für die Deklaration von <code>char</code>-Werten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // mit expliziter Typannotation
    let heart_eyed_cat = '😻';
}</code></pre></pre>
<p>Beachte, dass wir <code>char</code>-Literale mit einfachen Anführungszeichen angeben, im
Gegensatz zu Zeichenketten-Literalen, die doppelte Anführungszeichen verwenden.
Der Typ <code>char</code> von Rust ist vier Bytes groß und stellt einen Unicode-Skalarwert
dar, was bedeutet, dass er viel mehr als nur ASCII darstellen kann.
Akzentuierte Buchstaben, chinesische, japanische und koreanische Zeichen, Emoji
und Leerzeichen mit Null-Breite sind gültige <code>char</code>-Werte in Rust.
Unicode-Skalarwerte reichen von <code>U+0000</code> bis <code>U+D7FF</code> und von <code>U+E000</code> bis
einschließlich <code>U+10FFFF</code>. Ein „Zeichen“ ist jedoch nicht wirklich ein Konzept
in Unicode, deine menschliche Intuition dafür, was ein „Zeichen“ ist, stimmt
möglicherweise nicht mit dem überein, was ein <code>char</code> in Rust ist. Wir werden
dieses Thema in <a href="ch08-02-strings.html">„UTF-8-kodierten Text in Zeichenketten (strings)
ablegen“</a> in Kapitel 8 im Detail besprechen.</p>
<h3 id="verbund-typen"><a class="header" href="#verbund-typen">Verbund-Typen</a></h3>
<p><em>Verbund-Typen</em> (compound types) können mehrere Werte zu einem Typ gruppieren.
Rust hat zwei primitive Verbund-Typen: Tupel (tuples) und Arrays (arrays).</p>
<h4 id="der-tupel-typ"><a class="header" href="#der-tupel-typ">Der Tupel-Typ</a></h4>
<p>Ein <em>Tupel</em> ist eine allgemeine Möglichkeit, eine Reihe von Werten mit einer
Vielzahl von Typen zu einem Verbund-Typ zusammenzufassen. Tupel haben eine
feste Länge: Einmal deklariert, können sie weder wachsen noch schrumpfen.</p>
<p>Wir erzeugen ein Tupel, indem wir eine durch Kommata getrennte Liste von Werten
innerhalb von Klammern schreiben. Jede Position im Tupel hat einen Typ und die
Typen der verschiedenen Werte im Tupel müssen nicht gleich sein. In diesem
Beispiel haben wir optionale Typ-Annotationen angegeben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>Die Variable <code>tup</code> bindet das gesamte Tupel, da ein Tupel als ein einziges
Verbundelement betrachtet wird. Um die einzelnen Werte aus einem Tupel
herauszubekommen, können wir den Musterabgleich verwenden, um einen Tupelwert
zu destrukturieren, etwa so:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("Der Wert von y ist: {y}");
}</code></pre></pre>
<p>Dieses Programm erzeugt zunächst ein Tupel und bindet es an die Variable <code>tup</code>.
Dann benutzt es ein Muster mit <code>let</code>, um <code>tup</code> zu nehmen und in drei separate
Variablen <code>x</code>, <code>y</code> und <code>z</code> umzuwandeln. Dies nennt man <em>destrukturieren</em>
(destructuring), weil es das einzelne Tupel in drei Teile zerlegt. Schließlich
gibt das Programm den Wert von <code>y</code> aus, der <code>6.4</code> ist.</p>
<p>Wir können direkt auf ein Tupelelement zugreifen, indem wir einen Punkt (<code>.</code>)
gefolgt vom Index des Wertes, auf den wir zugreifen wollen, verwenden. Zum
Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>Dieses Programm erstellt das Tupel <code>x</code> und greift dann auf jedes Element des
Tupels über die jeweiligen Indizes zu. Wie bei den meisten Programmiersprachen
ist der erste Index in einem Tupel 0.</p>
<p>Das Tupel ohne Werte hat einen speziellen Namen: <em>Einheitswert</em> (unit value).
Dieser Wert und der zugehörige Typ (<em>Einheitstyp</em> (unit type)) werden beide mit
<code>()</code> geschrieben und stellen einen leeren Wert oder einen leeren Rückgabetyp
dar. Ausdrücke geben implizit den Einheitswert zurück, wenn sie keinen anderen
Wert zurückgeben.</p>
<h4 id="der-array-typ"><a class="header" href="#der-array-typ">Der Array-Typ</a></h4>
<p>Eine andere Möglichkeit, eine Kollektion mit mehreren Werten zu haben, ist mit
einem <em>Array</em>. Im Gegensatz zu einem Tupel muss jedes Element eines Arrays den
gleichen Typ haben. Anders als Arrays in einigen anderen Sprachen haben Arrays
in Rust eine feste Länge.</p>
<p>Wir schreiben die Werte in einem Array als kommagetrennte Liste in eckigen
Klammern:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>Arrays sind nützlich, wenn du deine Daten eher auf dem Stapelspeicher als im
Haldenspeicher abgelegt haben möchtest, wie bei den anderen Typen, die wir
bisher gesehen haben, (auf den Stapelspeicher und den Haldenspeicher gehen wir
in <a href="ch04-01-what-is-ownership.html#stapelspeicher-stack-und-haldenspeicher-heap">Kapitel 4</a> näher ein) oder wenn du sicherstellen willst,
dass du immer eine feste Anzahl von Elementen hast. Ein Array ist jedoch nicht
so flexibel wie der Vektortyp. Ein <em>Vektor</em> ist ein ähnlicher Kollektionstyp,
der von der Standardbibliothek zur Verfügung gestellt wird und der in seiner
Größe wachsen oder schrumpfen kann. Wenn du dir nicht sicher bist, ob du ein
Array oder einen Vektor verwenden sollst, ist es wahrscheinlich, dass du einen
Vektor verwenden solltest. In <a href="ch08-01-vectors.html">Kapitel 8</a> werden Vektoren
ausführlicher besprochen.</p>
<p>Arrays sind jedoch hilfreicher, wenn du weißt, dass sich die Anzahl der
Elemente nicht ändern wird. Wenn du z.B. die Monatsnamen in einem Programm
verwendest, würdest du wahrscheinlich eher ein Array als einen Vektor
verwenden, weil du weißt, dass es immer 12 Elemente enthalten wird:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli",
              "August", "September", "Oktober", "November", "Dezember"];
<span class="boring">}</span></code></pre></pre>
<p>Der Typ eines Arrays wird in eckigen Klammern mit dem Typ der einzelnen
Elemente angegeben, ein Semikolon und dann die Anzahl der Elemente im Array,
etwa so:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Hier ist <code>i32</code> der Typ aller Elemente. Nach dem Semikolon gibt die Zahl <code>5</code> an,
dass das Array fünf Elemente enthält.</p>
<p>Du kannst ein Array auch so initialisieren, dass es für jedes Element denselben
Wert enthält, indem du den Anfangswert, gefolgt von einem Semikolon, und dann
die Länge des Arrays in eckigen Klammern angibst, wie hier gezeigt:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p>Das Array mit dem Namen <code>a</code> wird <code>5</code> Elemente enthalten, die alle anfänglich
auf den Wert <code>3</code> gesetzt werden. Dies ist dasselbe wie das Schreiben von
<code>let a = [3, 3, 3, 3, 3];</code>, aber in einer prägnanteren Weise.</p>
<h5 id="zugriff-auf-array-elemente"><a class="header" href="#zugriff-auf-array-elemente">Zugriff auf Array-Elemente</a></h5>
<p>Ein Array ist ein einzelner Speicherbereich mit einer bekannten, festen Größe,
der auf den Stapelspeicher gelegt wird. Du kannst auf Elemente eines Arrays mit
Hilfe der Indizierung wie folgt zugreifen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>In diesem Beispiel erhält die Variable mit dem Namen <code>first</code> den Wert <code>1</code>, weil
das der Wert am Index <code>[0]</code> im Array ist. Die Variable mit dem Namen <code>second</code>
wird den Wert <code>2</code> vom Index <code>[1]</code> im Array erhalten.</p>
<h5 id="ungültiger-array-element-zugriff"><a class="header" href="#ungültiger-array-element-zugriff">Ungültiger Array-Element-Zugriff</a></h5>
<p>Sehen wir uns an was passiert, wenn du versuchst, auf ein Element eines Arrays
zuzugreifen, das sich hinter dem Ende des Arrays befindet. Angenommen, du
führst diesen Code aus, ähnlich zum Ratespiel in Kapitel 2, um einen
Array-Index vom Benutzer zu erhalten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust panics edition2024">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Bitte gib einen Array-Index ein.");

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect("Fehler beim Lesen der Zeile");

    let index: usize = index
        .trim()
        .parse()
        .expect("Eingegebener Index war keine Zahl");

    let element = a[index];

    println!(
        "Der Wert von element beim Index {index} ist: {element}");
}</code></pre></pre>
<p>Dieser Code kompiliert erfolgreich. Wenn du diesen Code mit <code>cargo run</code>
ausführst und <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> oder <code>4</code> eingibst, wird das Programm den
entsprechenden Wert an diesem Index im Array ausgeben. Wenn du stattdessen eine
Zahl hinter dem Ende des Arrays eingibst, z.B. <code>10</code>, erhältst du eine Ausgabe
wie diese:</p>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Das Programm führte zu einem <em>Laufzeitfehler</em> an der Stelle, an der ein
ungültiger Wert in der Index-Operation verwendet wurde. Das Programm wurde mit
einer Fehlermeldung beendet und hat die abschließende <code>println!</code>-Anweisung
nicht ausgeführt. Wenn du versuchst, mit Hilfe der Indizierung auf ein Element
zuzugreifen, prüft Rust, ob der angegebene Index kleiner als die Array-Länge
ist. Wenn der Index größer oder gleich der Länge ist, wird Rust das Programm
abbrechen. Diese Prüfung muss zur Laufzeit erfolgen, insbesondere in diesem
Fall, weil der Compiler unmöglich wissen kann, welchen Wert ein Benutzer später
eingeben wird, wenn er den Code ausführt.</p>
<p>Dies ist ein Beispiel für die Umsetzung der Speichersicherheitsprinzipien von
Rust. In vielen Low-Level-Sprachen wird diese Art der Überprüfung nicht
durchgeführt und wenn du einen falschen Index angibst, kann auf ungültigen
Speicher zugegriffen werden. Rust schützt dich vor dieser Art von Fehlern,
indem es das Programm sofort beendet, anstatt den Speicherzugriff zuzulassen
und fortzusetzen. Kapitel 9 behandelt die Fehlerbehandlung in Rust und wie du
lesbaren, sicheren Code schreiben kannst, der weder abstürzt noch ungültige
Speicherzugriffe zulässt.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="funktionen"><a class="header" href="#funktionen">Funktionen</a></h2>
<p>Funktionen sind im Rust-Code weit verbreitet. Du hast bereits eine der
wichtigsten Funktionen in der Sprache gesehen: Die Funktion <code>main</code>, die der
Einstiegspunkt vieler Programme ist. Du hast auch das Schlüsselwort <code>fn</code>
gesehen, mit dem du neue Funktionen deklarieren kannst.</p>
<p>Rust-Code verwendet die <em>Schlangenschrift</em>-Stil-Konvention (snake case) für
Funktions- und Variablennamen, bei der alle Buchstaben klein geschrieben sind
und Unterstriche Wörter separieren. Hier ist ein Programm, das eine
Beispiel-Funktionsdefinition enthält:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    println!("Hallo Welt!");

    another_function();
}

fn another_function() {
    println!("Eine andere Funktion.");
}</code></pre></pre>
<p>Wir definieren eine Funktion in Rust durch die Eingabe von <code>fn</code>, gefolgt von
einem Funktionsnamen und einem Satz Klammern. Die geschweiften Klammern teilen
dem Compiler mit, wo der Funktionsrumpf beginnt und endet.</p>
<p>Wir können jede Funktion, die wir definiert haben, aufrufen, indem wir ihren
Namen gefolgt von einem Satz Klammern eingeben. Da <code>another_function</code> im
Programm definiert ist, kann sie von innerhalb der Funktion <code>main</code> aufgerufen
werden. Beachte, dass wir <code>another_function</code> <em>nach</em> der Funktion <code>main</code> im
Quellcode definiert haben; wir hätten sie auch vorher definieren können. Rust
interessiert es nicht, wo du deine Funktionen definierst, nur dass sie irgendwo
definiert sind.</p>
<p>Lass uns ein neues Binärprojekt namens „functions“ anfangen, um Funktionen
weiter zu erforschen. Platziere das Beispiel <code>another_function</code> in
<em>src/main.rs</em> und lass es laufen. Du solltest die folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hallo Welt!
Eine andere Funktion.
</code></pre>
<p>Die Zeilen werden in der Reihenfolge ausgeführt, in der sie in der Funktion
<code>main</code> erscheinen. Zuerst wird die Nachricht „Hallo Welt!“ ausgegeben und dann
wird <code>another_function</code> aufgerufen und ihre Nachricht ausgegeben.</p>
<h3 id="parameter"><a class="header" href="#parameter">Parameter</a></h3>
<p>Wir können Funktionen auch so definieren, dass sie <em>Parameter</em> haben, das
sind spezielle Variablen, die Teil der Funktionssignatur sind. Wenn eine
Funktion Parameter hat, kannst du sie mit konkreten Werten für diese Parameter
versehen. Technisch gesehen werden die konkreten Werte <em>Argumente</em> genannt,
aber in lockeren Gesprächen neigen Leute dazu, die Worte <em>Parameter</em> und
<em>Argument</em> entweder für die Variablen in der Definition einer Funktion oder für
die konkreten Werte, die beim Aufruf einer Funktion übergeben werden,
synonym zu verwenden.</p>
<p>In dieser Version von <code>another_function</code> fügen wir einen Parameter hinzu:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("Der Wert von x ist: {x}");
}</code></pre></pre>
<p>Versuche, dieses Programm auszuführen; du solltest die folgende Ausgabe
erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
Der Wert von x ist: 5
</code></pre>
<p>Die Deklaration <code>another_function</code> hat einen Parameter namens <code>x</code>. Der Typ von
<code>x</code> wird als <code>i32</code> angegeben. Wenn wir <code>5</code> an <code>another_function</code> übergeben,
setzt das Makro <code>println!</code> den Wert <code>5</code> an die Stelle, an der sich das Paar
geschweifter Klammern mit dem <code>x</code> darin in der Formatierungszeichenkette
befand.</p>
<p>In Funktionssignaturen <em>musst</em> du den Typ jedes Parameters deklarieren. Dies
ist eine bewusste Designentscheidung von Rust: Das Erfordernis von
Typ-Annotationen in Funktionsdefinitionen bedeutet, dass der Compiler sie
fast nie an anderer Stelle im Code benötigt, um herauszufinden, welchen Typ du
meinst. Der Compiler ist auch in der Lage, hilfreichere Fehlermeldungen zu
geben, wenn er weiß, welche Typen die Funktion erwartet.</p>
<p>Wenn wir mehrere Parameter definieren, trennen wir die Parameterdeklarationen
mit Kommas, so wie hier:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("Das Maß ist: {value}{unit_label}");
}</code></pre></pre>
<p>Dieses Beispiel erzeugt eine Funktion namens <code>print_labeled_measurement</code> mit
zwei Parametern. Der erste Parameter heißt <code>value</code> und ist ein <code>i32</code>. Der
zweite heißt <code>unit_label</code> und ist vom Typ <code>char</code>. Die Funktion gibt dann einen
Text aus, der sowohl <code>value</code> als auch <code>unit_label</code> enthält.</p>
<p>Lass uns versuchen, diesen Code auszuführen. Ersetze das Programm, das sich
derzeit in der Datei <em>src/main.rs</em> deines „functions“-Projekts befindet, durch
das vorhergehende Beispiel und führe es mit <code>cargo run</code> aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
Das Maß ist: 5h
</code></pre>
<p>Da wir die Funktion mit <code>5</code> als Wert für <code>value</code> und <code>'h'</code> als Wert für
<code>unit_label</code> aufgerufen haben, enthält die Programmausgabe diese Werte.</p>
<h4 id="anweisungen-und-ausdrücke"><a class="header" href="#anweisungen-und-ausdrücke">Anweisungen und Ausdrücke</a></h4>
<p>Funktionsrümpfe bestehen aus einer Reihe von Anweisungen, die optional mit
einem Ausdruck enden können. Bisher haben wir nur Funktionen ohne einen
endenden Ausdruck behandelt, aber du hast einen Ausdruck als Teil einer
Anweisung gesehen. Da Rust eine auf Ausdrücken basierende Sprache ist, ist dies
eine wichtige Unterscheidung, die es zu verstehen gilt. Andere Sprachen haben
nicht dieselben Unterscheidungen, deshalb wollen wir uns ansehen, was
Anweisungen und Ausdrücke sind und wie sich ihre Unterschiede auf die
Funktionsrümpfe auswirken.</p>
<ul>
<li><strong>Anweisungen</strong> (statements) sind Instruktionen, die eine Aktion ausführen
und keinen Wert zurückgeben.</li>
<li><strong>Ausdrücke</strong> (expressions) werden zu einem Ergebniswert ausgewertet.
Schauen wir uns einige Beispiele an.</li>
</ul>
<p>Eine Variable zu erstellen und ihr mit dem Schlüsselwort <code>let</code> einen Wert
zuzuweisen, ist eine Anweisung. In Codeblock 3-1 ist <code>let y = 6;</code> eine
Anweisung.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let y = 6;
}</code></pre></pre>
<p><span class="caption">Codeblock 3-1: Eine Funktionsdeklaration <code>main</code>, die eine
Anweisung enthält</span></p>
<p>Auch Funktionsdefinitionen sind Anweisungen; das gesamte vorhergehende Beispiel
ist eine Anweisung für sich. (Wie wir weiter unten sehen werden, ist der
<em>Aufruf</em> einer Funktion keine Anweisung.)</p>
<p>Anweisungen geben keine Werte zurück. Daher kannst du keine <code>let</code>-Anweisung
einer anderen Variablen zuweisen, wie es der folgende Code versucht; du wirst
einen Fehler erhalten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let x = (let y = 6);
}</code></pre></pre>
<p>Wenn du dieses Programm ausführst, wirst du in etwa folgenden Fehler erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` (bin "functions") due to 1 previous error; 1 warning emitted
</code></pre>
<p>Die Anweisung <code>let y = 6</code> gibt keinen Wert zurück, also gibt es für <code>x</code> nichts,
woran <code>x</code> gebunden werden kann. Dies unterscheidet sich von dem, was in anderen
Sprachen wie C und Ruby geschieht, wo die Zuweisung den Wert der Zuweisung
zurückgibt. In diesen Sprachen kannst du <code>x = y = 6</code> schreiben und sowohl <code>x</code>
als auch <code>y</code> haben den Wert <code>6</code>; das ist in Rust nicht der Fall.</p>
<p>Ausdrücke werten zu einem Wert aus und machen den größten Teil des restlichen
Codes aus, den du in Rust schreiben wirst. Betrachte eine mathematische
Operation, z.B. <code>5 + 6</code>, die ein Ausdruck ist, der zum Wert <code>11</code> ausgewertet
wird. Ausdrücke können Teil von Anweisungen sein: In Codeblock 3-1 ist die <code>6</code>
in der Anweisung <code>let y = 6;</code> ein Ausdruck, der den Wert <code>6</code> ergibt. Der Aufruf
einer Funktion ist ein Ausdruck. Der Aufruf eines Makros ist ein Ausdruck. Ein
neuer Gültigkeitsbereichsblock, der mit geschweiften Klammern erstellt wird,
ist ein Ausdruck, zum Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("Der Wert von y ist: {y}");
}</code></pre></pre>
<p>Der Ausdruck</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>ist ein Block, der in diesem Fall zu <code>4</code> ausgewertet wird. Dieser Wert wird als
Teil der <code>let</code>-Anweisung an <code>y</code> gebunden. Beachte, dass die Zeile <code>x + 1</code> am
Ende kein Semikolon hat, was sich von den meisten Zeilen, die du bisher gesehen
hast, unterscheidet. Ausdrücke enthalten keine abschließenden Semikolons. Wenn
du ein Semikolon an das Ende eines Ausdrucks anfügst, machst du daraus eine
Anweisung, und sie gibt keinen Wert zurück.  Behalte dies im Hinterkopf, wenn
du als nächstes die Rückgabewerte von Funktionen und Ausdrücken untersuchst.</p>
<h3 id="funktionen-mit-rückgabewerten"><a class="header" href="#funktionen-mit-rückgabewerten">Funktionen mit Rückgabewerten</a></h3>
<p>Funktionen können Werte an den Code zurückgeben, der sie aufruft. Wir benennen
keine Rückgabewerte, aber wir müssen ihren Typ nach einem Pfeil (<code>-&gt;</code>)
deklarieren. In Rust ist der Rückgabewert der Funktion gleichbedeutend mit dem
Wert des letzten Ausdrucks im Block des Funktionsrumpfs. Du kannst frühzeitig
von einer Funktion zurückkehren, indem du das Schlüsselwort <code>return</code> verwendest
und einen Wert angibst, aber die meisten Funktionen geben den letzten Ausdruck
implizit zurück. Hier ist ein Beispiel für eine Funktion, die einen Wert
zurückgibt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("Der Wert von x ist: {x}");
}</code></pre></pre>
<p>Es gibt keine Funktionsaufrufe, Makros oder gar <code>let</code>-Anweisungen in der
Funktion <code>five</code> – nur die Zahl <code>5</code> selbst. Das ist eine vollkommen
gültige Funktion in Rust. Beachte, dass der Rückgabetyp der Funktion ebenfalls
angegeben ist, mit <code>-&gt; i32</code>. Versuche diesen Code auszuführen; die Ausgabe
sollte wie folgt aussehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
Der Wert von x ist: 5
</code></pre>
<p>Die <code>5</code> in <code>five</code> ist der Rückgabewert der Funktion, weshalb der Rückgabetyp
<code>i32</code> ist. Lass uns dies genauer untersuchen. Es gibt zwei wichtige Teile:
Erstens zeigt die Zeile <code>let x = five();</code>, dass wir den Rückgabewert einer
Funktion verwenden, um eine Variable zu initialisieren. Da die Funktion <code>five</code>
den Wert <code>5</code> zurückgibt, ist diese Zeile die gleiche wie die folgende:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Zweitens hat die Funktion <code>five</code> keine Parameter und definiert den Typ des
Rückgabewertes, aber der Funktionsrumpf ist eine einsame <code>5</code> ohne Semikolon,
weil es ein Ausdruck ist, dessen Wert wir zurückgeben wollen.</p>
<p>Sehen wir uns ein weiteres Beispiel an:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = plus_one(5);

    println!("Der Wert von x ist: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre></pre>
<p>Beim Ausführen dieses Codes wird <code>Der Wert von x ist: 6</code> ausgegeben. Wenn wir
aber ein Semikolon an das Ende der Zeile mit <code>x + 1</code> setzen und es von einem
Ausdruck in eine Anweisung ändern, erhalten wir einen Fehler:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let x = plus_one(5);

    println!("Der Wert von x ist: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}</code></pre></pre>
<p>Das Kompilieren dieses Codes führt zum folgenden Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin "functions") due to 1 previous error
</code></pre>
<p>Die Hauptfehlermeldung <code>mismatched types</code> offenbart das Kernproblem dieses
Codes. Die Definition der Funktion <code>plus_one</code> besagt, dass sie ein <code>i32</code>
zurückgibt, aber Anweisungen werden nicht zu einem Wert ausgewertet, was durch
den Einheitstyp <code>()</code> ausgedrückt wird. Daher wird nichts zurückgegeben, was der
Funktionsdefinition widerspricht und zu einem Fehler führt. In dieser Ausgabe
gibt Rust eine Meldung aus, die möglicherweise helfen kann, dieses Problem zu
beheben: Es wird vorgeschlagen, das Semikolon zu entfernen, was den Fehler
beheben würde.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kommentare"><a class="header" href="#kommentare">Kommentare</a></h2>
<p>Alle Programmierer bemühen sich, ihren Code leicht verständlich zu machen, aber
manchmal sind zusätzliche Erklärungen angebracht. In solchen Fällen versehen
Entwickler den Quellcode mit <em>Kommentaren</em>, welche der Compiler ignoriert
und für andere Entwickler nützlich sein können.</p>
<p>Dies ist ein einfacher Kommentar:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hallo Welt
<span class="boring">}</span></code></pre></pre>
<p>In Rust beginnt ein gewöhnlicher Kommentar mit zwei Schrägstrichen; der
Kommentar reicht dann bis zum Ende der Zeile. Für Kommentare, die über eine
einzelne Zeile hinausgehen, musst du bei jedem Zeilenanfang <code>//</code> angeben:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hier passiert etwas kompliziertes, so komplex dass wir
// mehrere Kommentarzeilen brauchen! Puh! Hoffentlich erklärt
// dieser Kommentar, was hier passiert.
<span class="boring">}</span></code></pre></pre>
<p>Kommentare können auch am Ende einer Codezeile stehen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let lucky_number = 7; // Heute habe ich Glück
}</code></pre></pre>
<p>Gängiger ist jedoch die Schreibweise mit dem Kommentar über der Codezeile, die
er beschreibt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    // Heute habe ich Glück
    let lucky_number = 7;
}</code></pre></pre>
<p>Rust kennt noch eine weitere Kommentarart, nämlich Dokumentationskommentare,
die wir im Abschnitt <a href="ch14-02-publishing-to-crates-io.html">„Kisten (crate) auf crates.io
veröffentlichen“</a> in Kapitel 14 besprechen werden.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kontrollfluss"><a class="header" href="#kontrollfluss">Kontrollfluss</a></h2>
<p>Die Fähigkeit, Code auszuführen, der davon abhängt, ob eine Bedingung <code>true</code>
ist, oder Code wiederholt auszuführen, während eine Bedingung <code>true</code> ist, sind
grundlegende Bausteine der meisten Programmiersprachen. Die gebräuchlichsten
Konstrukte, mit denen du den Kontrollfluss von Rust-Code kontrollieren kannst,
sind <code>if</code>-Ausdrücke und Schleifen.</p>
<h3 id="if-ausdrücke"><a class="header" href="#if-ausdrücke"><code>if</code>-Ausdrücke</a></h3>
<p>Ein <code>if</code>-Ausdruck erlaubt es dir, deinen Code abhängig von Bedingungen zu
verzweigen. Du gibst eine Bedingung an und legst dann fest: „Wenn diese
Bedingung erfüllt ist, führe diesen Codeblock aus. Wenn die Bedingung nicht
erfüllt ist, darf dieser Codeblock nicht ausgeführt werden.“</p>
<p>Erstelle in deinem <em>projects</em>-Verzeichnis ein neues Projekt namens <em>branches</em>,
um den <code>if</code>-Ausdruck zu erforschen. Gibt in der Datei <em>src/main.rs</em> folgendes
ein:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("Bedingung war wahr");
    } else {
        println!("Bedingung war falsch");
    }
}</code></pre></pre>
<p>Alle <code>if</code>-Ausdrücke beginnen mit dem Schlüsselwort <code>if</code>, gefolgt von einer
Bedingung. In diesem Fall prüft die Bedingung, ob die Variable <code>number</code> einen
Wert kleiner als 5 hat oder nicht. Der Codeblock, den wir ausführen wollen,
wenn die Bedingung <code>true</code> ist, wird unmittelbar nach der Bedingung in
geschweifte Klammern gesetzt. Codeblöcke, die mit den Bedingungen in
<code>if</code>-Ausdrücken verbunden sind, werden manchmal auch als <em>Zweige</em> (arms)
bezeichnet, genau wie die Zweige in <code>match</code>-Ausdrücken, die wir im Abschnitt
<a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">„Vergleichen der Schätzung mit der
Geheimzahl“</a> in Kapitel 2 besprochen
haben.</p>
<p>Optional können wir auch einen <code>else</code>-Ausdruck angeben, was wir hier gemacht
haben, um dem Programm einen alternativen Codeblock zur Ausführung zu geben,
falls die Bedingung zu <code>false</code> ausgewertet wird. Wenn du keinen <code>else</code>-Ausdruck
angibst und die Bedingung <code>false</code> ist, überspringt das Programm einfach den
<code>if</code>-Block und geht zum nächsten Codeteil über.</p>
<p>Versuche, diesen Code auszuführen; du solltest die folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Bedingung war wahr
</code></pre>
<p>Lass uns versuchen, den Wert von <code>number</code> in einen Wert zu ändern, der die
Bedingung <code>falsch</code> macht, um zu sehen, was passiert:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!("Bedingung war wahr");
</span><span class="boring">    } else {
</span><span class="boring">        println!("Bedingung war falsch");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>Führe das Programm erneut aus und sieh dir die Ausgabe an:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Bedingung war falsch
</code></pre>
<p>Es ist auch erwähnenswert, dass die Bedingung in diesem Code ein <code>bool</code> sein
<em>muss</em>. Wenn die Bedingung kein <code>bool</code> ist, erhalten wir einen Fehler. Versuche
zum Beispiel, den folgenden Code auszuführen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let number = 3;

    if number {
        println!("Zahl war drei");
    }
}</code></pre></pre>
<p>Die <code>if</code>-Bedingung wird diesmal zum Wert <code>3</code> ausgewertet und Rust wirft einen
Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>Der Fehler gibt an, dass Rust ein <code>bool</code> erwartet, aber eine ganze Zahl
erhalten hat. Im Gegensatz zu Sprachen wie Ruby und JavaScript wird Rust nicht
automatisch versuchen, nicht-boolsche Typen in ein Boolean zu konvertieren. Du
musst explizit sein und immer <code>if</code> mit einer Booleschen Bedingung versehen.
Wenn wir beispielsweise wollen, dass der <code>if</code>-Codeblock nur ausgeführt wird,
wenn eine Zahl ungleich <code>0</code> ist, können wir den <code>if</code>-Ausdruck wie folgt ändern:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 3;

    if number != 0 {
        println!("Zahl war etwas anderes als Null");
    }
}</code></pre></pre>
<p>Wenn du diesen Code ausführst, wird <code>Zahl war etwas anderes als Null</code>
ausgegeben.</p>
<h4 id="behandeln-mehrerer-bedingungen-mit-else-if"><a class="header" href="#behandeln-mehrerer-bedingungen-mit-else-if">Behandeln mehrerer Bedingungen mit <code>else if</code></a></h4>
<p>Du kannst mehrere Bedingungen verwenden, indem du <code>if</code> und <code>else</code> in einem
<code>else if</code>-Ausdruck kombinierst. Zum Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("Zahl ist durch 4 teilbar");
    } else if number % 3 == 0 {
        println!("Zahl ist durch 3 teilbar");
    } else if number % 2 == 0 {
        println!("Zahl ist durch 2 teilbar");
    } else {
        println!("Zahl ist nicht durch 4, 3 oder 2 teilbar");
    }
}</code></pre></pre>
<p>Dieses Programm hat vier mögliche Wege, die es nehmen kann. Nachdem du es
ausgeführt hast, solltest du folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Zahl ist durch 3 teilbar
</code></pre>
<p>Wenn dieses Programm ausgeführt wird, prüft es der Reihe nach jeden
<code>if</code>-Ausdruck und führt den ersten Block aus, für den die Bedingung zu <code>true</code>
ausgewertet wird. Beachte, dass, obwohl 6 durch 2 teilbar ist, wir weder die
Ausgabe <code>Zahl ist durch 2 teilbar</code> sehen, noch sehen wir den Text <code>Zahl ist nicht durch 4, 3 oder 2 teilbar</code> aus dem <code>else</code>-Block. Das liegt daran, dass
Rust den Block nur für die erste <code>true</code>-Bedingung ausführt, und wenn es eine
findet, prüft es den Rest nicht mehr.</p>
<p>Das Verwenden von zu vielen <code>else if</code>-Ausdrücken kann deinen Code
unübersichtlich machen. Wenn du also mehr als einen Ausdruck hast, solltest du
deinen Code vielleicht überarbeiten. Kapitel 6 beschreibt ein leistungsfähiges
Rust-Verzweigungskonstrukt namens <code>match</code> für solche Fälle.</p>
<h4 id="verwenden-von-if-in-einer-let-anweisung"><a class="header" href="#verwenden-von-if-in-einer-let-anweisung">Verwenden von <code>if</code> in einer <code>let</code>-Anweisung</a></h4>
<p>Weil <code>if</code> ein Ausdruck ist, können wir ihn auf der rechten Seite einer
<code>let</code>-Anweisung verwenden, um das Ergebnis einer Variablen zuzuordnen, wie in
Codeblock 3-2.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("Der Wert der Zahl ist: {number}");
}</code></pre></pre>
<p><span class="caption">Codeblock 3-2: Zuweisen des Ergebnisses eines
<code>if</code>-Ausdrucks an eine Variable</span></p>
<p>Die Variable <code>number</code> wird an einen Wert gebunden, der auf dem Ergebnis des
<code>if</code>-Ausdrucks basiert. Führe diesen Code aus, um zu sehen, was passiert:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
Der Wert der Zahl ist: 5
</code></pre>
<p>Denke daran, dass Codeblöcke bis zum letzten Ausdruck in ihnen ausgewertet
werden, und auch Zahlen an sich sind Ausdrücke. In diesem Fall hängt der Wert
des gesamten <code>if</code>-Ausdrucks davon ab, welcher Codeblock ausgeführt wird. Dies
bedeutet, dass die Werte, die potentielle Ergebnisse eines <code>if</code>-Zweigs sein
können, vom gleichen Typ sein müssen; in Codeblock 3-2 waren die Ergebnisse
sowohl des <code>if</code>-Zweigs als auch des <code>else</code>-Zweigs <code>i32</code>-Ganzzahlen. Wenn die
Typen nicht übereinstimmen, wie im folgenden Beispiel, erhalten wir einen
Fehler:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let condition = true;

    let number = if condition { 5 } else { "sechs" };

    println!("Der Wert der Zahl ist: {number}");
}</code></pre></pre>
<p>Wenn wir versuchen, diesen Code zu kompilieren, erhalten wir einen Fehler. Die
<code>if</code>- und <code>else</code>-Zweige haben Werttypen, die inkompatibel sind, und Rust zeigt
genau an, wo das Problem im Programm zu finden ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "sechs" };
  |                                 -          ^^^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>Der Ausdruck im <code>if</code>-Block wird zu einer ganzen Zahl und der Ausdruck im
<code>else</code>-Block zu einer Zeichenkette ausgewertet. Dies wird nicht funktionieren,
da Variablen einen einzigen Typ haben müssen. Rust muss zur Kompilierzeit
definitiv wissen, welchen Typ die Variable <code>number</code> hat, damit es zur
Kompilierzeit überprüfen kann, ob ihr Typ überall gültig ist, wo wir <code>number</code>
verwenden. Rust wäre dazu nicht in der Lage, wenn der Typ von <code>number</code> erst zur
Laufzeit bestimmt würde; der Compiler wäre komplexer und würde weniger
Garantien über den Code geben, wenn er mehrere hypothetische Typen für jede
Variable verfolgen müsste.</p>
<h3 id="wiederholung-mit-schleifen"><a class="header" href="#wiederholung-mit-schleifen">Wiederholung mit Schleifen</a></h3>
<p>Es ist oft hilfreich, einen Codeblock mehr als einmal auszuführen. Für diese
Aufgabe stellt Rust mehrere <em>Schleifen</em> (loops) zur Verfügung, die den Code
innerhalb des Schleifenrumpfs bis zum Ende durchläuft und dann sofort wieder am
Anfang beginnt. Um mit Schleifen zu experimentieren, machen wir ein neues
Projekt namens <em>loops</em>.</p>
<p>Rust hat drei Arten von Schleifen: <code>loop</code>, <code>while</code> und <code>for</code>. Probieren wir
jede einzelne aus.</p>
<h4 id="wiederholen-von-code-mit-loop"><a class="header" href="#wiederholen-von-code-mit-loop">Wiederholen von Code mit <code>loop</code></a></h4>
<p>Das Schlüsselwort <code>loop</code> weist Rust an, einen Codeblock immer und immer wieder
auszuführen, und zwar für immer oder bis du ihm explizit sagst, dass er
aufhören soll.</p>
<p>Als Beispiel änderst du die Datei <em>src/main.rs</em> in deinem <em>loops</em>-Verzeichnis
so, dass sie wie folgt aussieht:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!("nochmal!");
    }
}</code></pre>
<p>Wenn wir dieses Programm ausführen, werden wir sehen, dass es immer und immer
wieder <code>nochmal!</code> ausgibt, bis wir das Programm manuell stoppen. Die meisten
Terminals unterstützen das Tastaturkürzel <kbd>Strg</kbd>+<kbd>c</kbd>, um ein
Programm zu unterbrechen, das in einer Endlosschleife feststeckt. Probiere es
aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
nochmal!
nochmal!
nochmal!
nochmal!
^Cnochmal!
</code></pre>
<p>Das Symbol <code>^C</code> steht für die Stelle, an der du <kbd>Strg</kbd>+<kbd>c</kbd>
gedrückt hast. Je nachdem, wo sich der Code in der Schleife befand, als er das
Unterbrechungssignal empfing, siehst du nach dem <code>^C</code> das Wort <code>nochmal!</code> oder
nicht.</p>
<p>Glücklicherweise bietet Rust auch eine Möglichkeit, aus einer Schleife
mittels Code auszubrechen. Du kannst das Schlüsselwort <code>break</code> innerhalb der
Schleife platzieren, um dem Programm mitzuteilen, wann es die Ausführung der
Schleife beenden soll. Erinnere dich, dass wir dies im Ratespiel im Abschnitt
<a href="ch02-00-guessing-game-tutorial.html#beenden-nach-einer-korrekten-sch%C3%A4tzung">„Beenden nach einer korrekten Schätzung“</a> in
Kapitel 2 getan haben, um das Programm zu beenden, wenn der Benutzer das Spiel
durch Erraten der richtigen Zahl gewonnen hat.</p>
<p>Wir haben im Ratespiel auch <code>continue</code> verwendet, das innerhalb einer Schleife
das Programm anweist, jeden restlichen Code in dieser Iteration der Schleife zu
überspringen und mit der nächsten Iteration fortzufahren.</p>
<h4 id="rückgabe-von-werten-aus-schleifen"><a class="header" href="#rückgabe-von-werten-aus-schleifen">Rückgabe von Werten aus Schleifen</a></h4>
<p>Eine der Verwendungen von <code>loop</code> besteht darin, eine Operation, von der du
weißt, dass sie fehlschlagen könnte, erneut zu versuchen, z.B. um zu prüfen, ob
ein Strang (thread) seine Arbeit abgeschlossen hat. Möglicherweise musst du
jedoch das Ergebnis dieser Operation aus der Schleife heraus an den Rest deines
Codes weitergeben. Dazu kannst du den Wert, der zurückgegeben werden soll,
hinter dem <code>break</code>-Ausdruck angeben, den du zum Beenden der Schleife
verwendest; dieser Wert wird aus der Schleife zurückgegeben, sodass du ihn
verwenden kannst, wie hier gezeigt:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("Das Ergebnis ist {result}");
}</code></pre></pre>
<p>Vor der Schleife deklarieren wir eine Variable namens <code>counter</code> und
initialisieren sie mit <code>0</code>. Dann deklarieren wir eine Variable namens <code>result</code>,
die den von der Schleife zurückgegebenen Wert enthält. Bei jeder Iteration der
Schleife addieren wir <code>1</code> zur Variable <code>counter</code> und prüfen dann, ob der Zähler
in <code>counter</code> gleich <code>10</code> ist. Wenn dies der Fall ist, verwenden wir das
Schlüsselwort <code>break</code> mit dem Wert <code>counter * 2</code>. Nach der Schleife verwenden
wir ein Semikolon, um die Anweisung zu beenden, die <code>result</code> den Wert zuweist.
Schließlich geben wir den Wert in <code>result</code> aus, der in diesem Fall <code>20</code>
beträgt.</p>
<p>Du kannst auch innerhalb einer Schleife <code>return</code> aufrufen. Während <code>break</code> nur
die aktuelle Schleife verlässt, verlässt <code>return</code> immer die aktuelle Funktion.</p>
<h4 id="schleifenlabel-zur-eindeutigen-unterscheidung-mehrerer-schleifen"><a class="header" href="#schleifenlabel-zur-eindeutigen-unterscheidung-mehrerer-schleifen">Schleifenlabel zur eindeutigen Unterscheidung mehrerer Schleifen</a></h4>
<p>Wenn du Schleifen innerhalb von Schleifen hast, gelten <code>break</code> und <code>continue</code>
für die innerste Schleife an diesem Punkt. Du kannst optional ein
<em>Schleifenlabel</em> (loop label) für eine Schleife angeben, das wir dann mit
<code>break</code> oder <code>continue</code> verwenden können, um festzulegen, dass diese
Schlüsselwörter für die gekennzeichnete Schleife gelten und nicht für die
innerste Schleife. Schleifenlabel müssen mit einem einfachen Anführungszeichen
beginnen. Hier ist ein Beispiel mit zwei verschachtelten Schleifen:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("Zähler = {count}");
        let mut remaining = 10;

        loop {
            println!("Restliche = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("Zähler-Endstand = {count}");
}</code></pre></pre>
<p>Die äußere Schleife hat das Label <code>'counting_up</code> und zählt von 0 bis 2
aufwärts. Die innere Schleife ohne Label zählt von 10 bis 9 herunter. Das erste
<code>break</code>, das kein Label angibt, beendet nur die innere Schleife. Mit der
Anweisung <code>break 'counting_up;</code> wird die äußere Schleife verlassen. Dieser Code
gibt folgendes aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
Zähler = 0
Restliche = 10
Restliche = 9
Zähler = 1
Restliche = 10
Restliche = 9
Zähler = 2
Restliche = 10
Zähler-Endstand = 2
</code></pre>
<h4 id="bedingte-schleifen-mit-while"><a class="header" href="#bedingte-schleifen-mit-while">Bedingte Schleifen mit <code>while</code></a></h4>
<p>Ein Programm wird oft eine Bedingung innerhalb einer Schleife auszuwerten
haben. Solange die Bedingung <code>true</code> ist, wird die Schleife durchlaufen. Wenn
die Bedingung nicht mehr <code>true</code> ist, ruft das Programm <code>break</code> auf und stoppt
die Schleife. Es ist möglich, derartiges Verhalten mittels einer Kombination
von <code>loop</code>, <code>if</code>, <code>else</code> und <code>break</code> zu implementieren; du kannst das jetzt in
einem Programm versuchen, wenn du möchtest. Dieses Muster ist jedoch so weit
verbreitet, dass Rust ein eingebautes Sprachkonstrukt dafür hat, die sogenannte
<code>while</code>-Schleife. In Codeblock 3-3 wird <code>while</code> verwendet: Das Programm
durchläuft dreimal eine Schleife, in der es jedes Mal abwärts zählt, und dann
nach dem Ende der Schleife eine weitere Nachricht ausgibt und sich beendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("ABHEBEN!!!");
}</code></pre></pre>
<p><span class="caption">Codeblock 3-3: Verwenden einer <code>while</code>-Schleife, um Code
auszuführen, solange eine Bedingung wahr ist</span></p>
<p>Dieses Konstrukt eliminiert eine Menge von Verschachtelungen, die notwendig
wären, wenn du <code>loop</code>, <code>if</code>, <code>else</code> und <code>break</code> verwenden würdest, und es ist
klarer. Solange eine Bedingung zu <code>true</code> auswertet, läuft der Code ab;
andernfalls wird die Schleife verlassen.</p>
<h4 id="durchlaufen-einer-kollektion-mit-for"><a class="header" href="#durchlaufen-einer-kollektion-mit-for">Durchlaufen einer Kollektion mit <code>for</code></a></h4>
<p>Du kannst das <code>while</code>-Konstrukt verwenden, um die Elemente einer Kollektion,
z.B. ein Array, in einer Schleife zu durchlaufen. Die Schleife in Codeblock 3-4
gibt zum Beispiel jedes Element im Array <code>a</code> aus.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("Der Wert ist: {}", a[index]);

        index += 1;
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 3-4: Wiederholen anhand aller Elemente einer
Kollektion unter Verwendung einer <code>while</code>-Schleife</span></p>
<p>Hier zählt der Code die Elemente im Array aufwärts. Er beginnt bei Index <code>0</code>
und wiederholt bis er den letzten Index im Array erreicht (d.h. wenn
<code>index &lt; 5</code> nicht mehr <code>true</code> ist). Wenn du diesen Code ausführst, wird jedes
Element im Array ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
Der Wert ist: 10
Der Wert ist: 20
Der Wert ist: 30
Der Wert ist: 40
Der Wert ist: 50
</code></pre>
<p>Alle fünf Array-Werte erscheinen erwartungsgemäß im Terminal. Wenn <code>index</code> den
Wert <code>5</code> erreicht hat, stoppt die Schleife ihre Ausführung, bevor sie versucht,
einen sechsten Wert aus dem Array zu holen.</p>
<p>Aber dieser Ansatz ist fehleranfällig; wir könnten das Programm zum Abstürzen
bringen, wenn der Indexwert oder die Testbedingung falsch ist. Wenn du zum
Beispiel die Definition des Arrays <code>a</code> so änderst, dass es vier Elemente hat,
aber vergisst, die Bedingung <code>while index &lt; 4</code> zu aktualisieren, würde der Code
abstürzen. Er ist zudem langsam, weil der Compiler Laufzeitcode erzeugt, der
die Bedingungsprüfung, ob der Index innerhalb der Arraygrenzen liegt, bei jeder
Schleifeniteration durchführt.</p>
<p>Als prägnantere Alternative kannst du eine <code>for</code>-Schleife verwenden und für
jedes Element einer Kollektion etwas Code ausführen. Eine <code>for</code>-Schleife sieht
wie der Code in Codeblock 3-5 aus.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("Der Wert ist: {element}");
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 3-5: Wiederholen anhand aller Elemente einer
Kollektion unter Verwendung einer <code>for</code>-Schleife</span></p>
<p>Wenn wir diesen Code ausführen, werden wir die gleiche Ausgabe wie in Codeblock
3-4 sehen. Noch wichtiger ist, dass wir jetzt die Sicherheit des Codes erhöht
und die Möglichkeit von Fehlern eliminiert haben, die dadurch entstehen
könnten, dass wir über das Ende des Arrays hinausgehen oder nicht weit genug
gehen und einige Elemente übersehen.</p>
<p>Wenn du die <code>for</code>-Schleife verwendest, brauchst du nicht daran zu denken,
irgendeinen anderen Code zu ändern, wenn du die Anzahl der Werte im Array
änderst, wie bei der Methode in Codeblock 3-4 verwendet.</p>
<p>Die Sicherheit und Prägnanz der <code>for</code>-Schleifen machen sie zum am häufigsten
verwendeten Schleifenkonstrukt in Rust. Sogar in Situationen, in denen du einen
Code bestimmt oft laufen lassen willst, wie im Countdown-Beispiel, das in
Codeblock 3-3 eine <code>while</code>-Schleife verwendet hat, würden die meisten
Rust-Entwickler eine <code>for</code>-Schleife verwenden. Der Weg, dies zu erreichen, wäre
das Verwenden eines <code>Range</code>, der von der Standardbibliothek zur Verfügung
gestellt wird und alle Zahlen in Folge generiert, beginnend mit einer Zahl und
endend vor einer anderen Zahl.</p>
<p>So würde der Countdown aussehen, wenn man eine <code>for</code>-Schleife und die Methode
<code>rev</code>, über die wir noch nicht gesprochen haben und die den <code>Range</code> umkehrt,
verwenden würde:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("ABHEBEN!!!");
}</code></pre></pre>
<p>Dieser Code ist ein bisschen schöner, nicht wahr?</p>
<h2 id="zusammenfassung-2"><a class="header" href="#zusammenfassung-2">Zusammenfassung</a></h2>
<p>Du hast es geschafft! Das war ein beachtliches Kapitel: Du lerntest etwas über
Variablen, Skalare und zusammengesetzte Datentypen, Funktionen, Kommentare,
<code>if</code>-Ausdrücke und Schleifen! Um mit den in diesem Kapitel besprochenen
Konzepten zu üben, versuche, Programme zu bauen, um Folgendes zu tun:</p>
<ul>
<li>Temperaturen zwischen Fahrenheit und Celsius umrechnen.</li>
<li>Die <em>n</em>-te Fibonacci-Zahl berechnen.</li>
<li>Den Text des Weihnachtsliedes „Die Zwölf Weihnachtstage“ (The Twelve Days of
Christmas) ausgeben und dabei die Wiederholung im Lied nutzen.</li>
</ul>
<p>Wenn du bereit bist, weiterzumachen, werden wir in Rust über ein Konzept
sprechen, das es in anderen Programmiersprachen üblicherweise <em>nicht</em> gibt:
Eigentümerschaft (ownership).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eigentümerschaft-ownership-verstehen"><a class="header" href="#eigentümerschaft-ownership-verstehen">Eigentümerschaft (ownership) verstehen</a></h1>
<p>Eigentümerschaft (ownership) ist das wichtigste Alleinstellungsmerkmal von
Rust und hat tiefgreifende Auswirkungen auf den Rest der Sprache. Sie
ermöglicht es Rust, Speichersicherheitsgarantien ohne Einsatz
einer automatischen Speicherbereinigung (garbage collector) zu geben, deshalb
ist es wichtig zu verstehen, wie Eigentümerschaft in Rust funktioniert. In
diesem Kapitel werden wir uns neben der Eigentümerschaft weitere diesbezügliche
Funktionalitäten ansehen: Ausleihen (borrowing), Anteilstypen (slices) und wie
Rust Daten im Speicher anordnet.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="was-ist-eigentümerschaft-ownership"><a class="header" href="#was-ist-eigentümerschaft-ownership">Was ist Eigentümerschaft (ownership)?</a></h2>
<p><em>Eigentümerschaft</em> ist eine Reihe von Regeln, die bestimmen, wie ein
Rust-Programm den Speicher verwaltet. Alle Programme müssen den Arbeitsspeicher
eines Rechners verwalten, während sie ausgeführt werden. Einige Sprachen
verfügen über eine automatische Speicherbereinigung, die während der
Programmausführung ständig nach nicht mehr genutztem Speicher sucht. Bei
anderen Sprachen muss der Programmierer selbst den Speicher explizit
reservieren und freigeben. Rust verwendet einen dritten Ansatz: Der Speicher
wird durch ein System aus Eigentümerschaft und einer Reihe von Regeln
verwaltet, die der Compiler überprüft. Wenn eine der Regeln verletzt wird,
lässt sich das Programm nicht kompilieren. Keine der
Eigentümerschaftsfunktionalitäten verlangsamt dein Programm, während es läuft.</p>
<p>Da die Eigentümerschaft für viele Programmierer ein neues Konzept ist, braucht
es etwas Zeit, sich daran zu gewöhnen. Die gute Nachricht ist, je mehr
Erfahrung du mit Rust und den Regeln der Eigentümerschaft gesammelt hast, desto
einfacher findest du es, auf natürliche Weise Code zu entwickeln, der sicher und
effizient ist. Bleib dran!</p>
<p>Wenn du Eigentümerschaft verstehst, hast du eine solide Grundlage, um die
Funktionalitäten zu verstehen, die Rust einzigartig machen. In diesem Kapitel
lernst du Eigentümerschaft kennen, indem du einige Beispiele durcharbeitest,
die sich auf eine sehr verbreitete Datenstruktur konzentrieren: Zeichenketten
(strings).</p>
<blockquote>
<h3 id="stapelspeicher-stack-und-haldenspeicher-heap"><a class="header" href="#stapelspeicher-stack-und-haldenspeicher-heap">Stapelspeicher (stack) und Haldenspeicher (heap)</a></h3>
<p>Viele Programmiersprachen erfordern nicht, dass du sehr oft über
Stapelspeicher und Haldenspeicher nachdenken musst. Aber in einer
Systemprogrammiersprache wie Rust hat die Frage, ob ein Wert auf dem
Stapelspeicher oder im Haldenspeicher liegt, einen größeren Einfluss darauf,
wie sich die Sprache verhält und warum du bestimmte Entscheidungen treffen
musst. Teile der Eigentümerschaft werden später in diesem Kapitel in Bezug
auf den Stapelspeicher und den Haldenspeicher beschrieben, daher hier eine
kurze Erklärung zur Vorbereitung.</p>
<p>Sowohl Stapelspeicher als auch Haldenspeicher sind Teile des
Arbeitsspeichers, die deinem Code zur Laufzeit zur Verfügung stehen, aber sie
sind unterschiedlich strukturiert. Der Stapelspeicher speichert Werte in der
Reihenfolge, in der er sie erhält, und entfernt die Werte in umgekehrter
Reihenfolge. Dies wird als <em>zuletzt herein, zuerst hinaus</em> (last in, first
out) bezeichnet. Denke an einen Stapel Teller: Wenn du weitere Teller
hinzufügst, legst du sie auf den Stapel, und wenn du einen Teller benötigst,
nimmst du einen von oben. Das Hinzufügen oder Entfernen von Tellern aus der
Mitte oder von unten würde nicht so gut funktionieren! Das Hinzufügen von
Daten nennt man <em>auf den Stapel legen</em>, und das Entfernen von Daten nennt man
<em>vom Stapel nehmen</em>. Alle im Stapelspeicher gespeicherten Daten müssen eine
bekannte, feste Größe haben. Daten mit einer zur Kompilierzeit unbekannten
Größe oder einer Größe, die sich ändern könnte, müssen stattdessen im
Haldenspeicher gespeichert werden.</p>
<p>Der Haldenspeicher ist weniger organisiert: Wenn du Daten in den
Haldenspeicher legst, forderst du eine bestimmte Menge an Speicherplatz an.
Der Speicher-Allokator (memory allocator) sucht eine leere Stelle im
Haldenspeicher, die groß genug ist, markiert sie als in Benutzung und gibt
einen <em>Zeiger</em> (pointer) zurück, der die Adresse dieser Stelle ist. Dieser
Vorgang wird als <em>Allokieren im Haldenspeicher</em> bezeichnet und manchmal mit
<em>Allokieren</em> abgekürzt. (Das Legen von Werten auf den Stapelspeicher gilt
nicht als Allokieren.) Da es sich beim Zeiger um eine bekannte, feste Größe
handelt, kannst du den Zeiger auf den Stapelspeicher legen, aber wenn du die
eigentlichen Daten benötigst, musst du dem Zeiger folgen. Stell dir vor, du
sitzt in einem Restaurant. Wenn du hineingehst, gibst du die Anzahl der
Personen deiner Gruppe an, und der Restaurantbesitzer findet einen leeren,
ausreichend großen Tisch und führt euch dorthin. Wenn jemand aus deiner
Gruppe zu spät kommt, kann er fragen, wo ihr Platz genommen habt, um euch zu
finden.</p>
<p>Das Legen auf den Stapelspeicher ist schneller als das Allokieren im
Haldenspeicher, da der Speicher-Allokator nie nach Platz zum Speichern
neuer Daten suchen muss; dieser Ort ist immer ganz oben auf dem Stapel. Im
Vergleich dazu erfordert das Allokieren von Speicherplatz im dynamischen
Speicher mehr Arbeit, da der Speicher-Allokator zunächst einen ausreichend
großen Platz für die Daten finden und dann Buch führen muss, um die nächste
Allokation vorzubereiten.</p>
<p>Der Zugriff auf Daten im Haldenspeicher ist langsamer als der Zugriff
auf Daten auf dem Stapelspeicher, da du einem Zeiger folgen musst, um dorthin
zu gelangen. Heutige Prozessoren sind schneller, wenn sie weniger im Speicher
herumspringen. Um die Analogie fortzusetzen, betrachte einen Kellner in einem
Restaurant, der an vielen Tischen Bestellungen aufnimmt. Es ist am
effizientesten, alle Bestellungen an einem Tisch aufzunehmen, bevor man zum
nächsten Tisch weitergeht. Eine Bestellung von Tisch A, dann eine Bestellung
von Tisch B, dann wieder eine von A und dann wieder eine von B aufzunehmen,
wäre ein viel langsamerer Vorgang. Umgekehrt kann ein Prozessor seine Arbeit
besser erledigen, wenn er mit Daten arbeitet, die nahe beieinander liegen
(wie sie auf dem Stapelspeicher liegen) und nicht weiter voneinander entfernt
(wie sie im Haldenspeicher liegen können). Das Allokieren einer großen
Menge an Platz im Haldenspeicher kann ebenfalls Zeit in Anspruch
nehmen.</p>
<p>Wenn dein Code eine Funktion aufruft, werden die an die Funktion übergebenen
Werte (einschließlich potentieller Zeiger auf Daten im Haldenspeicher)
und die lokalen Variablen der Funktion auf den Stapelspeicher gelegt. Wenn
die Funktion beendet ist, werden diese Werte vom Stapelspeicher genommen.</p>
<p>Das Nachverfolgen, welche Codeteile welche Daten im Haldenspeicher
verwenden, das Minimieren der Menge an doppelten Daten im Haldenspeicher
und das Aufräumen ungenutzter Daten im Haldenspeicher, damit
dir der Speicherplatz nicht ausgeht, sind alles Probleme, die durch
Eigentümerschaft gelöst werden. Wenn du Eigentümerschaft einmal verstanden
hast, brauchst du nicht mehr so oft über Stapelspeicher und Haldenspeicher
nachzudenken. Aber zu wissen, dass der Hauptzweck der Eigentümerschaft die
Verwaltung der Haldenspeicher-Daten ist, kann helfen zu erklären, warum es so
funktioniert, wie es funktioniert.</p>
</blockquote>
<h3 id="eigentumsregeln"><a class="header" href="#eigentumsregeln">Eigentumsregeln</a></h3>
<p>Lass uns zunächst einen Blick auf die Eigentumsregeln (ownership rules) werfen.
Behalte diese Regeln im Hinterkopf, während wir veranschaulichende Beispiele
durcharbeiten:</p>
<ul>
<li>Jeder Wert in Rust hat einen <em>Eigentümer</em> (owner).</li>
<li>Es kann immer nur einen Eigentümer zur gleichen Zeit geben.</li>
<li>Wenn der Eigentümer den Gültigkeitsbereich verlässt, wird der Wert
aufgeräumt.</li>
</ul>
<h3 id="gültigkeitsbereich-scope-einer-variable"><a class="header" href="#gültigkeitsbereich-scope-einer-variable">Gültigkeitsbereich (scope) einer Variable</a></h3>
<p>Da wir nun über die grundlegende Syntax hinausgehen, werden wir nicht mehr den
gesamten <code>fn main() {</code>-Code in die Beispiele aufnehmen. Wenn du also
weitermachst, musst du die folgenden Beispiele manuell in eine Funktion <code>main</code>
einfügen. Folglich werden unsere Beispiele etwas prägnanter sein, damit wir uns
auf die eigentlichen Details konzentrieren können, anstatt auch den Code darum
herum betrachten zu müssen.</p>
<p>Als erstes Beispiel zu Eigentümerschaft werden wir uns den <em>Gültigkeitsbereich</em>
(scope) einiger Variablen ansehen. Der Gültigkeitsbereich ist der Bereich
innerhalb eines Programms, in dem ein Element gültig ist. Sieh dir folgende
Variable an:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hallo";
<span class="boring">}</span></code></pre></pre>
<p>Die Variable <code>s</code> bezieht sich auf ein Zeichenkettenliteral, wobei der Wert der
Zeichenkette fest in den Text unseres Programms kodiert ist. Die Variable ist
ab der Stelle, an der sie deklariert wurde, bis zum Ende des aktuellen
<em>Gültigkeitsbereichs</em> gültig. Codeblock 4-1 zeigt ein Programm mit Kommentaren,
die zeigen wo die Variable <code>s</code> gültig ist.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{                      // s ist hier nicht gültig, es wurde noch nicht deklariert
    let s = "Hallo";   // s ist ab dieser Stelle gültig

    // etwas mit s machen
}                      // dieser Gültigkeitsbereich ist nun vorbei,
                       // und s ist nicht mehr gültig
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 4-1: Eine Variable und der Bereich, in dem sie
gültig ist</span></p>
<p>Mit anderen Worten, es gibt hier zwei wichtige Zeitpunkte:</p>
<ul>
<li>Wenn <code>s</code> <em>in den Gültigkeitsbereich kommt</em>, ist es gültig.</li>
<li>Es bleibt gültig, bis es <em>den Gültigkeitsbereich verlässt</em>.</li>
</ul>
<p>An diesem Punkt ist die Beziehung zwischen Gültigkeitsbereichen und wann
Variablen gültig sind ähnlich zu anderen Programmiersprachen. Nun werden wir
auf diesem Verständnis aufbauen, indem wir den Typ <code>String</code> einführen.</p>
<h3 id="der-typ-string"><a class="header" href="#der-typ-string">Der Typ <code>String</code></a></h3>
<p>Um die Eigentumsregeln zu veranschaulichen, benötigen wir einen Datentyp, der
komplexer ist als die, die wir im Abschnitt <a href="ch03-02-data-types.html">„Datentypen“</a> in
Kapitel 3 behandelt haben. Die zuvor behandelten Typen haben eine bekannte
Größe, können auf dem Stapelspeicher gelegt und vom Stapelspeicher entfernt
werden, wenn ihr Gültigkeitsbereich beendet ist, und können schnell und trivial
kopiert werden, um eine neue, unabhängige Instanz zu erzeugen, wenn ein anderer
Teil des Codes denselben Wert in einem anderen Gültigkeitsbereich verwenden
muss. Wir wollen uns jedoch Daten ansehen, die im Haldenspeicher gespeichert
sind, und untersuchen, woher Rust weiß, wann es diese Daten aufräumen muss, und
der Typ <code>String</code> ist ein gutes Beispiel dafür.</p>
<p>Wir werden uns auf die Teile von <code>String</code> konzentrieren, die sich auf die
Eigentümerschaft beziehen. Diese Aspekte gelten auch für andere komplexe
Datentypen, unabhängig davon, ob sie von der Standardbibliothek bereitgestellt
oder von dir erstellt wurden. Wir werden <code>String</code> in <a href="ch08-02-strings.html">Kapitel 8</a>
eingehender behandeln.</p>
<p>Wir haben bereits Zeichenkettenliterale gesehen, bei denen ein
Zeichenkettenwert fest in unserem Programm kodiert ist. Zeichenkettenliterale
sind praktisch, aber sie eignen sich nicht für jede Situation, in der wir Text
verwenden möchten. Ein Grund dafür ist, dass sie unveränderbar sind. Ein
anderer Grund ist, dass nicht jeder Zeichenkettenwert bekannt ist, wenn wir
unseren Code schreiben: Was ist zum Beispiel, wenn wir Benutzereingaben
entgegennehmen und speichern wollen? Für diese Situationen hat Rust einen
zweiten Zeichenkettentyp: <code>String</code>. Dieser Typ verwaltet Daten, die auf dem
Haldenspeicher allokiert sind, und kann so eine Textmenge speichern, die uns
zur Kompilierzeit unbekannt ist. Du kannst einen <code>String</code> aus einem
Zeichenkettenliteral erzeugen, indem du die Funktion <code>from</code> wie folgt
verwendest:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("Hallo");
<span class="boring">}</span></code></pre></pre>
<p>Der doppelte Doppelpunkt (<code>::</code>) Operator erlaubt uns, diese spezielle Funktion
<code>from</code> mit dem Namensraum des <code>String</code>-Typs zu benennen, anstatt einen Namen
wie <code>string_from</code> zu verwenden. Wir werden diese Syntax im Abschnitt
<a href="ch05-03-method-syntax.html">„Methodensyntax“</a> in Kapitel 5 näher betrachten, und wenn wir
in Kapitel 7 unter <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit Pfaden auf ein Element im Modulbaum
verweisen“</a> über den Namensraum mit Modulen sprechen.</p>
<p>Diese Art von Zeichenkette kann <em>verändert</em> werden:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from("Hallo");

s.push_str(" Welt!"); // push_str() hängt ein Literal an eine Zeichenfolge an

println!("{s}"); // Gibt `Hallo Welt!` aus
<span class="boring">}</span></code></pre></pre>
<p>Was ist hier nun der Unterschied? Warum kann <code>String</code> verändert werden,
Literale jedoch nicht? Der Unterschied liegt darin, wie diese beiden Typen mit
dem Arbeitsspeicher umgehen.</p>
<h3 id="speicher-und-allokation"><a class="header" href="#speicher-und-allokation">Speicher und Allokation</a></h3>
<p>Im Falle eines Zeichenkettenliterals kennen wir den Inhalt zum Zeitpunkt der
Kompilierung, sodass der Text direkt in die endgültige ausführbare Datei fest
kodiert wird. Aus diesem Grund sind Zeichenkettenliterale schnell und
effizient. Allerdings ergeben sich diese Eigenschaften nur aus der
Unveränderbarkeit des Zeichenkettenliterals. Leider können wir nicht für jedes
Stück Text, dessen Größe zum Zeitpunkt der Kompilierung unbekannt ist und
dessen Größe sich während der Ausführung des Programms ändern könnte, einen
Speicherblock in die Binärdatei packen.</p>
<p>Um mit dem Typ <code>String</code> einen veränderbaren, größenänderbaren Textabschnitt zu
unterstützen, müssen wir Speicher im Haldenspeicher allokieren, dessen
Größe zur Kompilierzeit unbekannt ist. Dies bedeutet:</p>
<ul>
<li>Der Speicher muss zur Laufzeit vom Speicher-Allokator angefordert werden.</li>
<li>Wir brauchen eine Möglichkeit, diesen Speicher an den Speicher-Allokator
zurückzugeben, wenn wir mit unserem <code>String</code> fertig sind.</li>
</ul>
<p>Der erste Teil wird von uns erledigt: Wenn wir <code>String::from</code> aufrufen, fordert
seine Implementierung den Speicher an, den sie benötigt. Dies ist in
Programmiersprachen ziemlich einheitlich.</p>
<p>Der zweite Teil ist jedoch anders. In Sprachen mit einer <em>automatischen
Speicherbereinigung</em> (garbage collector, GC) behält der GC den Überblick und
räumt Speicherplatz, der nicht mehr verwendet wird, auf; wir brauchen nicht
darüber nachzudenken. Ohne einen GC liegt es in unserer Verantwortung, zu
erkennen, wann Speicherplatz nicht mehr benutzt wird, und Code aufzurufen, der
ihn explizit zurückgibt, so wie wir es beim Anfordern auch getan haben. Dies
korrekt zu tun, war in der Vergangenheit ein schwieriges Programmierproblem.
Wenn wir es vergessen, verschwenden wir Speicher. Wenn wir es zu früh machen,
haben wir eine ungültige Variable. Wenn wir es zweimal machen, ist das auch ein
Fehler. Wir müssen eine <em>Allokierung</em> mit genau einer <em>Freigabe</em> paaren.</p>
<p>Rust geht einen anderen Weg: Der Speicher wird automatisch zurückgegeben,
sobald die Variable, die ihn besitzt, den Gültigkeitsbereich verlässt. Hier ist
eine Variante unseres Gültigkeitsbereich-Beispiels aus Codeblock 4-1, bei der
ein <code>String</code> anstelle eines Zeichenkettenliterals verwendet wird:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from("Hallo"); // s ist ab dieser Stelle gültig

    // etwas mit s machen
}                                  // dieser Gültigkeitsbereich ist nun vorbei,
                                   // und s ist nicht mehr gültig
<span class="boring">}</span></code></pre></pre>
<p>Es gibt eine natürliche Stelle, an der wir den Speicher, den unser <code>String</code>
benötigt, an den Speicher-Allokator zurückgeben können: Wenn <code>s</code> den
Gültigkeitsbereich verlässt. Wenn eine Variable den Gültigkeitsbereich
verlässt, ruft Rust für uns eine spezielle Funktion auf: Diese Funktion heißt
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a> und an dieser Stelle kann der Autor von <code>String</code> Code
einfügen, um den Speicher zurückzugeben. Rust ruft <code>drop</code> automatisch an der
schließenden geschweiften Klammer auf.</p>
<blockquote>
<p>Hinweis: In C++ wird dieses Muster der Freigabe von Ressourcen am Ende der
Lebensdauer eines Elements manchmal als <em>Ressourcenbelegung ist
Initialisierung</em> (resource acquisition is initialization, RAII) bezeichnet.
Die Funktion <code>drop</code> in Rust wird dir vertraut vorkommen, wenn du bereits
RAII-Muster verwendet hast.</p>
</blockquote>
<p>Dieses Muster hat einen tiefgreifenden Einfluss auf die Art und Weise, wie
Rust-Code geschrieben wird. Es mag im Moment einfach erscheinen, aber das
Verhalten von Code kann in komplizierteren Situationen unerwartet sein, wenn
wir wollen, dass mehrere Variablen Daten verwenden, die wir im dynamischen
Speicher allokiert haben. Lass uns jetzt einige dieser Situationen untersuchen.</p>
<h4 id="variablen-und-daten-im-zusammenspiel-mit-move"><a class="header" href="#variablen-und-daten-im-zusammenspiel-mit-move">Variablen und Daten im Zusammenspiel mit Move</a></h4>
<p>Mehrere Variablen können in Rust auf unterschiedliche Weise mit denselben Daten
interagieren. Betrachten wir ein Beispiel mit einer ganzen Zahl in Codeblock
4-2.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 4-2: Zuweisen des ganzzahligen Wertes der
Variablen <code>x</code> an <code>y</code></span></p>
<p>Wir können wahrscheinlich erahnen, was das bewirkt: „Binde den Wert <code>5</code> an <code>x</code>;
dann erstelle eine Kopie des Wertes in <code>x</code> und binde ihn an <code>y</code>.“ Wir haben
jetzt zwei Variablen <code>x</code> und <code>y</code> und beide sind gleich <code>5</code>. Das ist in der Tat
der Fall, denn ganze Zahlen sind einfache Werte mit einer bekannten, festen
Größe, und diese beiden Werte <code>5</code> werden auf den Stapelspeicher gelegt.</p>
<p>Schauen wir uns nun die <code>String</code>-Variante an:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("Hallo");
let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>Dies sieht sehr ähnlich aus, sodass wir annehmen könnten, dass die
Funktionsweise die gleiche wäre: Das heißt, die zweite Zeile würde eine Kopie
des Wertes in <code>s1</code> erstellen und sie an <code>s2</code> binden. Aber das ist nicht ganz
das, was passiert.</p>
<p>Betrachte Abbildung 4-1, um zu sehen, was mit dem <code>String</code> unter der Haube
geschieht. Ein <code>String</code> besteht aus drei Teilen, die auf der linken Seite
dargestellt sind: Einem Zeiger auf den Speicherbereich, der den Inhalt der
Zeichenkette enthält, die Länge und die Kapazität. Dieser Datenblock wird auf
dem Stapelspeicher gespeichert. Auf der rechten Seite ist der Speicherbereich
im Haldenspeicher, der den Inhalt enthält.</p>
<p><img alt="Zwei Tabellen: Die erste Tabelle enthält die Darstellung von s1 auf
dem Stapelspeicher, bestehend aus seiner Länge (5), seiner Kapazität (5) und
einem Zeiger auf den ersten Wert in der zweiten Tabelle. Die zweite Tabelle
enthält die Darstellung der Zeichenkettendaten auf dem Haldenspeicher, Byte für
Byte." src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-1: Speicherdarstellung eines <code>String</code> mit dem
Wert „Hallo“, gebunden an <code>s1</code></span></p>
<p>Die Länge gibt an, wie viel Speicherplatz in Bytes der Inhalt der Zeichenkette
derzeit belegt. Die Kapazität ist die Gesamtmenge des Speichers in Bytes, die
der <code>String</code> vom Speicher-Allokator erhalten hat. Der Unterschied zwischen
Länge und Kapazität ist von Bedeutung, aber nicht in diesem Zusammenhang,
deshalb ist es im Moment in Ordnung, die Kapazität zu ignorieren.</p>
<p>Wenn wir <code>s1</code> an <code>s2</code> zuweisen, werden die <code>String</code>-Daten kopiert, d.h. wir
kopieren den Zeiger, die Länge und die Kapazität, die sich auf dem
Stapelspeicher befinden. Wir kopieren nicht die Daten im Haldenspeicher,
auf die sich der Zeiger bezieht. Die Speicherdarstellung sieht also wie in
Abbildung 4-2 aus.</p>
<p><img alt="Drei Tabellen: Die Tabellen s1 und s2, die die Zeichenketten auf dem
Stapelspeicher repräsentieren und beide auf die gleichen Zeichenkettendaten auf
dem Haldenspeicher verweisen." src="img/trpl04-02.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-2: Speicherdarstellung der Variable <code>s2</code>, die
eine Kopie des Zeigers, der Länge und der Kapazität von <code>s1</code> hat</span></p>
<p>Die Darstellung sieht <em>nicht</em> wie Abbildung 4-3 aus, so wie der Speicher
aussehen würde, wenn Rust stattdessen auch die Daten im Haldenspeicher
kopieren würde. Würde Rust dies tun, könnte die Operation <code>s2 = s1</code> bei großen
Datenmengen im Haldenspeicher sehr teuer hinsichtlich der
Laufzeitperformanz werden.</p>
<p><img alt="Vier Tabellen: Zwei Tabellen, die die Stapelspeicher-Daten für s1 und
s2 darstellen, und jede zeigt auf ihre eigene Kopie der Zeichenketten-Daten auf
dem Haldenspeicher." src="img/trpl04-03.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-3: Eine weitere Möglichkeit für das, was
<code>s2 = s1</code> tun könnte, falls Rust auch die Daten im Haldenspeicher
kopieren würde</span></p>
<p>Vorhin sagten wir, dass Rust automatisch die Funktion <code>drop</code> aufruft und den
Haldenspeicher für diese Variable aufräumt, wenn eine Variable den
Gültigkeitsbereich verlässt. Abbildung 4-2 zeigt jedoch, dass beide Datenzeiger
auf dieselbe Stelle zeigen. Das ist ein Problem: Wenn <code>s2</code> und <code>s1</code> den
Gültigkeitsbereich verlassen, werden beide versuchen, den gleichen Speicher
freizugeben. Dies wird als <em>doppelter Freigabefehler</em> (double free error)
bezeichnet und ist einer der Speichersicherheitsfehler, die wir zuvor erwähnt
haben. Das zweimalige Freigeben des Speichers kann zu einer
Speicherverfälschung führen, was potenziell zu Sicherheitslücken führen kann.</p>
<p>Um Speichersicherheit zu gewährleisten, betrachtet Rust nach der Zeile <code>let s2 = s1;</code> die Variable <code>s1</code> als nicht mehr gültig. Daher braucht Rust nichts
freizugeben, wenn <code>s1</code> den Gültigkeitsbereich verlässt. Schau dir an, was
passiert, wenn du versuchst, <code>s1</code> zu benutzen, nachdem <code>s2</code> erstellt wurde; es
wird nicht funktionieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("Hallo");
let s2 = s1;

println!("{s1} Welt!");
<span class="boring">}</span></code></pre></pre>
<p>Du erhältst eine Fehlermeldung wie diese, wodurch Rust dich daran hindert, die
ungültige Referenz zu verwenden:</p>
<pre><code class="language-console">   Compiling playground v0.0.1 (/playground)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:6:11
  |
3 | let s1 = String::from("Hallo");
  |     -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
4 | let s2 = s1;
  |          -- value moved here
5 |
6 | println!("{s1} Welt!");
  |           ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
4 | let s2 = s1.clone();
  |            ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `playground` (bin "playground") due to 1 previous error
</code></pre>
<p>Wenn du beim Arbeiten mit anderen Sprachen schon mal die Begriffe <em>flache
Kopie</em> (shallow copy) und <em>tiefe Kopie</em> (deep copy) gehört hast, hört sich das
Konzept des Kopierens des Zeigers, der Länge und der Kapazität ohne Kopieren
der Daten nach einer flachen Kopie an. Aber weil Rust auch die erste Variable
ungültig macht, wird es nicht als flache Kopie, sondern als <em>Verschieben</em>
(move) bezeichnet. In diesem Beispiel würden wir sagen, dass <code>s1</code> in <code>s2</code>
<em>verschoben</em> wurde. Was tatsächlich geschieht, ist in Abbildung 4-4
dargestellt.</p>
<p><img alt="Drei Tabellen: Die Tabellen s1 und s2, die jeweils die Zeichenketten
auf dem Stapelspeicher darstellen und beide auf dieselben Zeichenkettendaten
auf dem Haldenspeicher referenzieren. Die Tabelle s1 ist durchgestrichen, weil
s1 nicht mehr gültig ist; nur s2 kann für den Zugriff auf die
Haldenspeicher-Daten verwendet werden." src="img/trpl04-04.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-4: Speicherdarstellung, nachdem <code>s1</code> ungültig
gemacht wurde</span></p>
<p>Damit ist unser Problem gelöst! Da nur <code>s2</code> gültig ist, wenn es den
Gültigkeitsbereich verlässt, wird es allein den Speicher freigeben, und wir
sind fertig.</p>
<p>Darüber hinaus gibt es eine Entwurfsentscheidung, die damit impliziert ist:
Rust wird niemals automatisch „tiefe“ Kopien deiner Daten erstellen. Daher kann
man davon ausgehen, dass jedes <em>automatische</em> Kopieren im Hinblick auf die
Laufzeitperformanz kostengünstig ist.</p>
<h4 id="gültigkeitsbereich-und-zuweisung"><a class="header" href="#gültigkeitsbereich-und-zuweisung">Gültigkeitsbereich und Zuweisung</a></h4>
<p>Umgekehrt gilt dies auch für die Beziehung zwischen Gültigkeitsbereich,
Eigentümerschaft und Speicherfreigabe durch die Funktion <code>drop</code>. Wenn du einer
bestehenden Variablen einen völlig neuen Wert zuweist, ruft Rust die Funktion
<code>drop</code> auf und gibt den Speicher des ursprünglichen Wertes sofort frei.
Betrachte zum Beispiel diesen Code:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("Hallo");
    s = String::from("Ahoi");

    println!("{s} Welt!");
<span class="boring">}</span></code></pre></pre>
<p>Wir deklarieren zunächst eine Variable <code>s</code> und binden sie an einen <code>String</code> mit
dem Wert <code>„Hallo“</code>. Danach erstellen wir eine neue Zeichenkette mit dem Wert
„Ahoi“ und weisen sie der Variable „s“ zu. Zu diesem Zeitpunkt referenziert
nichts mehr auf den ursprünglichen Wert im Haldenspeicher.</p>
<p><img alt="Eine Tabelle stellt den Zeichenketten-Wert auf dem Haldenspeicher dar
und zeigt auf den zweiten Teil der Zeichenketten-Daten (Ahoi) auf dem
Haldenspeicher, wobei die ursprünglichen Zeichenketten-Daten (Hallo)
durchgestrichen sind, weil auf sie nicht mehr zugegriffen werden kann."
src="img/trpl04-05.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-5: Darstellung im Speicher, nachdem der
ursprüngliche Wert vollständig ersetzt worden ist.</span></p>
<p>Die ursprüngliche Zeichenkette verlässt damit sofort den Gültigkeitsbereich.
Rust führt die Funktion <code>drop</code> aus und ihr Speicher wird sofort freigegeben.
Wenn wir den Wert am Ende ausgeben, lautet er „Ahoi Welt!“.</p>
<h4 id="variablen-und-daten-im-zusammenspiel-mit-clone"><a class="header" href="#variablen-und-daten-im-zusammenspiel-mit-clone">Variablen und Daten im Zusammenspiel mit Clone</a></h4>
<p>Wenn wir die Daten von <code>String</code> im Haldenspeicher <em>tief</em> kopieren wollen,
nicht nur die Stapelspeicher-Daten, können wir eine gängige Methode namens
<code>clone</code> verwenden. Wir werden die Methodensyntax in Kapitel 5 besprechen, aber
da Methoden eine gängige Funktionalität vieler Programmiersprachen sind, hast
du sie wahrscheinlich schon einmal gesehen.</p>
<p>Hier ist ein Beispiel für die Methode <code>clone</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("Hallo");
let s2 = s1.clone();

println!("s1 = {s1}, s2 = {s2}");
<span class="boring">}</span></code></pre></pre>
<p>Das funktioniert sehr gut und erzeugt explizit das in Abbildung 4-3 gezeigte
Verhalten, bei dem die Daten im Haldenspeicher <em>kopiert</em> werden.</p>
<p>Wenn du einen Aufruf von <code>clone</code> siehst, weißt du, dass irgendein beliebiger
Code ausgeführt wird und dass dieser Code teuer sein könnte. Es ist ein
visueller Indikator dafür, dass etwas anderes vor sich geht.</p>
<h4 id="nur-stapelspeicher-daten-kopieren-copy"><a class="header" href="#nur-stapelspeicher-daten-kopieren-copy">Nur Stapelspeicher-Daten: Kopieren (copy)</a></h4>
<p>Es gibt noch einen weiteren Kniff, über den wir noch nicht gesprochen haben.
Folgender Code mit ganzen Zahlen, der teilweise in Codeblock 4-2 gezeigt wurde,
funktioniert und ist gültig:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!("x = {x}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p>Aber dieser Code scheint dem zu widersprechen, was wir gerade gelernt haben:
Wir haben keinen Aufruf von <code>clone</code>, aber <code>x</code> ist immer noch gültig und wurde
nicht in <code>y</code> verschoben.</p>
<p>Der Grund dafür ist, dass Typen wie ganze Zahlen, die zur Kompilierzeit eine
bekannte Größe haben, vollständig auf dem Stack gespeichert werden, so dass
Kopien der tatsächlichen Werte schnell erstellt werden können. Das bedeutet,
dass es keinen Grund gibt, warum wir verhindern wollen, dass <code>x</code> gültig ist,
nachdem wir die Variable <code>y</code> erstellt haben. Mit anderen Worten, es gibt hier
keinen Unterschied zwischen tiefen und flachen Kopien, also würde der Aufruf
<code>clone</code> nichts anderes tun als das übliche flache Kopieren, und wir können es
weglassen.</p>
<p>Rust hat eine spezielle Annotation, das Merkmal <code>Copy</code>, die wir an Typen hängen
können, die auf dem Stapelspeicher wie ganze Zahlen gespeichert sind (wir
werden in <a href="ch10-02-traits.html">Kapitel 10</a> mehr über Merkmale sprechen). Wenn ein Typ das
Merkmal <code>Copy</code> implementiert, werden Variablen, die dieses Merkmal verwenden,
nicht verschoben, sondern trivialerweise kopiert, sodass sie auch nach der
Zuweisung an eine andere Variable noch gültig sind.</p>
<p>Rust lässt uns einen Typ nicht mit dem Merkmal <code>Copy</code> annotieren, wenn der Typ
oder einer seiner Teile das Merkmal <code>Drop</code> implementiert. Wenn der Typ eine
Sonderbehandlung benötigt, wenn der Wert den Gültigkeitsbereich verlässt und
wir die Annotation <code>Copy</code> zu diesem Typ hinzufügen, erhalten wir einen
Kompilierfehler. Um zu erfahren, wie du die <code>Copy</code>-Annotation zu deinem Typ
hinzufügen kannst, siehe <a href="appendix-03-derivable-traits.html">„Ableitbare Merkmale (traits)“</a> in
Anhang C.</p>
<p>Welche Typen unterstützen also <code>Copy</code>? Du kannst die Dokumentation für einen
gegebenen Typ überprüfen, um sicherzugehen, aber als allgemeine Regel gilt:
Jede Gruppierung von einfachen skalaren Werten unterstützt <code>Copy</code>, und nichts,
was eine Allokation erfordert oder irgendeine Form von Ressource ist, kann
<code>Copy</code> implementieren. Hier sind einige Typen, die <code>Copy</code> unterstützen:</p>
<ul>
<li>Alle ganzzahligen Typen, z.B. <code>u32</code>.</li>
<li>Der boolesche Typ <code>bool</code> mit den Werten <code>true</code> und <code>false</code>.</li>
<li>Alle Fließkomma-Typen, z.B. <code>f64</code>.</li>
<li>Der Zeichentyp <code>char</code>.</li>
<li>Tupel, wenn sie nur Typen enthalten, die auch <code>Copy</code> unterstützen. Zum
Beispiel unterstützt <code>(i32, i32)</code> <code>Copy</code>, nicht aber <code>(i32, String)</code>.</li>
</ul>
<h3 id="eigentümerschaft-und-funktionen"><a class="header" href="#eigentümerschaft-und-funktionen">Eigentümerschaft und Funktionen</a></h3>
<p>Die Übergabe eines Wertes an eine Funktion funktioniert ähnlich wie die
Zuweisung eines Wertes an eine Variable. Wenn eine Variable an eine Funktion
übergeben wird, wird sie verschoben oder kopiert, genau wie bei der Zuweisung.
Codeblock 4-3 enthält ein Beispiel mit einigen Anmerkungen, aus denen
hervorgeht, wo Variablen in den Gültigkeitsbereich fallen und wo nicht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let s = String::from("Hallo");  // s kommt in den Gültigkeitsbereich

    takes_ownership(s);             // Der Wert von s wird in die Funktion
                                    // verschoben und ist daher hier nicht
                                    // mehr gültig.

    let x = 5;                      // x kommt in den Gültigkeitsbereich

    makes_copy(x);                  // x würde in die Funktion verschoben werden,
                                    // aber i32 erlaubt Copy, also ist es in
                                    // Ordnung, danach immer noch x zu verwenden.

} // Hier verlassen s und x den Gültigkeitsbereich.
  // Aber weil der Wert von s verschoben wurde, passiert nichts Besonderes.

fn takes_ownership(some_string: String) { // some_string kommt in den
                                          // Gültigkeitsbereich
    println!("{some_string}");
} // Hier verlässt some_string den Gültigkeitsbereich und `drop` wird aufgerufen.
  // Der zugehörige Speicherplatz wird freigegeben.

fn makes_copy(some_integer: i32) { // some_integer kommt in den Gültigkeitsbereich
    println!("{some_integer}");
} // Hier verlässt some_integer den Gültigkeitsbereich.
  // Es passiert nichts Besonderes.</code></pre></pre>
<p><span class="caption">Codeblock 4-3: Funktionen mit kommentierter
Eigentümerschaft und Gültigkeitsbereich</span></p>
<p>Wenn wir versuchen würden, <code>s</code> nach dem Aufruf von <code>takes_ownership</code> zu
verwenden, würde Rust einen Kompilierfehler anzeigen. Diese statischen
Prüfungen schützen uns vor Fehlern. Versuche, weiteren Code zu <code>main</code>
hinzuzufügen, der <code>s</code> und <code>x</code> verwendet, um zu sehen, wo du sie verwenden
kannst und wo die Eigentumsregeln dich daran hindern.</p>
<h3 id="rückgabewerte-und-gültigkeitsbereich"><a class="header" href="#rückgabewerte-und-gültigkeitsbereich">Rückgabewerte und Gültigkeitsbereich</a></h3>
<p>Rückgabewerte können auch Eigentümerschaft übertragen. Codeblock 4-4 ist ein
Beispiel für eine Funktion mit einem Rückgabewert mit ähnlichen Anmerkungen wie
die in Codeblock 4-3.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let s1 = gives_ownership();         // gives_ownership verschiebt seinen
                                        // Rückgabewert in s1

    let s2 = String::from("Hallo");     // s2 kommt in den Gültigkeitsbereich

    let s3 = takes_and_gives_back(s2);  // s2 wird in takes_and_gives_back
                                        // verschoben und der Rückgabewert
                                        // wird in s3 verschoben

} // Hier verlässt s3 den Gültigkeitsbereich und wird aufgeräumt.
  // s2 wurde verschoben, es passiert also nichts.
  // s1 verlässt den Gültigkeitsbereich und wird aufgeräumt.

fn gives_ownership() -&gt; String {        // gives_ownership verschiebt seinen
                                        // Rückgabewert in die aufrufende Funktion

    let some_string = String::from("Hallo"); // some_string kommt in den
                                             // Gültigkeitsbereich

    some_string                         // some_string wird zurückgegeben und
                                        // wird an die aufrufende Funktion
                                        // verschoben
}

// Diese Funktion nimmt einen String entgegen und gibt einen zurück
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string kommt in den
                                                      // Gültigkeitsbereich

    a_string  // a_string wird zurückgegeben und
              // an die aufrufende Funktion verschoben
}</code></pre></pre>
<p><span class="caption">Codeblock 4-4: Übertragen der Eigentümerschaft an Rückgabewerten</span></p>
<p>Die Eigentümerschaft an einer Variable folgt jedes Mal dem gleichen Muster: Das
Zuweisen eines Wertes an eine andere Variable verschiebt diese. Wenn eine
Variable, die Daten im Haldenspeicher enthält, den Gültigkeitsbereich
verlässt, wird der Wert durch <code>drop</code> aufgeräumt, es sei denn, die
Eigentümerschaft wurde auf eine andere Variable verschoben.</p>
<p>Dies funktioniert zwar, allerdings ist es etwas mühsam, die Eigentümerschaft zu
übernehmen und in jeder Funktion zurückzugeben. Was ist, wenn wir eine Funktion
einen Wert nutzen lassen wollen, aber nicht die Eigentümerschaft übergeben
wollen? Es ist ziemlich lästig, dass alles, was wir übergeben, auch wieder
zurückgegeben werden muss, wenn wir es wieder verwenden wollen, zusätzlich zu
den Daten, die sich aus dem Funktionsrumpf ergeben, die wir vielleicht auch
zurückgeben wollen.</p>
<p>Rust macht es es möglich, mehrere Werte mit Hilfe eines Tupels zurückzugeben,
wie in Codeblock 4-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let s1 = String::from("Hallo");

    let (s2, len) = calculate_length(s1);

    println!("Die Länge von '{s2}' ist {len}.");
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() gibt die Länge der Zeichenkette zurück

    (s, length)
}</code></pre></pre>
<p><span class="caption">Codeblock 4-5: Rückgeben der Eigentümerschaft an
Parametern</span></p>
<p>Aber das ist zu viel Zeremonie und zu viel Arbeit für ein Konzept, das
gebräuchlich sein sollte. Zum Glück gibt es in Rust eine Funktion, mit der man
einen Wert verwenden kann, ohne die Eigentümerschaft zu übertragen, nämlich
<em>Referenzen</em> (references).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referenzen-und-ausleihen-borrowing"><a class="header" href="#referenzen-und-ausleihen-borrowing">Referenzen und Ausleihen (borrowing)</a></h2>
<p>Das Problem mit dem Tupelcode in Codeblock 4-5 ist, dass wir der aufrufenden
Funktion den <code>String</code> zurückgeben müssen, damit wir den <code>String</code> nach dem
Aufruf von <code>calculate_length</code> weiter verwenden können, weil der <code>String</code> in
<code>calculate_length</code> verschoben wurde. Stattdessen können wir eine Referenz auf
den <code>String</code>-Wert angeben. Eine <em>Referenz</em> ist wie ein Zeiger, d.h. eine
Adresse, der wir folgen können, um auf Daten zugreifen zu können, die an dieser
Adresse gespeichert sind und einer anderen Variablen gehören. Im Gegensatz zu
einem Zeiger ist bei einer Referenz garantiert, dass sie auf einen gültigen
Wert eines bestimmten Typs zeigt.</p>
<p>Im Folgenden siehst du, wie du eine Funktion <code>calculate_length</code> definieren und
verwenden kannst, die eine Referenz auf ein Objekt als Parameter hat, anstatt
die Eigentümerschaft (ownership) des Wertes zu übernehmen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let s1 = String::from("Hallo");

    let len = calculate_length(&amp;s1);

    println!("Die Länge von '{s1}' ist {len}.");
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
<p>Beachte, dass der gesamte Tupelcode aus der Variablendeklaration und dem
Rückgabewert der Funktion verschwunden ist. Beachte des Weiteren, dass wir
<code>&amp;s1</code> an <code>calculate_length</code> übergeben und in seiner Definition <code>&amp;String</code> statt
<code>String</code> steht. Das <code>&amp;</code>-Zeichen steht für eine <em>Referenz</em>, und sie ermöglicht
es dir, sich auf einen Wert zu beziehen, ohne dessen Eigentümerschaft zu
übernehmen. Abbildung 4-6 zeigt die Speicherdarstellung.</p>
<p><img alt="Drei Tabellen: Die Tabelle für s enthält nur einen Zeiger auf die
Tabelle für s1. Die Tabelle für s1 enthält die Stapelspeicher-Daten für s1 und
zeigt auf die Zeichenketten-Daten auf dem Haldenspeicher."
src="img/trpl04-06.svg" class="center" /></p>
<p><span class="caption">Abbildung 4-6: Eine Grafik mit <code>&amp;String s</code>, das auf
<code>String s1</code> zeigt</span></p>
<blockquote>
<p>Anmerkung: Das Gegenteil der Referenzierung durch <code>&amp;</code> ist die
<em>Dereferenzierung</em> (dereferencing), die mittels Dereferenzoperator <code>*</code>
erfolgt. Wir werden in Kapitel 8 einige Verwendungen des Dereferenzoperators
sehen und in Kapitel 15 Einzelheiten der Dereferenzierung besprechen.</p>
</blockquote>
<p>Schauen wir uns den Funktionsaufruf hier genauer an:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("Hallo");

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!("Die Länge von '{}' ist {}.", s1, len);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p>Die Syntax <code>&amp;s1</code> erlaubt es uns, eine Referenz zu erstellen, die auf den Wert
von <code>s1</code> <em>referenziert</em>, ihn aber nicht besitzt. Da die Referenz diesen nicht
besitzt, wird der Wert nicht aufgeräumt, wenn die Referenz nicht mehr benutzt
wird.</p>
<p>Ebenso verwendet die Signatur der Funktion das Zeichen <code>&amp;</code>, um anzuzeigen, dass
der Typ des Parameters <code>s</code> eine Referenz ist. Lass uns einige erklärende
Anmerkungen ergänzen:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from("Hallo");
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!("Die Länge von '{}' ist {}.", s1, len);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s ist eine Referenz
                                           // auf eine Zeichenkette
    s.len()
} // Hier verlässt s den Gültigkeitsbereich. Aber weil es keine
  // Eigentümerschaft an dem hat, worauf es referenziert, passiert nichts.</code></pre></pre>
<p>Der Gültigkeitsbereich, in dem die Variable <code>s</code> gültig ist, ist derselbe wie
der Gültigkeitsbereich eines Funktionsparameters, aber der Wert, auf den die
Referenz zeigt, wird nicht aufgeräumt, wenn <code>s</code> nicht mehr verwendet wird, weil
<code>s</code> keine Eigentümerschaft hat. Wenn Funktionen statt der tatsächlichen Werte
Referenzen als Parameter haben, brauchen wir die Werte nicht zurückzugeben, um
die Eigentümerschaft zurückzugeben, denn wir hatten nie die Eigentümerschaft.</p>
<p>Wir nennen den Vorgang des Erstellens einer Referenz <em>Ausleihen</em> (borrowing).
Wenn eine Person im richtigen Leben etwas besitzt, kannst du es von ihr
ausleihen. Wenn du fertig bist, musst du es zurückgeben. Es gehört dir nicht.</p>
<p>Was passiert nun, wenn wir versuchen, etwas zu verändern, das wir uns
ausleihen? Versuche den Code in Codeblock 4-6. Achtung: Es funktioniert nicht!</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let s = String::from("Hallo");

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(" Welt");
}</code></pre></pre>
<p><span class="caption">Codeblock 4-6: Versuch, einen ausgeliehenen Wert zu
verändern</span></p>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
8 |     some_string.push_str(" Welt");
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn change(some_string: &amp;mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>So wie Variablen standardmäßig unveränderbar sind, so sind auch Referenzen
unveränderbar. Es ist uns nicht erlaubt, etwas zu verändern, auf das wir eine
Referenz haben.</p>
<h3 id="veränderbare-referenzen"><a class="header" href="#veränderbare-referenzen">Veränderbare Referenzen</a></h3>
<p>Wir können den Code aus Codeblock 4-6 so ändern, dass wir einen geliehenen Wert
mit ein paar kleinen Änderungen ändern können, die stattdessen eine
<em>veränderbare Referenz</em> verwenden:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut s = String::from("Hallo");

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(" Welt");
}</code></pre></pre>
<p>Zuerst ändern wir <code>s</code>, um <code>mut</code> zu sein. Dann erstellen wir eine
veränderbare Referenz mit <code>&amp;mut s</code>, wo wir die Funktion <code>change</code>
aufrufen, und aktualisieren die Funktionssignatur, um eine veränderbare
Referenz mit <code>some_string: &amp;mut String</code> entgegenzunehmen. Dies macht deutlich,
dass die Funktion <code>change</code> den Wert, den sie ausleiht, verändert.</p>
<p>Veränderbare Referenzen haben eine große Einschränkung: Wenn du eine
veränderbare Referenz auf einen Wert hast, kannst du keine andere Referenz auf
diesen Wert haben. Dieser Code versucht, zwei veränderbare Referenzen auf <code>s</code>
zu erstellen, und wird fehlschlagen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from("Hallo");

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!("{r1}, {r2}");
<span class="boring">}</span></code></pre></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling playground v0.0.1 (/playground)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:6:10
  |
5 | let r1 = &amp;mut s;
  |          ------ first mutable borrow occurs here
6 | let r2 = &amp;mut s;
  |          ^^^^^^ second mutable borrow occurs here
7 |
8 | println!("{r1}, {r2}");
  |           ---- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `playground` (bin "playground") due to 1 previous error
</code></pre>
<p>Dieser Fehler besagt, dass dieser Code ungültig ist, weil wir <code>s</code> nicht mehr
als einmal zur gleichen Zeit als veränderbar ausleihen können. Die erste
veränderbare Ausleihe ist in <code>r1</code> und muss beibehalten werden, bis sie in
<code>println!</code> verwendet wird, aber zwischen dem Erstellen dieser veränderbaren
Referenz und ihrer Verwendung haben wir versucht, eine andere veränderbare
Referenz in <code>r2</code> zu erstellen, der die gleichen Daten wie <code>r1</code> ausleiht.</p>
<p>Die Beschränkung, die mehrere veränderbare Referenz auf dieselben Daten zur
gleichen Zeit verhindert, erlaubt Veränderung, aber in einer sehr
kontrollierten Weise. Das ist etwas, womit Rust-Neulinge zu kämpfen haben, denn
in den meisten Sprachen kann man verändern wann immer man will. Diese
Beschränkung hat den Vorteil, dass Rust Daten-Wettlaufsituation zur
Kompilierzeit verhindern kann. Eine <em>Daten-Wettlaufsituation</em> (data race) ist
ähnlich einer Wettlaufsituation (race condition) und tritt auf, wenn diese drei
Verhaltensweisen auftreten:</p>
<ul>
<li>Zwei oder mehr Zeiger greifen gleichzeitig auf die gleichen Daten zu.</li>
<li>Mindestens einer der Zeiger wird zum Schreiben auf die Daten verwendet.</li>
<li>Es gibt keinen Mechanismus, um den Zugriff auf die Daten zu synchronisieren.</li>
</ul>
<p>Daten-Wettlaufsituationen verursachen undefiniertes Verhalten und können
schwierig zu diagnostizieren und zu beheben sein, wenn du versuchst, sie zur
Laufzeit aufzuspüren; Rust verhindert dieses Problem, indem es Code mit
Daten-Wettlaufsituationen gar nicht erst kompiliert!</p>
<p>Wie immer können wir geschweifte Klammern verwenden, um einen neuen
Gültigkeitsbereich zu schaffen, der mehrere veränderbare Referenzen erlaubt,
nur nicht <em>gleichzeitige</em>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from("Hallo");

{
    let r1 = &amp;mut s;
} // r1 verlässt hier den Gültigkeitsbereich, sodass wir
  // problemlos eine neue Referenz erstellen können.

let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>Rust erzwingt eine ähnliche Regel für die Kombination von veränderbaren und
unveränderbaren Referenzen. Dieser Code führt zu einem Fehler:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from("Hallo");

let r1 = &amp;s;     // kein Problem
let r2 = &amp;s;     // kein Problem
let r3 = &amp;mut s; // GROSSES PROBLEM

println!("{r1}, {r2} und {r3}");
<span class="boring">}</span></code></pre></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling playground v0.0.1 (/playground)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:7:10
  |
5 | let r1 = &amp;s;     // kein Problem
  |          -- immutable borrow occurs here
6 | let r2 = &amp;s;     // kein Problem
7 | let r3 = &amp;mut s; // GROSSES PROBLEM
  |          ^^^^^^ mutable borrow occurs here
8 |
9 | println!("{r1}, {r2} und {r3}");
  |           ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `playground` (bin "playground") due to 1 previous error
</code></pre>
<p>Puh! Wir können auch keine veränderbaren Referenzen verwenden, solange wir eine
unveränderbare Referenz auf denselben Wert haben.</p>
<p>Nutzer einer unveränderbaren Referenz erwarten nicht, dass sich die Werte
dahinter plötzlich ändern! Mehrere unveränderbare Referenzen sind jedoch in
Ordnung, da niemand, der die Daten nur liest, die Möglichkeit hat, das Lesen
der Daten durch andere zu beeinflussen.</p>
<p>Beachte, dass der Gültigkeitsbereich einer Referenz dort beginnt, wo sie
eingeführt wird, und sich bis zur letzten Verwendung dieser Referenz fortsetzt.
Zum Beispiel kompiliert dieser Code, weil die letzte Verwendung der
unveränderbaren Referenzen in <code>println!</code> vor der Einführung der veränderbaren
Referenz erfolgt:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from("Hallo");

let r1 = &amp;s; // kein Problem
let r2 = &amp;s; // kein Problem
println!("{r1} und {r2}");
// r1 und r2 werden nach dieser Stelle nicht mehr verwendet

let r3 = &amp;mut s; // kein Problem
println!("{r3}");
<span class="boring">}</span></code></pre></pre>
<p>Die Gültigkeitsbereiche der unveränderbaren Referenzen <code>r1</code> und <code>r2</code> enden
nach dem <code>println!</code>, wo sie zuletzt verwendet werden, d.h. bevor die
veränderbare Referenz <code>r3</code> erstellt wird. Diese Gültigkeitsbereiche
überschneiden sich nicht, daher ist dieser Code zulässig: Der Compiler kann
erkennen, dass die Referenz bereits vor dem Ende des Gültigkeitsbereichs nicht
mehr verwendet wird.</p>
<p>Auch wenn Fehler durch Ausleihen manchmal frustrierend sein können, denke
daran, dass es der Rust-Compiler ist, der frühzeitig (zur Kompilierzeit und
nicht zur Laufzeit) auf einen möglichen Fehler hinweist und dir genau zeigt, wo
das Problem liegt. Dann musst du nicht aufspüren, warum deine Daten nicht so
sind, wie du dachtest.</p>
<h3 id="hängende-referenzen"><a class="header" href="#hängende-referenzen">Hängende Referenzen</a></h3>
<p>In Sprachen mit Zeigern ist es leicht, fälschlicherweise einen <em>hängenden
Zeiger</em> (dangling pointer) zu erzeugen, also einen Zeiger, der auf eine Stelle
im Speicher verweist, die vielleicht an jemand anderem vergeben wurde, weil der
Speicher freigegeben wurde, während noch ein Zeiger auf diesen Speicher
bestehen bleibt. In Rust hingegen garantiert der Compiler, dass Referenzen
niemals hängende Referenzen sein können: Wenn du eine Referenz auf Daten hast,
stellt der Compiler sicher, dass die Daten nicht den Gültigkeitsbereich
verlassen, bevor die Referenz auf die Daten dies tut.</p>
<p>Versuchen wir, eine hängende Referenz zu erstellen, um zu sehen wie Rust das
mit einem Kompilierfehler verhindert:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("Hallo");

    &amp;s
}</code></pre></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling playground v0.0.1 (/playground)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
5 - fn dangle() -&gt; &amp;String {
5 + fn dangle() -&gt; String {
  |

error[E0515]: cannot return reference to local variable `s`
 --&gt; src/main.rs:8:5
  |
8 |     &amp;s
  |     ^^ returns a reference to data owned by the current function

Some errors have detailed explanations: E0106, E0515.
For more information about an error, try `rustc --explain E0106`.
error: could not compile `playground` (bin "playground") due to 2 previous errors; 1 warning emitted
</code></pre>
<p>Diese Fehlermeldung bezieht sich auf eine Funktionalität, die wir noch nicht
behandelt haben: Die Lebensdauer. Wir werden die Lebensdauer in Kapitel 10 im
Detail besprechen. Abgesehen von den Hinweisen zur Lebensdauer enthält die
Meldung den entscheidenden Hinweis, warum dieser Code nicht funktioniert:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>Lass uns einen genaueren Blick auf das werfen, was in jeder Phase unseres
<code>dangle</code>-Codes geschieht:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle gibt eine Referenz
                         // auf eine Zeichenkette zurück

    let s = String::from("Hallo"); // s ist eine neue Zeichenkette

    &amp;s // wir geben einen Verweis auf die Zeichenkette s zurück
} // Hier verlässt s den Gültigkeitsbereich und wird verworfen.
  // Sein Speicherplatz wird aufgeräumt. Gefahr!</code></pre></pre>
<p>Da <code>s</code> innerhalb <code>dangle</code> erzeugt wird, wird <code>s</code> wieder freigegeben, wenn der
Code von <code>dangle</code> zu Ende ist. Aber wir haben versucht, eine Referenz darauf
zurückzugeben. Das heißt, diese Referenz würde auf einen ungültigen <code>String</code>
verweisen. Das ist nicht gut! Rust lässt uns das nicht tun.</p>
<p>Die Lösung ist, den <code>String</code> direkt zurückzugeben:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from("Hallo");

    s
}</code></pre></pre>
<p>Dies funktioniert ohne Probleme. Die Eigentümerschaft wird nach außen
verschoben, und nichts wird freigegeben.</p>
<h3 id="regeln-für-referenzen"><a class="header" href="#regeln-für-referenzen">Regeln für Referenzen</a></h3>
<p>Lass uns rekapitulieren, was wir über Referenzen gelernt haben:</p>
<ul>
<li>Zu jedem beliebigen Zeitpunkt kannst du <em>entweder</em> eine veränderbare
Referenz <em>oder</em> eine beliebige Anzahl unveränderbarer Referenzen haben.</li>
<li>Referenzen müssen immer gültig sein.</li>
</ul>
<p>Als Nächstes werden wir uns mit einer anderen Art von Referenz befassen:
Anteilstypen (slice).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="der-anteilstyp-slice"><a class="header" href="#der-anteilstyp-slice">Der Anteilstyp (slice)</a></h2>
<p>Mit <em>Anteilstypen</em> kannst du auf eine zusammenhängende Folge von Elementen in
einer <a href="ch08-00-common-collections.html">Kollektion</a> referenzieren anstatt auf die gesamte
Kollektion. Ein Anteilstyp ist eine Art Referenz und hat daher keine
Eigentümerschaft.</p>
<p>Hier ist ein kleines Programmierproblem: Schreibe eine Funktion, die eine
Zeichenkette mit durch Leerzeichen getrennten Wörtern entgegennimmt und das
erste Wort zurückgibt, das sie in dieser Zeichenkette findet. Wenn die Funktion
kein Leerzeichen in der Zeichenkette findet, muss die gesamte Zeichenkette ein
Wort sein, also sollte die gesamte Zeichenkette zurückgegeben werden.</p>
<p>Gehen wir einmal durch, wie wir die Signatur dieser Funktion ohne Verwendung
von Anteilstypen schreiben würden, um das Problem zu verstehen, das durch
Anteilstypen gelöst wird:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p>Die Funktion <code>first_word</code> hat <code>&amp;String</code> als Parameter. Wir benötigen keine
Eigentümerschaft, also ist das in Ordnung. (In idiomatischem Rust übernehmen
Funktionen nicht die Eigentümerschaft an ihren Argumenten, es sei denn, sie
müssen es, und die Gründe dafür werden im weiteren Verlauf klar werden). Aber
was sollen wir zurückgeben? Wir haben nicht wirklich eine Möglichkeit, über
<em>einen Teil</em> einer Zeichenkette zu sprechen. Wir könnten jedoch den Index des
Wortendes zurückgeben. Versuchen wir das, wie in Codeblock 4-7 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 4-7: Die Funktion <code>first_word</code>, die einen
Byte-Indexwert zum Parameter <code>String</code> zurückgibt</span></p>
<p>Da wir den <code>String</code> Zeichen für Zeichen durchgehen und prüfen müssen, ob ein
Wert ein Leerzeichen ist, wandeln wir unseren <code>String</code> mit der Methode
<code>as_bytes</code> in ein Byte-Array um.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Als nächstes erstellen wir einen Iterator über das Byte-Array, indem wir die
Methode <code>iter</code> verwenden:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Auf Iteratoren werden wir in <a href="ch13-02-iterators.html">Kapitel 13</a> näher eingehen. Fürs Erste
solltest du wissen, dass <code>iter</code> eine Methode ist, die jedes Element in einer
Kollektion zurückgibt und dass <code>enumerate</code> das Ergebnis von <code>iter</code> umhüllt und
stattdessen jedes Element als Teil eines Tupels zurückgibt. Das erste Element
des Tupels, das von <code>enumerate</code> zurückgegeben wird, ist der Index, und das
zweite Element ist eine Referenz auf das Element. Das ist etwas bequemer, als
den Index selbst zu berechnen.</p>
<p>Da die Methode <code>enumerate</code> ein Tupel zurückgibt, können wir Muster verwenden,
um dieses Tupel zu zerlegen. Wir werden uns in <a href="ch06-02-match.html#muster-die-werte-binden">Kapitel 6</a> eingehender mit
Mustern befassen. In der <code>for</code>-Schleife spezifizieren wir also ein Muster, das
<code>i</code> für den Index im Tupel und <code>&amp;item</code> für das einzelne Byte im Tupel hat. Da
wir eine Referenz auf das Element aus <code>.iter().enumerate()</code> erhalten, verwenden
wir <code>&amp;</code> im Muster.</p>
<p>Innerhalb der <code>for</code>-Schleife suchen wir mit Hilfe der Byte-Literal-Syntax
<code>b' '</code> nach dem Byte, das das Leerzeichen repräsentiert. Wenn wir ein
Leerzeichen finden, geben wir die Position zurück. Andernfalls geben wir die
Länge der Zeichenkette zurück, indem wir <code>s.len()</code> verwenden.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Wir haben jetzt eine Möglichkeit, den Index des ersten Wortendes in der
Zeichenkette herauszufinden, aber es gibt ein Problem. Wir geben ein <code>usize</code>
für sich allein zurück, aber die Zahl ist nur aussagekräftig im Kontext des
<code>&amp;String</code>. Mit anderen Worten: Da es sich um einen vom <code>String</code> getrennten Wert
handelt, gibt es keine Garantie, dass er auch in Zukunft noch gültig ist.
Betrachte das Programm in Codeblock 4-8, das die Funktion <code>first_word</code> aus
Codeblock 4-7 verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("Hallo Welt");

    let word = first_word(&amp;s); // word erhält den Wert 5

    s.clear(); // leert die Zeichenkette und macht sie gleich ""

    // word hat noch immer den Wert 5, aber es gibt keine Zeichenkette mehr,
    // mit der wir den Wert 5 sinnvoll verwenden könnten.
    // word ist jetzt völlig ungültig!
}</code></pre></pre>
<p><span class="caption">Codeblock 4-8: Speichern des Ergebnisses des
Funktionsaufrufs <code>first_word</code> und anschließendes Ändern des Inhalts der
Zeichenkette</span></p>
<p>Dieses Programm kompiliert fehlerfrei und würde dies auch tun, wenn wir <code>word</code>
nach dem Aufruf von <code>s.clear()</code> benutzen würden. Da <code>word</code> überhaupt nicht mit
dem Zustand von <code>s</code> verbunden ist, enthält <code>word</code> immer noch den Wert <code>5</code>. Wir
könnten den Wert <code>5</code> mit der Variable <code>s</code> verwenden, um zu versuchen, das erste
Wort zu extrahieren, aber das wäre ein Fehler, weil sich der Inhalt von <code>s</code>
geändert hat, nachdem wir <code>5</code> in <code>word</code> gespeichert haben.</p>
<p>Sich darum kümmern zu müssen, dass der Index in <code>word</code> mit den Daten in <code>s</code>
konform ist, ist mühsam und fehleranfällig! Das Verwalten dieser Indizes ist
noch fehleranfälliger, wenn wir eine Funktion <code>second_word</code> schreiben. Ihre
Signatur müsste dann so aussehen:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>Jetzt verfolgen wir einen Anfangs- <em>und</em> einen Endindex, und wir haben noch
mehr Werte, die aus Daten in einem bestimmten Zustand berechnet wurden, aber
überhaupt nicht an diesen Zustand gebunden sind. Wir haben drei unverbundene
Variablen, die synchron gehalten werden müssen.</p>
<p>Glücklicherweise hat Rust eine Lösung für dieses Problem:
Zeichenkettenanteilstypen</p>
<h3 id="zeichenkettenanteilstypen-string-slices"><a class="header" href="#zeichenkettenanteilstypen-string-slices">Zeichenkettenanteilstypen (string slices)</a></h3>
<p>Ein <em>Zeichenkettenanteilstyp</em>  (string slice) ist ein Verweis auf einen Teil
eines <code>String</code>, und er sieht so aus:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("Hallo Welt");

let hello = &amp;s[0..5];
let world = &amp;s[6..10];
<span class="boring">}</span></code></pre></pre>
<p>Anstelle einer Referenz auf den gesamten <code>String</code> ist <code>hello</code> eine Referenz auf
einen Teil des <code>String</code>, der mit dem zusätzlichen <code>[0..5]</code> spezifiziert ist.
Wir erstellen Anteilstypen unter Angabe eines Bereichs innerhalb von Klammern,
indem wir <code>[starting_index..ending_index]</code> angeben, wobei <em><code>starting_index</code></em>
die erste Position im Anteilstyp und <em><code>ending_index</code></em> eine Position mehr als die
letzte Position im Anteilstyp ist. Intern speichert die
Anteilstyp-Datenstruktur die Anfangsposition und die Länge des Anteilstypen,
was <code>ending_index</code> minus <code>starting_index</code> entspricht. Im Fall von <code>let world = &amp;s[6..10];</code> wäre <code>world</code> also ein Anteilstyp, der einen Zeiger auf das Byte bei
Index 6 von <code>s</code> mit dem Längenwert <code>4</code> enthält.</p>
<p>Abbildung 4-7 stellt dies dar.</p>
<p><img alt="Drei Tabellen: Eine Tabelle, die die Stapelspeicher-Daten von s
darstellt, die auf das Byte bei Index 0 in einer Tabelle der
Zeichenketten-Daten &quot;Hallo Welt&quot; auf dem Haldenspeicher zeigt. Die
dritte Tabelle repräsentiert die Stapelspeicher-Daten des Anteilstypen Welt,
der den Längenwert 4 hat und auf Byte 6 der Haldenspeicher-Datentabelle zeigt."
src="img/trpl04-07.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-7: Zeichenkettenanteilstyp, der sich auf einen
Teil eines <code>String</code> bezieht</span></p>
<p>Wenn du mit der Bereichssyntax <code>..</code> in Rust beim Index 0 beginnen willst,
kannst du den Wert vor den zwei Punkte weglassen. Mit anderen Worten sind diese
gleich:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("Hallo");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre></pre>
<p>Ebenso kannst du den Endindex weglassen, wenn dein Anteilstyp das letzte Byte
des <code>String</code> enthält. Das bedeutet, dass diese gleich sind:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("Hallo");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>Du kannst auch beide Werte weglassen, um einen Ausschnitt der gesamten
Zeichenkette zu beschreiben. Diese sind also gleichwertig:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("Hallo");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Hinweis: Bereichsindizes bei Zeichenkettenanteilstypen müssen sich nach
gültigen UTF-8-Zeichengrenzen richten. Wenn du versuchst, einen
Zeichenkettenanteilstyp in der Mitte eines Mehrbyte-Zeichens zu erstellen,
wird dein Programm mit einem Fehler abbrechen. Bei der Einführung von
Zeichenkettenanteilstypen in diesem Abschnitt gehen wir nur von ASCII aus;
eine eingehendere Diskussion der UTF-8-Behandlung findet sich im Abschnitt
<a href="ch08-02-strings.html">„UTF-8-kodierten Text in Zeichenketten (strings) ablegen“</a> in
Kapitel 8.</p>
</blockquote>
<p>Mit all diesen Informationen im Hinterkopf schreiben wir <code>first_word</code> so um,
dass es einen Anteilstyp zurückgibt. Der Typ mit der Bedeutung
„Zeichenkettenanteilstyp“ wird <code>&amp;str</code> geschrieben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Den Index für das Wortende erhalten wir auf die gleiche Weise wie in Codeblock
4-7, indem wir nach dem ersten Vorkommen eines Leerzeichens suchen. Wenn wir
ein Leerzeichen finden, geben wir einen Zeichenkettenanteilstyp zurück, wobei
wir den Anfang der Zeichenkette und den Index des Leerzeichens als Anfangs-
bzw. Endindex verwenden.</p>
<p>Wenn wir nun <code>first_word</code> aufrufen, erhalten wir einen einzelnen Wert zurück,
der an die zugrundeliegenden Daten gebunden ist. Der Wert setzt sich aus einer
Referenz auf den Startpunkt des Anteilstyps und der Anzahl der Elemente im
Anteilstyp zusammen.</p>
<p>Die Rückgabe eines Anteilstyps würde auch für eine Funktion <code>second_word</code>
funktionieren:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Wir haben jetzt eine einfache API, die viel schwieriger durcheinanderzubringen
ist, weil der Compiler sicherstellt, dass die Referenzen auf den <code>String</code>
gültig bleiben. Erinnere dich an den Fehler im Programm in Codeblock 4-8, als
wir den Index bis zum Ende des ersten Wortes erhielten, dann aber die
Zeichenkette löschten, sodass unser Index ungültig wurde. Dieser Code war
logisch falsch, zeigte aber keine unmittelbaren Fehler. Die Probleme würden
sich später zeigen, wenn wir weiterhin versuchen würden, den ersten Wortindex
mit einer leeren Zeichenkette zu verwenden. Anteilstypen machen diesen Fehler
unmöglich und lassen uns viel früher wissen, dass wir ein Problem mit unserem
Code haben. Die Anteilstypen-Variante von <code>first_word</code> führt zu einem
Kompilierfehler:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("Hallo Welt");

    let word = first_word(&amp;s);

    s.clear(); // Fehler!

    println!("Das erste Wort ist: {word}");
}</code></pre></pre>
<p>Hier ist der Kompilierfehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // Fehler!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!("Das erste Wort ist: {word}");
   |                                   ------ immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Erinnere dich an die Ausleihregeln, durch die wir, wenn wir eine
unveränderbare Referenz auf etwas haben, nicht noch eine veränderbare
Referenz anlegen können. Da <code>clear</code> den <code>String</code> abschneiden muss, muss es
eine veränderbare Referenz erhalten. Das <code>println!</code> nach dem Aufruf von
<code>clear</code> verwendet die Referenz in <code>word</code>, sodass die unveränderbare Referenz
zu diesem Zeitpunkt noch aktiv sein muss. Rust verbietet, dass die
veränderbare Referenz in <code>clear</code> und die unveränderbare Referenz in <code>word</code>
nicht gleichzeitig existieren, und die Kompilierung schlägt fehl. Rust hat
nicht nur die Benutzung unserer API vereinfacht, sondern auch eine ganze Klasse
von Fehlern zur Kompilierzeit beseitigt!</p>
<h4 id="zeichenkettenliterale-als-anteilstypen"><a class="header" href="#zeichenkettenliterale-als-anteilstypen">Zeichenkettenliterale als Anteilstypen</a></h4>
<p>Erinnere dich, dass wir darüber sprachen, dass Zeichenkettenliterale in der
Binärdatei gespeichert werden. Jetzt, da wir über Anteilstypen Bescheid wissen,
können wir Zeichenkettenliterale richtig verstehen:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hallo Welt!";
<span class="boring">}</span></code></pre></pre>
<p>Der Typ von <code>s</code> hier ist <code>&amp;str</code>: Es ist ein Anteilstyp, der auf diesen
speziellen Punkt der Binärdatei zeigt. Das ist auch der Grund, warum
Zeichenkettenliterale unveränderbar sind; <code>&amp;str</code> ist eine unveränderbare
Referenz.</p>
<h4 id="zeichenkettenanteilstypen-als-parameter"><a class="header" href="#zeichenkettenanteilstypen-als-parameter">Zeichenkettenanteilstypen als Parameter</a></h4>
<p>Das Wissen, dass man Anteilstypen von Literalen und <code>String</code>-Werten erstellen
kann, führt uns zu einer weiteren Verbesserung von <code>first_word</code>, und das ist
ihre Signatur:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Ein erfahrenerer Rust-Entwickler würde stattdessen die in Codeblock 4-9
gezeigte Signatur schreiben, da sie es uns erlaubt, dieselbe Funktion sowohl
auf <code>&amp;String</code>-Werte als auch auf <code>&amp;str</code>-Werte anzuwenden.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("Hallo Welt");
</span><span class="boring">
</span><span class="boring">    // `first_word` funktioniert mit Anteilstypen von `String`, ob teilweise oder ganz
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` funktioniert auch bei Referenzen auf `String`, die
</span><span class="boring">    // äquivalent zu ganzen Anteilstypen von `String` sind
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "Hallo Welt";
</span><span class="boring">
</span><span class="boring">    // `first_word` funktioniert mit Anteilstypen von Zeichenkettenliteralen, ob teilweise oder ganz
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
</span><span class="boring">    // funktioniert dies auch ohne die Anteilstypensyntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 4-9: Verbessern der Funktion <code>first_word</code> durch
Verwenden eines Zeichenkettenanteilstyps für den Typ des Parameters <code>s</code></span></p>
<p>Wenn wir einen Zeichenkettenanteilstyp haben, können wir diesen direkt
übergeben. Wenn wir einen <code>String</code> haben, können wir einen Anteilstyp des
<code>String</code> oder eine Referenz auf den <code>String</code> übergeben. Diese Flexibilität
nutzt die Vorteile der <em>automatischen Umwandlung</em>, eine Funktionalität, die wir
im Abschnitt <a href="ch15-02-deref.html#implizite-automatische-umwandlung-mit-funktionen-und-methoden">„Implizite automatische Umwandlung mit Funktionen und
Methoden“</a> in Kapitel 15 behandeln.</p>
<p>Das Definieren einer Funktion, die einen Zeichenkettenanteilstyp statt einer
Referenz auf einen <code>String</code> entgegennimmt, macht unsere API allgemeiner und
nützlicher, ohne an Funktionalität einzubüßen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from("Hallo Welt");

    // `first_word` funktioniert mit Anteilstypen von `String`, ob teilweise oder ganz
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` funktioniert auch bei Referenzen auf `String`, die
    // äquivalent zu ganzen Anteilstypen von `String` sind
    let word = first_word(&amp;my_string);

    let my_string_literal = "Hallo Welt";

    // `first_word` funktioniert mit Anteilstypen von Zeichenkettenliteralen, ob teilweise oder ganz
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
    // funktioniert dies auch ohne die Anteilstypensyntax!
    let word = first_word(my_string_literal);
}</code></pre></pre>
<h3 id="andere-anteilstypen"><a class="header" href="#andere-anteilstypen">Andere Anteilstypen</a></h3>
<p>Zeichenkettenanteilstypen sind, wie du dir vorstellen kannst, spezifisch für
Zeichenketten. Es gibt aber auch einen allgemeineren Anteilstyp. Betrachte
dieses Array:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Genauso wie wir vielleicht auf einen Teil einer Zeichenkette verweisen möchten,
möchten wir vielleicht auf einen Teil eines Arrays verweisen. Wir würden das so
machen:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>Dieser Anteilstyp hat den Typ <code>&amp;[i32]</code>. Es funktioniert auf die gleiche Weise
wie bei Zeichenkettenanteilstypen, indem es eine Referenz auf das erste Element
und eine Länge speichert. Du wirst diese Art von Anteilstyp für alle möglichen
anderen Kollektionen verwenden. Wir werden diese Kollektionen im Detail
besprechen, wenn wir in Kapitel 8 über Vektoren sprechen.</p>
<h2 id="zusammenfassung-3"><a class="header" href="#zusammenfassung-3">Zusammenfassung</a></h2>
<p>Die Konzepte von Eigentümerschaft, Ausleihen und Anteilstypen gewährleisten
Speichersicherheit zur Kompilierzeit in Rust-Programmen. Die Sprache Rust gibt
dir Kontrolle über die Speicherverwendung auf die gleiche Weise wie andere
Systemprogrammiersprachen, aber dadurch, dass der Eigentümer der Daten diese
automatisch aufräumt, wenn der Eigentümer den Gültigkeitsbereich verlässt,
bedeutet dies, dass du keinen zusätzlichen Code schreiben und debuggen musst,
um diese Kontrolle zu erhalten.</p>
<p>Die Eigentümerschaft wirkt sich auf die Funktionsweise vieler anderer Teile von
Rust aus, deshalb werden wir im weiteren Verlauf des Buchs weiter über diese
Konzepte sprechen. Lass uns zu Kapitel 5 übergehen und uns das Gruppieren von
Datenteilen zu einer <code>struct</code> ansehen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strukturen-structs-für-zusammenhängende-daten-verwenden"><a class="header" href="#strukturen-structs-für-zusammenhängende-daten-verwenden">Strukturen (structs) für zusammenhängende Daten verwenden</a></h1>
<p>Eine <em>Struktur</em> (struct) ist ein benutzerdefinierter Datentyp, mit dem man
mehrere zusammenhängende Werte, die eine sinnvolle Gruppe bilden,
zusammenpacken und benennen kann. Wenn du mit einer objektorientierten Sprache
vertraut bist, ist eine <em>Struktur</em> analog zu den Datenattributen eines Objekts.
In diesem Kapitel werden wir Tupel mit Strukturen vergleichen und
gegenüberstellen, um auf den bereits vorhandenen Kenntnissen aufzubauen und zu
zeigen, wann Strukturen eine bessere Möglichkeit zur Gruppierung von Daten
sind.</p>
<p>Wir werden zeigen, wie man Strukturen definiert und instanziiert. Wir werden
besprechen, wie man assoziierte Funktionen definiert, insbesondere die Art
assoziierter Funktionen, die <em>Methoden</em> genannt werden, um das Verhalten eines
Strukturtyps zu spezifizieren. Strukturen und Aufzählungen (enums) (siehe
Kapitel 6) sind die Bausteine zum Erstellen neuer Typen in der Domäne deines
Programms, mit denen du die Vorteile der Kompilierzeit-Typprüfung von Rust voll
ausschöpfen kannst.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="strukturen-structs-definieren-und-instanziieren"><a class="header" href="#strukturen-structs-definieren-und-instanziieren">Strukturen (structs) definieren und instanziieren</a></h2>
<p>Strukturen (structs) ähneln Tupeln, die im Abschnitt <a href="ch03-02-data-types.html#der-tupel-typ">„Der Tupel-Typ“</a>
besprochen wurden. Wie bei Tupeln können die Teile einer Struktur verschiedene
Typen haben. Anders als bei Tupeln benennst du jedes Teil, so dass klar ist, was
die Werte bedeuten. Durch diese Namen sind Strukturen flexibler als Tupel: Du
musst dich nicht auf die Reihenfolge der Daten verlassen, um die Werte einer
Instanz zu spezifizieren oder auf sie zuzugreifen.</p>
<p>Um eine Struktur zu definieren, geben wir das Schlüsselwort <code>struct</code> an und
benennen die gesamte Struktur. Der Name einer Struktur sollte die Bedeutung der
Daten beschreiben, die gruppiert werden. Dann definieren wir innerhalb
geschweifter Klammern die Namen und Typen der Datenteile, die wir <em>Felder</em>
nennen. Beispielsweise zeigt Codeblock 5-1 eine Struktur, die Informationen
über ein Benutzerkonto speichert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 5-1: Definition der Struktur <code>User</code></span></p>
<p>Um eine Struktur zu verwenden, nachdem wir sie definiert haben, erstellen wir
eine <em>Instanz</em> dieser Struktur, indem wir für jedes Feld einen konkreten Wert
angeben. Wir erzeugen eine Instanz, indem wir den Namen der Struktur angeben
und dann in geschweiften Klammern die <em>Schlüssel: Wert</em>-Paare angeben, wobei
die Schlüssel die Namen der Felder und die Werte die Daten sind, die wir in
diesen Feldern speichern wollen. Wir müssen die Felder nicht in der gleichen
Reihenfolge angeben, in der wir sie in der Struktur deklariert haben. Anders
gesagt ist die Strukturdefinition wie eine allgemeine Typvorlage und Instanzen
füllen diese Vorlage mit bestimmten Daten aus, um Werte des Typs zu erzeugen.
Beispielsweise können wir einen bestimmten Benutzer deklarieren, wie in
Codeblock 5-2 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from("benutzername123"),
        email: String::from("jemand@example.com"),
        sign_in_count: 1,
    };
}</code></pre></pre>
<p><span class="caption">Codeblock 5-2: Eine Instanz der Struktur <code>User</code>
erzeugen</span></p>
<p>Um auf einen bestimmten Wert in einer Struktur zuzugreifen, verwenden wir die
Punktnotation. Um beispielsweise auf die E-Mail-Adresse dieses Benutzers
zuzugreifen, verwenden wir <code>user1.email</code>. Wenn die Instanz veränderbar ist,
können wir einen Wert ändern, indem wir die Punktnotation verwenden und ihn
einem bestimmten Feld zuweisen. Codeblock 5-3 gezeigt, wie der Wert im Feld
<code>email</code> einer veränderbaren <code>User</code>-Instanz geändert werden kann.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("benutzername123"),
        email: String::from("jemand@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("andere-email@example.com");
}</code></pre></pre>
<p><span class="caption">Codeblock 5-3: Wert im Feld <code>email</code> einer <code>User</code>-Instanz ändern</span></p>
<p>Beachte, dass die gesamte Instanz veränderbar sein muss. Rust erlaubt es
nicht, nur einzelne Felder als veränderbar zu markieren. Wie mit jedem
Ausdruck können wir eine neue Instanz der Struktur als letzten Ausdruck im
Funktionsrumpf erzeugen, um diese neue Instanz implizit zurückzugeben.</p>
<p>Codeblock 5-4 zeigt eine Funktion <code>build_user</code>, die eine <code>User</code>-Instanz mit der
angegebenen E-Mail und dem Benutzernamen zurückgibt. Das Feld <code>active</code> erhält
den Wert <code>true</code> und das Feld <code>sign_in_count</code> den Wert <code>1</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("jemand@example.com"),
</span><span class="boring">        String::from("benutzername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 5-4: Funktion <code>build_user</code>, die eine E-Mail und
einen Benutzernamen entgegennimmt und eine <code>User</code>-Instanz zurückgibt</span></p>
<p>Es ist sinnvoll, den Funktionsparametern dieselben Namen wie die der
Strukturfelder zu geben, jedoch ist das Wiederholen der Feldnamen <code>email</code> und
<code>username</code> etwas mühsam. Wenn die Struktur mehr Felder hätte, würde das
Wiederholen jedes Namens noch lästiger werden. Glücklicherweise gibt es eine
praktische Kurznotation!</p>
<h3 id="kurznotation-der-feld-initialisierung-verwenden"><a class="header" href="#kurznotation-der-feld-initialisierung-verwenden">Kurznotation der Feld-Initialisierung verwenden</a></h3>
<p>Da die Parameter und die Strukturfelder in Codeblock 5-4 die gleichen Namen
haben, können wir die <em>Kurznotation der Feld-Initialisierung</em> (field init
shorthand syntax) verwenden, um die Funktion <code>build_user</code> so umzuschreiben,
dass sie sich unverändert gleich verhält, ohne <code>email</code> und <code>username</code> zu
wiederholen, siehe Codeblock 5-5.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("jemand@example.com"),
</span><span class="boring">        String::from("benutzername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 5-5: Funktion <code>build_user</code> mit Kurznotation der
Feld-Initialisierung, weil die Parameternamen <code>email</code> und <code>username</code> identisch
mit den Strukturfeldern sind</span></p>
<p>Hier erzeugen wir eine neue Instanz der Struktur <code>User</code>, die ein Feld namens
<code>email</code> hat. Wir wollen den Wert des Feldes <code>email</code> auf den Wert des Parameters
<code>email</code> der Funktion <code>build_user</code> setzen. Da das Feld <code>email</code> und der Parameter
<code>email</code> den gleichen Namen haben, brauchen wir nur <code>email</code> statt <code>email: email</code>
zu schreiben.</p>
<h3 id="instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax"><a class="header" href="#instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax">Instanzen aus anderen Instanzen erzeugen mit der Strukturaktualisierungssyntax</a></h3>
<p>Oft ist es hilfreich, eine neue Instanz einer Struktur zu erstellen, die die
meisten Werte einer alten Instanz verwendet und nur einige davon verändert. Du
kannst dazu die <em>Strukturaktualisierungssyntax</em> (struct update syntax)
verwenden.</p>
<p>Zunächst zeigt Codeblock 5-6, wie wir eine neue <code>User</code>-Instanz <code>user2</code> ohne
Aktualisierungssyntax erstellen. Wir setzen einen neuen Wert für <code>email</code>,
verwenden aber ansonsten die gleichen Werte von <code>user1</code>, die wir in Codeblock
5-2 erstellt haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --abschneiden--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("jemand@example.com"),
</span><span class="boring">        username: String::from("benutzername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("andere@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
<p><span class="caption">Codeblock 5-6: Erstellen einer neuen <code>User</code>-Instanz unter
Verwendung aller Werte von <code>user1</code> bis auf einen.</span></p>
<p>Durch Verwenden der Strukturaktualisierungssyntax können wir dasselbe Ergebnis
mit weniger Code erreichen, wie Codeblock 5-7 zeigt. Die Syntax <code>..</code> gibt an,
dass die restlichen Felder, die nicht explizit gesetzt wurden, den gleichen
Wert haben sollen wie die Felder in der gegebenen Instanz.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --abschneiden--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("jemand@example.com"),
</span><span class="boring">        username: String::from("benutzername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from("andere@example.com"),
        ..user1
    };
}</code></pre></pre>
<p><span class="caption">Codeblock 5-7: Verwenden der
Strukturaktualisierungssyntax, um einen neuen Wert für <code>email</code> in der
<code>User</code>-Instanz zu setzen und die restlichen Werte aus der Instanz <code>user1</code> zu
übernehmen</span></p>
<p>Der Code in Codeblock 5-7 erzeugt auch eine Instanz <code>user2</code>, die einen anderen
Wert für <code>email</code> hat, aber die gleichen Werte der Felder <code>username</code>, <code>active</code>
und <code>sign_in_count</code> wie <code>user1</code>. Das <code>..user1</code> muss an letzter Stelle stehen um
festzulegen, dass alle verbleibenden Felder ihre Werte von den entsprechenden
Feldern in <code>user1</code> beziehen sollen, aber wir können Werte für so viele Felder
in beliebiger Reihenfolge angeben, unabhängig von der Reihenfolge der Felder in
der Strukturdefinition.</p>
<p>Beachte, dass die Strukturaktualisierungssyntax wie eine Zuweisung mit <code>=</code> ist,
da sie die Daten verschiebt, wie wir im Abschnitt <a href="ch04-01-what-is-ownership.html#variablen-und-daten-im-zusammenspiel-mit-move">„Variablen und Daten im
Zusammenspiel mit Move“</a> gesehen haben. In diesem Beispiel können wir
<code>user1</code> nicht mehr verwenden, nachdem wir <code>user2</code> erzeugt haben, weil der
<code>String</code> im Feld <code>username</code> von <code>user1</code> in <code>user2</code> verschoben wurde. Hätten wir
<code>user2</code> neue <code>String</code>-Werte für beide Felder <code>email</code> und <code>username</code> gegeben und
somit nur die Werte <code>active</code> und <code>sign_in_count</code> von <code>user1</code> verwendet, wäre
<code>user1</code> auch nach dem Erstellen von <code>user2</code> noch gültig. Die Typen <code>active</code> und
<code>sign_in_count</code> sind Typen, die das Merkmal <code>Copy</code> implementieren, sodass das
Verhalten, das wir im Abschnitt <a href="ch04-01-what-is-ownership.html#nur-stapelspeicher-daten-kopieren-copy">„Nur Stapelspeicher-Daten: Kopieren
(copy)“</a> besprochen haben, zutreffen würde. Wir können in diesem Beispiel
immer noch <code>user1.email</code> verwenden, da sein Wert <em>nicht</em> verschoben wurde.</p>
<h3 id="verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen"><a class="header" href="#verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen">Verwenden von Tupel-Strukturen ohne benannte Felder um verschiedene Typen zu erzeugen</a></h3>
<p>Rust unterstützt auch Strukturen, die ähnlich wie Tupel aussehen, genannt
<em>Tupel-Strukturen</em> (tuple structs). Tupel-Strukturen haben den Strukturnamen
als zusätzliche Bedeutung, allerdings haben die Felder keine Namen, sondern nur
Typen. Tupel-Strukturen sind hilfreich, wenn du dem gesamten Tupel einen Namen
geben und das Tupel von anderen Tupeln unterscheiden willst, und wenn die
Benennung der Felder wie in einer regulären Struktur langatmig oder unnötig
wäre.</p>
<p>Um eine Tupel-Struktur zu definieren, starte mit dem Schlüsselwort <code>struct</code>,
gefolgt vom Strukturnamen und den Typen im Tupel. Nachfolgend ein Beispiel mit
Definition und Verwendung zweier Tupel-Strukturen <code>Color</code> und <code>Point</code>:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
<p>Beachte, dass die Werte <code>black</code> und <code>origin</code> unterschiedliche Typen haben, weil
sie Instanzen unterschiedlicher Tupel-Strukturen sind. Jede von dir definierte
Struktur ist ein eigenständiger Typ, auch wenn die Felder innerhalb der
Struktur die gleichen Typen haben könnten. Zum Beispiel kann eine Funktion, die
einen Parameter vom Typ <code>Color</code> hat, keinen <code>Point</code> als Argument nehmen, obwohl
beide Typen aus drei <code>i32</code>-Werten bestehen. Ansonsten ähneln
Tupel-Struktur-Instanzen den Tupeln insofern, als dass sie in ihre einzelnen
Teile zerlegt werden können, und du kannst ein <code>.</code> gefolgt vom Index verwenden,
um auf einen einzelnen Wert zuzugreifen. Im Unterschied zu Tupeln musst du bei
Tupel-Strukturen den Typ der Struktur angeben, wenn du sie destrukturierst. Wir
würden zum Beispiel schreiben: <code>let Point(x, y, z) = point</code></p>
<h3 id="einheitstyp-ähnliche-strukturen-ohne-felder"><a class="header" href="#einheitstyp-ähnliche-strukturen-ohne-felder">Einheitstyp-ähnliche Strukturen ohne Felder</a></h3>
<p>Du kannst auch Strukturen definieren, die gar keine Felder haben! Diese werden
<em>Einheitstyp</em> (unit-like structs) genannt, weil sie sich ähnlich zum leeren
Tupel <code>()</code> verhalten, das wir im Abschnitt <a href="ch03-02-data-types.html#der-tupel-typ">„Der Tupel-Typ“</a> erwähnt
haben. Einheitstypen können in Situationen nützlich sein, in denen du ein
Merkmal (trait) zu einem Typ implementieren musst, du aber keine Daten hast,
die im Typ gespeichert werden sollen. Wir werden Merkmale in Kapitel 10
besprechen. Hier ist ein Beispiel für die Deklaration und Instanziierung einer
Unit-Struktur namens <code>AlwaysEqual</code>:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
<p>Um <code>AlwaysEqual</code> zu definieren, verwenden wir das Schlüsselwort <code>struct</code>, den
gewünschten Namen und dann ein Semikolon. Geschweifte Klammern und Klammern
sind nicht erforderlich! Dann können wir eine Instanz von <code>AlwaysEqual</code> in der
Variable <code>subject</code> auf ähnliche Weise erhalten: Mit dem Namen, den wir
definiert haben, ohne geschweifte Klammern oder Klammern. Stell dir vor, wir
implementieren ein Verhalten für diesen Typ, bei dem jede Instanz immer gleich
ist mit jeder Instanz jedes anderen Typs, vielleicht um ein bekanntes Ergebnis
für Testzwecke zu haben. Wir bräuchten keine Daten, um dieses Verhalten
umzusetzen! In Kapitel 10 wirst du sehen, wie man Merkmale definiert und sie
für jeden Typ implementiert, auch für unit-ähnliche Strukturen.</p>
<blockquote>
<h3 id="eigentümerschaft-von-strukturdaten"><a class="header" href="#eigentümerschaft-von-strukturdaten">Eigentümerschaft von Strukturdaten</a></h3>
<p>In der Strukturdefinition <code>User</code> in Codeblock 5-1 haben wir den Typ <code>String</code>
anstelle von <code>&amp;str</code> verwendet. Dies ist eine bewusste Entscheidung, denn wir
wollen, dass Instanzen dieser Struktur all ihre Daten besitzen und diese
Daten so lange gültig sind, wie die gesamte Struktur gültig ist.</p>
<p>Bei Strukturen ist es möglich, Referenzen auf Daten zu speichern, die im
Besitz von etwas anderem sind, aber das erfordert die Verwendung von
<em>Lebensdauern</em>, einer Rust-Funktionalität, die wir in Kapitel 10 besprechen
werden. Die Lebensdauer stellt sicher, dass die von einer Struktur
referenzierten Daten so lange gültig sind, wie die Struktur gültig ist.
Angenommen, du versuchst eine Referenz in einer Struktur zu speichern, ohne
eine Lebensdauer anzugeben, wird das nicht funktionieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "benutzername123",
        email: "jemand@example.com",
        sign_in_count: 1,
    };
}</code></pre></pre>
<p>Der Compiler wird sich beschweren, dass die Lebensdauer nicht angegeben ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` (bin "structs") due to 2 previous errors
</code></pre>
<p>In Kapitel 10 werden wir klären, wie man diese Fehler behebt und Referenzen
in Strukturen speichern kann. Aber für den Moment werden wir Fehler wie diese
vermeiden, indem wir Typen wie <code>String</code> anstelle von Referenzen wie <code>&amp;str</code>
verwenden.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="beispielprogramm-mit-strukturen-structs"><a class="header" href="#beispielprogramm-mit-strukturen-structs">Beispielprogramm mit Strukturen (structs)</a></h2>
<p>Um besser zu verstehen, wann wir Strukturen verwenden können, schreiben wir ein
Programm, das die Fläche eines Rechtecks berechnet. Wir beginnen mit einzelnen
Variablen und schreiben das Programm dann um, bis wir stattdessen Strukturen
einsetzen.</p>
<p>Legen wir mit Cargo ein neues Binärprojekt namens <em>rectangles</em> an, das die
Breite und Höhe eines in Pixeln angegebenen Rechtecks nimmt und die Fläche des
Rechtecks berechnet. Codeblock 5-8 zeigt ein kurzes Programm, das genau das in
<em>src/main.rs</em> unseres Projekts macht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "Die Fläche des Rechtecks ist {} Quadratpixel.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
<p><span class="caption">Codeblock 5-8: Berechnen der Fläche eines Rechtecks, das
durch separate Breiten- und Höhenvariablen beschrieben wird</span></p>
<p>Nun führe dieses Programm mit <code>cargo run</code> aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/structs`
Die Fläche des Rechtecks ist 1500 Quadratpixel.
</code></pre>
<p>Mit diesem Code gelingt es, die Fläche des Rechtecks zu ermitteln, indem die
Funktion <code>area</code> mit jeder Dimension aufgerufen wird. Aber wir können noch mehr
tun, um diesen Code klar und lesbar zu machen.</p>
<p>Das Problem dieses Codes wird bei der Signatur von <code>area</code> deutlich:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        "Die Fläche des Rechtecks ist {} Quadratpixel.",
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre></pre>
<p>Die Funktion <code>area</code> soll die Fläche eines Rechtecks berechnen, aber die von uns
geschriebene Funktion hat zwei Parameter und es geht in unserem Programm
nirgendwo klar hervor, dass die Parameter zusammenhängen. Es wäre besser lesbar
und überschaubarer, Breite und Höhe zusammenzufassen. Eine Möglichkeit dazu
haben wir bereits im Abschnitt <a href="ch03-02-data-types.html#der-tupel-typ">„Der Tupel-Typ“</a> in Kapitel 3
vorgestellt: Der Einsatz von Tupeln.</p>
<h3 id="refaktorierung-mit-tupeln"><a class="header" href="#refaktorierung-mit-tupeln">Refaktorierung mit Tupeln</a></h3>
<p>Codeblock 5-9 zeigt eine weitere Version unseres Programms, die Tupel
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let rect1 = (30, 50);

    println!(
        "Die Fläche des Rechtecks ist {} Quadratpixel.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre></pre>
<p><span class="caption">Codeblock 5-9: Breite und Höhe des Rechtecks werden mit
einem Tupel beschrieben</span></p>
<p>In einem Punkt ist dieses Programm besser. Das Tupel bringt etwas Struktur
hinein und wir geben jetzt nur noch ein Argument weiter. Andererseits ist
dieser Ansatz weniger deutlich: Tupel benennen ihre Elemente nicht, sodass wir
die Teile des Tupels indizieren müssen, was unsere Berechnung weniger klar
macht.</p>
<p>Die Verwechslung von Breite und Höhe ist für die Flächenberechnung nicht von
Bedeutung, aber wenn wir das Rechteck auf dem Bildschirm zeichnen wollen, wäre
es wichtig! Wir müssen uns merken, dass <code>width</code> der Tupelindex <code>0</code> und <code>height</code>
der Tupelindex <code>1</code> ist. Für andere wäre es noch schwieriger, dies
herauszufinden und im Kopf zu behalten, wenn sie unseren Code verwenden würden.
Da wir die Bedeutung unserer Daten nicht in unseren Code übertragen haben, ist
es jetzt einfacher, Fehler zu machen.</p>
<h3 id="refaktorierung-mit-strukturen-mehr-semantik"><a class="header" href="#refaktorierung-mit-strukturen-mehr-semantik">Refaktorierung mit Strukturen: Mehr Semantik</a></h3>
<p>Verwenden wir Strukturen, um durch die Benennung der Daten deren Bedeutung
anzugeben. Wir können das verwendete Tupel in eine Struktur mit einem Namen
für das Ganze sowie mit Namen für die Einzelteile umwandeln, wie in Codeblock
5-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "Die Fläche des Rechtecks ist {} Quadratpixel.",
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
<p><span class="caption">Codeblock 5-10: Definieren der Struktur <code>Rectangle</code></span></p>
<p>Hier haben wir eine Struktur definiert und sie <code>Rectangle</code> genannt. Innerhalb
der geschweiften Klammern haben wir die Felder <code>width</code> und <code>height</code> definiert,
die beide den Typ <code>u32</code> haben. Dann erzeugten wir in <code>main</code> eine Instanz von
<code>Rectangle</code> mit der Breite <code>30</code> und Höhe <code>50</code>.</p>
<p>Unsere Funktion <code>area</code> hat nun einen Parameter, den wir <code>rectangle</code> genannt
haben und dessen Typ eine unveränderbare Ausleihe (immutable borrow) einer
Strukturinstanz <code>Rectangle</code> ist. Wie in Kapitel 4 erwähnt, wollen wir die
Struktur nur ausleihen, nicht aber deren Eigentümerschaft (ownership)
übernehmen. Auf diese Weise behält <code>main</code> seine Eigentümerschaft und kann
weiterhin <code>rect1</code> verwenden, weshalb wir <code>&amp;</code> in der Funktionssignatur und an
der Aufrufstelle verwenden.</p>
<p>Die Funktion <code>area</code> greift auf die Felder <code>width</code> und <code>height</code> der Instanz
<code>Rectangle</code> zu. (Beachte, dass der Zugriff auf Felder einer ausgeliehenen
Struktur-Instanz die Feldwerte nicht verschiebt, weshalb du häufig Ausleihen
von Strukturen siehst.) Unsere Funktionssignatur für <code>area</code> sagt jetzt genau,
was wir meinen: Berechne die Fläche von <code>Rectangle</code> unter Verwendung seiner
Felder <code>width</code> und <code>height</code>. Dies drückt aus, dass Breite und Höhe in Beziehung
zueinander stehen, und gibt den Werten beschreibende Namen, ohne die
Tupelindexwerte <code>0</code> und <code>1</code> zu verwenden. Das erhöht die Lesbarkeit.</p>
<h3 id="hilfreiche-funktionalität-mit-abgeleiteten-merkmalen-derived-traits"><a class="header" href="#hilfreiche-funktionalität-mit-abgeleiteten-merkmalen-derived-traits">Hilfreiche Funktionalität mit abgeleiteten Merkmalen (derived traits)</a></h3>
<p>Es wäre hilfreich, eine Instanz von <code>Rectangle</code> samt der Werte seiner Felder
ausgeben zu können, während wir unser Programm debuggen. In Codeblock 5-11
versuchen wir, das <a href="https://doc.rust-lang.org/std/macro.println.html">Makro <code>println!</code></a> zu verwenden, das wir in den
vorangegangenen Kapiteln verwendet haben. Dies wird jedoch nicht funktionieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 ist {rect1}");
}</code></pre></pre>
<p><span class="caption">Codeblock 5-11: Versuch, eine <code>Rectangle</code>-Instanz
auszugeben</span></p>
<p>Wenn wir diesen Code kompilieren, erhalten wir folgende Fehlermeldung:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>Das Makro <code>println!</code> kann diverse Formatierungen vornehmen. Die geschweiften
Klammern weisen <code>println!</code> an, die Formatierung <code>Display</code> zu verwenden, bei der
die Ausgabe direkt für den Endbenutzer bestimmt ist. Die primitiven Typen, die
wir bisher gesehen haben, implementieren <code>Display</code> standardmäßig, denn es gibt
nur eine Möglichkeit, dem Benutzer eine <code>1</code> oder einen anderen primitiven Typ
zu zeigen. Aber bei Strukturen ist die Formatierung, die <code>println!</code> verwenden
soll, weniger klar, da es mehrere Darstellungsmöglichkeiten gibt: Möchtest du
Kommas oder nicht? Möchtest du die geschweiften Klammern ausgeben? Sollen alle
Felder angezeigt werden? Aufgrund der vielen Möglichkeiten versucht Rust nicht
zu erraten, was wir wollen. Strukturen haben daher keine
Standardimplementierung von <code>Display</code>, um die mit <code>println!</code> und dem
Platzhalter <code>{}</code> verwenden zu können.</p>
<p>Wenn wir die Fehlerausgabe weiterlesen, werden wir diesen hilfreichen Hinweis
finden:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Lass es uns versuchen! Der Makroaufruf <code>println!</code> wird geändert in
<code>println!("rect1 ist {rect1:?}");</code>. Wenn wir den Bezeichner <code>:?</code> innerhalb der
geschweiften Klammern angeben, teilen wir <code>println!</code> mit, dass wir das
Ausgabeformat <code>Debug</code> verwenden wollen. Das Merkmal <code>Debug</code> ermöglicht es, die
Struktur so auszugeben, dass Entwickler ihren Wert erkennen können, während sie
den Code debuggen.</p>
<p>Kompiliere den Code mit dieser Änderung. Verflixt! Wir erhalten immer noch
einen Fehler:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>Aber auch hier gibt uns der Compiler einen hilfreichen Hinweis:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust enthält durchaus eine Funktionalität zum Ausgeben von Debug-Informationen,
aber wir müssen diese explizit für unsere Struktur aktivieren. Dazu fügen wir
das äußere Attribut <code>#[derive(Debug)]</code> unmittelbar vor der Strukturdefinition
ein, wie in Codeblock 5-12 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 ist {rect1:?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 5-12: Attribut zum Verwenden des Merkmals
<code>Debug</code> und Ausgeben der Instanz <code>Rectangle</code> mittels Debug-Formatierung</span></p>
<p>Wenn wir das Programm nun ausführen, werden wir keinen Fehler mehr erhalten und
folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 ist Rectangle { width: 30, height: 50 }
</code></pre>
<p>Toll! Es ist nicht die schönste Ausgabe, aber sie zeigt die Werte aller Felder
dieser Instanz, was bei der Fehlersuche definitiv hilfreich ist. Bei größeren
Strukturen ist es hilfreich, eine leichter lesbare Ausgabe zu erhalten.
In diesen Fällen können wir <code>{:#?}</code> anstelle von <code>{:?}</code> in der
<code>println!</code>-Meldung verwenden. In diesem Beispiel wird bei Verwendung von
<code>{:#?}</code> folgendes ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 ist Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Eine andere Möglichkeit, einen Wert im <code>Debug</code>-Format auszugeben, ist die
Verwendung des <a href="https://doc.rust-lang.org/std/macro.dbg.html">Makros <code>dbg!</code></a>, das die Eigentümerschaft eines Ausdrucks
übernimmt (im Gegensatz zu <code>println!</code>, das eine Referenz nimmt), die Datei und
Zeilennummer, in der der <code>dbg!</code>-Makroaufruf in deinem Code vorkommt, zusammen
mit dem resultierenden Wert des Ausdrucks ausgibt und die Eigentümerschaft am
Wert zurückgibt.</p>
<blockquote>
<p>Hinweis: Der Aufruf des Makros <code>dbg!</code> schreibt in die
Standardfehlerausgabe (<code>stderr</code>), im Gegensatz zu <code>println!</code>, das in
die Standardausgabe (<code>stdout</code>) schreibt. Wir werden mehr über
<code>stderr</code> und <code>stdout</code> im Abschnitt <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">„Fehlermeldungen in die
Standardfehlerausgabe anstatt der Standardausgabe schreiben“ in Kapitel
12</a> erfahren.</p>
</blockquote>
<p>Hier ist ein Beispiel, bei dem wir am Wert interessiert sind, der dem Feld
<code>width</code> zugewiesen wird, als auch am Wert der gesamten Struktur in <code>rect1</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre></pre>
<p>Wir können <code>dbg!</code> um den Ausdruck <code>30 * scale</code> setzen, und da <code>dbg!</code> die
Eigentümerschaft des Werts des Ausdrucks zurückgibt, erhält das Feld <code>width</code>
denselben Wert, als wenn wir den <code>dbg!</code>-Aufruf dort nicht hätten. Wir wollen
nicht, dass <code>dbg!</code> die Eigentümerschaft von <code>rect1</code> übernimmt, also übergeben
wir eine Referenz auf <code>rect1</code> im nächsten Aufruf. So sieht die Ausgabe dieses
Beispiels aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>Wir können sehen, dass der erste Teil der Ausgabe von <em>src/main.rs</em> Zeile 10
stammt, wo wir den Ausdruck <code>30 * scale</code> debuggen, und der Ergebniswert ist
<code>60</code> (die <code>Debug</code>-Formatierung, die für Ganzzahlen implementiert ist, gibt nur
deren Wert aus). Der <code>dbg!</code>-Aufruf in Zeile 14 von <em>src/main.rs</em> gibt den Wert
von <code>&amp;rect1</code> aus, der die Struktur <code>Rectangle</code> ist. Diese Ausgabe verwendet die
hübsche <code>Debug</code>-Formatierung des Typs <code>Rectangle</code>. Das Makro <code>dbg!</code> kann sehr
hilfreich sein, wenn du versuchst, herauszufinden, was dein Code macht!</p>
<p>Zusätzlich zum Merkmal <code>Debug</code> hat Rust eine Reihe von Merkmalen für uns
bereitgestellt, die wir mit dem Attribut <code>derive</code> verwenden können und die
unseren benutzerdefinierten Typen nützliches Verhalten verleihen können. Diese
Merkmale und ihr Verhalten sind in <a href="appendix-03-derivable-traits.html">Anhang C</a> aufgeführt. In Kapitel 10
werden wir behandeln, wie man diese Merkmale mit benutzerdefiniertem Verhalten
implementiert und wie man eigene Merkmale erstellt. Es gibt auch viele andere
Attribute als <code>derive</code>; für weitere Informationen, siehe den <a href="https://doc.rust-lang.org/reference/attributes.html">Abschnitt
„Attribute“ in der Rust-Referenz</a>.</p>
<p>Unsere Funktion <code>area</code> ist sehr spezifisch: Sie berechnet nur die Fläche von
Rechtecken. Es wäre hilfreich, dieses Verhalten enger mit unserer Struktur
<code>Rectangle</code> zu verbinden, da es zu keinem anderen Typ passt. Schauen wir uns
an, wie wir den Code weiter umgestalten und unsere Funktion <code>area</code> in eine
<em>Methode</em> <code>area</code> unseres Typs <code>Rectangle</code> verwandeln können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="methodensyntax"><a class="header" href="#methodensyntax">Methodensyntax</a></h2>
<p><em>Methoden</em> sind Funktionen recht ähnlich: Sie werden mit dem Schlüsselwort <code>fn</code>
und ihrem Namen deklariert, sie können Parameter und einen Rückgabewert haben,
und sie enthalten etwas Code, der ausgeführt wird, wenn sie aufgerufen werden.
Methoden unterscheiden sich jedoch von Funktionen dadurch, dass sie im Kontext
einer Struktur (struct) (oder einer Aufzählung (enum) oder eines
Merkmalsobjektes (trait object), die wir in <a href="ch06-00-enums.html">Kapitel 6</a> und <a href="ch18-02-trait-objects.html">Kapitel
18</a> behandeln) definiert werden und ihr erster Parameter stets
<code>self</code> ist. <code>self</code> repräsentiert die Instanz der Struktur, zu der die Methode
aufgerufen wird.</p>
<h3 id="definieren-von-methoden"><a class="header" href="#definieren-von-methoden">Definieren von Methoden</a></h3>
<p>Lass uns die Funktion <code>area</code>, die eine <code>Rectangle</code>-Instanz als Parameter hat,
ändern und stattdessen eine Methode <code>area</code> auf der Struktur <code>Rectangle</code>
definieren, wie in Codeblock 5-13 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "Die Fläche des Rechtecks ist {} Quadratpixel.",
        rect1.area()
    );
}</code></pre></pre>
<p><span class="caption">Codeblock 5-13: Methode <code>area</code> der Struktur <code>Rectangle</code></span></p>
<p>Um die Funktion im Kontext von <code>Rectangle</code> zu definieren, beginnen wir mit dem
Block <code>impl</code> (Implementierung) für <code>Rectangle</code>. Alles in diesem Block wird mit
dem Typ <code>Rectangle</code> assoziiert. Dann verschieben wir die Funktion <code>area</code> in die
geschweiften Klammern von <code>impl</code>, ändern den ersten (und in diesem Fall
einzigen) Parameter zu <code>self</code> und passen den Methodenrumpf entsprechend an. In
<code>main</code>, wo wir die Funktion <code>area</code> aufrufen und <code>rect1</code> als Argument übergeben,
können wir stattdessen die <em>Methodensyntax</em> verwenden, um die Methode <code>area</code>
auf unserer <code>Rectangle</code>-Instanz aufzurufen. Die Methodensyntax bezieht sich auf
eine Instanz: Wir ergänzen einen Punkt, gefolgt vom Methodennamen, Klammern und
Argumenten.</p>
<p>In der Signatur von <code>area</code> verwenden wir <code>&amp;self</code> anstelle von <code>rectangle: &amp;Rectangle</code>. Das <code>&amp;self</code> ist eigentlich die Abkürzung für <code>self: &amp;Self</code>.
Innerhalb eines <code>impl</code>-Blocks ist der Typ <code>Self</code> ein Alias für den Typ, für den
der <code>impl</code>-Block steht. Methoden müssen einen Parameter mit dem Namen <code>self</code>
vom Typ <code>Self</code> als ihren ersten Parameter haben, Rust lässt dich dies abkürzen,
indem du nur den Namen <code>self</code> an der Stelle des ersten Parameters angibst.
Beachte, dass wir immer noch das <code>&amp;</code> vor der Abkürzung <code>self</code> verwenden müssen,
um anzuzeigen, dass diese Methode die Instanz <code>Self</code> ausleiht, genau wie in
<code>rectangle: &amp;Rectangle</code>. Methoden können die Eigentümerschaft von <code>self</code>
übernehmen, <code>self</code> unveränderbar ausleihen, wie wir es hier getan haben, oder
<code>self</code> veränderbar ausleihen, so wie bei jedem anderen Parameter auch.</p>
<p>Wir haben hier <code>&amp;self</code> aus dem gleichen Grund gewählt wie <code>&amp;Rectangle</code> in der
Funktionsvariante: Wir wollen keine Eigentümerschaft übernehmen, wir wollen die
Daten der Struktur nur lesen, nicht schreiben. Wenn wir die Instanzdaten ändern
wollten, müssten wir <code>&amp;mut self</code> als ersten Parameter verwenden. Es kommt nur
selten vor, dass eine Methode die Eigentümerschaft der Instanz übernimmt, indem
sie <code>self</code> als ersten Parameter verwendet. Diese Technik wird typischerweise
dann verwendet, wenn die Methode <code>self</code> in etwas anderes transformiert und man
verhindern will, dass der Aufrufer nach der Transformation die ursprüngliche
Instanz verwendet.</p>
<p>Der Hauptgrund für Methoden gegenüber Funktionen liegt abgesehen davon, dass
bei jeder Methodendeklaration der Typ von <code>self</code> nicht ständig wiederholt
werden muss, in der Organisation. Wir haben alle Dinge, die wir mit einer
Instanz eines Typs tun können, in einen einzigen <code>impl</code> Block gepackt.
Zukünftige Nutzer unseres Codes müssen so nicht an verschiedenen Stellen in der
von uns bereitgestellten Bibliothek nach Fähigkeiten von <code>Rectangle</code> suchen.</p>
<p>Beachte, dass wir einer Methode denselben Namen geben können wie einem der
Felder der Struktur. Zum Beispiel können wir eine Methode auf <code>Rectangle</code>
definieren, die ebenfalls <code>width</code> heißt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("Das Rechteck hat eine Breite ungleich Null; sie ist {}", rect1.width);
    }
}</code></pre></pre>
<p>Hier entscheiden wir uns dafür, dass die Methode <code>width</code> den Wert <code>true</code>
zurückgibt, wenn der Wert im Feld <code>width</code> der Instanz größer als 0 ist, und
<code>false</code>, wenn der Wert 0 ist: Wir können ein Feld innerhalb einer gleichnamigen
Methode für jeden Zweck verwenden. Wenn wir in <code>main</code> nach <code>rect1.width</code> eine
Klammer setzen, weiß Rust, dass wir die Methode <code>width</code> meinen. Wenn wir keine
Klammern verwenden, weiß Rust, dass wir das Feld <code>width</code> meinen.</p>
<p>Oft, aber nicht immer, wird eine Methode mit demselben Namen wie ein Feld so
definiert, dass sie nur den Wert des Feldes zurückgeben und nichts anderes tun.
Methoden wie diese werden <em>getters</em> genannt, und Rust implementiert sie nicht
automatisch für Strukturfelder, wie es einige andere Sprachen tun. Getter sind
nützlich, weil man das Feld als privat, die Methode aber als öffentlich
kennzeichnen und so den Nur-Lese-Zugriff auf dieses Feld als Teil der
öffentlichen API des Typs erhält. Was öffentlich und privat bedeuten und wie
man ein Feld oder eine Methode als öffentlich oder privat kennzeichnet, werden
wir in <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#pfade-mit-dem-schl%C3%BCsselwort-pub-%C3%B6ffentlich-machen">Kapitel 7</a> behandeln.</p>
<blockquote>
<h3 id="wo-ist-der-operator--"><a class="header" href="#wo-ist-der-operator--">Wo ist der Operator <code>-&gt;</code>?</a></h3>
<p>In C und C++ werden zwei verschiedene Operatoren für den Aufruf von Methoden
verwendet: Man verwendet <code>.</code>, wenn eine Methode direkt auf dem Objekt
aufgerufen wird, und <code>-&gt;</code>, wenn die Methode auf einem Zeiger auf das Objekt
aufrufen und der Zeiger zuerst dereferenziert werden muss. Anders gesagt,
wenn <code>object</code> ein Zeiger ist, ist <code>object-&gt;something()</code> ähnlich zu
<code>(*object).something()</code>.</p>
<p>Rust hat kein Äquivalent zum Operator <code>-&gt;</code>. Stattdessen hat Rust eine
Funktionalität namens <em>automatische Referenzierung und Dereferenzierung</em>
(automatic referencing and dereferencing). Der Aufruf von Methoden ist einer
der wenigen Orte in Rust, der dieses Verhalten aufweist.</p>
<p>Und so funktioniert es: Wenn du eine Methode mit <code>object.something()</code>
aufrufst, fügt Rust automatisch <code>&amp;</code>, <code>&amp;mut</code> oder <code>*</code> hinzu, sodass <code>object</code>
zur Signatur der Methode passt. Mit anderen Worten sind folgende Aufrufe
gleich:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>Der erste Aufruf sieht viel sauberer aus. Die automatische Referenzierung
funktioniert, weil Methoden einen eindeutigen Empfänger haben - den Typ von
<code>self</code>. Wenn man den Empfänger und den Namen einer Methode angibt, kann Rust
eindeutig herausfinden, ob die Methode lesend (<code>&amp;self</code>), veränderbar
(<code>&amp;mut self</code>) oder konsumierend (<code>self</code>) ist. Die Tatsache, dass Rust das
Ausleihen für die Methodenempfänger implizit macht, ist ein großer Beitrag
zur Ergonomie der Eigentümerschaft in der Praxis.</p>
</blockquote>
<h3 id="methoden-mit-mehreren-parametern"><a class="header" href="#methoden-mit-mehreren-parametern">Methoden mit mehreren Parametern</a></h3>
<p>Lass uns den Umgang mit Methoden üben, indem wir eine zweite Methode zur
Struktur <code>Rectangle</code> implementieren. Diesmal soll eine zweite Instanz von
<code>Rectangle</code> entgegengenommen und <code>true</code> zurückgeben werden, wenn das zweite
<code>Rectangle</code> vollständig in <code>self</code> (dem ersten <code>Rectangle</code>) hineinpasst;
andernfalls soll <code>false</code> zurückgegeben werden. Das heißt, sobald wir die
Methode <code>can_hold</code> definiert haben, wollen wir in der Lage sein, das in
Codeblock 5-14 gezeigte Programm zu schreiben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("rect1 umfasst rect2? {}", rect1.can_hold(&amp;rect2));
    println!("rect1 umfasst rect3? {}", rect1.can_hold(&amp;rect3));
}</code></pre>
<p><span class="caption">Codeblock 5-14: Verwendung der noch nicht geschriebenen
Methode <code>can_hold</code></span></p>
<p>Die erwartete Ausgabe würde wie folgt aussehen, da beide Dimensionen von
<code>rect2</code> kleiner als die Dimensionen von <code>rect1</code> sind, aber <code>rect3</code> breiter als
<code>rect1</code> ist:</p>
<pre><code class="language-text">rect1 umfasst rect2? true
rect1 umfasst rect3? false
</code></pre>
<p>Wir wissen, dass wir eine Methode definieren wollen, also wird sie innerhalb
des Blocks <code>impl Rectangle</code> liegen. Die Methode wird <code>can_hold</code> heißen und sie
wird einen weiteren Parameter vom Typ <code>Rectangle</code> unveränderbar ausleihen. Wir
können den Typ des Parameters erkennen, indem wir uns den Code ansehen, der die
Methode aufruft: <code>rect1.can_hold(&amp;rect2)</code> nimmt <code>&amp;rect2</code> entgegen, also eine
unveränderbare Ausleihe von <code>rect2</code> vom Typ <code>Rectangle</code>. Das macht Sinn, da
wir <code>rect2</code> nur lesen müssen (anstatt zu schreiben, wofür wir eine
veränderbare Ausleihe bräuchten) und <code>main</code> die Eigentümerschaft an <code>rect2</code>
zurückerhalten soll, sodass wir es nach dem Aufruf der Methode <code>can_hold</code>
weiter verwenden können. Der Rückgabewert von <code>can_hold</code> ist ein boolescher
Wert und die Implementierung prüft, ob Breite und Höhe von <code>self</code> jeweils
größer als von <code>Rectangle</code> sind. Fügen wir die neue Methode <code>can_hold</code> zum
Block <code>impl</code> aus Codeblock 5-13 hinzu, wie in Codeblock 5-15 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("rect1 umfasst rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("rect1 umfasst rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 5-15: Implementierung der Methode <code>can_hold</code>
auf <code>Rectangle</code>, die eine weitere <code>Rectangle</code>-Instanz als Parameter hat</span></p>
<p>Wenn wir diesen Code mit der Funktion <code>main</code> in Codeblock 5-14 ausführen,
erhalten wir die gewünschte Ausgabe. Methoden können mehrere Parameter haben,
die wir in der Signatur nach dem Parameter <code>self</code> angeben. Diese Parameter
funktionieren genau wie Parameter in Funktionen.</p>
<h3 id="assoziierte-funktionen"><a class="header" href="#assoziierte-funktionen">Assoziierte Funktionen</a></h3>
<p>Alle Funktionen, die innerhalb eines <code>impl</code>-Blocks definiert sind, werden
<em>assoziierte Funktionen</em> genannt, weil sie mit dem Typ assoziiert sind, der
nach dem <code>impl</code> benannt ist. Wir können assoziierte Funktionen definieren, die
nicht <code>self</code> als ihren ersten Parameter haben (und somit keine Methoden sind),
weil sie keine Instanz des Typs benötigen, um damit zu arbeiten. Wir haben
bereits eine solche Funktion verwendet: Die Funktion <code>String::from</code>, die für
den Typ <code>String</code> definiert ist.</p>
<p>Assoziierte Funktionen, die keine Methoden sind, werden oft als Konstruktoren
verwendet, die eine neue Instanz der Struktur zurückgeben. Diese werden oft als
<code>new</code> bezeichnet, aber <code>new</code> ist kein spezieller Name und ist nicht in die
Sprache eingebaut. Wir könnten zum Beispiel eine assoziierte Funktion mit dem
Namen <code>square</code> bereitstellen, die einen eindimensionalen Parameter hat und
diesen sowohl für die Breite als auch für die Höhe verwendet, sodass es
einfacher ist, ein quadratisches <code>Rectangle</code> zu erstellen, anstatt denselben
Wert zweimal angeben zu müssen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>Die Schlüsselwörter <code>Self</code> im Rückgabetyp und im Rumpf der Funktion sind Aliase
für den Typ, der nach dem Schlüsselwort <code>impl</code> steht, in diesem Fall
<code>Rectangle</code>.</p>
<p>Um diese assoziierte Funktion aufzurufen, verwenden wir die Syntax <code>::</code> mit dem
Strukturnamen, z.B. <code>let sq = Rectangle::square(3);</code>. Diese Funktion gehört zum
Namensraum der Struktur: Die Syntax <code>::</code> wird sowohl für assoziierte Funktionen
als auch für Namensräume, die von Modulen erzeugt werden, verwendet. Wir werden
die Module in <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">Kapitel 7</a> besprechen.</p>
<h3 id="mehrere-impl-blöcke"><a class="header" href="#mehrere-impl-blöcke">Mehrere <code>impl</code>-Blöcke</a></h3>
<p>Jede Struktur darf mehrere <code>impl</code>-Blöcke haben. Beispielsweise entspricht
Codeblock 5-15 dem in Codeblock 5-16 gezeigten Code, bei dem jede Methode in
einem eigenen <code>impl</code>-Block steht.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("rect1 umfasst rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("rect1 umfasst rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 5-16: Neuschreiben von Codeblock 5-15 unter
Verwendung mehrerer <code>impl</code>-Blöcke</span></p>
<p>Es ist nicht nötig, diese Methoden hier auf mehrere <code>impl</code>-Blöcke zu verteilen,
aber es handelt sich um eine gültige Syntax. Wir werden in Kapitel 10 einen
Fall sehen, bei dem mehrere <code>impl</code>-Blöcke hilfreich sind, wenn wir generische
Typen und Merkmale behandeln.</p>
<h2 id="zusammenfassung-4"><a class="header" href="#zusammenfassung-4">Zusammenfassung</a></h2>
<p>Mit Strukturen kannst du benutzerdefinierte Typen erstellen, die in deiner
Domäne eine Bedeutung haben. Durch die Verwendung von Strukturen kannst du
zusammengehörige Datenteile miteinander verbunden halten und jedes Teil
benennen, um deinen Code verständlich zu machen. In <code>impl</code>-Blöcken kannst du
Funktionen definieren, die mit deinem Typ assoziiert sind, und Methoden sind
eine Art assoziierte Funktion, mit der du das Verhalten von Instanzen deiner
Strukturen festlegen kannst.</p>
<p>Aber Strukturen sind nicht die einzige Möglichkeit, benutzerdefinierte Typen zu
definieren: Wenden wir uns der Rust-Funktionalität Aufzählung zu, um ein
weiteres Werkzeug in deinen Werkzeugkasten zu legen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aufzählungen-enums-und-musterabgleich-pattern-matching"><a class="header" href="#aufzählungen-enums-und-musterabgleich-pattern-matching">Aufzählungen (enums) und Musterabgleich (pattern matching)</a></h1>
<p>In diesem Kapitel werden wir uns mit <em>Aufzählungen</em> (enumerations, kurz: enums)
befassen. Aufzählungen erlauben es, einen Typ durch Aufzählung seiner möglichen
<em>Varianten</em> (variants) zu definieren. Zuerst werden wir eine Aufzählung
definieren und verwenden, um zu zeigen, wie eine Aufzählung mit Daten eine
Bedeutung kodieren kann. Als Nächstes werden wir eine besonders nützliche
Aufzählung untersuchen, die <code>Option</code> genannt wird und zum Ausdruck bringt, dass
ein Wert entweder etwas oder nichts sein kann. Dann sehen wir uns an, wie man
mit dem Musterabgleich (pattern matching) im Ausdruck <code>match</code> auf einfache
Weise unterschiedlichen Code für verschiedene Werte einer Aufzählung
auszuführen kann. Schließlich werden wir uns mit dem Konstrukt <code>if let</code>
befassen, einem weiteren bequemen und prägnanten Idiom, um mit Aufzählungen in
deinem Code umzugehen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="eine-aufzählung-enum-definieren"><a class="header" href="#eine-aufzählung-enum-definieren">Eine Aufzählung (enum) definieren</a></h2>
<p>Während Strukturen (structs) eine Möglichkeit bieten, zusammengehörige Felder
und Daten zu gruppieren, wie ein <code>Rectangle</code> mit seiner <code>width</code> und <code>height</code>,
bieten Aufzählungen (enums) eine Möglichkeit, einen Wert als einen aus einer
möglichen Gruppe von Werten anzugeben. Wir können zum Beispiel sagen, dass
<code>Rectangle</code> eine von mehreren möglichen Formen ist, zu denen auch <code>Circle</code> und
<code>Triangle</code> gehören. Um dies zu tun, erlaubt Rust uns, diese Möglichkeiten als
Aufzählung zu kodieren.</p>
<p>Schauen wir uns eine Situation an, die wir vielleicht in Code ausdrücken
wollen, und sehen wir, warum Aufzählungen in diesem Fall nützlich und besser
geeignet sind als Strukturen. Angenommen, wir müssen mit IP-Adressen arbeiten.
Aktuell werden zwei Hauptstandards für IP-Adressen verwendet: Version vier und
Version sechs. Da dies die einzigen Möglichkeiten für eine IP-Adresse sind, auf
die unser Programm stößt, können wir alle möglichen Varianten <em>aufzählen</em>,
woher die Aufzählung ihren Namen hat.</p>
<p>Jede IP-Adresse kann entweder eine Adresse der Version vier oder der Version
sechs sein, aber nicht beides gleichzeitig. Diese Eigenschaft der IP-Adressen
passt zur Aufzählungs-Datenstruktur, da ein Aufzählungswert nur eine seiner
Varianten sein kann. Sowohl die Adressen der Version vier als auch der Version
sechs sind grundsätzlich immer noch IP-Adressen, sodass sie als der gleiche Typ
behandelt werden sollten, wenn der Code mit Situationen zu tun hat, die für
beide IP-Adressenarten gelten.</p>
<p>Wir können dieses Konzept im Code ausdrücken, indem wir eine Aufzählung
<code>IpAddrKind</code> definieren und die möglichen Varianten auflisten, die eine
IP-Adresse haben kann, <code>V4</code> und <code>V6</code>. Hier die Varianten der Aufzählung:</p>
<pre><pre class="playground"><code class="language-rust edition2024">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code> ist jetzt ein benutzerdefinierter Datentyp, den wir an anderer
Stelle in unserem Code verwenden können.</p>
<h3 id="werte-in-aufzählungen"><a class="header" href="#werte-in-aufzählungen">Werte in Aufzählungen</a></h3>
<p>Wir können Instanzen von beiden Varianten von <code>IpAddrKind</code> wie folgt erstellen:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Beachte, dass die Varianten der Aufzählung mit dem Namensraum des Bezeichners
angegeben sind und wir einen doppelten Doppelpunkt verwenden, um die beiden zu
trennen. Das ist sinnvoll, weil beide Werte <code>IpAddrKind::V4</code> und
<code>IpAddrKind::V6</code> vom gleichen Typ sind: <code>IpAddrKind</code>. Wir können dann zum
Beispiel eine Funktion definieren, die jedes <code>IpAddrKind</code> annimmt:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>Und wir können diese Funktion mit beiden Varianten aufrufen:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Aufzählungen haben noch weitere Vorteile. Wenn wir weiter über unseren
IP-Adresstyp nachdenken, haben wir im Moment keine Möglichkeit, den <em>Wert</em> der
tatsächlichen IP-Adresse zu speichern; wir wissen nur, um welche <em>Variante</em> es
sich handelt. Mit dem was du gerade erst in Kapitel 5 über Strukturen gelernt
hast, könntest du versucht sein, dieses Problem mit Strukturen zu lösen, wie in
Codeblock 6-1.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-1: Speichern des Wertes und der
<code>IpAddrKind</code>-Variante einer IP-Adresse mittels <code>struct</code></span></p>
<p>Hier haben wir eine Struktur <code>IpAddr</code> definiert, die zwei Felder hat:  Ein Feld
<code>kind</code> vom Typ <code>IpAddrKind</code> (die zuvor definierte Aufzählung) und ein Feld
<code>address</code> vom Typ <code>String</code>. Wir haben zwei Instanzen dieser Struktur erzeugt.
Die erste ist <code>home</code> und hat die Variante <code>IpAddrKind::V4</code> und die zugehörige
Adresse <code>127.0.0.1</code>. Die zweite Instanz ist <code>loopback</code> und hat die Variante
<code>V6</code> von <code>IpAddrKind</code> als ihren Wert für <code>kind</code> und die zugehörige Adresse
<code>::1</code>. Wir haben eine Struktur verwendet, um die Werte <code>kind</code> und <code>address</code> zu
bündeln, sodass jetzt die Variante mit dem Wert verbunden ist.</p>
<p>Allerdings ist die Darstellung desselben Konzepts mit einer Aufzählung
prägnanter: Anstelle einer Aufzählung innerhalb einer Struktur können wir die
Daten direkt in jede Aufzählungsvariante einfügen. Diese neue Definition der
Aufzählung <code>IpAddr</code> legt fest, dass sowohl die Variante <code>V4</code> als auch <code>V6</code>
zugehörige <code>String</code>-Werte haben:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>Wir hängen die Daten direkt an jede Variante der Aufzählung an, so dass keine
zusätzliche Struktur erforderlich ist. Hier ist es auch einfacher, ein weiteres
Detail der Funktionsweise von Aufzählungen zu betrachten: Der Name jeder
Aufzählungs-Variante, die wir definieren, wird auch zu einer Funktion, die eine
Instanz der Aufzählung konstruiert. Das heißt, <code>IpAddr::V4()</code> ist ein
Funktionsaufruf der ein <code>String</code>-Argument entgegennimmt und eine Instanz des
Typs <code>IpAddr</code> zurückgibt. Diese Konstruktorfunktion wird automatisch definiert
als Ergebnis der Definition der Aufzählung.</p>
<p>Es gibt noch einen weiteren Vorteil, eine Aufzählung statt einer Struktur zu
verwenden: Jede Variante kann verschiedene Typen und verschieden viele
zugehöriger Daten haben. IP-Adressen der Version vier haben stets vier
numerische Komponenten, die Werte zwischen 0 und 255 haben. Wenn wir
<code>V4</code>-Adressen als vier <code>u8</code>-Werte speichern und <code>V6</code>-Adressen als einen
<code>String</code>-Wert ausdrücken wollten, wäre das mit einer Struktur nicht möglich.
Aufzählungen lösen diesen Fall ganz einfach:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>Wir haben verschiedene Möglichkeiten zur Definition von Datenstrukturen
gezeigt, die Version vier und sechs einer IP-Adresse speichern können.
Wie sich jedoch herausstellt, ist der Wunsch, IP-Adressen inklusive deren
Variante zu speichern, so verbreitet, dass <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">die Standardbibliothek eine
Definition bereitstellt</a>, die wir verwenden können! Schauen wir uns an,
wie die Standardbibliothek <code>IpAddr</code> definiert: Es hat genau die Aufzählung und
die Varianten, die wir definiert und verwendet haben, aber es bettet die
Adressdaten innerhalb der Varianten in Form von zwei verschiedenen Strukturen
ein, die für jede Variante unterschiedlich definiert sind:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --abschneiden--
}

struct Ipv6Addr {
    // --abschneiden--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code veranschaulicht, dass du jede Art von Daten in eine
Aufzählungsvariante einfügen kannst: Zeichenketten, numerische Typen,
Strukturen usw. Du kannst sogar eine weitere Aufzählung einfügen! Außerdem sind
Standardbibliothekstypen oft nicht viel komplizierter als das, was du dir
vielleicht ausdenkst. Beachte, dass wir, obwohl die Standardbibliothek eine
Definition für <code>IpAddr</code> enthält, konfliktfrei unsere eigene Definition
erstellen und verwenden können, da wir die Definition der Standardbibliothek
nicht in unseren Gültigkeitsbereich aufgenommen haben. Wir werden in Kapitel 7
mehr darauf eingehen, wie man Typen in den Gültigkeitsbereich aufnimmt.</p>
<p>Schauen wir uns ein weiteres Beispiel für eine Aufzählung in Codeblock 6-2 an:
In dieser Aufzählung ist eine Vielzahl von Typen in ihren Varianten eingebettet.</p>
<pre><pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-2: Eine Aufzählung <code>Message</code>, deren Varianten
jeweils eine unterschiedliche Anzahl an Werttypen speichern</span></p>
<p>Diese Aufzählung hat vier Varianten mit unterschiedlichen Typen:</p>
<ul>
<li><code>Quit</code> hat überhaupt keine Daten.</li>
<li><code>Move</code> hat benannte Felder wie eine Struktur.</li>
<li><code>Write</code> enthält einen einzelnen <code>String</code>.</li>
<li><code>ChangeColor</code> enthält drei <code>i32</code>-Werte.</li>
</ul>
<p>Die Definition einer Aufzählung mit Varianten wie in Codeblock 6-2 ist ähnlich
zur Definition verschiedener Arten von Strukturdefinitionen, außer dass die
Aufzählung nicht das Schlüsselwort <code>struct</code> verwendet und alle Varianten unter
dem Typ <code>Message</code> zusammengefasst sind. Die folgenden Strukturen könnten die
gleichen Daten aufnehmen wie die vorhergehenden Aufzählungsvarianten:</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct QuitMessage; // leere Struktur
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // Tupelstruktur
struct ChangeColorMessage(i32, i32, i32); // Tupelstruktur
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Aber wenn wir die verschiedenen Strukturen verwenden würden, die jeweils ein
eigener Typ sind, könnten wir nicht so einfach eine Funktion definieren, die
eine dieser Nachrichtenarten entgegennimmt, wie wir es mit der in Codeblock 6-2
definierten Aufzählung <code>Message</code> gemacht haben, bei der es sich um einen
einzigen Typ handelt.</p>
<p>Es gibt noch eine weitere Ähnlichkeit zwischen Aufzählungen und Strukturen: So
wie wir Methoden für Strukturen mit <code>impl</code> definieren können, können wir auch
Methoden für Aufzählungen definieren. Hier ist eine Methode namens <code>call</code>, die
wir für unsere Aufzählung <code>Message</code> definieren könnten:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // Methodenrumpf
        }
    }

    let m = Message::Write(String::from("hallo"));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>Der Methodenrumpf würde <code>self</code> benutzen, um den Wert zu erhalten, auf den wir
die Methode aufgerufen haben. In diesem Beispiel haben wir eine Variable <code>m</code>
erstellt, die den Wert <code>Message::Write(String::from("hallo"))</code> hat. Genau
diesen Wert wird <code>self</code> im Rumpf der Methode <code>call</code> haben, wenn <code>m.call()</code>
ausgeführt wird.</p>
<p>Sehen wir uns eine weitere Aufzählung in der Standardbibliothek an, die sehr
verbreitet und hilfreich ist: <code>Option</code></p>
<h3 id="die-aufzählung-option-und-ihre-vorteile-gegenüber-nullwerten"><a class="header" href="#die-aufzählung-option-und-ihre-vorteile-gegenüber-nullwerten">Die Aufzählung <code>Option</code> und ihre Vorteile gegenüber Nullwerten</a></h3>
<p>Dieser Abschnitt befasst sich mit einer Fallstudie zu <code>Option</code>, einer weiteren
Aufzählung, die von der Standardbibliothek definiert wird. Der Typ <code>Option</code>
kodiert das sehr häufige Szenario, in dem ein Wert etwas oder nichts sein kann.</p>
<p>Wenn du zum Beispiel das erste Element einer nichtleeren Liste anforderst,
erhältst du einen Wert. Wenn du das erste Element einer leeren Liste abfragst,
erhältst du nichts. Im Sinne des Typsystems bedeutet das, dass der Compiler
überprüfen kann, ob du alle Fälle behandelt hast, die du behandelt haben solltest.
Diese Funktionalität kann Fehler vermeiden, die in anderen Programmiersprachen
extrem häufig auftreten.</p>
<p>Bei der Entwicklung von Programmiersprachen wird oft überlegt, welche
Funktionalität aufgenommen werden soll, aber auch die auszuschließende
Funktionalität ist wichtig. Rust hat nicht die Funktionalität „null“, die es in
vielen anderen Sprachen gibt. <em>Null</em> ist ein Wert, der bedeutet, dass kein Wert
vorhanden ist. In Sprachen mit null können sich Variablen immer in einem von
zwei Zuständen befinden: null oder nicht null.</p>
<p>In seinem Vortrag „Nullreferenzen: Der milliardenschwere Fehler“ von 2009 hat
Tony Hoare, der Erfinder von null, folgendes gesagt:</p>
<blockquote>
<p>Ich nenne es meinen milliardenschweren Fehler. Zu dieser Zeit entwarf ich das
erste umfangreiche Typsystem für Referenzen in einer objektorientierten
Sprache. Mein Ziel war es, sicherzustellen, dass jede Verwendung von
Referenzen absolut sicher sein sollte, wobei die Überprüfung automatisch
durch den Compiler durchgeführt wird. Aber ich konnte der Versuchung nicht
widerstehen, eine Nullreferenz einzuführen, nur weil sie so einfach
umzusetzen war. Dies hat zu unzähligen Fehlern, Schwachstellen und
Systemabstürzen geführt, die in den letzten vierzig Jahren wahrscheinlich
eine Milliarde Dollar Schmerz und Schaden verursacht haben.</p>
</blockquote>
<p>Das Problem mit Nullwerten besteht darin, dass du einen Fehler erhältst, wenn
du versuchst, einen Nullwert als Nicht-Nullwert zu verwenden. Da diese Null-
oder Nicht-Null-Eigenschaft allgegenwärtig ist, ist es extrem einfach, einen
derartigen Fehler zu machen.</p>
<p>Das Konzept, das die Null zum Ausdruck bringen will, ist jedoch nach wie vor
nützlich: Null ist ein Wert, der aktuell ungültig ist oder aus irgendeinem
Grund nicht vorhanden ist.</p>
<p>Das Problem liegt nicht wirklich im Konzept, sondern in der konkreten
Umsetzung. Als solches hat Rust keine Nullen, aber es hat eine Aufzählung, die
das Konzept des Vorhandenseins oder Nichtvorhandenseins eines Wertes abbilden
kann. Diese Aufzählung heißt <code>Option&lt;T&gt;</code> und ist
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">in der Standardbibliothek</a> wie folgt definiert:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>Die Aufzählung <code>Option&lt;T&gt;</code> ist so nützlich, dass sie sogar im Präludium
enthalten ist; du musst sie nicht explizit in den Gültigkeitsbereich bringen.
Ihre Varianten sind ebenfalls im Präludium enthalten: Du kannst <code>Some</code> und
<code>None</code> direkt ohne Präfix <code>Option::</code> verwenden. Die Aufzählung <code>Option&lt;T&gt;</code> ist
dennoch nur eine normale Aufzählung, und <code>Some(T)</code> und <code>None</code> sind nur
Varianten des Typs <code>Option&lt;T&gt;</code>.</p>
<p>Die Syntax <code>&lt;T&gt;</code> ist eine Funktionalität von Rust, über die wir noch nicht
gesprochen haben. Es handelt sich um einen generischen Typparameter, auf den
wir in Kapitel 10 näher eingehen werden. Für den Moment musst du nur wissen,
dass <code>&lt;T&gt;</code> bedeutet, dass die Variante <code>Some</code> der Aufzählung <code>Option</code> einen
Wert eines beliebigen Typs enthalten kann und dass jeder konkrete Typ, der
anstelle von <code>T</code> verwendet wird, den Gesamttyp <code>Option&lt;T&gt;</code> zu einem anderen Typ
macht. Hier sind einige Beispiele für die Verwendung von <code>Option</code>-Werten zur
Aufnahme von Zahlentypen und Zeichentypen:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>Der Typ von <code>some_number</code> ist <code>Option&lt;i32&gt;</code>. Der Typ von <code>some_char</code> ist
<code>Option&lt;char&gt;</code>, was ein anderer Typ ist. Rust kann diese Typen ableiten, weil
wir einen Wert innerhalb der <code>Some</code>-Variante angegeben haben. Für
<code>absent_number</code> verlangt Rust den gesamten Typ <code>Option</code> zu annotieren: Der
Compiler kann den Typ, den die entsprechende <code>Some</code>-Variante haben wird, nicht
ableiten, wenn sie nur einen <code>None</code>-Wert enthält. Hier sagen wir Rust, dass
<code>absent_number</code> vom Typ <code>Option&lt;i32&gt;</code> sein soll.</p>
<p>Wenn wir einen Wert <code>Some</code> haben, wissen wir, dass ein Wert vorhanden ist und
der Wert innerhalb von <code>Some</code> gehalten wird. Wenn wir einen Wert <code>None</code> haben,
bedeutet das in gewisser Weise dasselbe wie Null: Wir haben keinen gültigen
Wert. Warum ist nun besser <code>Option&lt;T&gt;</code> anstelle von Null zu verwenden?</p>
<p>Kurz gesagt, weil <code>Option&lt;T&gt;</code> und <code>T</code> (wobei <code>T</code> ein beliebiger Typ sein kann)
unterschiedliche Typen sind, erlaubt es der Compiler nicht <code>Option&lt;T&gt;</code> so zu
verwenden als wäre es definitiv ein gültiger Wert. Beispielsweise lässt sich
dieser Code nicht kompilieren, weil er versucht, ein <code>i8</code> mit einem
<code>Option&lt;i8&gt;</code> zu addieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
<span class="boring">}</span></code></pre></pre>
<p>Wenn wir diesen Code ausführen, erhalten wir eine Fehlermeldung wie diese:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            &lt;i8 as Add&gt;
            &lt;i8 as Add&lt;&amp;i8&gt;&gt;
            &lt;&amp;'a i8 as Add&lt;i8&gt;&gt;
            &lt;&amp;i8 as Add&lt;&amp;i8&gt;&gt;

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Stark! Tatsächlich bedeutet diese Fehlermeldung, dass Rust nicht versteht, wie
man ein <code>i8</code> und eine <code>Option&lt;i8&gt;</code> addiert, da es sich um unterschiedliche Typen
handelt. Wenn wir einen Wert eines Typs wie <code>i8</code> in Rust haben, stellt der
Compiler sicher, dass wir immer einen gültigen Wert haben. Wir können getrost fortfahren, ohne vor der Verwendung dieses Wertes auf Null prüfen zu
müssen. Nur wenn wir eine <code>Option&lt;i8&gt;</code> (oder einen anderen Werttyp) haben,
müssen wir befürchten, dass wir möglicherweise keinen Wert haben, und der
Compiler wird sicherstellen, dass wir diesen Fall behandeln, bevor wir den
Wert verwenden.</p>
<p>Mit anderen Worten musst du eine <code>Option&lt;T&gt;</code> in ein <code>T</code> konvertieren, bevor du
<code>T</code>-Operationen darauf durchführen kannst. Im Allgemeinen hilft dies, eines der
häufigsten Probleme mit Null abzufangen: Anzunehmen, dass etwas nicht null ist,
obwohl es tatsächlich null ist.</p>
<p>Durch Vermeiden des Risikos, fälschlicherweise einen Nicht-Null-Wert
anzunehmen, gewinnst du mehr Vertrauen in deinen Code. Um einen Wert zu haben,
der möglicherweise null sein kann, musst du dich explizit dafür entscheiden,
indem du als Typ <code>Option&lt;T&gt;</code> verwendest. Wenn du dann diesen Wert verwendest,
musst du den Fall null explizit behandeln. Überall dort, wo ein Wert nicht den
Typ <code>Option&lt;T&gt;</code> hat, kannst du <em>sicher</em> sein, dass der Wert nicht null ist.
Dies war eine bewusste Konstruktionsentscheidung bei Rust, um die Verbreitung
von Null einzuschränken und die Sicherheit von Rust-Code zu erhöhen.</p>
<p>Wie erhältst du nun den <code>T</code>-Wert aus einer Variante <code>Some</code>, wenn du einen Wert
vom Typ <code>Option&lt;T&gt;</code> hast? Die Aufzählung <code>Option&lt;T&gt;</code> enthält eine große Anzahl
von Methoden, die in einer Vielzahl von Situationen nützlich sind; mehr dazu
findest du in <a href="https://doc.rust-lang.org/std/option/enum.Option.html">der Dokumentation</a>. Sich mit den Methoden von <code>Option&lt;T&gt;</code>
vertraut zu machen, wird dir auf deiner Reise mit Rust äußerst nützlich sein.</p>
<p>Um einen <code>Option&lt;T&gt;</code>-Wert zu verwenden, benötigst du im Allgemeinen Code, der
jede Variante behandelt. Du möchtest einen Code, der nur läuft, wenn du einen
Wert <code>Some(T)</code> hast, und dieser Code darf das innere <code>T</code> benutzen. Du möchtest,
dass ein anderer Code ausgeführt wird, wenn du einen Wert <code>None</code> hast, und
dieser Code hat keinen <code>T</code>-Wert. Der Ausdruck <code>match</code> ist ein
Kontrollflusskonstrukt, das genau dies tut, wenn es mit Aufzählungen verwendet
wird: Es führt unterschiedlichen Code aus, je nachdem, welche Variante der
Aufzählung es hat, und dieser Code kann die Daten innerhalb des passenden
Wertes verwenden.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="das-kontrollflusskonstrukt-match"><a class="header" href="#das-kontrollflusskonstrukt-match">Das Kontrollflusskonstrukt <code>match</code></a></h2>
<p>Rust verfügt über ein extrem leistungsfähiges Kontrollflusskonstrukt namens
<code>match</code>, der es dir ermöglicht, einen Wert mit einer Reihe von Mustern
abzugleichen und dann Code zum jeweils passenden Muster auszuführen. Muster
können sich aus Literalen, Variablennamen, Platzhaltern und vielen anderen
Dingen zusammensetzen. <a href="ch19-00-patterns.html">Kapitel 19</a> befasst sich mit all den
verschiedenen Musterarten und wie sie funktionieren. Die Mächtigkeit von
<code>match</code> kommt von der Ausdruckskraft der Muster und der Tatsache, dass der
Compiler sicherstellt, dass alle möglichen Fälle behandelt werden.</p>
<p>Stelle dir einen <code>match</code>-Ausdruck wie eine Münzsortiermaschine vor:  Die Münzen
rutschen eine Bahn mit unterschiedlich großen Löchern entlang, und jede Münze
fällt durch das erste Loch, in das sie hineinpasst. Auf die gleiche Weise
durchlaufen die Werte die Muster in einem <code>match</code>-Ausdruck und beim ersten
„passenden“ Muster fällt der Wert in den zugehörigen Codeblock, der ausgeführt
werden soll.</p>
<p>Apropos Münzen, nehmen wir sie als Beispiel für die Verwendung von <code>match</code>! Wir
können eine Funktion schreiben, die eine unbekannte US-Münze nimmt und, ähnlich
wie die Zählmaschine, bestimmt, um welche Münze es sich handelt und ihren Wert
in Cent zurückgibt, wie in Codeblock 6-3 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust edition2024">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-3: Eine Aufzählung und ein <code>match</code>-Ausdruck,
der die Varianten der Aufzählung als Muster hat</span></p>
<p>Lass uns den <code>match</code>-Ausdruck in der Funktion <code>value_in_cents</code> aufschlüsseln.
Zuerst geben wir das Schlüsselwort <code>match</code> an, gefolgt von einem Ausdruck, der
in diesem Fall der Wert <code>coin</code> ist. Dies scheint einem bedingten Ausdruck sehr
ähnlich zu sein, der bei <code>if</code> verwendet wird, aber es gibt einen großen
Unterschied: Bei <code>if</code> muss die Bedingung einen booleschen Wert ergeben, aber
hier kann ein beliebiger Typ zurückgegeben werden. Der Typ von <code>coin</code> ist in
diesem Beispiel die Aufzählung <code>Coin</code>, die wir in der ersten Zeile definiert
haben.</p>
<p>Als nächstes kommen die <code>match</code>-Zweige. Ein Zweig hat zwei Teile: Ein Muster
und etwas Code. Der erste Zweig hat als Muster den Wert <code>Coin::Penny</code>, dann den
Operator <code>=&gt;</code>, der das Muster und den auszuführenden Code trennt. Der Code ist
in diesem Fall nur der Wert <code>1</code>. Jeder Zweig wird durch ein Komma vom nächsten
getrennt.</p>
<p>Wenn der <code>match</code>-Ausdruck ausgeführt wird, gleicht er den Ergebniswert mit dem
Muster jedes Zweigs ab, und zwar der Reihe nach. Wenn ein Muster zum Wert
passt, wird der zu diesem Muster gehörende Code ausgeführt. Wenn das Muster
nicht zum Wert passt, wird die Ausführung beim nächsten Zweig fortgesetzt,
ähnlich wie bei einer Münzsortiermaschine. Wir können so viele Zweige haben,
wie wir brauchen: In Codeblock 6-3 hat unser <code>match</code>-Ausdruck vier Zweige.</p>
<p>Der zu jedem Zweig gehörende Code ist ein Ausdruck, und der Ergebniswert des
Ausdrucks im zugehörenden Zweig ist der Wert, der für den gesamten
<code>match</code>-Ausdruck zurückgegeben wird.</p>
<p>Wir verwenden üblicherweise keine geschweiften Klammern, wenn der Zweig-Code
kurz ist, so wie in Codeblock 6-3, wo jeder Zweig nur einen Wert zurückgibt.
Wenn du mehrere Codezeilen in einem Zweig ausführen möchtest, musst du
geschweifte Klammern verwenden, und das Komma nach dem Zweig ist dann optional.
Zum Beispiel gibt der folgende Code jedes Mal „Glückspfennig!“ aus, wenn die
Methode mit <code>Coin::Penny</code> aufgerufen wird, er gibt aber immer noch den letzten
Wert <code>1</code> des Blocks zurück:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("Glückspfennig!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="muster-die-werte-binden"><a class="header" href="#muster-die-werte-binden">Muster, die Werte binden</a></h3>
<p>Eine weitere nützliche Funktionalität von <code>match</code>-Zweigen ist, dass sie Teile
der Werte binden können, die dem Muster entsprechen. Auf diese Weise können wir
Werte aus Aufzählungsvarianten extrahieren.</p>
<p>Lass uns als Beispiel eine unserer Aufzählungsvarianten so ändern, dass sie
Daten enthält. Von 1999 bis 2008 prägten die Vereinigten Staaten 25-Cent-Münzen
mit unterschiedlichem Aussehen auf einer Seite für jeden der 50 Staaten. Keine
andere Münze hatte ein Staaten-spezifisches Aussehen, sodass nur 25-Cent-Münzen
diese zusätzliche Eigenschaft haben. Wir können diese Information in unserer
Aufzählung unterbringen, indem wir die Variante <code>Quarter</code> so ändern, dass sie
einen <code>UsState</code>-Wert enthält, wie in Codeblock 6-4 umgesetzt.</p>
<pre><pre class="playground"><code class="language-rust edition2024">enum UsState {
    Alabama,
    Alaska,
    // --abschneiden--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-4: Aufzählung <code>Coin</code>, bei der die Variante
<code>Quarter</code> zusätzlich einen <code>UsState</code>-Wert enthält</span></p>
<p>Stellen wir uns vor, dass ein Freund versucht, 25-Cent-Münzen aller 50
Staaten zu sammeln. Während wir unser Kleingeld nach Münzsorten sortieren,
geben wir auch den Namen des Staates der 25-Cent-Münze aus, sodass es unser
Freund in seine Sammlung aufnehmen kann, falls er es nicht hat. Im
<code>match</code>-Ausdruck für diesen Code fügen wir zum Muster der Variante
<code>Coin::Quarter</code> eine Variable <code>state</code> hinzu. Wenn der Zweig für <code>Coin::Quarter</code>
passt, wird die Variable <code>state</code> an den Wert der Eigenschaft der 25-Cent-Münze
gebunden. Dann können wir <code>state</code> im Code für diesen Zweig etwa so verwenden:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("25-Cent-Münze aus {state:?}!");
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p>Wenn wir <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code> aufrufen würden,
hätte <code>coin</code> den Wert <code>Coin::Quarter(UsState::Alaska)</code>. Gleichen wir den Wert
mit jedem der <code>match</code>-Zweige ab, passt keiner von ihnen, bis wir
<code>Coin::Quarter(state)</code> erreichen. An diesem Punkt wird <code>state</code> an den Wert
<code>UsState::Alaska</code> gebunden. Wir können dann diese Bindung im
<code>println!</code>-Ausdruck verwenden und so den inneren Zustandswert aus der
<code>Coin</code>-Aufzählungsvariante für <code>Quarter</code> herausholen.</p>
<h3 id="abgleich-mit-optiont"><a class="header" href="#abgleich-mit-optiont">Abgleich mit <code>Option&lt;T&gt;</code></a></h3>
<p>Im vorigen Abschnitt wollten wir den inneren <code>T</code>-Wert aus dem Fall <code>Some</code>
herausholen, als wir <code>Option&lt;T&gt;</code> verwendet haben. Wir können <code>Option&lt;T&gt;</code> ebenso
mit <code>match</code> handhaben, wie wir es mit der Aufzählung <code>Coin</code> getan haben! Statt
Münzen zu vergleichen, werden wir die Varianten von <code>Option&lt;T&gt;</code> vergleichen,
aber die Art und Weise, wie der <code>match</code>-Ausdruck funktioniert, bleibt die
gleiche.</p>
<p>Nehmen wir an, wir wollen eine Funktion schreiben, die eine <code>Option&lt;i32&gt;</code> nimmt
und, falls ein Wert darin enthalten ist, zu diesem Wert 1 addiert. Wenn darin
kein Wert enthalten ist, soll die Funktion den Wert <code>None</code> zurückgeben und
nicht versuchen, irgendwelche Operationen durchzuführen.</p>
<p>Diese Funktion ist dank <code>match</code> sehr einfach zu schreiben und wird wie in
Codeblock 6-5 aussehen.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-5: Eine Funktion, die einen <code>match</code>-Ausdruck
auf einer <code>Option&lt;i32&gt;</code> verwendet</span></p>
<p>Lass uns die erste Ausführung von <code>plus_one</code> näher betrachten. Wenn wir
<code>plus_one(five)</code> aufrufen, wird die Variable <code>x</code> im Rumpf von <code>plus_one</code> den
Wert <code>Some(5)</code> haben. Dann vergleichen wir das mit jedem <code>match</code>-Zweig:</p>
<pre><code class="language-rust ignore"><span class="boring">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">    match x {
</span>        None =&gt; None,
<span class="boring">        Some(i) =&gt; Some(i + 1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let five = Some(5);
</span><span class="boring">let six = plus_one(five);
</span><span class="boring">let none = plus_one(None);</span></code></pre>
<p>Der Wert <code>Some(5)</code> passt nicht zum Muster <code>None</code>, also fahren wir mit dem
nächsten Zweig fort:</p>
<pre><code class="language-rust ignore"><span class="boring">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">    match x {
</span><span class="boring">        None =&gt; None,
</span>        Some(i) =&gt; Some(i + 1),
<span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let five = Some(5);
</span><span class="boring">let six = plus_one(five);
</span><span class="boring">let none = plus_one(None);</span></code></pre>
<p>Passt <code>Some(5)</code> zu <code>Some(i)</code>? Das tut es! Wir haben die gleiche Variante. <code>i</code>
bindet den in <code>Some</code> enthaltenen Wert, sodass <code>i</code> den Wert <code>5</code> annimmt. Dann
wird der Code im <code>match</code>-Zweig ausgeführt, also fügen wir 1 zum Wert von <code>i</code>
hinzu und erzeugen einen neuen <code>Some</code>-Wert mit der Summe <code>6</code> darin.</p>
<p>Betrachten wir nun den zweiten Aufruf von <code>plus_one</code> in Codeblock 6-5, wo <code>x</code>
den Wert <code>None</code> hat. Wir betreten den <code>match</code>-Block und vergleichen mit dem
ersten Zweig:</p>
<pre><code class="language-rust ignore"><span class="boring">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">    match x {
</span>        None =&gt; None,
<span class="boring">        Some(i) =&gt; Some(i + 1),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let five = Some(5);
</span><span class="boring">let six = plus_one(five);
</span><span class="boring">let none = plus_one(None);</span></code></pre>
<p>Er passt! Es gibt keinen Wert zum Hinzufügen, also stoppt das Programm und gibt
den Wert <code>None</code> auf der rechten Seite von <code>=&gt;</code> zurück. Da der erste Zweig
passt, werden keine anderen Zweige abgeglichen.</p>
<p>Die Kombination von <code>match</code> und Aufzählungen ist in vielen Situationen
nützlich. Du wirst dieses Muster häufig in Rust-Code sehen: <code>match</code> mit einer
Aufzählung, eine Variable an die darin enthaltenen Daten binden und dann
dazugehörenden Code ausführen. Am Anfang ist es etwas knifflig, aber wenn man
sich erst einmal daran gewöhnt hat, wird man sich wünschen, es in allen
Sprachen zu haben. Es ist durchweg ein beliebtes Werkzeug.</p>
<h3 id="abgleiche-sind-vollständig"><a class="header" href="#abgleiche-sind-vollständig">Abgleiche sind vollständig</a></h3>
<p>Es gibt noch einen weiteren Aspekt von <code>match</code>, den wir besprechen müssen: Die
Muster der Zweige müssen alle Möglichkeiten abdecken. Betrachte folgende
Version unserer Funktion <code>plus_one</code>, die einen Fehler hat und sich nicht
kompilieren lässt:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
<span class="boring">
</span><span class="boring">let five = Some(5);
</span><span class="boring">let six = plus_one(five);
</span><span class="boring">let none = plus_one(None);
</span><span class="boring">}</span></code></pre></pre>
<p>Wir haben den Fall <code>None</code> nicht behandelt, daher wird dieser Code einen Fehler
verursachen. Glücklicherweise ist es ein Fehler, von dem Rust weiß, wie er
zu lösen ist. Wenn wir versuchen, diesen Code zu kompilieren, werden wir
diese Fehlermeldung bekommen:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
note: `Option&lt;i32&gt;` defined here
 --&gt; /rustc/07dca489ac2d933c78d3c5158e3f43beefeb/library/core/src/option.rs:570:1
 ::: /rustc/07dca489ac2d933c78d3c5158e3f43beefeb/library/core/src/option.rs:574:5
  |
  = note: not covered
  = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
4 ~             Some(i) =&gt; Some(i + 1),
5 ~             None =&gt; todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Rust weiß, dass wir nicht alle möglichen Fälle abgedeckt haben, und es weiß
sogar, welches Muster wir vergessen haben! Abgleiche in Rust sind
<em>vollständig</em>: Wir müssen jede letzte Möglichkeit ausschöpfen, damit der Code
gültig ist! Speziell im Fall <code>Option&lt;T&gt;</code> schützt uns Rust davor, den Fall
<code>None</code> zu übersehen, und davon auszugehen, dass wir einen Wert haben, obwohl
vielleicht null vorliegt, und macht so den zuvor besprochenen Milliardenfehler
unmöglich.</p>
<h3 id="auffangmuster-und-der-platzhalter-_"><a class="header" href="#auffangmuster-und-der-platzhalter-_">Auffangmuster und der Platzhalter <code>_</code></a></h3>
<p>Mit Aufzählungen können wir auch spezielle Aktionen für ausgewählte Werte
durchführen und für alle anderen Werte eine Standardaktion. Stell dir vor, wir
implementieren ein Spiel, bei dem ein Spieler bei einem Würfelwurf von 3 einen
schicken Hut bekommt anstatt sich zu bewegen. Wenn du eine 7 würfelst, verliert
dein Spieler einen schicken Hut. Bei allen anderen Werten zieht der Spieler die
entsprechende Anzahl an Feldern auf dem Spielfeld. Hier ist ein <code>match</code>, das
diese Logik implementiert, wobei das Ergebnis des Würfelwurfs anstelle eines
Zufallswerts fest kodiert ist, und alle weitere Logik wird durch Funktionen ohne
Rumpf dargestellt, da die tatsächliche Implementierung für dieses Beispiel den
Rahmen sprengen würde:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dice_roll = 9;
match dice_roll {
    3 =&gt; add_fancy_hat(),
    7 =&gt; remove_fancy_hat(),
    other =&gt; move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>Bei den ersten beiden Zweigen sind die Muster die literalen Werte <code>3</code> und <code>7</code>.
Beim letzten Zweig, der alle anderen möglichen Werte abdeckt, ist das Muster
die Variable die wir als <code>other</code> bezeichnet haben. Der Code, der für den
<code>other</code>-Zweig läuft, verwendet die Variable, indem er sie an die Funktion
<code>move_player</code> übergibt.</p>
<p>Dieser Code lässt sich kompilieren, auch wenn wir nicht alle möglichen Werte
aufgelistet haben, die ein <code>u8</code> haben kann, weil das letzte Muster zu allen
nicht explizit aufgeführten Werte passt. Dieses Auffangmuster (catch-all
pattern) erfüllt die Anforderung, dass <code>match</code> vollständig sein muss. Beachte,
dass wir den Auffangzweig an letzter Stelle angeben müssen, da die Muster der
Reihe nach ausgewertet werden. Wenn wir den Auffangzweig früher einfügen
würden, würden die anderen Zweige nie ausgeführt werden, also warnt uns Rust,
wenn wir Zweige nach einem Auffangzweig hinzufügen!</p>
<p>Rust hat auch ein Muster, das wir verwenden können, wenn wir einen Auffangzweig
wollen, aber den Wert im Auffangmuster <em>nicht</em> verwenden wollen: <code>_</code> ist ein
spezielles Muster, das zu jedem Wert passt und nicht an diesen Wert bindet.
Dies sagt Rust, dass wir den Wert nicht verwenden werden, damit Rust uns nicht
vor einer unbenutzten Variable warnt.</p>
<p>Ändern wir die Spielregeln: Wenn du jetzt etwas anderes als eine 3 oder eine 7
würfelst, musst du erneut würfeln. Wir brauchen den Auffangwert nicht mehr zu
verwenden, also können wir unseren Code so ändern, dass wir <code>_</code> anstelle der
Variable namens <code>other</code> verwenden:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dice_roll = 9;
match dice_roll {
    3 =&gt; add_fancy_hat(),
    7 =&gt; remove_fancy_hat(),
    _ =&gt; reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>Dieses Beispiel erfüllt auch die Bedingung der Vollständigkeit, weil wir
ausdrücklich alle anderen Werte im letzten Zweig ignorieren; wir haben nichts
vergessen.</p>
<p>Zum Schluss ändern wir die Spielregeln noch einmal, sodass bei einem Zug nichts
anderes passiert, wenn etwas anderes als eine 3 oder eine 7 gewürfelt wird. Wir
können das ausdrücken, indem wir den Einheitswert (den leeren Tupel-Typ, den
wir im Abschnitt <a href="ch03-02-data-types.html#der-tupel-typ">„Der Tupel-Typ“</a> erwähnt haben) als Code im <code>_</code>-Zweig
angeben:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dice_roll = 9;
match dice_roll {
    3 =&gt; add_fancy_hat(),
    7 =&gt; remove_fancy_hat(),
    _ =&gt; (),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>Hier teilen wir Rust explizit mit, dass wir keinen anderen Wert verwenden
werden, der nicht mit einem Muster in einem früheren Zweig übereinstimmt, und
dass wir in diesem Fall keinen Code ausführen wollen.</p>
<p>Weitere Informationen zu Mustern und Abgleich findest du in <a href="ch19-00-patterns.html">Kapitel
19</a>. Für den Moment machen wir mit der <code>if let</code>-Syntax
weiter, die in Situationen nützlich sein kann, in denen der <code>match</code>-Ausdruck
etwas wortreich ist.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="prägnanter-kontrollfluss-mit-if-let-und-let-else"><a class="header" href="#prägnanter-kontrollfluss-mit-if-let-und-let-else">Prägnanter Kontrollfluss mit <code>if let</code> und <code>let else</code></a></h2>
<p>Mit der Syntax <code>if let</code> kannst du <code>if</code> und <code>let</code> in einer weniger wortreichen
Weise kombinieren, um mit Werten umzugehen, die einem Muster entsprechen,
während der Rest ignoriert wird. Betrachte das Programm in Codeblock 6-6, das
auf einen <code>Option&lt;u8&gt;</code>-Wert in der Variable <code>config_max</code> passt, aber nur dann
Code ausführen soll, wenn der Wert die <code>Some</code>-Variante ist.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_max = Some(3u8);
match config_max {
    Some(max) =&gt; println!("Das Maximum ist mit {max} konfiguriert"),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-6: Ein <code>match</code>-Ausdruck, der nur dann Code
ausführt, wenn der Wert <code>Some</code> ist</span></p>
<p>Wenn der Wert <code>Some</code> ist, geben wir den Wert in der Variante <code>Some</code> aus, indem
wir den Wert an die Variable <code>max</code> im Muster binden. Wir wollen nichts mit dem
Wert <code>None</code> machen. Um den Ausdruck <code>match</code> zu erfüllen, müssen wir nach der
Verarbeitung nur einer Variante <code>_ =&gt; ()</code> hinzufügen, was lästiger Codeballast
ist.</p>
<p>Stattdessen könnten wir dies in kürzerer Form schreiben, indem wir <code>if let</code>
verwenden. Der folgende Code verhält sich genauso wie der <code>match</code>-Ausdruck in
Codeblock 6-6:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("Das Maximum ist mit {max} konfiguriert");
}
<span class="boring">}</span></code></pre></pre>
<p>Die Syntax <code>if let</code> nimmt ein Muster und einen Ausdruck, getrennt durch ein
Gleichheitszeichen. Sie funktioniert auf gleiche Weise wie bei <code>match</code>, wo der
Ausdruck hinter <code>match</code> angegeben wird und das Muster der erste Zweig ist. In
diesem Fall ist das Muster <code>Some(max)</code> und das <code>max</code> ist an den Wert innerhalb
von <code>Some</code> gebunden. Wir können dann <code>max</code> im Rumpf des <code>if let</code>-Blocks auf die
gleiche Weise verwenden, wie <code>max</code> im entsprechenden <code>match</code>-Zweig. Der Code im
<code>if let</code>-Block wird nur ausgeführt, wenn der Wert zum Muster passt.</p>
<p>Die Verwendung von <code>if let</code> bedeutet weniger Tipparbeit, weniger Einrückung und
weniger Codeanteil. Du verlierst jedoch die Prüfung auf Vollständigkeit, die
<code>match</code> erzwingt. Die Wahl zwischen <code>match</code> und <code>if let</code> hängt davon ab, was
du in der speziellen Situation machst, und davon, ob ein Gewinn an Prägnanz ein
angemessener Kompromiss für den Verlust einer Prüfung auf Vollständigkeit ist.</p>
<p>Anders gesagt kannst du dir <code>if let</code> als syntaktischen Zucker für einen
<code>match</code>-Ausdruck vorstellen, der Code nur bei Übereinstimmung mit einem Muster
ausführt und alle anderen Werte ignoriert.</p>
<p>Wir können ein <code>else</code> an ein <code>if let</code> anhängen. Der Code-Block, der zum <code>else</code>
gehört, ist der gleiche wie der Code-Block, der zum <code>_</code>-Zweig im
<code>match</code>-Ausdruck gehören würde. Erinnere dich an die Aufzählung <code>Coin</code> in
Codeblock 6-4, wo die Variante <code>Quarter</code> auch einen <code>UsState</code>-Wert enthielt.
Wenn wir alle Nicht-25-Cent-Münzen zählen wollten, während wir die Eigenschaft
der 25-Cent-Münzen ausgeben, könnten wir das mit einem <code>match</code>-Ausdruck wie
diesem tun:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!("25-Cent-Münze aus {state:?}!"),
        _ =&gt; count += 1,
    }
<span class="boring">}</span></code></pre></pre>
<p>Oder wir könnten einen Ausdruck mit <code>if let</code> und <code>else</code> wie diesen verwenden:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("25-Cent-Münze aus {state:?}!");
    } else {
        count += 1;
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="auf-dem-richtigen-weg-bleiben-mit-letelse"><a class="header" href="#auf-dem-richtigen-weg-bleiben-mit-letelse">Auf dem „richtigen Weg“ bleiben mit <code>let...else</code></a></h2>
<p>Ein gängiges Muster besteht darin, eine Berechnung durchzuführen, wenn ein Wert
vorhanden ist, und andernfalls einen Standardwert zurückzugeben. Um bei unserem
Beispiel der Münzen mit einem <code>UsState</code>-Wert zu bleiben: Wenn wir etwas
Lustiges sagen wollten, je nachdem, wie alt der Zustand des Vierteldollars ist,
könnten wir eine Methode für <code>UsState</code> einführen, um das Alter eines
Bundesstaates zu prüfen, etwa so:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span>impl UsState {
    fn existed_in(&amp;self, year: u16) -&gt; bool {
        match self {
            UsState::Alabama =&gt; year &gt;= 1819,
            UsState::Alaska =&gt; year &gt;= 1959,
            // --abschneiden--
        }
    }
}
<span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
</span><span class="boring">    if let Coin::Quarter(state) = coin {
</span><span class="boring">        if state.existed_in(1900) {
</span><span class="boring">            Some(format!("{state:?} ist ziemlich alt für Amerika!"))
</span><span class="boring">        } else {
</span><span class="boring">            Some(format!("{state:?} ist relativ neu."))
</span><span class="boring">        }
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>Dann könnten wir <code>if let</code> verwenden, um die Art der Münze zu bestimmen, und
eine Variable <code>state</code> in den Rumpf der Bedingung einfügen, wie in Codeblock
6-7.</p>
<p>Dateiname: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)] // so we can inspect the state in a minute
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // --abschneiden--
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    if let Coin::Quarter(state) = coin {
        if state.existed_in(1900) {
            Some(format!("{state:?} ist ziemlich alt für Amerika!"))
        } else {
            Some(format!("{state:?} ist relativ neu."))
        }
    } else {
        None
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-7: Prüfen, ob ein Bundesstaat im Jahr 1900
existiert, durch Verwenden von Bedingungen, die in <code>if let</code> verschachtelt
sind.</span></p>
<p>Damit ist die Aufgabe erledigt, aber die Arbeit wurde in den Rumpf der <code>if  let</code>-Anweisung verlagert. Und wenn die zu erledigende Arbeit komplizierter
ist, könnte es schwierig sein, genau zu verfolgen, wie die Verzweigungen der
obersten Ebene zusammenhängen. Wir könnten uns auch die Tatsache zunutze
machen, dass Ausdrücke einen Wert erzeugen, um entweder <code>state</code> aus der <code>if let</code>-Anweisung zu setzen oder um früh zurückzukehren, wie in Codeblock 6-8.
(Ähnliches könnte man auch mit einem <code>match</code> machen.)</p>
<p>Dateiname: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // --abschneiden--
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    let state = if let Coin::Quarter(state) = coin {
        state
    } else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} ist ziemlich alt für Amerika!"))
    } else {
        Some(format!("{state:?} ist relativ neu."))
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-8: Verwenden von <code>if let</code>, um einen Wert zu
setzen oder frühzeitig zurückzukehren.</span></p>
<p>Das ist allerdings auf gewisse Weise schwierig zu verstehen! Ein Zweig von <code>if let</code> erzeugt einen Wert und der andere verlässt die Funktion vollständig.</p>
<p>Um dieses gängige Muster besser auszudrücken, gibt es in Rust <code>let...else</code>. Die
<code>let...else</code>-Syntax nimmt ein Muster auf der linken Seite und einen Ausdruck
auf der rechten Seite, sehr ähnlich zu <code>if let</code>, aber sie hat keinen
<code>if</code>-Zweig, nur einen <code>else</code>-Zweig. Wenn das Muster passt, wird der Wert des
Musters im äußeren Gültigkeitsbereich gebunden. Wenn das Muster <em>nicht</em> passt,
wird das Programm im <code>else</code>-Zweig fortgesetzt, der die Funktion beendet.</p>
<p>In Codeblock 6-9 kannst du sehen, wie Codeblock 6-8 aussieht, wenn du
<code>let...else</code> anstelle von <code>if let</code> verwendest. Beachte, dass der Funktionsrumpf
auf diese Weise „auf dem richtigen Weg“ bleibt, ohne dass sich der
Kontrollfluss für zwei Verzweigungen signifikant unterscheidet, wie es bei <code>if  let</code> der Fall war.</p>
<p>Dateiname: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // --abschneiden--
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    let Coin::Quarter(state) = coin else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} ist ziemlich alt für Amerika!"))
    } else {
        Some(format!("{state:?} ist relativ neu."))
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-9: Verwenden von <code>let...else</code>, um den Fluss
durch die Funktion klarer darzustellen.</span></p>
<p>Wenn du eine Situation hast, in der dein Programm über eine Logik verfügt, die
mit einem <code>match</code>-Ausdruck zu wortreich auszudrücken wäre, denke daran, dass
<code>if let</code> und <code>let...else</code> ebenfalls in deinem Rust-Werkzeugkasten enthalten
sind.</p>
<h2 id="zusammenfassung-5"><a class="header" href="#zusammenfassung-5">Zusammenfassung</a></h2>
<p>Wir haben uns damit befasst, wie man Aufzählungen verwendet, um
benutzerdefinierte Typen zu erstellen, die zu einem Satz von Aufzählungswerten
gehören können. Wir haben gezeigt, wie der Typ <code>Option&lt;T&gt;</code> der
Standardbibliothek dir dabei hilft, das Typsystem zu verwenden, um Fehler zu
vermeiden. Wenn Aufzählungswerte Daten enthalten, kannst du diese Werte mit
<code>match</code> oder <code>if let</code> extrahieren und verwenden, je nachdem, wie viele Fälle du
behandeln musst.</p>
<p>Deine Rust-Programme können nun Konzepte in deiner Domäne mit Hilfe von
Strukturen und Aufzählungen ausdrücken. Das Erstellen benutzerdefinierter Typen
zur Verwendung in deiner API gewährleistet Typsicherheit: Der Compiler wird
sicherstellen, dass deine Funktionen nur Werte jenes Typs erhalten, den die
Funktion erwartet.</p>
<p>Um deinen Nutzern eine gut organisierte API zur Verfügung zu stellen, die
einfach zu benutzen ist und nur genau das offenbart, was deine Nutzer
benötigen, wenden wir uns nun den Modulen von Rust zu.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wachsende-projekte-verwalten-mit-paketen-packages-kisten-crates-und-modulen"><a class="header" href="#wachsende-projekte-verwalten-mit-paketen-packages-kisten-crates-und-modulen">Wachsende Projekte verwalten mit Paketen (packages), Kisten (crates) und Modulen</a></h1>
<p>Wenn du große Programme schreibst, wird die Organisation deines Codes immer
wichtiger. Durch die Gruppierung verwandter Funktionen und die Trennung von
Code mit unterschiedlichen Funktionalitäten wird klar, wo der Code zu finden
ist, der eine bestimmte Funktionalität implementiert, und an welcher Stelle
die Funktionalität eines Merkmals zu ändern ist.</p>
<p>Die Programme, die wir bisher geschrieben haben, waren in einem Modul in einer
Datei. Wenn ein Projekt wächst, solltest du den Code organisieren, indem du ihn
in mehrere Module und dann in mehrere Dateien aufteilst. Ein Paket (package)
kann mehrere Binär-Kisten (binary crates) und optional eine Bibliotheks-Kiste
(library crate) enthalten. Wenn ein Paket wächst, kannst du Teile in separate
Kisten extrahieren, die zu externen Abhängigkeiten werden. Dieses Kapitel
behandelt all diese Techniken. Für sehr große Projekte aus einer Reihe von
zusammenhängenden Paketen, die sich gemeinsam weiterentwickeln, stellt Cargo
<em>Arbeitsbereiche</em> zur Verfügung, die wir in
<a href="ch14-03-cargo-workspaces.html">„Cargo-Arbeitsbereiche“</a> in Kapitel 14 behandeln werden.</p>
<p>Wir werden auch die Kapselung von Implementierungsdetails besprechen, wodurch
du Code auf einer höheren Ebene wiederverwenden kannst: Sobald du eine
Operation implementiert hast, kann anderer Code diesen Code über die
öffentliche Schnittstelle des Codes aufrufen, ohne wissen zu müssen, wie die
Implementierung funktioniert. Die Art und Weise, wie du Code schreibst,
definiert, welche Teile für anderen Code öffentlich sind und welche Teile
private Implementierungsdetails sind, deren Änderung du dir vorbehältst. Dies
ist eine weitere Möglichkeit, die Menge der Details, die man im Kopf behalten
muss, zu begrenzen.</p>
<p>Ein verwandtes Konzept ist der Gültigkeitsbereich (scope): Der verschachtelte
Kontext, in dem Code geschrieben wird, hat eine Reihe von Namen, die als „im
Gültigkeitsbereich“ (in scope) definiert sind. Beim Lesen, Schreiben und
Kompilieren von Code müssen Programmierer und Compiler wissen, ob sich ein
bestimmter Name an einer bestimmten Stelle auf eine Variable, Funktion,
Struktur (struct), Aufzählung (enum), Modul, Konstante oder ein anderes Element
bezieht und was dieses Element bedeutet. Du kannst Gültigkeitsbereiche
erstellen und verändern, welche Namen in oder außerhalb des Gültigkeitsbereichs
liegen. Du kannst nicht zwei Elemente mit gleichem Namen im selben
Gültigkeitsbereich haben; es sind Werkzeuge zur Lösung von Namenskonflikten
vorhanden.</p>
<p>Rust verfügt über eine Reihe von Funktionalitäten, mit denen du die
Organisation deines Codes verwalten kannst, z.B. welche Details offengelegt
werden, welche Details privat sind und welche Namen im jeweiligen
Gültigkeitsbereich deines Programms sind. Zu diesen Funktionalitäten, die
manchmal kollektiv als <em>Modulsystem</em> bezeichnet werden, gehören:</p>
<ul>
<li><strong>Pakete (packages):</strong> Eine Cargo-Funktionalität, mit der du Kisten bauen,
testen und gemeinsam nutzen kannst.</li>
<li><strong>Kisten (crates):</strong> Ein Baum von Modulen, der eine Bibliothek oder ein
ausführbares Programm erzeugt.</li>
<li><strong>Module</strong> und <strong><code>use</code></strong>: Ermöglicht dir, die Organisation, den
Gültigkeitsbereich und den Datenschutz von Pfaden zu steuern.</li>
<li><strong>Pfade:</strong> Eine Möglichkeit, ein Element zu benennen, z.B. eine Struktur,
eine Funktion oder ein Modul.</li>
</ul>
<p>In diesem Kapitel gehen wir auf all diese Funktionalitäten ein, besprechen, wie
sie zusammenwirken, und erklären, wie sie zur Verwaltung der
Gültigkeitsbereiche eingesetzt werden können. Am Ende solltest du ein solides
Verständnis des Modulsystems haben und in der Lage sein, mit den
Gültigkeitsbereichen wie ein Profi zu arbeiten!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pakete-packages-und-kisten-crates"><a class="header" href="#pakete-packages-und-kisten-crates">Pakete (packages) und Kisten (crates)</a></h2>
<p>Die ersten Teile des Modulsystems, die wir behandeln werden, sind Pakete und
Kisten.</p>
<p>Eine <em>Kiste</em> ist die kleinste Menge an Code, die der Rust-Compiler zu einem
bestimmten Zeitpunkt berücksichtigt. Selbst wenn du <code>rustc</code> anstelle von
<code>cargo</code> ausführst und eine einzelne Quellcodedatei übergibst (wie wir es
bereits im Abschnitt „Schreiben und Ausführen eines Rust-Programms“ in Kapitel
1 getan haben), betrachtet der Compiler diese Datei als eine Kiste. Kisten
können Module enthalten, und die Module können in anderen Dateien definiert
sein, die mit der Kiste kompiliert werden, wie wir in den nächsten Abschnitten
sehen werden.</p>
<p>Es gibt zwei Arten von Kisten: Binäre Kisten und Bibliothekskisten. <em>Binäre
Kisten</em> (binary crates) sind Programme, die du zu einer ausführbaren Datei
kompilieren und starten kannst, z.B. ein Befehlszeilenprogramm
oder einen Server. Jede muss eine Funktion namens <code>main</code> haben, die definiert,
was passiert, wenn die ausführbare Datei läuft. Alle Kisten, die wir bisher
erstellt haben, waren binäre Kisten.</p>
<p><em>Bibliothekskisten</em> (library crates) haben keine Funktion <code>main</code> und sie werden
nicht zu einer ausführbaren Datei kompiliert. Stattdessen definieren sie
Funktionalität, die für mehrere Projekte gemeinsam genutzt werden soll. Zum
Beispiel bietet die Kiste <code>rand</code>, die wir in <a href="ch02-00-guessing-game-tutorial.html#generieren-einer-geheimzahl">Kapitel 2</a> verwendet haben,
Funktionalität, die Zufallszahlen erzeugt. Wenn Rust-Entwickler „Kiste“ sagen,
meinen sie meistens „Bibliothekskiste“, und sie verwenden „Kiste“ austauschbar
mit dem allgemeinen Programmierkonzept einer „Bibliothek“.</p>
<p>Die <em>Kistenwurzel</em> ist eine Quelldatei, von der der Rust-Compiler ausgeht und
die das Wurzel-Modul deiner Kiste bildet (Module werden in <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">„Mit Modulen den
Kontrollumfang und Datenschutz steuern“</a> ausführlich erklärt).</p>
<p>Ein <em>Paket</em> ist ein Bündel von einer oder mehreren Kisten, die eine Reihe von
Funktionalitäten bereitstellen. Ein Paket enthält eine Datei <em>Cargo.toml</em>, die
beschreibt, wie diese Kisten zu bauen sind. Cargo ist eigentlich ein Paket, das
die Binärkiste für das Kommandozeilenwerkzeug enthält, das du zum Erstellen
deines Codes verwendet hast. Das Cargo-Paket enthält auch eine
Bibliothekskiste, von der die binäre Kiste abhängt. Andere Projekte können von
der Bibliothekskiste Cargo abhängen, um die gleiche Logik wie das
Befehlszeilenwerkzeug Cargo zu verwenden.</p>
<p>Ein Paket kann beliebig viele Binärkisten enthalten, aber höchstens eine
Bibliothekskiste. Ein Paket muss mindestens eine Kiste enthalten, unabhängig
davon, ob es sich um eine Bibliothek oder eine binäre Kiste handelt.</p>
<p>Lass uns durchgehen, was passiert, wenn wir ein Paket erstellen. Zuerst geben
wir den Befehl <code>cargo new my-project</code> ein:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>Nachdem wir <code>cargo new my-project</code> ausgeführt haben, verwenden wir <code>ls</code>, um zu
sehen, was Cargo erzeugt. Im Projektverzeichnis gibt es eine Datei
<em>Cargo.toml</em>, die uns ein Paket gibt. Es gibt auch ein Verzeichnis <em>src</em>, das
<em>main.rs</em> enthält. Öffne <em>Cargo.toml</em> in deinem Texteditor und beachte, dass
<em>src/main.rs</em> nicht erwähnt wird. Cargo folgt der Konvention, dass
<em>src/main.rs</em> die Kistenwurzel einer binären Kiste mit dem gleichen Namen wie
das Paket ist. Ebenso weiß Cargo, dass, wenn das Paketverzeichnis <em>src/lib.rs</em>
enthält, das Paket eine Bibliothekskiste mit dem gleichen Namen wie das Paket
enthält, und <em>src/lib.rs</em> deren Kistenstamm ist. Cargo übergibt die
Kistenwurzel-Dateien an <code>rustc</code>, um die Bibliothek oder Binärdatei zu bauen.</p>
<p>Hier haben wir ein Paket, das nur <em>src/main.rs</em> enthält, d.h. es enthält nur
eine binäre Kiste mit dem Namen <code>my-project</code>. Wenn ein Paket <em>src/main.rs</em> und
<em>src/lib.rs</em> enthält, hat es zwei Kisten: Eine binäre und eine Bibliothek,
beide mit dem gleichen Namen wie das Paket. Ein Paket kann mehrere binäre
Kisten haben, indem es Dateien im Verzeichnis <em>src/bin</em> ablegt: Jede Datei ist
dann eine eigene binäre Kiste.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mit-modulen-den-kontrollumfang-und-datenschutz-steuern"><a class="header" href="#mit-modulen-den-kontrollumfang-und-datenschutz-steuern">Mit Modulen den Kontrollumfang und Datenschutz steuern</a></h2>
<p>In diesem Abschnitt werden wir über Module und andere Teile des Modulsystems
sprechen, nämlich <em>Pfade</em>, die es dir erlauben, Elemente zu benennen; das
Schlüsselwort <code>use</code>, das einen Pfad in den Gültigkeitsbereich bringt; und das
Schlüsselwort <code>pub</code>, um Elemente öffentlich zu machen. Wir werden auch das
Schlüsselwort <code>as</code>, externe Pakete und den Stern-Operator (glob operator)
besprechen.</p>
<h3 id="spickzettel-für-module"><a class="header" href="#spickzettel-für-module">Spickzettel für Module</a></h3>
<p>Bevor wir zu den Details von Modulen und Pfaden kommen, stellen wir hier eine
kurze Referenz zusammen, wie Module, Pfade, das Schlüsselwort <code>use</code> und das
Schlüsselwort <code>pub</code> im Compiler funktionieren und wie die meisten Entwickler
ihren Code organisieren. Wir werden im Laufe dieses Kapitels Beispiele für jede
dieser Regeln durchgehen, aber dies ist ein guter Ort, um sich daran zu
erinnern, wie Module funktionieren.</p>
<ul>
<li><strong>Beginne bei der Kistenwurzel (crate root)</strong>: Beim Kompilieren einer Kiste
sucht der Compiler zuerst in der Wurzeldatei der Kiste (normalerweise
<em>src/lib.rs</em> für eine Bibliothekskiste oder <em>src/main.rs</em> für eine
Binärkiste).</li>
<li><strong>Module deklarieren</strong>: In der Kisten-Stammdatei kannst du neue Module
deklarieren; z.B. deklarierst du ein „Garten“-Modul mit <code>mod garden;</code>. Der
Compiler wird an diesen Stellen nach dem Code des Moduls suchen:
<ul>
<li>In der Zeile direkt nach <code>mod garden</code>, in geschweiften Klammern anstelle
des Semikolons</li>
<li>In der Datei <em>src/garden.rs</em></li>
<li>In der Datei <em>src/garden/mod.rs</em></li>
</ul>
</li>
<li><strong>Submodule deklarieren</strong>: In jeder anderen Datei als der Kistenwurzel
kannst du Untermodule deklarieren. Du kannst zum Beispiel <code>mod vegetables;</code>
in <em>src/garden.rs</em> deklarieren. Der Compiler sucht den Code des Submoduls in
dem Verzeichnis, das nach dem übergeordneten Modul benannt ist, an folgenden
Stellen:
<ul>
<li>In der Zeile direkt nach <code>mod vegetables</code>, in geschweiften Klammern
anstelle des Semikolons</li>
<li>In der Datei <em>src/garden/vegetables.rs</em></li>
<li>In der Datei <em>src/garden/vegetables/mod.rs</em></li>
</ul>
</li>
<li><strong>Pfade zum Code in Modulen</strong>: Sobald ein Modul Teil deiner Kiste ist, kannst
du auf den Code in diesem Modul von jedem anderen Ort in derselben Kiste aus
referenzieren, solange die Datenschutzregeln dies zulassen, indem du den Pfad
zum Code verwendest. Zum Beispiel würde ein Typ <code>Asparagus</code> (engl. Spargel)
im Gartengemüse-Modul unter <code>crate::garden::vegetables::Asparagus</code> zu finden
sein.</li>
<li><strong>Privat vs. öffentlich</strong>: Der Code innerhalb eines Moduls ist standardmäßig
für seine übergeordneten Module nicht zugänglich. Um ein Modul öffentlich zu
machen, deklariere es mit <code>pub mod</code> anstelle von <code>mod</code>. Um Elemente innerhalb
eines öffentlichen Moduls ebenfalls öffentlich zu machen, verwende <code>pub</code> vor
ihren Deklarationen.</li>
<li><strong>Das Schlüsselwort <code>use</code></strong>: Innerhalb eines Gültigkeitsbereichs werden mit
dem Schlüsselwort <code>use</code> Verknüpfungen zu Elementen erstellt, um die
Wiederholung langer Pfade zu reduzieren. In jedem Gültigkeitsbereichs, der
auf <code>crate::garden::vegetables::Asparagus</code> referenzieren kann, kann man eine
Verknüpfung mit <code>use crate::garden::vegetables::Asparagus</code> erstellen und von
da an braucht man nur noch <code>Asparagus</code> zu schreiben, um diesen Typ im
Gültigkeitsbereich zu verwenden.</li>
</ul>
<p>Hier erstellen wir eine binäre Kiste namens <code>backyard</code> (Hinterhof), die diese
Regeln veranschaulicht. Das Verzeichnis der Kiste, ebenfalls <code>backyard</code>
genannt, enthält diese Dateien und Verzeichnisse:</p>
<pre><code class="language-text">backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
</code></pre>
<p>Die Stammdatei der Kiste ist in diesem Fall <em>src/main.rs</em>, und sie enthält:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("Ich baue {plant:?} an!");
}</code></pre>
<p>Die Zeile <code>pub mod garden;</code> weist den Compiler an, den Code einzubinden, den er
in <em>src/garden.rs</em> findet, nämlich:</p>
<p><span class="filename">Dateiname: src/garden.rs</span></p>
<pre><code class="language-rust noplayground ignore">pub mod vegetables;</code></pre>
<p>Hier bedeutet <code>pub mod vegetables;</code>, dass der Code in
<em>src/garden/vegetables.rs</em> ebenfalls enthalten ist. Dieser Code ist:</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}</code></pre>
<p>Lass uns nun auf die Einzelheiten dieser Regeln eingehen und sie in der Praxis demonstrieren!</p>
<h3 id="gruppierung-von-zugehörigem-code-in-modulen"><a class="header" href="#gruppierung-von-zugehörigem-code-in-modulen">Gruppierung von zugehörigem Code in Modulen</a></h3>
<p><em>Module</em> ermöglichen es uns, den Code innerhalb einer Kiste zu organisieren,
damit er lesbar und leicht wiederverwendbar ist. Mit Modulen können wir auch
den <em>Datenschutz</em> (privacy) von Elementen kontrollieren, da Code innerhalb
eines Moduls standardmäßig privat ist. Private Elemente sind interne
Implementierungsdetails, die nicht für die externe Nutzung zur Verfügung
stehen. Wir können uns dafür entscheiden, Module und die darin enthaltenen
Elemente öffentlich zu machen, damit externer Code sie verwenden und von ihnen
abhängen kann.</p>
<p>Als Beispiel schreiben wir eine Bibliothekskiste, die die Funktionalität eines
Restaurants bietet. Wir werden die Signaturen der Funktionen definieren, aber
ihre Rümpfe leer lassen, um uns auf die Organisation des Codes zu konzentrieren
und nicht auf die Implementierung eines Restaurants.</p>
<p>Im Gaststättengewerbe werden einige Teile eines Restaurants als <em>Vorderseite
des Hauses</em> und andere als <em>Hinterseite des Hauses</em> bezeichnet. Auf der
Vorderseite des Hauses sind die Kunden; hier setzen Gastgeber ihre Kunden hin,
Kellner nehmen Bestellungen auf und rechnen ab und Barkeeper machen die
Getränke. Auf der Hinterseite des Hauses arbeiten die Küchenchefs und Köche in
der Küche, Geschirrspüler waschen ab und Manager erledigen Verwaltungsarbeiten.</p>
<p>Um unsere Kiste auf diese Weise zu strukturieren, können wir ihre Funktionen in
verschachtelten Modulen organisieren. Erstelle eine neue Bibliothek namens
<code>restaurant</code>, indem du <code>cargo new --lib restaurant</code> ausführst. Gib dann den
Code in Codeblock 7-1 in <em>src/lib.rs</em> ein, um einige Module und
Funktionssignaturen zu definieren. Hier ist der vordere Teil des Hauses:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}</code></pre>
<p><span class="caption">Codeblock 7-1: Ein Modul <code>front_of_house</code>, das andere
Module enthält, die dann Funktionen enthalten</span></p>
<p>Wir definieren ein Modul mit dem Schlüsselwort <code>mod</code>, gefolgt vom Namen des
Moduls (in diesem Fall <code>front_of_house</code>). Der Rumpf des Moduls steht dann in
geschweiften Klammern. Innerhalb von Modulen können wir andere Module
platzieren, wie in diesem Fall mit den Modulen <code>hosting</code> und <code>serving</code>. Module
können auch Definitionen für andere Elemente enthalten, wie Strukturen,
Aufzählungen, Konstanten, Merkmalen und – wie in Codeblock 7-1 –
Funktionen.</p>
<p>Durch die Verwendung von Modulen können wir verwandte Definitionen gruppieren
und angeben, warum sie verwandt sind. Programmierer, die diesen Code verwenden,
können anhand der Gruppen durch den Code navigieren, anstatt alle Definitionen
lesen zu müssen, und finden so leichter die für sie relevanten Definitionen.
Programmierer, die diesem Code neue Funktionalität hinzufügen, wissen, wo sie
den Code platzieren müssen, damit das Programm übersichtlich bleibt.</p>
<p>Vorhin haben wir erwähnt, dass <em>src/main.rs</em> und <em>src/lib.rs</em> als Kistenwurzel
bezeichnet werden. Der Grund für ihren Namen ist, dass der Inhalt dieser beiden
Dateien ein Modul namens <code>crate</code> an der Wurzel der Modulstruktur der Kiste
bilden, die als <em>Modulbaum</em> bekannt ist.</p>
<p>Codeblock 7-2 zeigt den Modulbaum für die Struktur in Codeblock 7-1.</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Codeblock 7-2: Modulbaum für den Code in Codeblock
7-1</span></p>
<p>Dieser Baum zeigt, wie einige Module in anderen Modulen verschachtelt sind;
z.B. ist <code>hosting</code> innerhalb von <code>front_of_house</code>. Der Baum zeigt auch, dass
einige Module <em>Geschwister</em> sind, was bedeutet, dass sie im selben Modul
definiert sind; <code>hosting</code> und <code>serving</code> sind Geschwister, die innerhalb von
<code>front_of_house</code> definiert sind. Wenn Modul A innerhalb von Modul B enthalten
ist, sagen wir, dass Modul A das <em>Kind</em> (child) von Modul B ist und dass Modul
B der <em>Elternteil</em> (parent) von Modul A ist. Beachte, dass der gesamte
Modulbaum als Wurzel das implizite Modul namens <code>crate</code> hat.</p>
<p>Der Modulbaum könnte dich an den Verzeichnisbaum des Dateisystems auf deinem
Computer erinnern; dies ist ein sehr treffender Vergleich! Genau wie
Verzeichnisse in einem Dateisystem verwendest du Module, um deinen Code zu
organisieren. Und genau wie Dateien in einem Verzeichnis brauchen wir einen
Weg, unsere Module zu finden.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mit-pfaden-auf-ein-element-im-modulbaum-verweisen"><a class="header" href="#mit-pfaden-auf-ein-element-im-modulbaum-verweisen">Mit Pfaden auf ein Element im Modulbaum verweisen</a></h2>
<p>Um Rust zu zeigen, wo ein Element in einem Modulbaum zu finden ist, verwenden
wir einen Pfad, auf gleiche Weise wie beim Navigieren durch ein Dateisystem.
Um eine Funktion aufzurufen, müssen wir ihren Pfad kennen.</p>
<p>Ein Pfad kann zwei Formen annehmen:</p>
<ul>
<li>Ein <em>absoluter Pfad</em> ist der vollständige Pfad ausgehend von einer
Kistenwurzel; für Code aus einer externen Kiste beginnt der absolute Pfad mit
der Kistenwurzel, und für Code aus der aktuellen Kiste beginnt er mit dem
Literal <code>crate</code>.</li>
<li>Ein <em>relativer Pfad</em> startet beim aktuellen Modul und benutzt <code>self</code>, <code>super</code>
oder einen Bezeichner im aktuellen Modul.</li>
</ul>
<p>Sowohl absolute als auch relative Pfade bestehen aus einem oder mehreren
Bezeichnern, die durch doppelte Doppelpunkte (<code>::</code>) getrennt sind.</p>
<p>Um zu Codeblock 7-1 zurückzukehren, nehmen wir an, wir wollen die Funktion
<code>add_to_waitlist</code> aufrufen. Das ist dasselbe wie die Frage, wie der Pfad der
Funktion <code>add_to_waitlist</code> ist. Codeblock 7-3 enthält Codeblock 7-1, wobei
einige Module und Funktionen entfernt wurden.</p>
<p>Wir zeigen zwei Möglichkeiten, wie die Funktion <code>add_to_waitlist</code> von einer
neuen Funktion <code>eat_at_restaurant</code> aus aufgerufen werden kann, die in der
Kistenwurzel definiert ist. Diese Pfade sind korrekt, aber es gibt noch ein
weiteres Problem, das verhindert, dass dieses Beispiel in dieser Form
kompiliert. Wir werden gleich erklären, warum.</p>
<p>Die Funktion <code>eat_at_restaurant</code> ist Teil der öffentlichen
Programmierschnittstelle (API) unserer Bibliothekskiste, daher markieren wir
sie mit dem Schlüsselwort <code>pub</code>. Im Abschnitt <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#pfade-mit-dem-schl%C3%BCsselwort-pub-%C3%B6ffentlich-machen">„Pfade mit dem Schlüsselwort
<code>pub</code> öffentlich machen“</a> gehen wir näher auf <code>pub</code> ein.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absoluter Pfad
    crate::front_of_house::hosting::add_to_waitlist();

    // Relativer Pfad
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-3: Aufruf der Funktion <code>add_to_waitlist</code>
mittels absoluter und relativer Pfade</span></p>
<p>Beim ersten Aufruf der Funktion <code>add_to_waitlist</code> in <code>eat_at_restaurant</code>
verwenden wir einen absoluten Pfad. Die Funktion <code>add_to_waitlist</code> ist in der
gleichen Kiste definiert wie <code>eat_at_restaurant</code>, daher können wir das
Schlüsselwort <code>crate</code> verwenden, um einen absoluten Pfad zu beginnen. Dann
geben wir jedes der aufeinanderfolgenden Module an, bis wir <code>add_to_waitlist</code>
erreichen. Du kannst dir ein Dateisystem mit der gleichen Struktur vorstellen:
Wir würden den Pfad <code>/front_of_house/hosting/add_to_waitlist</code> angeben, um das
Programm <code>add_to_waitlist</code> auszuführen; das Verwenden des Namens <code>crate</code>, um
von der Kistenwurzel aus zu beginnen, ist analog zu <code>/</code>, um vom
Dateisystem-Wurzelverzeichnis in deinem Terminal aus zu beginnen.</p>
<p>Beim zweiten Aufruf von <code>add_to_waitlist</code> in <code>eat_at_restaurant</code> verwenden wir
einen relativen Pfad. Der Pfad beginnt mit <code>front_of_house</code>, dem Namen des
Moduls, das auf der gleichen Ebene des Modulbaums definiert ist wie
<code>eat_at_restaurant</code>. Hier wäre das Dateisystem-Äquivalent die Verwendung des
Pfades <code>front_of_house/hosting/add_to_waitlist</code>. Mit einem Modulnamen zu
beginnen bedeutet, dass der Pfad relativ ist.</p>
<p>Die Überlegung, ob ein relativer oder absoluter Pfad verwendet wird, ist eine
Entscheidung, die du auf Basis deines Projekts treffen wirst, und hängt davon
ab, ob du den Code für die Elementdefinition eher separat oder zusammen mit dem
Code ablegen möchtest, der das Element verwendet. Wenn wir zum Beispiel das
Modul <code>front_of_house</code> und die Funktion <code>eat_at_restaurant</code> in ein Modul namens
<code>customer_experience</code> verschieben, müssten wir den absoluten Pfad in
<code>add_to_waitlist</code> ändern, aber der relative Pfad wäre immer noch gültig. Wenn
wir jedoch die Funktion <code>eat_at_restaurant</code> in ein separates Modul namens
<code>dining</code> verschieben würden, würde der absolute Pfad beim Aufruf
<code>add_to_waitlist</code> gleich bleiben, aber der relative Pfad müsste aktualisiert
werden. Wir bevorzugen generell die Angabe absoluter Pfade, da es
wahrscheinlicher ist, dass Codedefinitionen und Elementaufrufe unabhängig
voneinander verschoben werden.</p>
<p>Lass uns versuchen, Codeblock 7-3 zu kompilieren, und herausfinden, warum er
sich noch nicht kompilieren lässt! Die Fehler, die wir erhalten, sind in
Codeblock 7-4 zu sehen.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<p><span class="caption">Codeblock 7-4: Kompilierfehler im Code in Codeblock
7-3</span></p>
<p>Die Fehlermeldungen besagen, dass das Modul <code>hosting</code> privat ist. Mit anderen
Worten, wir haben die korrekten Pfade für das Modul <code>hosting</code> und die Funktion
<code>add_to_waitlist</code> angegeben, aber Rust lässt sie uns nicht nutzen, weil es
keinen Zugriff auf die privaten Abschnitte hat. In Rust sind alle Elemente
(Funktionen, Methoden, Strukturen, Aufzählungen, Module und Konstanten)
standardmäßig privat für übergeordnete Module. Wenn du ein Element wie eine
Funktion oder Struktur privat machen willst, setze es in ein Modul.</p>
<p>Objekte in einem übergeordneten Modul können die privaten Objekte in
untergeordneten Modulen nicht verwenden, aber Objekte in untergeordneten
Modulen können die Objekte in ihren übergeordneten Modulen verwenden. Der Grund
dafür ist, dass untergeordnete Module ihre Implementierungsdetails ein- und
ausblenden, aber die untergeordneten Module können den Gültigkeitsbereich
sehen, in dem sie definiert sind. Um mit unserer Metapher fortzufahren, stelle
dir die Datenschutzregeln wie das Backoffice eines Restaurants vor: Was dort
drinnen passiert, ist für Restaurantkunden privat, aber Büroleiter können alles
im Restaurant, in dem sie arbeiten, sehen und tun.</p>
<p>Rust entschied sich dafür, das Modulsystem auf diese Weise funktionieren zu
lassen, sodass das Ausblenden innerer Implementierungsdetails die Vorgabe ist.
Auf diese Weise weißt du, welche Teile des inneren Codes du ändern kannst, ohne
den äußeren Code zu brechen. Rust gibt dir jedoch die Möglichkeit, innere Teile
des Codes von Kindmodulen für äußere Vorgängermodule offenzulegen, indem du das
Schlüsselwort <code>pub</code> verwendest, um ein Element öffentlich zu machen.</p>
<h3 id="pfade-mit-dem-schlüsselwort-pub-öffentlich-machen"><a class="header" href="#pfade-mit-dem-schlüsselwort-pub-öffentlich-machen">Pfade mit dem Schlüsselwort <code>pub</code> öffentlich machen</a></h3>
<p>Kehren wir zum Fehler in Codeblock 7-4 zurück, der uns sagte, das Modul
<code>hosting</code> sei privat. Wir wollen, dass die Funktion <code>eat_at_restaurant</code> im
übergeordneten Modul Zugriff auf die Funktion <code>add_to_waitlist</code> im
untergeordneten Modul hat, also markieren wir das Modul <code>hosting</code> mit dem
Schlüsselwort <code>pub</code>, wie in Codeblock 7-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absoluter Pfad
    crate::front_of_house::hosting::add_to_waitlist();

    // Relativer Pfad
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-5: Deklarieren des Moduls <code>hosting</code> als
<code>pub</code>, um es von <code>eat_at_restaurant</code> aus zu benutzen</span></p>
<p>Leider führt der Code in Codeblock 7-5 immer noch zu Kompilierfehlern, wie
Codeblock 7-6 zeigt.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<p><span class="caption">Codeblock 7-6: Kompilierfehler im Code in Codeblock
7-5</span></p>
<p>Was ist passiert? Das Hinzufügen des Schlüsselworts <code>pub</code> vor <code>mod hosting</code>
macht das Modul öffentlich. Wenn wir auf <code>front_of_house</code> zugreifen können,
können wir mit dieser Änderung auch auf <code>hosting</code> zugreifen. Aber die <em>Inhalte</em>
von <code>hosting</code> sind immer noch privat; das Modul öffentlich zu machen, macht
seinen Inhalt nicht öffentlich. Das Schlüsselwort <code>pub</code> für ein Modul erlaubt
es dem Code in seinen Vorgängermodulen nur, auf das Modul zu referenzieren,
nicht aber auf seinen inneren Code zuzugreifen. Da Module Container sind,
können wir nicht viel tun, indem wir nur das Modul öffentlich machen; wir
müssen weiter gehen und eines oder mehrere der Elemente innerhalb des Moduls
ebenfalls öffentlich machen.</p>
<p>Die Fehler in Codeblock 7-6 besagen, dass die Funktion <code>add_to_waitlist</code> privat
ist. Die Datenschutzregeln gelten für Strukturen, Aufzählungen, Funktionen und
Methoden sowie für Module.</p>
<p>Lass uns auch die Funktion <code>add_to_waitlist</code> öffentlich machen, indem wir das
Schlüsselwort <code>pub</code> vor ihre Definition hinzufügen, wie in Codeblock 7-7.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absoluter Pfad
    crate::front_of_house::hosting::add_to_waitlist();

    // Relativer Pfad
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Codeblock 7-7: Das Hinzufügen des Schlüsselworts <code>pub</code> zu
<code>mod hosting</code> und <code>fn add_to_waitlist</code> lässt uns die Funktion in
<code>eat_at_restaurant</code> aufrufen</span></p>
<p>Jetzt kompiliert der Code! Um zu sehen, warum das Hinzufügen des Schlüsselworts
<code>pub</code> uns erlaubt, diese Pfade in <code>eat_at_restaurant</code> im Hinblick auf die
Datenschutzregeln zu verwenden, sehen wir uns die absoluten und relativen Pfade
an.</p>
<p>Auf dem absoluten Pfad beginnen wir mit <code>crate</code>, der Wurzel des Modulbaums
unserer Kiste. Dann wird das Modul <code>front_of_house</code> in der Kistenwurzel
definiert. Während das Modul <code>front_of_house</code> nicht öffentlich ist, weil die
Funktion <code>eat_at_restaurant</code> im gleichen Modul wie <code>front_of_house</code> definiert
ist (d.h. <code>eat_at_restaurant</code> und <code>front_of_house</code> sind Geschwister), können
wir auf <code>front_of_house</code> von <code>eat_at_restaurant</code> aus zugreifen. Als nächstes
wird das Modul <code>hosting</code> mit <code>pub</code> gekennzeichnet. Wir können auf das
übergeordnete Modul von <code>hosting</code> zugreifen, also können wir auf <code>hosting</code>
zugreifen. Schließlich wird die Funktion <code>add_to_waitlist</code> mit <code>pub</code> markiert
und wir können auf ihr Elternmodul zugreifen, sodass dieser Funktionsaufruf
klappt!</p>
<p>Beim relativen Pfad ist die Logik die gleiche wie beim absoluten Pfad, mit
Ausnahme des ersten Schritts: Anstatt von der Kistenwurzel auszugehen, beginnt
der Pfad mit <code>front_of_house</code>. Das Modul <code>front_of_house</code> wird innerhalb
desselben Moduls wie <code>eat_at_restaurant</code> definiert, sodass der relative Pfad
ausgehend vom Modul, in dem <code>eat_at_restaurant</code> definiert ist, funktioniert.
Weil <code>hosting</code> und <code>add_to_waitlist</code> nun mit <code>pub</code> markiert sind, funktioniert
der Rest des Pfades, und dieser Funktionsaufruf ist gültig!</p>
<p>Wenn du vorhast, deine Bibliothekskiste weiterzugeben, damit andere Projekte
deinen Code verwenden können, ist deine öffentliche API deine Übereinkunft mit den
Benutzern deiner Kiste, die festlegt, wie sie mit deinem Code interagieren
können. Es gibt viele Überlegungen zum Umgang mit Änderungen an deiner
öffentlichen API, um es für andere einfacher zu machen, sich auf deine Kiste zu
verlassen. Diese Überlegungen gehen über den Rahmen dieses Buches hinaus; wenn
du an diesem Thema interessiert bist, lies die <a href="https://rust-lang.github.io/api-guidelines/">Rust API
Guidelines</a>.</p>
<blockquote>
<h4 id="bewährte-praktiken-für-pakete-mit-einer-binärdatei-und-einer-bibliothek"><a class="header" href="#bewährte-praktiken-für-pakete-mit-einer-binärdatei-und-einer-bibliothek">Bewährte Praktiken für Pakete mit einer Binärdatei und einer Bibliothek</a></h4>
<p>Wir haben bereits erwähnt, dass ein Paket sowohl eine Binärkistenwurzel
<em>src/main.rs</em> als auch eine Bibliothekskistenwurzel <em>src/lib.rs</em> enthalten
kann, und beide Kisten tragen standardmäßig den Paketnamen. Normalerweise
haben Pakete mit diesem Muster, die sowohl eine Bibliothek als auch eine
Binärkiste enthalten, gerade genug Code in der Binärkiste, um eine
ausführbare Datei zu starten, die Code aus der Bibliothekskiste aufruft.
Dadurch können andere Projekte von den meisten Funktionen des Pakets
profitieren, da der Code der Bibliothekskiste gemeinsam genutzt werden kann.</p>
<p>Der Modulbaum sollte in <em>src/lib.rs</em> definiert werden. Dann können alle
öffentlichen Elemente in der Binärkiste verwendet werden, indem die Pfade
mit dem Namen des Pakets beginnen. Die binäre Kiste wird zu einem Benutzer
der Bibliothekskiste, so wie eine vollständig externe Kiste die
Bibliothekskiste verwenden würde: Sie kann nur die öffentliche API
verwenden. Dies hilft dir, eine gute API zu entwerfen; Du bist nicht nur der
Autor, sondern auch ein Kunde!</p>
<p>In <a href="ch12-00-an-io-project.html">Kapitel 12</a> werden wir diese organisatorische Praxis anhand eines
Befehlszeilenprogramms demonstrieren, das sowohl eine Binärkiste als auch
eine Bibliothekskiste enthält.</p>
</blockquote>
<h3 id="relative-pfade-mit-super-beginnen"><a class="header" href="#relative-pfade-mit-super-beginnen">Relative Pfade mit <code>super</code> beginnen</a></h3>
<p>Wir können relative Pfade konstruieren, die im übergeordneten Modul beginnen
und nicht im aktuellen Modul oder der Kistenwurzel, indem wir <code>super</code> am Anfang
des Pfades verwenden. Dies ist so, als würde man einen Dateisystempfad mit der
Syntax <code>..</code> beginnen. Das Verwenden von <code>super</code> erlaubt es uns, auf ein Element
zu referenzieren, von dem wir wissen, dass es sich im übergeordneten Modul
befindet, was die Neuordnung des Modulbaums erleichtern kann, wenn das Modul
eng mit dem übergeordneten Modul verwandt ist, aber das übergeordnete Modul
eines Tages an eine andere Stelle im Modulbaum verschoben werden könnte.</p>
<p>Betrachte den Code in Codeblock 7-8, der die Situation nachbildet, in der ein
Koch eine falsche Bestellung korrigiert und persönlich zum Kunden bringt. Die
Funktion <code>fix_incorrect_order</code>, die im Modul <code>back_of_house</code> definiert ist,
ruft die im übergeordneten Modul definierte Funktion <code>deliver_order</code> auf, indem
sie den Pfad zu <code>deliver_order</code> angibt, der mit <code>super</code> beginnt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-8: Aufrufen einer Funktion unter Verwendung
eines relativen Pfades, der mit <code>super</code> beginnt</span></p>
<p>Die Funktion <code>fix_incorrect_order</code> befindet sich im Modul <code>back_of_house</code>,
sodass wir <code>super</code> benutzen können, um zum Elternmodul von <code>back_of_house</code> zu
gelangen, was in diesem Fall die Wurzel <code>crate</code> ist. Von dort aus suchen wir
nach <code>deliver_order</code> und finden es. Erfolg! Wir denken, dass das Modul
<code>back_of_house</code> und die Funktion <code>deliver_order</code> wahrscheinlich in der gleichen Beziehung zueinander stehen und zusammen verschoben werden, sollten wir uns dazu
entschließen, den Modulbaum der Kiste neu zu organisieren. Deshalb haben wir
<code>super</code> verwendet, sodass wir in Zukunft weniger Codestellen zu aktualisieren
haben, wenn dieser Code in ein anderes Modul verschoben wird.</p>
<h3 id="strukturen-und-aufzählungen-öffentlich-machen"><a class="header" href="#strukturen-und-aufzählungen-öffentlich-machen">Strukturen und Aufzählungen öffentlich machen</a></h3>
<p>Wir können auch <code>pub</code> verwenden, um Strukturen und Aufzählungen als öffentlich
zu kennzeichnen, aber es gibt ein paar zusätzliche Details zur Verwendung von
<code>pub</code> mit Strukturen und Aufzählungen. Wenn wir <code>pub</code> vor einer
Struktur-Definition verwenden, machen wir die Struktur öffentlich, aber die
Felder der Struktur sind immer noch privat. Wir können jedes Feld von Fall zu
Fall öffentlich machen oder auch nicht. In Codeblock 7-9 haben wir eine
öffentliche Struktur <code>back_of_house::Breakfast</code> mit einem öffentlichen Feld
<code>toast</code>, aber einem privaten Feld <code>seasonal_fruit</code> definiert. Dies ist der Fall
in einem Restaurant, in dem der Kunde die Brotsorte auswählen kann, die zu
einer Mahlzeit gehört, aber der Küchenchef entscheidet, welche Früchte die
Mahlzeit begleiten, je nach Saison und Vorrat. Das verfügbare Obst ändert sich
schnell, sodass die Kunden nicht wählen oder gar sehen können, welches Obst sie
bekommen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("Pfirsiche"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Bestelle im Sommer ein Frühstück mit Roggentoast
    let mut meal = back_of_house::Breakfast::summer("Roggen");
    // Ändere unsere Meinung darüber, welche Brotsorte wir gerne hätten
    meal.toast = String::from("Weizen");
    println!("Ich möchte {}-Toast", meal.toast);

    // Die nächste Zeile lässt sich nicht kompilieren, wenn wir sie nicht
    // auskommentieren; wir dürfen die Früchte der Saison, die wir mit der
    // Mahlzeit bekommen, weder sehen noch verändern.
    // meal.seasonal_fruit = String::from("Heidelbeeren");
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-9: Eine Struktur mit öffentlichen und
privaten Feldern</span></p>
<p>Da das Feld <code>toast</code> in der Struktur <code>back_of_house::Breakfast</code> öffentlich ist,
können wir in <code>eat_at_restaurant</code> in das Feld <code>toast</code> schreiben und lesen,
indem wir die Punktnotation verwenden. Beachte, dass wir das Feld
<code>seasonal_fruit</code> in <code>eat_at_restaurant</code> nicht verwenden können, weil
<code>seasonal_fruit</code> privat ist. Versuche, die Kommentarzeichen in der Zeile, die
den Feldwert <code>seasonal_fruit</code> modifiziert, zu entfernen, um zu sehen, welchen
Fehler du erhältst!</p>
<p>Beachte auch, dass, weil <code>back_of_house::Breakfast</code> ein privates Feld hat, die
Struktur eine öffentliche Funktion (hier haben wir sie <code>summer</code> genannt) zum
Erzeugen einer Instanz von <code>Breakfast</code> bereitstellen muss. Wenn <code>Breakfast</code>
keine solche Funktion hätte, könnten wir keine Instanz von <code>Breakfast</code> in
<code>eat_at_restaurant</code> erzeugen, weil wir den Wert des privaten Feldes
<code>seasonal_fruit</code> in <code>eat_at_restaurant</code> nicht setzen könnten.</p>
<p>Wenn wir dagegen eine Aufzählung veröffentlichen, dann sind alle ihre
Varianten öffentlich. Wir brauchen nur das Schlüsselwort <code>pub</code> vor dem
Schlüsselwort <code>enum</code>, wie in Codeblock 7-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-10: Kennzeichnen einer Aufzählung als
öffentlich macht alle ihre Varianten öffentlich</span></p>
<p>Da wir die Aufzählung <code>Appetizer</code> öffentlich gemacht haben, können wir die
Varianten <code>Soup</code> und <code>Salad</code> in <code>eat_at_restaurant</code> verwenden.</p>
<p>Aufzählungen wären ohne öffentliche Varianten nicht sehr nützlich; es wäre
ärgerlich, alle Aufzählungs-Varianten stets mit <code>pub</code> annotieren zu müssen,
daher sind die Aufzählungs-Varianten standardmäßig öffentlich. Strukturen sind
auch ohne öffentliche Felder nützlich, daher folgen Strukturfelder
standardmäßig der allgemeinen Regel, dass alles privat ist, es sei denn, es
wird mit <code>pub</code> annotiert.</p>
<p>Es gibt noch eine weitere Situation mit <code>pub</code>, die wir noch nicht behandelt
haben, und das ist unser letztes Modulsystem-Feature: Das Schlüsselwort <code>use</code>.
Zuerst werden wir <code>use</code> an sich behandeln, und dann zeigen wir, wie man <code>pub</code>
und <code>use</code> kombiniert.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfade-in-den-gültigkeitsbereich-bringen-mit-dem-schlüsselwort-use"><a class="header" href="#pfade-in-den-gültigkeitsbereich-bringen-mit-dem-schlüsselwort-use">Pfade in den Gültigkeitsbereich bringen mit dem Schlüsselwort <code>use</code></a></h2>
<p>Die Pfade für den Aufruf von Funktionen auszuschreiben, kann lästig sein und
sich wiederholen. In Codeblock 7-7 mussten wir, unabhängig davon, ob wir den
absoluten oder relativen Pfad zur Funktion <code>add_to_waitlist</code> wählten, jedes
Mal, wenn wir <code>add_to_waitlist</code> aufrufen wollten, auch <code>front_of_house</code> und
<code>hosting</code> angeben. Glücklicherweise gibt es eine Möglichkeit, diesen Vorgang zu
vereinfachen: Wir können eine Verknüpfung zu einem Pfad mit dem Schlüsselwort
<code>use</code> einmal erstellen und dann den kürzeren Namen überall sonst im
Gültigkeitsbereich verwenden.</p>
<p>In Codeblock 7-11 bringen wir das Modul <code>crate::front_of_house::hosting</code> in den
Gültigkeitsbereich der Funktion <code>eat_at_restaurant</code>, sodass wir nur noch
<code>hosting::add_to_waitlist</code> angeben müssen, um die Funktion <code>add_to_waitlist</code> in
<code>eat_at_restaurant</code> aufzurufen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Codeblock 7-11: Ein Modul mit <code>use</code> in den
Gültigkeitsbereich bringen</span></p>
<p>Das Angeben von <code>use</code> und einem Pfad in einem Gültigkeitsbereich ist ähnlich
dem Erstellen eines symbolischen Links im Dateisystem. Durch Hinzufügen von
<code>use crate::front_of_house::hosting</code> in der Kistenwurzel ist <code>hosting</code> nun ein
gültiger Name in diesem Gültigkeitsbereich, so als wäre das Modul <code>hosting</code> in
der Kistenwurzel definiert worden. Pfade, die mit <code>use</code> in den
Gültigkeitsbereich gebracht werden, überprüfen wie alle anderen Pfade auch die
Privatsphäre.</p>
<p>Beachte, dass <code>use</code> nur die Verknüpfung für den jeweiligen Gültigkeitsbereich
erstellt, in dem <code>use</code> vorkommt. Codeblock 7-12 verschiebt die Funktion
<code>eat_at_restaurant</code> in ein neues untergeordnetes Modul namens <code>customer</code>, das
dann einen anderen Gültigkeitsbereich als die <code>use</code>-Anweisung hat, sodass der
Funktionsrumpf nicht kompiliert werden kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness does_not_compile">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
<p><span class="caption">Codeblock 7-12: Eine <code>use</code>-Anweisung gilt nur in dem
Gültigkeitsbereich, in dem sie steht</span></p>
<p>Der Compilerfehler zeigt, dass die Verknüpfung innerhalb des Moduls <code>customer</code>
nicht mehr gilt:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`
   |
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>Beachte, dass es auch eine Warnung gibt, dass <code>use</code> nicht mehr in seinem
Gültigkeitsbereich verwendet wird! Um dieses Problem zu beheben, verschiebe
<code>use</code> auch innerhalb des Moduls <code>customer</code>, oder referenziere die Verknüpfung
im übergeordneten Modul mit <code>super::hosting</code> innerhalb des untergeordneten
Moduls <code>customer</code>.</p>
<h3 id="idiomatische-use-pfade-erstellen"><a class="header" href="#idiomatische-use-pfade-erstellen">Idiomatische <code>use</code>-Pfade erstellen</a></h3>
<p>In Codeblock 7-11 hast du dich vielleicht gefragt, warum wir <code>use crate::front_of_house::hosting</code> angegeben und dann <code>hosting::add_to_waitlist</code>
in <code>eat_at_restaurant</code> aufgerufen haben, anstatt den <code>use</code>-Pfad bis hin zur
Funktion <code>add_to_waitlist</code> anzugeben, um dasselbe Ergebnis zu erzielen wie in
Codeblock 7-13.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
<p><span class="caption">Codeblock 7-13: Die Funktion <code>add_to_waitlist</code> mit <code>use</code>
in den Gültigkeitsbereich bringen ist nicht idiomatisch.</span></p>
<p>Obwohl sowohl Codeblock 7-11 als auch Codeblock 7-13 die gleiche Aufgabe
erfüllen, ist Codeblock 7-11 der idiomatische Weg, eine Funktion mit <code>use</code> in
den Gültigkeitsbereich zu bringen. Wenn wir das Elternmodul der Funktion mit
<code>use</code> in den Gültigkeitsbereich bringen, sodass wir das Elternmodul beim Aufruf
der Funktion angeben müssen, wird klar, dass die Funktion nicht lokal definiert
ist, während gleichzeitig die Wiederholung des vollständigen Pfades minimiert
wird. Im Code in Codeblock 7-13 ist unklar, wo <code>add_to_waitlist</code> definiert ist.</p>
<p>Wenn andererseits Strukturen, Aufzählungen und andere Elemente mit <code>use</code>
eingebracht werden, ist es idiomatisch, den vollständigen Pfad anzugeben.
Codeblock 7-14 zeigt den idiomatischen Weg, die Struktur <code>HashMap</code> der
Standardbibliothek in den Gültigkeitsbereich einer binären Kiste zu bringen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
<p><span class="caption">Codeblock 7-14: <code>HashMap</code> auf idiomatische Weise in den
Gültigkeitsbereich bringen</span></p>
<p>Es gibt keinen triftigen Grund für dieses Idiom: Es ist einfach eine
Konvention, die entstanden ist, und die Leute haben sich daran gewöhnt,
Rust-Code auf diese Weise zu lesen und zu schreiben.</p>
<p>Die Ausnahme von diesem Idiom ist, wenn wir zwei gleichnamige Elemente mit
<code>use</code> in den Gültigkeitsbereich bringen, denn das lässt Rust nicht zu. In
Codeblock 7-15 wird gezeigt, wie zwei <code>Result</code>-Typen mit gleichem Namen, aber
unterschiedlichen Elternmodulen in den Gültigkeitsbereich gebracht werden und
wie auf sie verwiesen werden kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --abschneiden--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --abschneiden--
<span class="boring">    Ok(())
</span>}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-15: Um zwei Typen mit dem gleichen Namen in
denselben Gültigkeitsbereich zu bringen, müssen ihre übergeordneten Module
angegeben werden.</span></p>
<p>Wie du sehen kannst, unterscheidet die Verwendung der übergeordneten Module die
beiden <code>Result</code>-Typen. Wenn wir stattdessen <code>use std::fmt::Result</code> und
<code>use std::io::Result</code> angeben würden, hätten wir zwei <code>Result</code>-Typen im selben
Gültigkeitsbereich und Rust wüsste nicht, welchen wir beim Verwenden von
<code>Result</code> meinten.</p>
<h3 id="mit-dem-schlüsselwort-as-neue-namen-vergeben"><a class="header" href="#mit-dem-schlüsselwort-as-neue-namen-vergeben">Mit dem Schlüsselwort <code>as</code> neue Namen vergeben</a></h3>
<p>Es gibt eine andere Lösung für das Problem, zwei Typen desselben Namens mit
<code>use</code> in den gleichen Gültigkeitsbereich zu bringen: Hinter dem Pfad können wir
<code>as</code> und einen neuen lokalen Namen oder <em>Alias</em> für den Typ angeben. Codeblock
7-16 zeigt eine weitere Möglichkeit, den Code in Codeblock 7-15 zu schreiben,
indem einer der beiden <code>Result</code>-Typen mittels <code>as</code> umbenannt wird.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --abschneiden--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --abschneiden--
<span class="boring">    Ok(())
</span>}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-16: Umbenennen eines Typs, wenn er mit dem
Schlüsselwort <code>as</code> in den Gültigkeitsbereich gebracht wird</span></p>
<p>In der zweiten <code>use</code>-Anweisung wählten wir den neuen Namen <code>IoResult</code> für den
Typ <code>std::io::Result</code>, der nicht im Konflikt zum ebenfalls von uns in den
Gültigkeitsbereich gebrachten <code>Result</code> aus <code>std::fmt</code> steht. Codeblock 7-15
und Codeblock 7-16 gelten als idiomatisch, die Wahl liegt also bei dir!</p>
<h3 id="rück-exportieren-von-namen-mit-pub-use"><a class="header" href="#rück-exportieren-von-namen-mit-pub-use">Rück-Exportieren von Namen mit <code>pub use</code></a></h3>
<p>Wenn wir einen Namen mit dem Schlüsselwort <code>use</code> in den Gültigkeitsbereich
bringen, ist der Name privat für den Gültigkeitsbereich, in den wir ihn
importiert haben. Damit der Code, der unseren Code aufruft, auf diesen Namen
verweisen kann, als wäre er im Gültigkeitsbereich dieses Codes definiert
worden, können wir <code>pub</code> und <code>use</code> kombinieren. Diese Technik wird
<em>Rück-Exportieren</em> (re-exporting) genannt, weil wir ein Element in den
Gültigkeitsbereich bringen, dieses Element aber auch anderen zur Verfügung
stellen, um es in ihren Gültigkeitsbereich zu bringen.</p>
<p>Codeblock 7-17 zeigt den Code in Codeblock 7-11, wobei <code>use</code> im Wurzelmodul in
<code>pub use</code> geändert wurde.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Codeblock 7-17: Bereitstellen eines Namens für externen
Code zum Verwenden in einem neuen Gültigkeitsbereich mit <code>pub use</code></span></p>
<p>Vor dieser Änderung musste externer Code die Funktion <code>add_to_waitlist</code> mit dem
Pfad <code>restaurant::front_of_house::hosting::add_to_waitlist()</code> aufrufen, was
zudem erfordert hätte, dass das Modul <code>front_of_house</code> als <code>pub</code> gekennzeichnet
ist. Da aber <code>pub use</code> das Modul <code>hosting</code> aus dem Wurzel-Modul re-exportiert
hat, kann externer Code nun stattdessen den Pfad
<code>restaurant::hosting::add_to_waitlist()</code> verwenden.</p>
<p>Der Rück-Export ist nützlich, wenn sich die interne Struktur deines Codes von
dem unterscheidet, wie Programmierer, die deinen Code
aufrufen, über die Domäne denken würden. In der Restaurantmetapher denken die
Betreiber des Restaurants zum Beispiel an die „Vorderseite des Hauses“ und die
„Rückseite des Hauses“. Mit <code>pub use</code> können wir unseren Code mit einer
Struktur schreiben, aber eine andere Struktur veröffentlichen. Auf diese Weise
ist unsere Bibliothek für Programmierer, die an der Bibliothek arbeiten, und
Programmierer, die die Bibliothek aufrufen, gut organisiert. Ein weiteres
Beispiel für <code>pub use</code> und wie es sich auf die Dokumentation deiner Kiste
auswirkt, werden wir in <a href="ch14-02-publishing-to-crates-io.html#mit-pub-use-eine-benutzerfreundliche-%C3%B6ffentliche-api-exportieren">„Mit <code>pub use</code> eine benutzerfreundliche öffentliche
API exportieren“</a> in Kapitel 14 betrachten.</p>
<h3 id="verwenden-externer-pakete"><a class="header" href="#verwenden-externer-pakete">Verwenden externer Pakete</a></h3>
<p>In Kapitel 2 programmierten wir ein Ratespielprojekt, das ein externes Paket
namens <code>rand</code> benutzte, um Zufallszahlen zu generieren. Um <code>rand</code> in unserem
Projekt zu verwenden, fügten wir diese Zeile zu <em>Cargo.toml</em> hinzu:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">rand = "0.8.5"
</code></pre>
<p>Das Hinzufügen von <code>rand</code> als Abhängigkeit in <em>Cargo.toml</em> weist Cargo an, das
Paket <code>rand</code> und alle Abhängigkeiten von <a href="https://crates.io/">crates.io</a>
herunterzuladen und <code>rand</code> für unser Projekt verfügbar zu machen.</p>
<p>Um dann Definitionen von <code>rand</code> in den Gültigkeitsbereich unseres Pakets
aufzunehmen, haben wir eine Zeile mit <code>use</code> hinzugefügt, die mit dem
Kistennamen <code>rand</code> beginnt und die Elemente auflistet, die wir in den
Gültigkeitsbereich bringen wollten. Erinnere dich, dass wir in <a href="ch02-00-guessing-game-tutorial.html#generieren-einer-geheimzahl">„Generieren
einer Geheimzahl“</a> in Kapitel 2 das Merkmal <code>Rng</code> in den
Gültigkeitsbereich gebracht und die Funktion <code>rand::thread_rng</code> aufgerufen
haben:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!("Die geheime Zahl ist: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Bitte gib deine Vermutung ein.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Fehler beim Lesen einer Zeile");
</span><span class="boring">
</span><span class="boring">    println!("Du hast geraten: {guess}");
</span>}</code></pre></pre>
<p>Mitglieder der Rust-Gemeinschaft haben viele Pakete unter
<a href="https://crates.io/">crates.io</a> zur Verfügung gestellt und wenn du eines davon
in dein Paket aufnimmst, sind die gleichen Schritte erforderlich: Liste sie
in der Datei <em>Cargo.toml</em> deines Pakets auf und verwende <code>use</code>, um Elemente aus
ihren Kisten in den Gültigkeitsbereich zu bringen.</p>
<p>Beachte, dass die Standardbibliothek <code>std</code> ebenfalls eine Kiste ist, die nicht
zu unserem Paket gehört. Da die Standardbibliothek mit der Sprache Rust
ausgeliefert wird, brauchen wir <em>Cargo.toml</em> nicht zu ändern, um <code>std</code>
einzubinden. Aber wir müssen <code>use</code> verwenden, um Elemente von dort in den
Gültigkeitsbereich unseres Pakets zu bringen. Zum Beispiel würden wir für
<code>HashMap</code> diese Zeile verwenden:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>Dies ist ein absoluter Pfad, der mit <code>std</code>, dem Namen der
Standard-Bibliothekskiste, beginnt.</p>
<h3 id="verschachtelte-pfade-verwenden-um-lange-use-listen-zu-vereinfachen"><a class="header" href="#verschachtelte-pfade-verwenden-um-lange-use-listen-zu-vereinfachen">Verschachtelte Pfade verwenden, um lange <code>use</code>-Listen zu vereinfachen</a></h3>
<p>Wenn wir mehrere in der gleichen Kiste oder im gleichen Modul definierte
Elemente verwenden, kann das Auflisten jedes Elements in einer eigenen Zeile
viel vertikalen Platz in unseren Dateien einnehmen. Zum Beispiel bringen diese
beiden <code>use</code>-Anweisungen, die wir im Ratespiel in Codeblock 2-4 hatten,
Elemente aus <code>std</code> in den Gültigkeitsbereich:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// --abschneiden--
use std::cmp::Ordering;
use std::io;
// --abschneiden--
<span class="boring">}</span></code></pre></pre>
<p>Stattdessen können wir verschachtelte Pfade verwenden, um die gleichen Elemente
in einer Zeile in den Gültigkeitsbereich zu bringen. Wir tun dies, indem wir
den gemeinsamen Teil des Pfades angeben, gefolgt von zwei Doppelpunkten und
dann geschweiften Klammern um Liste der Pfadteile, die sich unterscheiden, wie
in Codeblock 7-18 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// --abschneiden--
use std::{cmp::Ordering, io};
// --abschneiden--
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-18: Angeben eines verschachtelten Pfades, um
mehrere Elemente mit demselben Präfix in den Gültigkeitsbereich zu
bringen</span></p>
<p>In größeren Programmen kann das Einbeziehen vieler Elemente aus derselben Kiste
oder demselben Modul in den Gültigkeitsbereich durch verschachtelte Pfade die
Anzahl der separaten <code>use</code>-Anweisungen um ein Vielfaches reduzieren!</p>
<p>Wir können einen verschachtelten Pfad auf jeder Ebene in einem Pfad verwenden,
was nützlich ist, wenn zwei <code>use</code>-Anweisungen kombiniert werden, die sich einen
Teilpfad teilen. Beispielsweise zeigt Codeblock 7-19 zwei <code>use</code>-Anweisungen:
Eine, die <code>std::io</code> in den Gültigkeitsbereich bringt, und eine, die
<code>std::io::Write</code> in den Gültigkeitsbereich bringt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Write;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-19: Zwei <code>use</code>-Anweisungen, bei denen eine
ein Teilpfad der anderen ist</span></p>
<p>Der gemeinsame Teil dieser beiden Pfade ist <code>std::io</code> und das ist der
vollständige erste Pfad. Um diese beiden Pfade zu einer einzigen
<code>use</code>-Anweisung zu verschmelzen, können wir <code>self</code> im verschachtelten Pfad
verwenden, wie in Codeblock 7-20 gezeigt wird.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-20: Zusammenfassen der Pfade aus Codeblock
7-19 zu einer <code>use</code>-Anweisung</span></p>
<p>Diese Zeile bringt <code>std::io</code> und <code>std::io::Write</code> in den Gültigkeitsbereich.</p>
<h3 id="der-stern-operator-glob"><a class="header" href="#der-stern-operator-glob">Der Stern-Operator (glob)</a></h3>
<p>Wenn wir <em>alle</em> öffentlichen Elemente, die in einem Pfad definiert sind, in den
Gültigkeitsbereich bringen wollen, können wir diesen Pfad gefolgt vom
Stern-Operator <code>*</code> angeben:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>Diese <code>use</code>-Anweisung bringt alle öffentlichen Elemente, die in
<code>std::collections</code> definiert sind, in den aktuellen Gültigkeitsbereich. Sei
vorsichtig beim Verwenden des Stern-Operators! Er kann es schwieriger machen,
zu erkennen, welche Namen in den Gültigkeitsbereich fallen und wo ein in deinem
Programm verwendeter Name definiert wurde.</p>
<p>Der Stern-Operator wird oft beim Testen verwendet, um alles, was getestet wird,
in das Modul <code>tests</code> zu bringen. Wir werden darüber in <a href="ch11-01-writing-tests.html">„Tests
schreiben“</a> in Kapitel 11 sprechen. Der Stern-Operator wird
manchmal auch als Teil des Präludiumsmusters (prelude pattern) verwendet: Siehe
<a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">Standardbibliotheksdokumentation</a> für weitere Informationen
zu diesem Muster.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="module-in-verschiedene-dateien-aufteilen"><a class="header" href="#module-in-verschiedene-dateien-aufteilen">Module in verschiedene Dateien aufteilen</a></h2>
<p>Bisher haben alle Beispiele in diesem Kapitel mehrere Module in einer Datei
definiert. Wenn Module groß werden, solltest du ihre Definitionen in eine
separate Datei verschieben, um die Navigation im Code zu erleichtern.</p>
<p>Gehen wir zum Beispiel von dem Code in Codeblock 7-17 aus, der mehrere
Restaurantmodule enthält. Wir verschieben das Modul <code>front_of_house</code> in seine
eigene Datei <em>src/front_of_house.rs</em>, indem wir die Kistenwurzeldatei so
ändern, dass sie den in Codeblock 7-21 gezeigten Code enthält. In diesem Fall
ist die Kistenwurzeldatei <em>src/lib.rs</em>, aber diese Vorgehensweise funktioniert
auch mit binären Kisten, deren Kistenwurzeldatei <em>src/main.rs</em> ist.</p>
<p>Zuerst extrahieren wir das Modul <code>front_of_house</code> in eine eigene Datei.
Entferne den Code innerhalb der geschweiften Klammern des Moduls
<code>front_of_house</code> und lasse nur die Deklaration <code>mod front_of_house;</code> übrig,
sodass <em>src/lib.rs</em> den in Codeblock 7-21 gezeigten Code enthält. Beachte, dass
dies nicht kompiliert und wir noch die Datei <em>src/front_of_house.rs</em> in
Codeblock 7-22 erstellen müssen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Codeblock 7-21: Deklarieren des Moduls <code>front_of_house</code>,
dessen Rumpf sich in <em>src/front_of_house.rs</em> befinden wird</span></p>
<p>Als nächstes fügst du den Code in den geschweiften Klammern in eine neue Datei
namens <em>src/front_of_house.rs</em> ein, wie in Codeblock 7-22 zu sehen ist. Der
Compiler weiß, dass er in dieser Datei suchen muss, weil er auf die
Moduldeklaration in der Kistenwurzel mit dem Namen <code>front_of_house</code> gestoßen
ist.</p>
<p><span class="filename">Dateiname: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}</code></pre>
<p><span class="caption">Codeblock 7-22: Definitionen innerhalb des Moduls
<code>front_of_house</code> in <em>src/front_of_house.rs</em></span></p>
<p>Beachte, dass du den Inhalt einer Datei mit einer <code>mod</code>-Deklaration nur
<em>einmal</em> in deinem Modulbaum laden musst. Sobald der Compiler weiß, dass die
Datei Teil des Projekts ist (und weiß, wo im Modulbaum sich der Code befindet,
weil du die <code>mod</code>-Anweisung eingefügt hast), sollten andere Dateien in deinem
Projekt auf den Code der geladenen Datei referenzieren, indem sie einen Pfad zu
der Stelle verwenden, an der er deklariert wurde, wie im Abschnitt <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit Pfaden
auf ein Element im Modulbaum verweisen“</a> beschrieben. Mit anderen
Worten: <code>mod</code> ist <em>keine</em> „include“-Operation, wie du sie vielleicht aus
anderen Programmiersprachen kennst.</p>
<p>Als Nächstes extrahieren wir das Modul <code>hosting</code> in seine eigene Datei. Der
Prozess ist ein bisschen anders, weil <code>hosting</code> ein untergeordnetes Modul von
<code>front_of_house</code> ist, nicht vom Stammmodul. Wir legen die Datei für <code>hosting</code>
in einem neuen Verzeichnis ab, das nach seinen Vorgängern im Modulbaum benannt
wird, in diesem Fall <em>src/front_of_house</em>.</p>
<p>Um mit dem Verschieben von <code>hosting</code> zu beginnen, ändern wir
<em>src/front_of_house.rs</em> so, dass es nur die Deklaration des <code>hosting</code>-Moduls
enthält:</p>
<p><span class="filename">Dateiname: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting;</code></pre>
<p>Dann erstellen wir ein Verzeichnis <em>src/front_of_house</em> und eine Datei
<em>hosting.rs</em>, die die Definitionen des Moduls <code>hosting</code> enthält:</p>
<p><span class="filename">Dateiname: src/front_of_house/hosting.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_to_waitlist() {}
<span class="boring">}</span></code></pre></pre>
<p>Wenn wir stattdessen <em>hosting.rs</em> in das <em>src</em>-Verzeichnis legen, würde der
Compiler erwarten, dass der <em>hosting.rs</em>-Code in einem <code>hosting</code>-Modul
enthalten ist, das im Stammverzeichnis der Kiste deklariert ist, und nicht als
Kind des <code>front_of_house</code>-Moduls. Die Regeln des Compilers dafür, welche
Dateien auf den Code welcher Module zu prüfen sind, bedeuten, dass die
Verzeichnisse und Dateien dem Modulbaum besser entsprechen.</p>
<blockquote>
<h3 id="alternative-dateipfade"><a class="header" href="#alternative-dateipfade">Alternative Dateipfade</a></h3>
<p>Bis jetzt haben wir die idiomatischsten Dateipfade behandelt, die der
Rust-Compiler verwendet, aber Rust unterstützt auch eine ältere Art von
Dateipfaden. Für ein Modul mit dem Namen <code>front_of_house</code>, das in der
Kistenwurzel deklariert ist, sucht der Compiler den Code des Moduls in:</p>
<ul>
<li><em>src/front_of_house.rs</em> (was wir behandelt haben)</li>
<li><em>src/front_of_house/mod.rs</em> (älterer Stil, noch unterstützter Pfad)</li>
</ul>
<p>Bei einem Modul mit dem Namen <code>hosting</code>, das ein Untermodul von
<code>front_of_house</code> ist, sucht der Compiler den Code des Moduls in:</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (was wir behandelt haben)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (älterer Stil, noch unterstützter Pfad)</li>
</ul>
<p>Wenn du beide Stile für dasselbe Modul verwendest, erhältst einen
Compilerfehler. Die Verwendung einer Mischung beider Stile für verschiedene
Module im selben Projekt ist zulässig, kann aber für die Benutzer verwirrend
sein, die durch dein Projekt navigieren.</p>
<p>Der größte Nachteil des Stils, der Dateien mit dem Namen <em>mod.rs</em> verwendet,
ist, dass dein Projekt am Ende viele Dateien mit dem Namen <em>mod.rs</em> haben
kann, was verwirrend sein kann, wenn du sie gleichzeitig in deinem Editor
geöffnet hast.</p>
</blockquote>
<p>Wir haben den Code jedes Moduls in eine separate Datei verschoben, und der
Modulbaum bleibt derselbe. Die Funktionsaufrufe in <code>eat_at_restaurant</code>
funktionieren ohne jede Änderung, auch wenn die Definitionen in verschiedenen
Dateien stehen. Mit dieser Technik kannst du Module in neue Dateien
verschieben, wenn diese größer werden.</p>
<p>Beachte, dass sich die Anweisung <code>pub use crate::front_of_house::hosting</code> in
<em>src/lib.rs</em> ebenfalls nicht geändert hat und dass <code>use</code> keinen Einfluss darauf
hat, welche Dateien als Teil der Kiste kompiliert werden. Das Schlüsselwort
<code>mod</code> deklariert Module und Rust sucht in einer Datei mit dem Modulnamen nach
dem Code, der zu diesem Modul gehört.</p>
<h2 id="zusammenfassung-6"><a class="header" href="#zusammenfassung-6">Zusammenfassung</a></h2>
<p>Mit Rust kannst du ein Paket in mehrere Kisten und eine Kiste in Module
aufteilen, sodass du auf in einem Modul definierte Elemente aus einem anderen
Modul verweisen kannst. Du kannst dies tun, indem du absolute oder relative
Pfade angibst. Diese Pfade können mit einer <code>use</code>-Anweisung in den
Gültigkeitsbereich gebracht werden, sodass du einen kürzeren Pfad für mehrere
Verwendungen des Elements in diesem Gültigkeitsbereich angeben kannst. Der
Modulcode ist standardmäßig privat, aber du kannst Definitionen öffentlich
machen, indem du das Schlüsselwort <code>pub</code> angibst.</p>
<p>Im nächsten Kapitel werden wir uns einige Kollektionsdatenstrukturen in der
Standardbibliothek ansehen, die du in deinem ordentlich organisierten Code
verwenden kannst.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allgemeine-kollektionen"><a class="header" href="#allgemeine-kollektionen">Allgemeine Kollektionen</a></h1>
<p>Die Standardbibliothek von Rust enthält eine Reihe sehr nützlicher
Datenstrukturen, die <em>Kollektionen</em> (collections) genannt werden. Die meisten
anderen Datentypen repräsentieren einen bestimmten Wert, aber Kollektionen
können mehrere Werte enthalten. Im Gegensatz zu den eingebauten Array- und
Tupel-Typen werden die Daten, auf die diese Kollektionen zeigen, im dynamischen
Speicher abgelegt. Somit muss die Datenmenge zum Kompilierzeitpunkt nicht
bekannt sein und kann während der Programmausführung wachsen oder schrumpfen.
Jede Kollektionsart hat unterschiedliche Fähigkeiten und Kosten, und die
Auswahl einer für deine aktuelle Situation geeigneten Kollektion ist eine
Fähigkeit, die du im Laufe der Zeit entwickeln wirst. In diesem Kapitel
besprechen wir drei Kollektionen, die sehr häufig in Rust-Programmen verwendet
werden:</p>
<ul>
<li>Ein <em>Vektor</em> erlaubt es dir, eine variable Anzahl von Werten nebeneinander zu
speichern.</li>
<li>Eine <em>Zeichenkette</em> ist eine Kollektion von Zeichen. Wir haben den Typ
<code>String</code> bereits kennengelernt, aber in diesem Kapitel werden wir ausführlich
darauf eingehen.</li>
<li>Eine <em>Hashtabelle</em> (hash map) erlaubt es dir, einen Wert mit einem
bestimmten Schlüssel zu assoziieren. Es ist eine spezielle Implementierung
der allgemeineren Datenstruktur, die <em>assoziatives Datenfeld</em> (map) genannt
wird.</li>
</ul>
<p>Informationen über weitere Kollektionsarten, die von der Standardbibliothek
bereitgestellt werden, findest du in <a href="https://doc.rust-lang.org/std/collections/index.html">der Dokumentation</a>.</p>
<p>Wir werden erörtern, wie Vektoren, Zeichenketten und Hashtabellen erstellt und
aktualisiert werden und was jede einzelne besonders macht.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="wertlisten-in-vektoren-ablegen"><a class="header" href="#wertlisten-in-vektoren-ablegen">Wertlisten in Vektoren ablegen</a></h2>
<p>Der erste Kollektionstyp, den wir betrachten werden, ist <code>Vec&lt;T&gt;</code>, auch bekannt
als <em>Vektor</em>. Vektoren ermöglichen es dir, mehr als einen Wert in einer
einzigen Datenstruktur zu speichern und alle Werte nebeneinander im Speicher
abzulegen. Vektoren können nur Werte desselben Typs speichern. Sie sind nützlich,
wenn du eine Liste von Einträgen hast, z.B. die Textzeilen einer Datei oder die
Preise der Artikel in einem Einkaufswagen.</p>
<h3 id="erstellen-eines-neuen-vektors"><a class="header" href="#erstellen-eines-neuen-vektors">Erstellen eines neuen Vektors</a></h3>
<p>Um einen neuen, leeren Vektor zu erstellen, rufen wir die Funktion <code>Vec::new</code>
auf, wie in Codeblock 8-1 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-1: Erstellen eines neuen, leeren Vektors zur
Aufnahme von Werten des Typs <code>i32</code></span></p>
<p>Beachte, dass wir hier eine Typ-Annotation hinzugefügt haben. Da wir keine
Werte in diesen Vektor einfügen, weiß Rust nicht, welche Art von Elementen wir
zu speichern beabsichtigen. Dies ist ein wichtiger Punkt. Vektoren werden mit
Hilfe generischer Typen implementiert; wie du eigene generische Typen verwenden
kannst, wird in Kapitel 10 behandelt. Für den Moment sollst du wissen, dass der
von der Standardbibliothek bereitgestellte Typ <code>Vec&lt;T&gt;</code> jeden Typ enthalten
kann. Wenn wir einen Vektor zu einem bestimmten Typ erstellen, wird der Typ
in spitzen Klammern angegeben. In Codeblock 8-1 haben wir Rust gesagt, dass der
Vektor <code>Vec&lt;T&gt;</code> in <code>v</code> Elemente des Typs <code>i32</code> enthalten wird.</p>
<p>Meistens wird man ein <code>Vec&lt;T&gt;</code> mit Anfangswerten erstellen und Rust wird den
Typ des Wertes, den man speichern will, ableiten, sodass man diese
Typ-Annotation nur selten benötigt. Rust bietet praktischerweise das Makro
<code>vec!</code>, das einen neuen Vektor erzeugt, der die von dir angegebenen Werte
enthält. Codeblock 8-2 erzeugt einen neuen <code>Vec&lt;i32&gt;</code>, der die Werte <code>1</code>, <code>2</code>
und <code>3</code> enthält. Als Integer-Typ wird <code>i32</code> verwendet, weil das der
Standard-Integer-Typ ist, wie wir im Abschnitt <a href="ch03-02-data-types.html">„Datentypen“</a> in
Kapitel 3 besprochen haben.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-2: Erstellen eines neuen Vektors mit
Werten</span></p>
<p>Da wir initiale <code>i32</code>-Werte angegeben haben, kann Rust daraus schließen, dass
<code>v</code> den Typ <code>Vec&lt;i32&gt;</code> hat, und die Typ-Annotation ist nicht notwendig. Als
Nächstes werden wir uns ansehen, wie man einen Vektor modifiziert.</p>
<h3 id="aktualisieren-eines-vektors"><a class="header" href="#aktualisieren-eines-vektors">Aktualisieren eines Vektors</a></h3>
<p>Um einen Vektor zu erstellen und ihm dann Elemente hinzuzufügen, können wir die
Methode <code>push</code> verwenden, wie in Codeblock 8-3 zu sehen ist.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-3: Verwenden der Methode <code>push</code> zum
Hinzufügen von Werten zu einem Vektor</span></p>
<p>Wie bei jeder Variablen müssen wir, wenn wir ihren Wert ändern wollen, sie mit
dem Schlüsselwort <code>mut</code> als veränderbar markieren, wie in Kapitel 3
besprochen. Die Zahlen, die wir darin platzieren, sind alle vom Typ <code>i32</code>, und
Rust leitet dies aus den Daten ab, sodass wir die Annotation <code>Vec&lt;i32&gt;</code> nicht
benötigen.</p>
<h3 id="elemente-aus-vektoren-lesen"><a class="header" href="#elemente-aus-vektoren-lesen">Elemente aus Vektoren lesen</a></h3>
<p>Es gibt zwei Möglichkeiten, einen in einem Vektor gespeicherten Wert zu
referenzieren. In den Beispielen haben wir zur besseren Lesbarkeit die
Werttypen, die von den Funktionen zurückgegeben werden, mit angegeben.</p>
<p>Codeblock 8-4 zeigt beide Zugriffsmethoden auf einen Wert in einem Vektor,
mittels Indexierungssyntax und der Methode <code>get</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
println!("Das dritte Element ist {third}");

let third: Option&lt;&amp;i32&gt; = v.get(2);
match third {
    Some(third) =&gt; println!("Das dritte Element ist {third}"),
    None =&gt; println!("Es gibt kein drittes Element."),
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-4: Verwenden der Indexierungssyntax und der
Methode <code>get</code> für den Zugriff auf ein Element in einem Vektor</span></p>
<p>Beachte hier einige Details. Wir verwenden den Indexwert <code>2</code>, um das dritte
Element zu erhalten, da Vektoren mit Zahlen beginnend bei null indiziert
werden. Mit <code>&amp;</code> und <code>[]</code> erhalten wir eine Referenz auf das Element mit dem
Indexwert. Wenn wir die Methode <code>get</code> mit dem Index als Argument verwenden,
erhalten wir eine <code>Option&lt;&amp;T&gt;</code>, die wir mit <code>match</code> verwenden können.</p>
<p>Rust bietet diese beide Möglichkeiten, um auf ein Element zu referenzieren. Du
kannst nun ausprobieren, wie sich das Programm verhält, wenn du einen Indexwert
außerhalb des Bereichs der vorhandenen Elemente zu verwendest. Als Beispiel
wollen wir sehen, was passiert, wenn wir bei einem Vektor mit fünf Elementen
versuchen, auf ein Element mit Index 100 zuzugreifen, wie in Codeblock 8-5 zu
sehen ist.</p>
<pre><pre class="playground"><code class="language-rust should_panic panics edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-5: Versuch, auf das Element mit Index 100 in
einem Vektor zuzugreifen, der fünf Elemente enthält</span></p>
<p>Wenn wir diesen Code ausführen, wird die erste <code>[]</code> Variante das Programm abbrechen
lassen, weil es auf ein nicht existierendes Element verweist. Diese Methode
wird vorzugsweise verwendet, wenn du dein Programm abstürzen lassen möchtest,
wenn versucht wird, auf ein Element hinter dem Ende des Vektors zuzugreifen.</p>
<p>Wenn der Methode <code>get</code> ein Index außerhalb des Vektors übergeben wird, gibt sie
<code>None</code> zurück, ohne abzubrechen. Du würdest diese Methode verwenden, wenn der
Zugriff auf ein Element außerhalb des Bereichs des Vektors unter normalen
Umständen gelegentlich vorkommt. Dein Code wird dann eine Logik haben, die mit
<code>Some(&amp;element)</code> und <code>None</code> umgehen kann, wie in Kapitel 6 besprochen. Der
Index könnte zum Beispiel von einer Person stammen, die eine Zahl eingibt. Wenn
sie versehentlich eine zu große Zahl eingibt und das Programm einen <code>None</code>-Wert
erhält, kannst du dem Benutzer mitteilen, wie viele Elemente sich aktuell im
Vektor befinden und ihm eine weitere Chance geben, einen gültigen Wert
einzugeben. Das wäre benutzerfreundlicher, als das Programm wegen eines
Tippfehlers abstürzen zu lassen!</p>
<p>Wenn das Programm über eine gültige Referenz verfügt, stellt der
Ausleihenprüfer mittels Eigentümerschafts- und Ausleihregeln (siehe Kapitel 4)
sicher, dass diese Referenz und alle anderen Referenzen auf den Inhalt des
Vektors gültig bleiben. Erinnere dich an die Regel, die besagt, dass du keine
veränderbaren und unveränderbaren Referenzen im gleichen Gültigkeitsbereich
haben kannst. Diese Regel trifft in Codeblock 8-6 zu, wo wir eine
unveränderbare Referenz auf das erste Element in einem Vektor halten und
versuchen, am Ende ein Element hinzuzufügen. Das wird nicht funktionieren, wenn
wir später in der Funktion versuchen auch auf dieses Element zuzugreifen.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);

println!("Das erste Element ist: {first}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-6: Versuch, ein Element zu einem Vektor
hinzuzufügen, während eine Referenz auf ein Element gehalten wird</span></p>
<p>Das Kompilieren dieses Codes führt zu folgendem Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!("Das erste Element ist: {first}");
  |                                      ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>Der Code in Codeblock 8-6 sieht so aus, als könnte er funktionieren: Warum
sollte sich eine Referenz auf das erste Element darum kümmern, was sich am
Ende des Vektors ändert? Dieser Fehler ist in der Funktionsweise von Vektoren
begründet: Weil Vektoren die Werte nebeneinander im Speicher ablegen, könnte
das Hinzufügen eines neuen Elements am Ende des Vektors die Allokation neuen
Speichers und das Kopieren der alten Elemente an die neue Stelle erfordern,
wenn nicht genügend Platz vorhanden ist, um alle Elemente nebeneinander an der
aktuellen Stelle des Vektors zu platzieren. In diesem Fall würde die Referenz
auf das erste Element auf einen freigegebenen Speicherplatz verweisen. Die
Ausleihregeln verhindern, dass Programme in diese Situation geraten.</p>
<blockquote>
<p>Anmerkung: Weitere Einzelheiten zu den Implementierungsdetails des Typs
<code>Vec&lt;T&gt;</code> findest du in <a href="https://doc.rust-lang.org/nomicon/vec.html">„Das Rustonomicon“</a>.</p>
</blockquote>
<h3 id="iterieren-über-die-werte-in-einem-vektor"><a class="header" href="#iterieren-über-die-werte-in-einem-vektor">Iterieren über die Werte in einem Vektor</a></h3>
<p>Um auf die Elemente eines Vektors der Reihe nach zuzugreifen, können wir über
alle Elemente iterieren, anstatt Indizes zu verwenden, um auf jeweils ein
Element zur gleichen Zeit zuzugreifen. Codeblock 8-7 zeigt, wie man eine
<code>for</code>-Schleife verwendet, um unveränderbare Referenzen auf die Elemente eines
Vektors von <code>i32</code>-Werten zu erhalten und diese auszugeben.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![100, 32, 57];
for i in &amp;v {
    println!("{i}");
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-7: Ausgeben aller Elemente eines Vektors
durch Iterieren über die Elemente mittels <code>for</code>-Schleife</span></p>
<p>Wir können auch über veränderbare Referenzen der Elemente eines veränderbaren
Vektors iterieren, um Änderungen an allen Elementen vorzunehmen. Die
<code>for</code>-Schleife in Codeblock 8-8 addiert zu jedem Element <code>50</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-8: Iterieren über veränderbare Referenzen
der Elemente eines Vektors</span></p>
<p>Um den Wert, auf den sich die veränderbare Referenz bezieht, zu ändern, müssen
wir den Dereferenzierungsoperator (<code>*</code>) verwenden, um an den Wert in <code>i</code> zu
kommen, bevor wir den Operator <code>+=</code> verwenden können. Wir werden mehr über den
Dereferenzierungsoperator im Abschnitt <a href="ch15-02-deref.html#dem-zeiger-zum-wert-folgen">„Dem Zeiger zum Wert folgen“</a> in
Kapitel 15 sprechen.</p>
<p>Die Iteration über einen Vektor, ob unveränderbar oder veränderbar, ist
aufgrund der Regeln des Ausleihenprüfers sicher. Wenn wir versuchen würden,
Elemente in den <code>for</code>-Schleifenrümpfen in Codeblock 8-7 und Codeblock 8-8
einzufügen oder zu entfernen, würden wir einen Compilerfehler erhalten, ähnlich
dem, den wir mit dem Code in Codeblock 8-6 erhalten haben. Die Referenz auf den
Vektor, den die <code>for</code>-Schleife enthält, verhindert eine gleichzeitige Änderung
des gesamten Vektors.</p>
<h3 id="verwenden-einer-aufzählung-zum-speichern-mehrerer-typen"><a class="header" href="#verwenden-einer-aufzählung-zum-speichern-mehrerer-typen">Verwenden einer Aufzählung zum Speichern mehrerer Typen</a></h3>
<p>Vektoren können nur Werte desselben Typs speichern. Das kann unbequem sein; es
gibt definitiv Anwendungsfälle, in denen es notwendig ist, eine Liste von
Einträgen unterschiedlicher Typen zu speichern. Glücklicherweise werden die
Varianten einer Aufzählung unter dem gleichen Aufzählungstyp definiert. Wenn
wir also Elemente eines anderen Typs in einem Vektor speichern wollen, können
wir eine Aufzählung definieren und verwenden!</p>
<p>Angenommen, wir möchten Werte aus einer Zeile einer Tabellenkalkulationstabelle
erhalten, in der einige Spalten der Zeile ganze Zahlen, Fließkommazahlen und
Zeichenketten enthalten. Wir können eine Aufzählung definieren, deren Varianten
die verschiedenen Werttypen enthalten, und alle Aufzählungsvarianten werden als
derselbe Typ angesehen: Der Typ der Aufzählung. Dann können wir einen Vektor
erstellen, der diese Aufzählung und damit letztlich verschiedene Typen enthält.
Wir haben dies in Codeblock 8-9 demonstriert.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blau")),
    SpreadsheetCell::Float(10.12),
];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-9: Definieren eines <code>enum</code>, um Werte
verschiedener Typen in einem Vektor zu speichern</span></p>
<p>Rust muss wissen, welche Typen zur Kompilierzeit im Vektor enthalten sein
werden, damit es genau weiß, wie viel Speicherplatz im Haldenspeicher
benötigt wird, um alle Elemente zu speichern. Wir müssen auch eindeutig
festlegen, welche Typen in diesem Vektor zulässig sind. Wenn Rust einen Vektor
mit beliebigen Typen zuließe, bestünde die Möglichkeit, dass einer oder mehrere
Typen Fehler bei den an den Elementen des Vektors durchgeführten Operationen
verursachen würden. Das Verwenden einer Aufzählung zusammen mit einem
<code>match</code>-Ausdruck bedeutet, dass Rust zur Kompilierzeit sicherstellt, dass jeder
mögliche Fall behandelt wird, wie in Kapitel 6 besprochen.</p>
<p>Wenn du nicht weißt, welche Typen ein Programm zur Laufzeit in einem Vektor
speichern kann, funktioniert der Aufzählungsansatz nicht. Stattdessen kannst du
ein Merkmalsobjekt (trait object) verwenden, das wir in Kapitel 17 behandeln
werden.</p>
<p>Nachdem wir nun einige der gängigsten Methoden zur Verwendung von Vektoren
besprochen haben, solltest du dir unbedingt die <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">API-Dokumentation</a> zu
den vielen nützlichen Methoden ansehen, die die Standardbibliothek für <code>Vec&lt;T&gt;</code>
mitbringt. Zum Beispiel gibt es zusätzlich zu <code>push</code> die Methode <code>pop</code>, die das
letzte Element entfernt und zurückgibt.</p>
<h3 id="beim-aufräumen-eines-vektors-werden-seine-elemente-aufgeräumt"><a class="header" href="#beim-aufräumen-eines-vektors-werden-seine-elemente-aufgeräumt">Beim Aufräumen eines Vektors werden seine Elemente aufgeräumt</a></h3>
<p>Wie bei jeder anderen Struktur wird ein Vektor freigegeben, wenn er den
Gültigkeitsbereich verlässt, wie in Codeblock 8-10 kommentiert wird.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let v = vec![1, 2, 3, 4];

    // mache etwas mit v
} // &lt;- v verlässt den Gültigkeitsbereich und wird hier aufgeräumt
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-10: Zeigt, wo der Vektor und seine Elemente
aufgeräumt werden</span></p>
<p>Wenn der Vektor aufgeräumt wird, wird auch sein gesamter Inhalt aufgeräumt,
d.h. die ganzen Zahlen, die er enthält, werden beseitigt. Der Ausleihenprüfer
stellt sicher, dass alle Referenzen auf den Inhalt eines Vektors nur verwendet
werden, solange der Vektor selbst gültig ist.</p>
<p>Lass uns zum nächsten Kollektionstyp übergehen: <code>String</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="utf-8-kodierten-text-in-zeichenketten-strings-ablegen"><a class="header" href="#utf-8-kodierten-text-in-zeichenketten-strings-ablegen">UTF-8-kodierten Text in Zeichenketten (strings) ablegen</a></h2>
<p>Wir haben in Kapitel 4 über Zeichenketten (strings) gesprochen, aber wir werden
uns jetzt eingehender damit befassen. Neue Rust-Entwickler haben gewöhnlich aus
einer Kombination von drei Gründen Probleme mit Zeichenketten: Rusts Neigung,
mögliche Fehler aufzudecken, Zeichenketten als eine kompliziertere
Datenstruktur, als viele Programmierer ihnen zugestehen, und UTF-8. Diese
Faktoren kombinieren sich in einer Weise, die schwierig erscheinen kann, wenn
man von anderen Programmiersprachen kommt.</p>
<p>Wir besprechen Zeichenketten im Kontext von Kollektionen, da Zeichenketten als
Byte-Kollektion implementiert sind, sowie einige Methoden, die nützliche
Funktionalitäten bieten, wenn diese Bytes als Text interpretiert werden. In
diesem Abschnitt werden wir über <code>String</code>-Operationen sprechen, die jeder
Kollektionstyp hat, wie das Erstellen, Aktualisieren und Lesen. Wir werden auch
die Art und Weise besprechen, in der sich <code>String</code> von den anderen Kollektionen
unterscheidet, nämlich warum die Indexierung bei einem <code>String</code> kompliziert
ist, weil Menschen und Computer <code>String</code>-Daten unterschiedlich interpretieren.</p>
<h3 id="was-ist-eine-zeichenkette"><a class="header" href="#was-ist-eine-zeichenkette">Was ist eine Zeichenkette?</a></h3>
<p>Zuerst werden wir definieren, was wir mit dem Begriff <em>Zeichenkette</em> (string)
meinen. Rust hat nur einen einzigen Zeichenkettentyp in der Kernsprache,
nämlich den Zeichenkettenanteilstyp <code>str</code>, der üblicherweise in seiner
Ausleihenform <code>&amp;str</code> zu sehen ist. In Kapitel 4 sprachen wir über
<em>Zeichenkettenanteilstypen</em> (string slices), die Referenzen auf einige
UTF-8-kodierte Zeichenkettendaten sind, die anderswo gespeichert sind.
Zeichenkettenliterale werden beispielsweise in der Binärdatei des Programms
gespeichert und sind daher Zeichenkettenanteilstypen.</p>
<p>Der Typ <code>String</code>, der von Rusts Standardbibliothek zur Verfügung gestellt wird
und nicht in die Kernsprache kodiert ist, ist ein größenänderbarer,
veränderbarer, aneigenbarer, UTF-8-kodierter Zeichenkettentyp. Wenn
Rust-Entwickler von Zeichenketten in Rust sprechen, meinen sie normalerweise
den Typ <code>String</code> sowie den Zeichenkettenanteilstyp <code>&amp;str</code>, nicht nur einen
dieser Typen. Obwohl es in diesem Abschnitt weitgehend um <code>String</code> geht, werden
beide Typen in Rusts Standardbibliothek stark verwendet, und sowohl <code>String</code>
als auch Zeichenkettenanteilstypen sind UTF-8-kodiert.</p>
<h3 id="erstellen-einer-neuen-zeichenkette"><a class="header" href="#erstellen-einer-neuen-zeichenkette">Erstellen einer neuen Zeichenkette</a></h3>
<p>Viele der gleichen Operationen, die mit <code>Vec&lt;T&gt;</code> verfügbar sind, sind auch mit
<code>String</code> verfügbar, weil <code>String</code> eigentlich als Hülle um einen Vektor von
Bytes mit einigen zusätzlichen Garantien, Einschränkungen und Fähigkeiten
implementiert ist. Ein Beispiel für eine Funktion, die auf die gleiche Weise
mit <code>Vec&lt;T&gt;</code> und <code>String</code> arbeitet, ist die Funktion <code>new</code> zum Erstellen einer
Instanz, die in Codeblock 8-11 gezeigt wird.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-11: Erstellen einer neuen, leeren
Zeichenkette</span></p>
<p>Diese Zeile erzeugt eine neue, leere Zeichenkette namens <code>s</code>, in die wir dann
Daten aufnehmen können. Oft werden wir einige initiale Daten haben, mit denen
wir die Zeichenkette füllen wollen. Dazu verwenden wir die Methode <code>to_string</code>,
die für jeden Typ verfügbar ist, der das Merkmal <code>Display</code> implementiert, wie
es bei Zeichenkettenliteralen der Fall ist. Codeblock 8-12 zeigt zwei
Beispiele.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = "initialer Inhalt";

let s = data.to_string();

// die Methode funktioniert auch direkt für ein Literal:
let s = "initialer Inhalt".to_string();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-12: Verwenden der Methode <code>to_string</code> zum
Erzeugen eines <code>String</code> aus einem Zeichenkettenliteral</span></p>
<p>Dieser Code erzeugt eine Zeichenkette, die <code>initialer Inhalt</code> enthält.</p>
<p>Wir können auch die Funktion <code>String::from</code> verwenden, um einen <code>String</code> aus
einem Zeichenkettenliteral zu erzeugen. Der Code in Codeblock 8-13 ist
äquivalent zum Code in Codeblock 8-12, der <code>to_string</code> verwendet.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("initialer Inhalt");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-13: Verwenden der Funktion <code>String::from</code> zum
Erzeugen eines <code>String</code> aus einem Zeichenkettenliteral</span></p>
<p>Da Zeichenketten für so viele Dinge verwendet werden, können wir viele
verschiedene generische Programmierschnittstellen (APIs) für Zeichenketten
verwenden, was uns viele Möglichkeiten bietet. Einige von ihnen können
überflüssig erscheinen, aber sie alle haben ihren Platz! In diesem Fall machen
<code>String::from</code> und <code>to_string</code> dasselbe, also ist die Wahl eine Frage des
Stils und der Lesbarkeit.</p>
<p>Denke daran, dass Zeichenketten UTF-8-kodiert sind, sodass sie alle
ordnungsgemäß kodierten Daten aufnehmen können, wie in Codeblock 8-14 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hallo");
let hello = String::from("Hello");
let hello = String::from("שָׁלוֹם");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-14: Speichern von Begrüßungstexten in
verschiedenen Sprachen in Zeichenketten</span></p>
<p>All dies sind gültige <code>String</code>-Werte.</p>
<h3 id="aktualisieren-einer-zeichenkette"><a class="header" href="#aktualisieren-einer-zeichenkette">Aktualisieren einer Zeichenkette</a></h3>
<p>Ein <code>String</code> kann an Größe zunehmen und sein Inhalt kann sich ändern, genau wie
der Inhalt eines <code>Vec&lt;T&gt;</code>, wenn du mehr Daten hineinschiebst. Darüber hinaus
kannst du bequem den Operator <code>+</code> oder das Makro <code>format!</code> verwenden, um
<code>String</code>-Werte aneinanderzuhängen.</p>
<h4 id="anhängen-an-eine-zeichenkette-mit-push_str-und-push"><a class="header" href="#anhängen-an-eine-zeichenkette-mit-push_str-und-push">Anhängen an eine Zeichenkette mit <code>push_str</code> und <code>push</code></a></h4>
<p>Wir können einen <code>String</code> wachsen lassen, indem wir die Methode <code>push_str</code>
verwenden, um einen Zeichenkettenanteilstyp anzuhängen, wie in Codeblock 8-15
zu sehen ist.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from("foo");
s.push_str("bar");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-15: Anhängen eines Zeichenkettenanteilstyps
an einen <code>String</code> mit der Methode <code>push_str</code></span></p>
<p>Nach diesen beiden Zeilen enthält <code>s</code> den Wert <code>foobar</code>. Die Methode <code>push_str</code>
nimmt einen Zeichenkettenanteilstyp, weil wir nicht unbedingt die
Eigentümerschaft des Parameters übernehmen wollen. Zum Beispiel wollen wir im
Code in Codeblock 8-16 in der Lage sein, <code>s2</code> zu verwenden, nachdem wir seinen
Inhalt an <code>s1</code> angehängt haben.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 ist {s2}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-16: Verwenden eines Zeichenkettenanteilstyps
nach dem Anhängen seines Inhalts an eine Zeichenkette</span></p>
<p>Wenn die Methode <code>push_str</code> die Eigentümerschaft von <code>s2</code> übernehmen würde,
könnten wir ihren Wert nicht in der letzten Zeile ausgeben. Dieser Code
funktioniert jedoch wie erwartet!</p>
<p>Die Methode <code>push</code> nimmt ein einzelnes Zeichen als Parameter und fügt es dem
<code>String</code> hinzu. Codeblock 8-17 fügt den Buchstaben <code>l</code> mit der Methode <code>push</code>
zu einem <code>String</code> hinzu.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from("lo");
s.push('l');
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-17: Hinzufügen eines Zeichens zu einem
<code>String</code>-Wert mit <code>push</code></span></p>
<p>Als Ergebnis wird <code>s</code> den Wert <code>lol</code> enthalten.</p>
<h4 id="aneinanderhängen-mit-dem-operator--und-dem-makro-format"><a class="header" href="#aneinanderhängen-mit-dem-operator--und-dem-makro-format">Aneinanderhängen mit dem Operator <code>+</code> und dem Makro <code>format!</code></a></h4>
<p>Häufig möchtest du zwei vorhandene Zeichenketten kombinieren. Eine Möglichkeit
das zu tun ist, den Operator <code>+</code> zu verwenden, wie in Codeblock 8-18 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("Hallo ");
let s2 = String::from("Welt!");
let s3 = s1 + &amp;s2; // Beachte, s1 wurde hierher verschoben und
                   // kann nicht mehr verwendet werden
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-18: Verwenden des Operators <code>+</code>, um zwei
Zeichenketten zu einer neuen zu kombinieren</span></p>
<p>Die Zeichenkette <code>s3</code> wird <code>Hallo Welt!</code> enthalten. Der Grund, warum <code>s1</code> nach
der Addition nicht mehr gültig ist und warum wir eine Referenz auf <code>s2</code>
verwendet haben, hat mit der Signatur der Methode zu tun, die aufgerufen wird,
wenn wir den Operator <code>+</code> verwenden. Der Operator <code>+</code> benutzt die Methode
<code>add</code>, deren Signatur ungefähr so aussieht:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>In der Standardbibliothek wird <code>add</code> mittels generischer Datentypen und
assoziierter Typen definiert. Hier haben wir konkrete Typen ersetzt, was
geschieht, wenn wir diese Methode mit <code>String</code>-Werten aufrufen. Wir werden
generische Datentypen in Kapitel 10 besprechen. Diese Signatur gibt uns den
entscheidenden Hinweis, um die kniffligen Stellen des Operators <code>+</code> zu
verstehen.</p>
<p>Erstens hat <code>s2</code> ein <code>&amp;</code>, was bedeutet, dass wir eine <em>Referenz</em> der zweiten
Zeichenkette an die erste Zeichenkette anhängen. Der Grund dafür ist der
Parameter <code>s</code> in der Funktion <code>add</code>: Wir können nur einen <code>&amp;str</code> zu einem
<code>String</code> hinzufügen; wir können nicht zwei <code>String</code>-Werte aneinanderhängen.
Aber warte – der Typ von <code>&amp;s2</code> ist <code>&amp;String</code>, nicht <code>&amp;str</code>, wie im
zweiten Parameter von <code>add</code> spezifiziert. Warum kompiliert also Codeblock 8-18?</p>
<p>Der Grund, warum wir <code>&amp;s2</code> im Aufruf von <code>add</code> verwenden können, ist, dass der
Compiler das Argument <code>&amp;String</code> in einen <code>&amp;str</code> umwandeln (coerce) kann.
Wenn wir die Methode <code>add</code> aufrufen, benutzt Rust eine <em>automatische
Umwandlung</em> (deref coercion), die hier <code>&amp;s2</code> in <code>&amp;s2[...]</code> umwandelt. Auf die
automatische Umwandlung werden wir in Kapitel 15 tiefer eingehen. Da <code>add</code>
nicht die Eigentümerschaft des Parameters <code>s</code> übernimmt, ist <code>s2</code> auch nach
dieser Operation immer noch ein gültiger <code>String</code>.</p>
<p>Zweitens können wir in der Signatur sehen, dass <code>add</code> die Eigentümerschaft von
<code>self</code> übernimmt, weil <code>self</code> <em>kein</em> <code>&amp;</code> hat. Das bedeutet, dass <code>s1</code> in
Codeblock 8-18 in den Aufruf von <code>add</code> verschoben wird und danach nicht mehr
gültig ist. Obwohl also <code>let s3 = s1 + &amp;s2;</code> so aussieht, als ob beide
Zeichenketten kopiert und eine neue erzeugt wird, übernimmt diese Anweisung
tatsächlich die Eigentümerschaft von <code>s1</code>, hängt eine Kopie des Inhalts von
<code>s2</code> an und gibt dann die Eigentümerschaft des Ergebnisses zurück. In anderen
Worten sieht es so aus, als würde es viele Kopien erstellen, das ist aber nicht
so; die Implementierung ist effizienter als Kopieren.</p>
<p>Wenn wir mehrere Zeichenketten aneinanderhängen wollen, wird das Verhalten des
Operators <code>+</code> unhandlich:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>An diesem Punkt wird <code>s</code> den Wert <code>tic-tac-toe</code> haben. Bei all den Zeichen <code>+</code>
und <code>"</code> ist es schwer zu erkennen, was vor sich geht. Um Zeichenketten auf
kompliziertere Weise zu kombinieren, können wir stattdessen das Makro <code>format!</code>
verwenden:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
<span class="boring">}</span></code></pre></pre>
<p>Auch bei diesem Code wird <code>s</code> den Wert <code>tic-tac-toe</code> haben. Das Makro <code>format!</code>
funktioniert wie <code>println!</code>, aber anstatt das Ergebnis auf den Bildschirm
auszugeben, gibt es einen <code>String</code> mit dem Inhalt zurück. Die Codevariante mit
<code>format!</code> ist viel leichter lesbar, und der durch das Makro
<code>format!</code> erzeugte Code verwendet Referenzen, sodass dieser Aufruf keine
Eigentümerschaft seiner Parameter übernimmt.</p>
<h3 id="indexierung-von-zeichenketten"><a class="header" href="#indexierung-von-zeichenketten">Indexierung von Zeichenketten</a></h3>
<p>In vielen anderen Programmiersprachen ist das Zugreifen auf einzelne Zeichen in
einer Zeichenkette mittels Index eine gültige und gängige Operation. Wenn du
jedoch in Rust versuchst, mittels Indexierungssyntax auf Teile einer
Zeichenkette zuzugreifen, wirst du einen Fehler erhalten. Betrachte den
ungültigen Code in Codeblock 8-19.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("Hallo");
let h = s1[0];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-19: Versuch, die Indexierungssyntax bei einer
Zeichenkette zu verwenden</span></p>
<p>Dieser Code führt zu folgendem Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`
  = help: the following other types implement trait `Index&lt;Idx&gt;`:
            &lt;String as Index&lt;RangeFull&gt;&gt;
            &lt;String as Index&lt;std::ops::Range&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeFrom&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeTo&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeInclusive&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeToInclusive&lt;usize&gt;&gt;&gt;

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>Die Fehlermeldung und der Hinweis erzählen die Geschichte: Zeichenketten in
Rust unterstützen keine Indexierung. Aber warum nicht? Um diese Frage zu
beantworten, müssen wir uns ansehen, wie Rust Zeichenketten im Speicher ablegt.</p>
<h4 id="interne-darstellung"><a class="header" href="#interne-darstellung">Interne Darstellung</a></h4>
<p>Ein <code>String</code> ist eine Hülle um einen <code>Vec&lt;u8&gt;</code>. Sehen wir uns einige unserer
korrekt kodierten UTF-8-Beispielzeichenketten aus Codeblock 8-14 an. Zuerst
diese:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p>In diesem Fall wird <code>hello.len()</code> gleich 4 sein, was bedeutet, dass der Vektor,
der die Zeichenkette „Hola“ speichert, 4 Bytes lang ist. Jeder dieser
Buchstaben benötigt 1 Byte in UTF-8-Kodierung. Die folgende Zeile mag dich
jedoch überraschen. (Beachte, dass diese Zeichenkette mit dem kyrillischen
Großbuchstaben „Ze“ beginnt, nicht mit der Zahl 3.)</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from("Здравствуйте");
<span class="boring">}</span></code></pre></pre>
<p>Auf die Frage, wie lang die Zeichenkette ist, könnte man sagen: 12. Die Antwort
von Rust lautet jedoch 24: Das ist die Anzahl der Bytes, die benötigt wird, um
„Здравствуйте“ in UTF-8 zu kodieren, da jeder Unicode-Skalarwert in dieser
Zeichenkette 2 Bytes Speicherplatz benötigt. Daher wird ein Index auf die Bytes
der Zeichenkette nicht immer mit einem gültigen Unicode-Skalarwert korrelieren.
Um das zu erläutern, betrachte diesen ungültigen Rust-Code:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Здравствуйте";
let answer = &amp;hello[0];
<span class="boring">}</span></code></pre></pre>
<p>Du weißt bereits, dass <code>answer</code> nicht <code>З</code>, der erste Buchstabe, sein wird. In
der UTF-8-Kodierung von <code>З</code> ist das erste Byte <code>208</code> und das zweite <code>151</code>,
sodass <code>answer</code> eigentlich <code>208</code> sein müsste, aber <code>208</code> ist kein eigenständig
gültiges Zeichen. Die Rückgabe von <code>208</code> ist wahrscheinlich nicht das, was ein
Nutzer wünschen würde, wenn er nach dem ersten Buchstaben dieser Zeichenkette
fragte; das sind jedoch die einzigen Daten, die Rust beim Byte-Index 0 hat.
Nutzer wollen im Allgemeinen nicht, dass der Byte-Wert zurückgegeben wird,
selbst wenn die Zeichenkette nur lateinische Buchstaben enthält: Wenn
<code>&amp;"hi"[0]</code> gültiger Code wäre, der den Byte-Wert zurückgibt, würde er <code>104</code>
zurückgeben, nicht <code>h</code>.</p>
<p>Um zu vermeiden, dass ein unerwarteter Wert zurückgegeben wird und dadurch
Fehler entstehen, die möglicherweise nicht sofort entdeckt werden, kompiliert
Rust diesen Code überhaupt nicht und verhindert so Missverständnisse in einem
frühen Stadium des Entwicklungsprozesses.</p>
<h4 id="bytes-skalare-werte-und-graphemgruppen-grapheme-clusters-oje"><a class="header" href="#bytes-skalare-werte-und-graphemgruppen-grapheme-clusters-oje">Bytes, skalare Werte und Graphemgruppen (grapheme clusters)! Oje!</a></h4>
<p>Ein weiterer Punkt bei UTF-8 ist, dass es eigentlich drei relevante
Möglichkeiten gibt, Zeichenketten aus Rusts Perspektive zu betrachten: Als
Bytes, als skalare Werte und als Graphemgruppen (das, was wir am ehesten als
<em>Buchstaben</em> bezeichnen würden).</p>
<p>Wenn wir uns das in der Devanagari-Schrift geschriebene Hindi-Wort „नमस्ते“
(<a href="https://de.wikipedia.org/wiki/Namaste"><em>Namaste</em></a>) ansehen, wird es als ein
Vektor von <code>u8</code>-Werten gespeichert, der wie folgt aussieht:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Das sind 18 Bytes, so wie ein Computer diese Daten letztendlich speichert. Wenn
wir sie als Unicode-Skalarwerte betrachten, also als das, was der Typ <code>char</code> in
Rust ist, sehen diese Bytes wie folgt aus:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Es gibt hier sechs <code>char</code>-Werte, aber der vierte und der sechste sind keine
Buchstaben: Sie sind diakritische Zeichen, die für sich allein genommen keinen
Sinn ergeben. Wenn wir sie schließlich als Graphemgruppen betrachten, erhalten
wir das, was eine Person die vier Buchstaben nennen würde, aus denen das
Hindi-Wort besteht:</p>
<pre><code class="language-text">["न", "म", "स्", "ते"]
</code></pre>
<p>Rust bietet verschiedene Möglichkeiten zur Interpretation von rohen
Zeichenkettendaten, die von Computern gespeichert werden, sodass jedes Programm
die Interpretation wählen kann, die es benötigt, unabhängig davon, in welcher
menschlichen Sprache die Daten vorliegen.</p>
<p>Ein letzter Grund, warum Rust uns nicht erlaubt, eine Zeichenkette zu
indexieren, um ein Zeichen zu erhalten, ist, dass von Indexoperationen erwartet
wird, dass sie immer in konstanter Zeit (O(1)) erfolgen. Es ist jedoch nicht
möglich, diese Zeitgarantie bei einem <code>String</code> einzuhalten, da Rust den Inhalt
von Anfang an bis zum Index durchgehen müsste, um festzustellen, wie viele
gültige Zeichen es gibt.</p>
<h3 id="anteilige-zeichenketten"><a class="header" href="#anteilige-zeichenketten">Anteilige Zeichenketten</a></h3>
<p>Die Indexierung einer Zeichenkette ist oft eine schlechte Idee, weil nicht klar
ist, was der Rückgabetyp der Zeichenketten-Indexoperation sein soll: Ein
Byte-Wert, ein Zeichen, eine Graphemgruppe oder ein Zeichenkettenanteilstyp.
Wenn du wirklich Indizes verwenden musst, um Zeichenkettenanteilstypen zu
erstellen, bittet Rust dich daher, genauer zu sein.</p>
<p>Anstatt <code>[]</code> mit einer einzelnen Zahl zu indizieren, kannst du <code>[]</code> mit einem
Bereich verwenden, um ein Zeichenkettenanteilstyp zu erstellen, der bestimmte
Bytes enthält:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Здравствуйте";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>Hier wird <code>s</code> ein <code>&amp;str</code> sein, das die ersten vier Bytes der Zeichenkette
enthält. Vorhin haben wir bereits erwähnt, dass jedes dieser Zeichen zwei Bytes
lang ist, was bedeutet, dass <code>s</code> gleich <code>Зд</code> ist.</p>
<p>Wenn wir versuchen würden, nur einen Teil der Bytes eines Zeichens mit etwas
wie <code>&amp;hello[0..1]</code> zu zerschneiden, würde Rust das Programm zur Laufzeit
abbrechen, genauso als wenn mit einem ungültigen Index auf einen Vektor
zugegriffen würde:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Bei der Verwendung von Bereichen zum Erstellen von Zeichenkettenanteilstypen
ist Vorsicht geboten, da dies zum Absturz deines Programms führen kann.</p>
<h3 id="methoden-zum-iterieren-über-zeichenketten"><a class="header" href="#methoden-zum-iterieren-über-zeichenketten">Methoden zum Iterieren über Zeichenketten</a></h3>
<p>Der beste Weg, um mit Teilen von Zeichenketten zu arbeiten, besteht darin,
explizit anzugeben, ob du Zeichen oder Bytes benötigst. Für einzelne
Unicode-Skalarwerte ist die Methode <code>chars</code> zu verwenden. Der Aufruf von
<code>chars</code> auf „Зд“ trennt zwei Werte vom Typ <code>char</code> heraus und gibt sie
zurück, und du kannst über das Ergebnis iterieren, um auf jedes Element
zuzugreifen:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "Зд".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code wird folgendes ausgeben:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>Die Methode <code>bytes</code> gibt jedes rohe Byte zurück, das für deinen
Verwendungszweck benötigt wird:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "Зд".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code gibt die vier Bytes aus, aus denen diese Zeichenkette besteht:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>Aber denke daran, dass gültige Unicode-Skalarwerte aus mehr als ein Byte
bestehen können.</p>
<p>Die Ermittlung von Graphemgruppen aus Zeichenketten wie bei der
Devanagari-Schrift ist komplex, sodass diese Funktionalität nicht von der
Standardbibliothek bereitgestellt wird. Kisten (crates) sind unter
<a href="https://crates.io/">crates.io</a> verfügbar, falls du diese Funktionalität
benötigst.</p>
<h3 id="zeichenketten-sind-nicht-so-einfach"><a class="header" href="#zeichenketten-sind-nicht-so-einfach">Zeichenketten sind nicht so einfach</a></h3>
<p>Zusammenfassend kann man sagen, dass Zeichenketten kompliziert sind.
Verschiedene Programmiersprachen treffen unterschiedliche Entscheidungen
darüber, wie diese Komplexität dem Programmierer angezeigt wird. Rust hat sich
dafür entschieden, den korrekten Umgang mit Zeichenkettendaten zum
Standardverhalten für alle Rust-Programme zu machen, was bedeutet, dass
Programmierer sich im Vorfeld mehr Gedanken über den Umgang mit UTF-8-Daten
machen müssen. Dieser Zielkonflikt macht die Komplexität von Zeichenketten
größer als in anderen Programmiersprachen, aber er verhindert, dass du später
in deinem Entwicklungslebenszyklus mit Fehlern umgehen musst, wenn
Nicht-ASCII-Zeichen vorkommen.</p>
<p>Die gute Nachricht ist, dass die Standardbibliothek eine Vielzahl von
Funktionen bietet, die auf den Typen <code>String</code> und <code>&amp;str</code> aufbauen, um diese
komplexen Situationen korrekt zu behandeln. In der Dokumentation findest du
nützliche Methoden wie <code>contains</code> zum Suchen in einer Zeichenkette und
<code>replace</code> zum Ersetzen von Teilen einer Zeichenkette durch eine andere
Zeichenkette.</p>
<p>Lass uns zu etwas weniger Kompliziertem übergehen: Hashtabellen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="schlüssel-mit-zugehörigen-werten-in-hashtabellen-ablegen"><a class="header" href="#schlüssel-mit-zugehörigen-werten-in-hashtabellen-ablegen">Schlüssel mit zugehörigen Werten in Hashtabellen ablegen</a></h2>
<p>Die letzte unserer allgemeinen Kollektionen ist die <em>Hashtabelle</em> (hash map).
Der Typ <code>HashMap&lt;K, V&gt;</code> speichert eine Zuordnung von Schlüsseln vom Typ <code>K</code> zu
Werten vom Typ <code>V</code> mittels einer <em>Hashfunktion</em> (hash function), die bestimmt,
wie er diese Schlüssel und Werte im Speicher ablegt. Viele Programmiersprachen
unterstützen diese Art Datenstruktur, aber sie verwenden oft einen anderen
Namen wie <em>Hash</em>, <em>Abbildung</em> (map), <em>Objekt</em>, <em>Hashtabelle</em> (hash table),
<em>Wörterbuch</em> (dictionary) oder <em>assoziatives Array</em> (associative array), um nur
einige zu nennen.</p>
<p>Hashtabellen sind nützlich, wenn du Daten nicht wie bei Vektoren über einen
Index nachschlagen willst, sondern über einen Schlüssel, der ein beliebiger Typ
sein kann. Beispielsweise könntest du in einem Spiel den Spielstand jedes Teams
in einer Hashtabelle vermerken, in der die Schlüssel den Teamnamen und die
Werte den Spielstand des jeweiligen Teams darstellen. Wenn du den Namen eines
Teams angibst, kannst du seine Punktzahl abrufen.</p>
<p>In diesem Abschnitt gehen wir die grundlegende Programmierschnittstelle (API)
von Hashtabellen durch, aber viele weitere Leckerbissen verbergen sich in den
Funktionen, die in der Standardbibliothek für <code>HashMap&lt;K, V&gt;</code> definiert sind.
Weitere Informationen findest du wie immer in der
Standardbibliotheksdokumentation.</p>
<h3 id="erstellen-einer-neuen-hashtabelle"><a class="header" href="#erstellen-einer-neuen-hashtabelle">Erstellen einer neuen Hashtabelle</a></h3>
<p>Ein Weg um eine leere Hashtabelle zu erzeugen ist mit <code>new</code> und um Elemente
hinzuzufügen mit <code>insert</code>. In Codeblock 8-20 verfolgen wir die Ergebnisse
zweier Mannschaften mit den Namen Blau und Gelb. Das Team Blau startet mit 10
Punkten, das Team Gelb mit 50 Punkten.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blau"), 10);
scores.insert(String::from("Gelb"), 50);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-20: Erstellen einer neuen Hashtabelle und
Einfügen einiger Schlüssel und Werte</span></p>
<p>Beachte, dass wir zuerst mit <code>use</code> die <code>HashMap</code> aus dem Kollektionsteil der
Standardbibliothek einbinden müssen. Von unseren drei allgemeinen Kollektionen
wird diese am seltensten verwendet, sodass sie nicht zu den Funktionalitäten
gehört, die automatisch in den Gültigkeitsbereich aufgenommen werden.
Hashtabellen werden auch weniger von der Standardbibliothek unterstützt; es
gibt zum Beispiel kein eingebautes Makro, um sie zu erzeugen.</p>
<p>Genau wie Vektoren speichern Hashtabellen ihre Daten im Haldenspeicher.
Obige <code>HashMap</code> hat Schlüssel vom Typ <code>String</code> und Werte vom Typ <code>i32</code>.
Hashtabellen sind homogen wie Vektoren: Alle Schlüssel müssen denselben Typ
haben und alle Werte müssen denselben Typ haben.</p>
<h3 id="zugreifen-auf-werte-in-einer-hashtabelle"><a class="header" href="#zugreifen-auf-werte-in-einer-hashtabelle">Zugreifen auf Werte in einer Hashtabelle</a></h3>
<p>Wir können einen Wert aus der Hashtabelle herausholen, indem wir die Methode
<code>get</code> mit ihrem Schlüssel aufrufen, wie in Codeblock 8-21 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blau"), 10);
scores.insert(String::from("Gelb"), 50);

let team_name = String::from("Blau");
let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-21: Zugreifen auf den Spielstand von Team
Blau in der Hashtabelle</span></p>
<p>Hier wird <code>score</code> den Wert haben, der mit Team Blau assoziiert ist, und das
Ergebnis wird <code>10</code> sein. Die Methode <code>get</code> gibt eine <code>Option&lt;&amp;V&gt;</code> zurück;
wenn es keinen Wert für diesen Schlüssel in der Hashtabelle gibt, gibt <code>get</code>
den Wert <code>None</code> zurück. Dieses Programm behandelt die <code>Option</code>, indem es
<code>copied</code> aufruft, um eine <code>Option&lt;i32&gt;</code> anstelle einer <code>Option&lt;&amp;i32&gt;</code> zu
erhalten, und ruft dann <code>unwrap_or</code> auf, um <code>score</code> auf Null zu setzen, wenn
<code>scores</code> keinen Eintrag für den Schlüssel hat.</p>
<p>Wir können über jedes Schlüssel-Wert-Paar in einer Hashtabelle auf ähnliche
Weise iterieren wie bei Vektoren, indem wir eine <code>for</code>-Schleife verwenden:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blau"), 10);
scores.insert(String::from("Gelb"), 50);

for (key, value) in &amp;scores {
    println!("{key}: {value}");
}
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code gibt alle Paare in einer beliebigen Reihenfolge aus:</p>
<pre><code class="language-text">Gelb: 50
Blau: 10
</code></pre>
<h3 id="hashtabellen-und-eigentümerschaft"><a class="header" href="#hashtabellen-und-eigentümerschaft">Hashtabellen und Eigentümerschaft</a></h3>
<p>Bei Typen wie <code>i32</code>, die das Merkmal <code>Copy</code> implementieren, werden die Werte in
die Hashtabelle kopiert. Bei aneigenbaren Werten wie <code>String</code> werden die Werte
verschoben und die Hashtabelle ist Eigentümer dieser Werte, wie in Codeblock
8-22 gezeigt wird.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let field_name = String::from("Lieblingsfarbe");
let field_value = String::from("Blau");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name und field_value sind nach diesem Zeitpunkt ungültig.
// Versuche, sie zu benutzen und beobachte, welchen Kompilierfehler du erhältst!
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-22: Zeigt, dass Schlüssel und Werte nach dem
Aufruf von <code>insert</code> Eigentum der Hashtabelle sind</span></p>
<p>Wir können die Variablen <code>field_name</code> und <code>field_value</code> nicht mehr verwenden,
nachdem sie mit dem Aufruf von <code>insert</code> in die Hashtabelle verschoben wurden.</p>
<p>Wenn wir Referenzen auf Werte in die Hashtabelle einfügen, werden die Werte
nicht in die Hashtabelle verschoben. Die Werte, auf die die Referenzen zeigen,
müssen mindestens so lange gültig sein, wie die Hashtabelle gültig ist. Wir
werden mehr über diese Fragen in <a href="ch10-03-lifetime-syntax.html">„Referenzen validieren mit
Lebensdauern“</a> in Kapitel 10 sprechen.</p>
<h3 id="aktualisieren-einer-hashtabelle"><a class="header" href="#aktualisieren-einer-hashtabelle">Aktualisieren einer Hashtabelle</a></h3>
<p>Obwohl die Anzahl der Schlüssel- und Wertepaare vergrößerbar ist, kann jedem
eindeutigen Schlüssel jeweils nur ein Wert zugeordnet werden (aber nicht
umgekehrt: Zum Beispiel könnten sowohl das blaue Team als auch das gelbe Team
den Wert <code>10</code> in der Hashtabelle <code>scores</code> gespeichert haben).</p>
<p>Wenn du die Daten in einer Hashtabelle ändern willst, musst du entscheiden, wie
der Fall zu behandeln ist, wenn einem Schlüssel bereits ein Wert zugewiesen
wurde. Du kannst den alten Wert durch den neuen ersetzen und dabei den alten
Wert völlig außer Acht lassen. Du kannst den alten Wert behalten und den neuen
Wert ignorieren und nur dann den neuen Wert hinzufügen, wenn der Schlüssel noch
<em>keinen</em> zugewiesenen Wert hat. Oder du kannst den alten und neuen Wert
kombinieren. Schauen wir uns an, wie diese Varianten jeweils funktionieren!</p>
<h4 id="Überschreiben-eines-wertes"><a class="header" href="#Überschreiben-eines-wertes">Überschreiben eines Wertes</a></h4>
<p>Wenn wir einen Schlüssel und einen Wert in eine Hashtabelle einfügen und dann
denselben Schlüssel mit einem anderen Wert einfügen, wird der mit diesem
Schlüssel assoziierte Wert ersetzt. Auch wenn der Code in Codeblock 8-23
zweimal <code>insert</code> aufruft, wird die Hashtabelle nur ein Schlüssel-Wert-Paar
enthalten, weil wir beide Male einen Wert für den Schlüssel des Teams Blau
einfügen.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blau"), 10);
scores.insert(String::from("Blau"), 25);

println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-23: Ersetzen eines gespeicherten Wertes für
einen bestimmten Schlüssel</span></p>
<p>Dieser Code wird <code>{"Blau": 25}</code> ausgeben. Der ursprüngliche Wert <code>10</code> wurde
überschrieben.</p>
<h4 id="einen-schlüssel-und-wert-nur-dann-einfügen-wenn-der-schlüssel-nicht-vorhanden-ist"><a class="header" href="#einen-schlüssel-und-wert-nur-dann-einfügen-wenn-der-schlüssel-nicht-vorhanden-ist">Einen Schlüssel und Wert nur dann einfügen, wenn der Schlüssel nicht vorhanden ist</a></h4>
<p>Es ist üblich, zu prüfen, ob ein bestimmter Schlüssel bereits in der
Hashtabelle mit einem Wert vorhanden ist, und dann folgende Maßnahmen zu
ergreifen: Wenn der Schlüssel in der Hashtabelle vorhanden ist, sollte der
vorhandene Wert so bleiben, wie er ist. Wenn der Schlüssel nicht vorhanden ist,
füge ihn und einen Wert für ihn ein.</p>
<p>Hashtabellen haben dafür eine spezielle Programmierschnittstelle (API) namens
<code>entry</code>, die den Schlüssel, den du prüfen willst, als Parameter nimmt. Der
Rückgabewert der Methode <code>entry</code> ist eine Aufzählung (enum) namens <code>Entry</code>, die
einen Wert repräsentiert, der existieren könnte oder auch nicht. Nehmen wir an,
wir wollen prüfen, ob der Schlüssel für das Team Gelb einen Wert hat. Wenn das
nicht der Fall ist, wollen wir den Wert <code>50</code> einfügen, und dasselbe gilt für
das Team Blau. Bei Verwendung von <code>entry</code> sieht der Code wie Codeblock 8-24
aus.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blau"), 10);

scores.entry(String::from("Gelb")).or_insert(50);
scores.entry(String::from("Blau")).or_insert(50);

println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-24: Verwenden der Methode <code>entry</code> zum
Einfügen, nur wenn der Schlüssel nicht bereits einen Wert hat</span></p>
<p>Die Methode <code>or_insert</code> von <code>Entry</code> ist so definiert, dass sie eine
veränderbare Referenz auf den Wert des entsprechenden <code>Entry</code>-Schlüssels
zurückgibt, wenn dieser Schlüssel existiert, andernfalls fügt sie den Parameter
als neuen Wert für diesen Schlüssel ein und gibt eine veränderbare Referenz
auf den neuen Wert zurück. Diese Technik ist viel sauberer, als die Logik
selbst zu schreiben, und sie harmoniert besser mit dem Ausleihenprüfer.</p>
<p>Der Code in Codeblock 8-24 gibt <code>{"Gelb": 50, "Blau": 10}</code> aus. Beim ersten
Aufruf von <code>entry</code> wird der Schlüssel von Team Gelb mit dem Wert <code>50</code>
eingefügt, da das Team Gelb noch keinen Wert hat. Der zweite Aufruf von <code>entry</code>
wird die Hashtabelle nicht verändern, da das Team Blau bereits den Wert <code>10</code>
hat.</p>
<h4 id="aktualisieren-eines-wertes-auf-basis-des-alten-wertes"><a class="header" href="#aktualisieren-eines-wertes-auf-basis-des-alten-wertes">Aktualisieren eines Wertes auf Basis des alten Wertes</a></h4>
<p>Ein weiterer gängiger Anwendungsfall für Hashtabellen besteht darin, den Wert
eines Schlüssels nachzuschlagen und ihn dann auf Basis des alten Wertes zu
aktualisieren. Beispielsweise zeigt Codeblock 8-25 einen Code, der zählt, wie
oft jedes Wort in einem Text vorkommt. Wir verwenden eine Hashtabelle mit den
Wörtern als Schlüssel und inkrementieren den Wert, um nachzuvollziehen, wie oft
wir dieses Wort schon gesehen haben. Wenn es das erste Mal ist, dass wir ein
Wort sehen, fügen wir zuerst den Wert <code>0</code> ein.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let text = "Hallo Welt wunderbare Welt";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{map:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-25: Zählen des Vorkommens von Wörtern mit
Hilfe einer Hashtabelle, die Wörter speichert und zählt</span></p>
<p>Dieser Code gibt <code>{"Welt": 2, "wunderbare": 1, "Hallo": 1}</code> aus. Es kann sein,
dass dieselben Schlüssel/Wert-Paare in einer anderen Reihenfolge ausgegeben
werden: Du erinnerst dich an <a href="ch08-03-hash-maps.html#zugreifen-auf-werte-in-einer-hashtabelle">„Zugreifen auf Werte in einer
Hashtabelle“</a>, wo die Iteration über eine Hashtabelle in einer
willkürlichen Reihenfolge erfolgt.</p>
<p>Die Methode <code>split_whitespace</code> gibt einen Iterator über durch Leerzeichen
getrennte Sub-Anteilstypen des Wertes in <code>text</code> zurück. Die Methode <code>or_insert</code>
gibt eine veränderbare Referenz (<code>&amp;mut V</code>) auf den Wert für den angegebenen
Schlüssel zurück. Hier speichern wir diese veränderbaren Referenz in der
Variablen <code>count</code>. Um diesen Wert zuzuweisen, müssen wir also zuerst <code>count</code>
mit dem Stern (<code>*</code>) derefenzieren. Die veränderbare Referenz verlässt am Ende
der <code>for</code>-Schleife dem Gültigkeitsbereich, sodass alle diese Änderungen sicher
und gemäß der Ausleihregeln zulässig sind.</p>
<h3 id="hash-funktionen"><a class="header" href="#hash-funktionen">Hash-Funktionen</a></h3>
<p>Standardmäßig verwendet <code>HashMap</code> eine Hash-Funktion namens <em>SipHash</em>, die robust
gegen Denial-of-Service-Angriffe (DoS) mit Hash-Tabellen<sup class="footnote-reference" id="fr-siphash-1"><a href="#footnote-siphash">1</a></sup> ist. Dies
ist nicht der schnellste verfügbare Hashing-Algorithmus, aber der Kompromiss
zugunsten einer höheren Sicherheit gegenüber einer geringeren Performanz ist es
Wert. Wenn du eine Performanzanalyse deines Codes machst und feststellst, dass
die Standard-Hash-Funktion für deine Zwecke zu langsam ist, kannst du zu einer
anderen Funktion wechseln, indem du eine andere Hash-Funktion angibst. Eine
<em>Hash-Funktion</em> ist ein Typ, der das Merkmal <code>BuildHasher</code> implementiert. Wir
werden in <a href="ch10-02-traits.html">Kapitel 10</a> über Merkmale und ihre Implementierung sprechen.
Du musst nicht unbedingt deine eigene Hash-Funktion von Grund auf
implementieren; <a href="https://crates.io/">crates.io</a> verfügt über Bibliotheken, die von anderen
Rust-Nutzern bereitgestellt werden und viele gängige Hash-Funktionen
implementieren.</p>
<h2 id="zusammenfassung-7"><a class="header" href="#zusammenfassung-7">Zusammenfassung</a></h2>
<p>Vektoren, Zeichenketten und Hashtabellen bieten eine große Menge an
Funktionalität, die in Programmen benötigt wird, wenn du Daten speichern,
darauf zugreifen und sie verändern willst. Hier sind einige Übungen, für deren
Lösung du jetzt gerüstet sein solltest:</p>
<ol>
<li>Verwende bei einer Liste von ganzen Zahlen einen Vektor und gib den
Median (wenn sortiert, den Wert in der Mitte) und den Modus (den Wert,
der am häufigsten vorkommt; eine Hashtabelle ist hier hilfreich) der Liste
zurück.</li>
<li>Wandle Zeichenketten in Schweinelatein (pig latin) um. Der erste Konsonant
jedes Wortes wird an das Ende des Wortes verschoben und „ay“ angehängt,
sodass „zuerst“ zu „uerst-zay“ wird. Bei Wörtern, die mit einem Vokal
beginnen, wird stattdessen „hay“ an das Ende angefügt („ansehen“ wird zu
„ansehen-hay“). Beachte die Details zur UTF-8-Kodierung!</li>
<li>Erstelle mit Hilfe einer Hashtabelle und Vektoren eine Textschnittstelle, die
es einem Benutzer ermöglicht, Mitarbeiternamen zu einer Abteilung in einem
Unternehmen hinzuzufügen. Zum Beispiel „Sally zur Technik hinzufügen“ oder
„Amir zum Vertrieb hinzufügen“. Lass den Benutzer dann eine alphabetisch
sortierte Liste aller Personen in einer Abteilung oder aller Personen in der
Firma nach Abteilung ausgeben.</li>
</ol>
<p>Die API-Dokumentation der Standard-Bibliothek beschreibt Methoden für Vektoren,
Zeichenketten und Hashtabellen, die für diese Übungen hilfreich sind!</p>
<p>Wir steigen in komplexere Programme ein, in denen Operationen fehlschlagen
können, daher ist es ein perfekter Zeitpunkt, auf die Fehlerbehandlung
einzugehen. Das werden wir als nächstes tun!</p>
<hr>
<ol class="footnote-definition"><li id="footnote-siphash">
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a> <a href="#fr-siphash-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="fehlerbehandlung"><a class="header" href="#fehlerbehandlung">Fehlerbehandlung</a></h1>
<p>Fehler sind eine Tatsache im Software-Alltag, deshalb enthält Rust eine Reihe von
Funktionalitäten zur Behandlung von Situationen, in denen etwas schiefgeht. In
vielen Fällen verlangt Rust von dir, dass du die Möglichkeit eines Fehlers
anerkennst und Vorkehrungen ergreifst, damit dein Code kompiliert werden kann.
Diese Anforderung macht dein Programm robuster, da sichergestellt wird, dass du
Fehler entdeckst und diese angemessen behandelst, bevor dein Code in Produktion
gebracht wird!</p>
<p>Rust gruppiert Fehler in zwei Hauptkategorien: <em>Behebbare</em> (recoverable) und
<em>nicht behebbare</em> (unrecoverable) Fehler. Bei einem behebbaren Fehler, z.B.
„Datei nicht gefunden“, wollen wir das Problem wahrscheinlich dem Benutzer
melden und den Vorgang erneut versuchen. Nicht behebbare Fehler sind immer
Symptome von Programmierfehlern, z.B. der Versuch, auf eine Stelle hinter dem
Ende eines Arrays zuzugreifen, und deshalb wollen wir das Programm sofort
anhalten.</p>
<p>Die meisten Sprachen unterscheiden nicht zwischen diesen beiden Fehlerarten und
behandeln beide auf die gleiche Weise, indem sie Mechanismen wie die
Ausnahmebehandlung verwenden. Rust hat keine Ausnahmebehandlung. Stattdessen
hat es den Typ <code>Result&lt;T, E&gt;</code> für behebbare Fehler und das Makro <code>panic!</code>, das
die Ausführung stoppt, wenn das Programm auf einen nicht behebbaren Fehler
stößt. Dieses Kapitel behandelt zuerst das Aufrufen von <code>panic!</code> und spricht
dann über die Rückgabe von <code>Result&lt;T, E&gt;</code>-Werten. Darüber hinaus werden wir
uns mit der Frage befassen, wann man versuchen sollte, einen Fehler zu beheben
oder die Ausführung zu stoppen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nicht-behebbare-fehler-mit-panic"><a class="header" href="#nicht-behebbare-fehler-mit-panic">Nicht behebbare Fehler mit <code>panic!</code></a></h2>
<p>Manchmal passieren schlimme Dinge in deinem Code und du kannst nichts dagegen
tun. Für diese Fälle hat Rust das Makro <code>panic!</code>. In der Praxis gibt es zwei
Möglichkeiten, ein Programm abstürzen zu lassen: Durch eine Aktion, die unseren
Code abstürzen lässt (z.B. Zugriff auf ein Array über das Ende hinaus) oder
durch den expliziten Aufruf des Makros <code>panic!</code>. In beiden Fällen brechen wir
unser Programm ab. Standardmäßig geben diese Programmabbrüche eine
Fehlermeldung aus, räumen den Stapelspeicher auf und beenden sich. Über eine
Umgebungsvariable kannst du auch festlegen, dass Rust den Stapelspeicher
anzeigt, wenn das Programm abbricht, damit du die Quelle des Abbruchs leichter
aufspüren kannst.</p>
<blockquote>
<h3 id="auflösen-des-stapelspeichers-oder-abbrechen-als-fehlerreaktion"><a class="header" href="#auflösen-des-stapelspeichers-oder-abbrechen-als-fehlerreaktion">Auflösen des Stapelspeichers oder Abbrechen als Fehlerreaktion</a></h3>
<p>Wenn ein Programmabbruch auftritt, beginnt das Programm standardmäßig mit dem
<em>Abwickeln</em>, was bedeutet, dass Rust den Stapelspeicher wieder nach oben geht
und die Daten aller Funktion aufräumt. Allerdings ist dieses Zurückgehen und
Aufräumen eine Menge Arbeit. Rust bietet dir als Alternative daher an, das
Programm sofort <em>abzubrechen</em>, also das Programm ohne Aufräumen zu beenden.</p>
<p>Der Speicher, den das Programm benutzt hat, muss dann vom Betriebssystem
aufgeräumt werden. Wenn du in deinem Projekt die resultierende Binärdatei so
klein wie möglich machen willst, kannst du für ein vorzeitiges Programmende
vom Abwickeln zum sofortigen Abbrechen umschalten, indem du <code>panic = 'abort'</code>
in den entsprechenden <code>[profile]</code>-Abschnitten in deiner <em>Cargo.toml</em>-Datei
hinzufügst. Wenn du beispielsweise im Freigabemodus (release mode) im
Fehlerfall sofort abbrechen möchtest, füge dies hinzu:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Versuchen wir <code>panic!</code> in einem einfachen Programm aufzurufen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics edition2024">fn main() {
    panic!("abstürzen und verbrennen");
}</code></pre></pre>
<p>Wenn du das Programm ausführst, wirst du in etwa das hier sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:2:5:
abstürzen und verbrennen
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Der Aufruf von <code>panic!</code> verursacht die in den letzten beiden Zeilen enthaltene
Fehlermeldung. Die erste Zeile zeigt unsere Fehlermeldung und die Position in
unserem Quellcode, an der der Fehler aufgetreten ist: <em>src/main.rs:2:5</em> gibt
an, dass es sich um die zweite Zeile und dem fünften Zeichen in unserer Datei
<em>src/main.rs</em> handelt.</p>
<p>In diesem Fall ist die angegebene Zeile Teil unseres Codes und wenn wir uns
diese Zeile ansehen, sehen wir den Makroaufruf <code>panic!</code>. In anderen Fällen
könnte der Aufruf von <code>panic!</code> in Code erfolgen, den unser Code aufruft, und
der Dateiname und die Zeilennummer in der Fehlermeldung gehören zu Code von
jemand anderen, der das Makro <code>panic!</code> aufruft, nicht zu unserem Code, der
schließlich zum Aufruf von <code>panic!</code> geführt hat.</p>
<p>Wir können die Aufrufhistorie (backtrace) der Funktionen, von der der
<code>panic!</code>-Aufruf kam, nutzen, um den Codeteil zu ermitteln, der das Problem
verursacht. Um zu verstehen, wie man eine <code>panic!</code>-Aufrufhistorie liest, lass
uns ein anderes Beispiel betrachten, bei dem ein <code>panic!</code>-Aufruf aufgrund eines
Fehlers in unserem Code von einer Bibliothek kommt, anstatt von unserem Code,
der das Makro direkt aufruft. Codeblock 9-1 enthält einen Code, der versucht,
auf einen Index in einem Vektor zuzugreifen, der außerhalb des Bereichs
gültiger Indizes liegt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics edition2024">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}</code></pre></pre>
<p><span class="caption">Codeblock 9-1: Versuch, auf ein Element jenseits des
Endes eines Vektors zuzugreifen, was einen Aufruf von <code>panic!</code> auslöst</span></p>
<p>Hier versuchen wir, auf das 100. Element unseres Vektors zuzugreifen (das bei
Index 99 liegt, weil die Indexierung bei Null beginnt), der Vektor hat aber nur
drei Elemente. In dieser Situation wird Rust das Programm abbrechen. Das
Verwenden von <code>[]</code> soll ein Element zurückgeben, aber wenn du einen ungültigen
Index übergibst, gibt es kein Element, das Rust hier korrekterweise zurückgeben
könnte.</p>
<p>In C ist der Versuch, über das Ende einer Datenstruktur hinaus zu lesen, ein
undefiniertes Verhalten. Möglicherweise erhältst du den Wert im Speicher an der
der Datenstruktur entsprechenden Stelle, selbst wenn der Speicher nicht zu
dieser Struktur gehört. Dies wird als <em>Hinauslesen über den Puffer</em> (buffer
overread) bezeichnet und kann zu Sicherheitslücken führen, wenn ein Angreifer
in der Lage ist, den Index so zu manipulieren, dass er unerlaubterweise Daten
lesen kann, die nach der Datenstruktur gespeichert sind.</p>
<p>Um dein Programm vor dieser Art Verwundbarkeit zu schützen, wird Rust beim
Versuch, ein Element an einem Index zu lesen, der nicht existiert, die
Ausführung stoppen und die Fortsetzung verweigern. Versuchen wir es und sehen,
was passiert:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Dieser Fehler weist auf Zeile 4 in unserer <code>main.rs</code> hin, wo wir versuchen, auf
den Index <code>99</code> des Vektors in <code>v</code> zuzugreifen.</p>
<p>Die Zeile <code>note:</code> sagt uns, dass wir die Umgebungsvariable <code>RUST_BACKTRACE</code>
setzen können, um eine Aufrufhistorie zu erhalten, was genau passiert ist und
den Fehler verursacht hat. Eine <em>Aufrufhistorie</em> ist eine Liste aller
Funktionen, die aufgerufen wurden, um an diesen Punkt zu gelangen.
Aufrufhistorien in Rust funktionieren wie in anderen Sprachen: Der Schlüssel
zum Lesen der Aufrufhistorie ist, von oben zu beginnen und zu lesen, bis du
Dateien siehst, die du geschrieben hast. Das ist die Stelle, an der das Problem
entstanden ist. Die Zeilen darüber sind Code, den dein Code aufgerufen hat; die
Zeilen darunter sind Code, der deinen Code aufgerufen hat. Diese Zeilen können
Core-Rust-Code, Code der Standardbibliothek oder Kisten, enthalten, die du
verwendest. Versuchen wir, eine Aufrufhistorie zu erhalten, indem wir die
Umgebungsvariable <code>RUST_BACKTRACE</code> auf einen beliebigen Wert außer <code>0</code> setzen.
Codeblock 9-2 zeigt eine ähnliche Ausgabe wie die, die du sehen wirst.</p>
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/07dca489ac2d933c78d3c5158e3f43/library/std/src/panicking.rs:645:5
   1: core::panicking::panic_fmt
             at /rustc/07dca489ac2d933c78d3c5158e3f43/library/core/src/panicking.rs:72:14
   2: core::panicking::panic_bounds_check
             at /rustc/07dca489ac2d933c78d3c5158e3f43/library/core/src/panicking.rs:208:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/07dca489ac2d933c78d3c5158e3f43/library/core/src/slice/index.rs:255:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/07dca489ac2d933c78d3c5158e3f43/library/core/src/slice/index.rs:18:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/07dca489ac2d933c78d3c5158e3f43/library/alloc/src/vec/mod.rs:2770:9
   6: panic::main
             at ./src/main.rs:4:6
   7: core::ops::function::FnOnce::call_once
             at /rustc/07dca489ac2d933c78d3c5158e3f43/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p><span class="caption">Codeblock 9-2: Aufrufhistorie, erzeugt durch einen Aufruf
von <code>panic!</code>, wenn die Umgebungsvariable <code>RUST_BACKTRACE</code> gesetzt ist</span></p>
<p>Das ist eine lange Ausgabe! Die genaue Ausgabe kann je nach Betriebssystem und
Rust-Version unterschiedlich sein. Um Aufrufhistorien mit diesen Informationen
zu erhalten, müssen Fehlersuchinfos (debug symbols) aktiviert sein.
Fehlersuchinfos sind standardmäßig aktiviert, wenn du <code>cargo build</code> oder
<code>cargo run</code> ohne Flag <code>--release</code> verwendest, wie wir es hier haben.</p>
<p>In der Ausgabe in Codeblock 9-2 zeigt Zeile 17 der Aufrufhistorie auf die Zeile
in unserem Projekt, die das Problem verursacht: Zeile 4 in <em>src/main.rs</em>. Wenn
wir nicht wollen, dass unser Programm abbricht, sollten wir bei der ersten
Zeile, die auf eine von uns geschriebenen Datei verweist, mit der Untersuchung
beginnen. In Codeblock 9-1, wo wir absichtlich Code geschrieben haben, der das
Programm abbricht, besteht die Möglichkeit das Problem zu beheben darin, kein
Element außerhalb des Bereichs der Vektorindizes anzufordern. Wenn dein Code in
Zukunft abbricht, musst du herausfinden, bei welcher Aktion der Code mit
welchen Werten abbricht und was der Code stattdessen tun sollte.</p>
<p>In Abschnitt <a href="ch09-03-to-panic-or-not-to-panic.html">„Wann <code>panic!</code> aufrufen und wann
nicht?“</a> später in diesem Kapitel kommen wir noch
einmal auf <code>panic!</code> zurück und wann wir <code>panic!</code> verwenden sollten und wann
nicht, um Fehlerfälle zu behandeln. Als Nächstes schauen wir uns an, wie man
Fehler mit <code>Result</code> abfangen kann.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="behebbare-fehler-mit-result"><a class="header" href="#behebbare-fehler-mit-result">Behebbare Fehler mit <code>Result</code></a></h2>
<p>Die meisten Fehler sind nicht so schwerwiegend, dass das Programm ganz
abgebrochen werden müsste. Manchmal, wenn eine Funktion fehlschlägt, hat das
einen Grund, den man leicht erkennen und darauf reagieren kann. Wenn du
beispielsweise versuchst, eine Datei zu öffnen, und dieser Vorgang schlägt
fehl, weil die Datei nicht existiert, könntest du die Datei erstellen, anstatt
den Vorgang zu beenden.</p>
<p>Erinnere dich an <a href="ch02-00-guessing-game-tutorial.html#behandeln-potentieller-fehler-mit-result">„Behandeln potentieller Fehler mit
<code>Result</code>“</a> in Kapitel 2, das die Aufzählung <code>Result</code> mit zwei
Varianten <code>Ok</code> und <code>Err</code> definiert, wie nachfolgend zu sehen ist:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>T</code> und <code>E</code> sind generische Typparameter: Wir werden generische Datentypen in
Kapitel 10 ausführlicher besprechen. Was du jetzt wissen musst, ist, dass <code>T</code>
den Typ des Wertes darstellt, der im Erfolgsfall innerhalb der <code>Ok</code>-Variante
zurückgegeben wird, und <code>E</code> den Typ des Fehlers, der im Fehlerfall innerhalb
der <code>Err</code>-Variante zurückgegeben wird. Da <code>Result</code> diese generischen
Typparameter hat, können wir den <code>Result</code>-Typ und die Funktionen, die darauf
definiert sind, in vielen verschiedenen Situationen verwenden, in denen der
Erfolgswert und der Fehlerwert, den wir zurückgeben wollen, unterschiedlich
sein können.</p>
<p>Rufen wir eine Funktion auf, die einen <code>Result</code>-Wert zurückgibt, weil die
Funktion fehlschlagen könnte. In Codeblock 9-3 versuchen wir, eine Datei zu
öffnen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hallo.txt");
}</code></pre></pre>
<p><span class="caption">Codeblock 9-3: Eine Datei öffnen</span></p>
<p>Der Rückgabetyp von <code>File::open</code> ist <code>Result&lt;T, E&gt;</code>. Der generische Parameter
<code>T</code> wurde hier mit dem Typ des Erfolgswertes <code>std::fs::File</code>, der eine
Dateiressource (file handle) ist, gefüllt. Der Typ <code>E</code> für den Fehlerwert ist
<code>std::io::Error</code>. Dieser Rückgabetyp bedeutet, dass der Aufruf von <code>File::open</code>
erfolgreich sein könnte und eine Dateiressource zurückgibt, aus der wir lesen
oder in die wir schreiben können. Der Funktionsaufruf kann auch fehlschlagen:
Zum Beispiel könnte die Datei nicht existieren oder wir haben möglicherweise
keine Zugriffsberechtigung für die Datei. Die Funktion <code>File::open</code> muss eine
Möglichkeit haben, uns zu sagen, ob sie erfolgreich war oder fehlgeschlagen
ist, und uns gleichzeitig entweder die Dateiressource oder die
Fehlerinformationen liefern. Diese Informationen sind genau das, was die
Aufzählung <code>Result</code> übermittelt.</p>
<p>Falls <code>File::open</code> erfolgreich ist, wird der Wert der Variable
<code>greeting_file_result</code> eine Instanz von <code>Ok</code> sein, die eine Dateiressource
enthält. Im Fehlerfall ist der Wert von <code>greeting_file_result</code> eine Instanz von
<code>Err</code>, die mehr Informationen über die Art des aufgetretenen Fehlers enthält.</p>
<p>Wir müssen den Code in Codeblock 9-3 ergänzen, um abhängig vom Rückgabewert von
<code>File::open</code> unterschiedliche Aktionen durchzuführen. Codeblock 9-4 zeigt eine
Möglichkeit, <code>Result</code> mit Hilfe eines grundlegenden Werkzeugs, dem Ausdruck
<code>match</code>, den wir in Kapitel 6 besprochen haben, zu behandeln.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic edition2024">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hallo.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("Problem beim Öffnen der Datei: {error:?}"),
    };
}</code></pre></pre>
<p><span class="caption">Codeblock 9-4: Verwenden eines <code>match</code>-Ausdrucks zum
Behandeln der <code>Result</code>-Varianten, die zurückgegeben werden könnten</span></p>
<p>Beachte, dass die Aufzählung <code>Result</code> und ihre Varianten automatisch im
Gültigkeitsbereich verfügbar sind, genau wie bei der Aufzählung <code>Option</code>,
sodass wir in den <code>match</code>-Zweigen nicht mehr <code>Result::</code> vor den Varianten <code>Ok</code>
und <code>Err</code> angeben müssen.</p>
<p>Wenn das Ergebnis <code>Ok</code> ist, gibt dieser Code den inneren <code>file</code>-Wert aus der
<code>Ok</code>-Variante zurück, und wir weisen diese Dateiressource der Variablen
<code>greeting_file </code> zu. Nach dem <code>match</code> können wir die Dateiressource zum Lesen
und Schreiben verwenden.</p>
<p>Der andere Zweig von <code>match</code> behandelt den Fall, dass wir einen <code>Err</code>-Wert von
<code>File::open</code> erhalten. In diesem Beispiel haben wir uns dafür entschieden, das
Makro <code>panic!</code> aufzurufen. Wenn es keine Datei namens <em>hallo.txt</em> in unserem
aktuellen Verzeichnis gibt und wir diesen Code ausführen, sehen wir die
folgende Ausgabe des Makros <code>panic!</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at src/main.rs:8:23:
Problem beim Öffnen der Datei: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Wie üblich sagt uns diese Ausgabe genau, was schiefgelaufen ist.</p>
<h3 id="abgleich-verschiedener-fehler"><a class="header" href="#abgleich-verschiedener-fehler">Abgleich verschiedener Fehler</a></h3>
<p>Der Code in Codeblock 9-4 wird abbrechen, egal aus welchem Grund <code>File::open</code>
fehlschlug. Nun wollen wir jedoch bei verschiedenen Fehlerursachen
unterschiedliche Maßnahmen ergreifen. Wenn <code>File::open</code> fehlgeschlagen ist,
weil die Datei nicht existiert, wollen wir die Datei erstellen und die
Dateiressource der neuen Datei zurückgeben. Wenn <code>File::open</code> aus irgendeinem
anderen Grund fehlschlug, z.B. weil wir keine Berechtigung zum Öffnen der Datei
hatten, wollen wir immer noch, dass der Code abbricht, so wie es in Codeblock
9-4 der Fall war. Dazu fügen wir einen inneren <code>match</code>-Ausdruck hinzu, wie in
Codeblock 9-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hallo.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hallo.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("Problem beim Erstellen der Datei: {e:?}"),
            },
            other_error =&gt; {
                panic!("Problem beim Öffnen der Datei: {other_error:?}")
            }
        },
    };
}</code></pre></pre>
<p><span class="caption">Codeblock 9-5: Unterschiedliche Arten von Fehlern auf
unterschiedliche Weise behandeln</span></p>
<p>Der Typ des Wertes, den <code>File::open</code> innerhalb der Variante <code>Err</code> zurückgibt,
ist <code>io::Error</code>, eine Struktur (struct), die von der Standardbibliothek zur
Verfügung gestellt wird. Diese Struktur hat eine Methode <code>kind</code>, die wir
aufrufen können, um einen <code>io::ErrorKind</code>-Wert zu erhalten. Die Aufzählung
<code>io::ErrorKind</code> wird von der Standardbibliothek zur Verfügung gestellt und
enthält Varianten, die die verschiedenen Fehlerarten repräsentieren, die bei
einer <code>io</code>-Operation auftreten können. Die Variante, die wir verwenden wollen,
ist <code>ErrorKind::NotFound</code>, was bedeutet, dass die Datei, die wir zu öffnen
versuchen, noch nicht existiert. Wir werten also <code>greeting_file_result</code> aus,
als auch <code>error.kind()</code>.</p>
<p>Die Bedingung, die wir beim inneren Abgleich überprüfen wollen, ist, ob der von
<code>error.kind()</code> zurückgegebene Wert die Variante <code>NotFound</code> der Aufzählung
<code>ErrorKind</code> ist. Wenn das der Fall ist, versuchen wir, die Datei mit
<code>File::create</code> zu erstellen. Da <code>File::create</code> aber auch scheitern könnte,
brauchen wir einen zweiten Zweig im inneren <code>match</code>-Ausdruck. Wenn die Datei
nicht erstellt werden kann, wird eine andere Fehlermeldung ausgegeben. Der
zweite Zweig des äußeren <code>match</code> bleibt gleich, sodass das Programm bei jedem
Fehler, außer dem Fehler der fehlenden Datei, abbricht.</p>
<blockquote>
<h4 id="alternativen-zur-verwendung-von-match-mit-resultt-e"><a class="header" href="#alternativen-zur-verwendung-von-match-mit-resultt-e">Alternativen zur Verwendung von <code>match</code> mit <code>Result&lt;T, E&gt;</code></a></h4>
<p>Das sind viele <code>match</code>! Der Ausdruck <code>match</code> ist sehr nützlich, aber auch
sehr primitiv. In Kapitel 13 wirst du etwas über Funktionsabschlüsse
(closures) lernen, die mit vielen der auf <code>Result&lt;T, E&gt;</code> definierten Methoden
verwendet werden. Diese Methoden können prägnanter sein als die Verwendung
von <code>match</code> bei der Behandlung von <code>Result&lt;T, E&gt;</code>-Werten in deinem Code.</p>
<p>Hier ist zum Beispiel eine andere Möglichkeit, die gleiche Logik wie in
Codeblock 9-5 zu schreiben, aber unter Verwendung von Funktionsabschlüssen
und der Methode <code>unwrap_or_else</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hallo.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hallo.txt").unwrap_or_else(|error| {
                panic!("Problem beim Erstellen der Datei: {error:?}");
            })
        } else {
            panic!("Problem beim Öffnen der Datei: {error:?}");
        }
    });
}</code></pre></pre>
<p>Obwohl dieser Code dasselbe Verhalten wie Codeblock 9-5 aufweist, enthält er
keine <code>match</code>-Ausdrücke und ist einfacher zu lesen. Kehre zu diesem Beispiel
zurück, nachdem du Kapitel 13 gelesen hast, und schlage die Methode
<code>unwrap_or_else</code> in der Standardbibliotheksdokumentation nach. Viele weitere
dieser Methoden können große, verschachtelte <code>match</code>-Ausdrücke vermeiden,
wenn du mit Fehlern zu tun hast.</p>
</blockquote>
<h4 id="abkürzungen-zum-abbrechen-im-fehlerfall-unwrap-und-expect"><a class="header" href="#abkürzungen-zum-abbrechen-im-fehlerfall-unwrap-und-expect">Abkürzungen zum Abbrechen im Fehlerfall: <code>unwrap</code> und <code>expect</code></a></h4>
<p>Das Verwenden von <code>match</code> funktioniert gut genug, aber es kann etwas langatmig
sein und vermittelt das Vorhaben nicht immer gut. Der Typ <code>Result&lt;T, E&gt;</code> bietet
viele Hilfsmethoden, um verschiedene, spezifischere Aufgaben zu erledigen. Die
Methode <code>unwrap</code> ist eine Abkürzungsmethode, implementiert wie der Ausdruck
<code>match</code>, den wir in Codeblock 9-4 verwendet haben. Wenn der <code>Result</code>-Wert die
Variante <code>Ok</code> ist, gibt <code>unwrap</code> den Wert innerhalb <code>Ok</code> zurück. Wenn <code>Result</code>
die Variante <code>Err</code> ist, ruft <code>unwrap</code> das Makro <code>panic!</code> für uns auf. Hier ist
ein Beispiel für <code>unwrap</code> im Einsatz:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic edition2024">use std::fs::File;

fn main() {
    let greeting_file = File::open("hallo.txt").unwrap();
}</code></pre></pre>
<p>Wenn wir diesen Code ohne eine Datei <em>hallo.txt</em> ausführen, werden wir die
Fehlermeldung des <code>panic!</code>-Aufrufs sehen, den die Methode <code>unwrap</code> macht:</p>
<pre><code class="language-console">thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>In ähnlicher Weise können wir bei der Methode <code>expect</code> auch die Fehlermeldung
von <code>panic!</code> angeben. Das Verwenden von <code>expect</code> anstelle von <code>unwrap</code> und das
Angeben guter Fehlermeldungen kann deine Absicht vermitteln und das Aufspüren
der Fehlerursache erleichtern. Die Syntax von <code>expect</code> sieht wie folgt aus:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic edition2024">use std::fs::File;

fn main() {
    let greeting_file = File::open("hallo.txt")
        .expect("hallo.txt sollte in dieses Projekt aufgenommen werden");
}</code></pre></pre>
<p>Wir benutzen <code>expect</code> auf die gleiche Weise wie <code>unwrap</code>: Um die Dateiressource
zurückzugeben oder das Makro <code>panic!</code> aufzurufen. Die Fehlermeldung, die
<code>expect</code> beim Aufruf von <code>panic!</code> mitgibt, wird als Parameter an <code>expect</code>
übergeben, anstelle der standardmäßigen <code>panic!</code>-Nachricht, die <code>unwrap</code>
verwendet. So sieht sie aus:</p>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:5:10:
hallo.txt sollte in dieses Projekt aufgenommen werden: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>In produktivem Code wählen die meisten Rust-Entwickler <code>expect</code> statt
<code>unwrap</code> und geben mehr Kontext darüber an, warum die Operation voraussichtlich
immer erfolgreich sein wird. Auf diese Weise hast du mehr Informationen, die du
bei der Fehlersuche verwenden kannst, falls sich deine Annahmen als falsch
erweisen sollten.</p>
<h3 id="weitergeben-von-fehlern"><a class="header" href="#weitergeben-von-fehlern">Weitergeben von Fehlern</a></h3>
<p>Wenn die Implementierung einer Funktion etwas aufruft, das fehlschlagen könnte,
kannst du, anstatt den Fehler innerhalb dieser Funktion zu behandeln, den
Fehler an den aufrufenden Code zurückgeben, damit dieser entscheiden kann, was
zu tun ist. Dies wird als <em>Weitergeben</em> (propagating) des Fehlers bezeichnet
und gibt dem aufrufenden Code mehr Kontrolle, wo mehr Informationen und Logik
zur Fehlerbehandlung vorhanden sein könnte, als im Kontext deines Codes zur
Verfügung steht.</p>
<p>Beispielsweise zeigt Codeblock 9-6 eine Funktion, die einen Benutzernamen aus
einer Datei liest. Wenn die Datei nicht existiert oder nicht gelesen werden
kann, gibt diese Funktion den Fehler an den Code zurück, der die Funktion
aufgerufen hat.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open("hallo.txt");

    let mut username_file = match username_file_result  {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 9-6: Eine Funktion, die mit <code>match</code> Fehler an
den aufrufenden Code zurückgibt</span></p>
<p>Diese Funktion kann auf eine viel kürzere Art und Weise geschrieben werden,
aber wir wollen für den Anfang viel davon manuell machen, um die
Fehlerbehandlung kennen zu lernen; am Ende werden wir den kürzeren Weg zeigen. Sehen
wir uns zunächst den Rückgabetyp der Funktion an: <code>Result&lt;String, io::Error&gt;</code>.
Das bedeutet, dass die Funktion einen Wert vom Typ <code>Result&lt;T, E&gt;</code> zurückgibt,
wobei der generische Typ <code>T</code> mit dem konkreten Typ <code>String</code> und der generische
Typ <code>E</code> mit dem konkreten Typ <code>io::Error</code> gefüllt wurde.</p>
<p>Wenn diese Funktion erfolgreich ist, erhält der aufrufende Code einen
<code>Ok</code>-Wert, der einen <code>String</code> enthält – den Benutzernamen, den diese
Funktion aus der Datei liest. Wenn diese Funktion auf Probleme stößt, erhält
der aufrufende Code einen <code>Err</code>-Wert, der eine Instanz von <code>io::Error</code> enthält,
mit weiteren Informationen darüber, was die Probleme waren. Wir wählten
<code>io::Error</code> als Rückgabetyp dieser Funktion, weil dies zufällig der Typ des
Fehlerwertes ist, der von beiden Operationen zurückgegeben wird, die wir im
Funktionsrumpf aufrufen und fehlschlagen könnten: Die Funktion <code>File::open</code> und
die Methode <code>read_to_string</code>.</p>
<p>Der Funktionsrumpf beginnt mit dem Aufruf der Funktion <code>File::open</code>. Dann
behandeln wir den <code>Result</code>-Wert, der von <code>match</code> zurückgegeben wird, auf
ähnliche Weise wie bei <code>match</code> in Codeblock 9-4. Wenn <code>File::open</code> erfolgreich
ist, erhält die Dateiressource in der Mustervariablen <code>file</code> den Wert in der
veränderbaren Variablen <code>username_file</code> und die Funktion wird fortgesetzt. Im
Fall von <code>Err</code> verwenden wir das Schlüsselwort <code>return</code>, anstatt <code>panic!</code>
aufzurufen, um die Funktion vorzeitig ganz zu verlassen und den Fehlerwert von
<code>File::open</code> in der Mustervariablen <code>e</code> als Fehlerwert dieser Funktion an den
aufrufenden Code zurückzugeben.</p>
<p>Wenn wir also eine Dateiressource in <code>username_file</code> haben, erzeugt die
Funktion einen neuen <code>String</code> in der Variablen <code>username</code> und ruft die Methode
<code>read_to_string</code> für die Dateiressource in <code>username_file</code> auf, um den Inhalt
der Datei in die Variable <code>username</code> zu lesen. Die Methode <code>read_to_string</code>
gibt ebenfalls ein <code>Result</code> zurück, weil sie fehlschlagen könnte, obwohl
<code>File::open</code> erfolgreich war. Wir brauchen also ein weiteres <code>match</code>, um dieses
<code>Result</code> zu verarbeiten: Wenn <code>read_to_string</code> erfolgreich ist, dann war unsere
Funktion erfolgreich und wir geben den Benutzernamen aus der Datei zurück, die
jetzt in <code>username</code> innerhalb <code>Ok</code> enthalten ist. Wenn <code>read_to_string</code>
fehlschlägt, geben wir den Fehlerwert auf die gleiche Weise zurück, wie wir den
Fehlerwert in <code>match</code> zurückgegeben haben, das den Rückgabewert von
<code>File::open</code> behandelt hat. Wir brauchen jedoch nicht ausdrücklich <code>return</code>
anzugeben, weil dies der letzte Ausdruck in der Funktion ist.</p>
<p>Der Code, der diesen Code aufruft, wird dann damit zurechtkommen, entweder
einen <code>Ok</code>-Wert zu erhalten, der einen Benutzernamen enthält, oder einen
<code>Err</code>-Wert, der einen <code>io::Error</code> enthält. Es ist Sache des aufrufenden Codes,
zu entscheiden, was mit diesen Werten geschehen soll. Wenn der aufrufende Code
einen <code>Err</code>-Wert erhält, könnte er <code>panic!</code> aufrufen und das Programm zum
Absturz bringen, einen Standardbenutzernamen verwenden oder den Benutzernamen
von irgendwo anders als z.B. einer Datei nachschlagen. Wir haben nicht genug
Informationen darüber, was der aufrufende Code tatsächlich versucht, also
propagieren wir alle Erfolgs- und Fehlerinformationen nach oben, damit sie
angemessen behandelt werden.</p>
<p>Dieses Muster der Fehlerweitergabe ist in Rust so verbreitet, dass Rust den
Fragezeichen-Operator <code>?</code> bereitstellt, um dies zu erleichtern.</p>
<h4 id="abkürzung-zum-weitergeben-von-fehlern-der-operator-"><a class="header" href="#abkürzung-zum-weitergeben-von-fehlern-der-operator-">Abkürzung zum Weitergeben von Fehlern: Der Operator <code>?</code></a></h4>
<p>Codeblock 9-7 zeigt eine Implementierung von <code>read_username_from_file</code>, die
dasselbe Verhalten wie Codeblock 9-6 hat, aber diese Implementierung verwendet
den <code>?</code>-Operator.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open("hallo.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username )?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 9-7: Eine Funktion, die Fehler an den
aufrufenden Code zurückgibt, indem sie den <code>?</code>-Operator verwendet</span></p>
<p>Das <code>?</code> hinter dem <code>Result</code>-Wert bewirkt fast das gleiche wie die
<code>match</code>-Ausdrücke, die wir zum Behandeln der <code>Result</code>-Werte in Codeblock 9-6
definiert haben. Wenn der Wert von <code>Result</code> ein <code>Ok</code> ist, wird der Wert
innerhalb <code>Ok</code> zurückgegeben und das Programm fortgesetzt. Wenn der Wert ein
<code>Err</code> ist, wird er als Funktionsergebnis zurückgegeben, als ob wir das
Schlüsselwort <code>return</code> verwendet hätten.</p>
<p>Es gibt einen Unterschied zwischen dem, was der <code>match</code>-Ausdruck aus Codeblock
9-6 tut, und dem, was der <code>?</code>-Operator tut: Fehlerwerte, bei denen der
<code>?</code>-Operator aufgerufen wird, durchlaufen die Funktion <code>from</code>, die im Merkmal
<code>From</code> der Standardbibliothek definiert ist und die zur Konvertierung von
Werten eines Typs in einen anderen verwendet wird. Wenn der <code>?</code>-Operator die
Funktion <code>from</code> aufruft, wird der empfangene Fehlertyp in den Fehlertyp
umgewandelt, der als Rückgabetyp der aktuellen Funktion definiert ist. Das ist
hilfreich, wenn eine Funktion einen einzigen Fehlertyp zurückgibt, um alle
möglichen Fehlerarten einer Funktion darzustellen, auch wenn Teile aus vielen
verschiedenen Gründen versagen könnten.</p>
<p>Wir könnten zum Beispiel die Funktion <code>read_username_from_file</code> in Codeblock
9-7 so ändern, dass sie einen von uns definierten Fehlertyp namens <code>OurError</code>
zurückgibt. Wenn wir auch <code>impl From&lt;io::Error&gt; for OurError</code> definieren, um
eine Instanz von <code>OurError</code> aus einem <code>io::Error</code> zu konstruieren, dann werden
die <code>?</code>-Operator-Aufrufe im Rumpf von <code>read_username_from_file</code> <code>from</code> aufrufen
und die Fehlertypen konvertieren, ohne dass weiterer Code zur Funktion
hinzugefügt werden muss.</p>
<p>Im Zusammenhang mit Codeblock 9-7 gibt das <code>?</code> am Ende des Aufrufs von
<code>File::open</code> den Wert innerhalb eines <code>Ok</code> an die Variable <code>username_file</code>
zurück. Wenn ein Fehler auftritt, beendet der Operator vorzeitig die gesamte
Funktion und gibt dem aufrufenden Code einen <code>Err</code>-Wert zurück. Dasselbe gilt
für das <code>?</code> am Ende des <code>read_to_string</code>-Aufrufs.</p>
<p>Der <code>?</code>-Operator eliminiert viel umständlichen Code und macht die
Implementierung dieser Funktion einfacher. Wir können diesen Code sogar noch
weiter verkürzen, indem wir die Methodenaufrufe unmittelbar nach dem <code>?</code>
verketten, wie in Codeblock 9-8 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open("hallo.txt")?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 9-8: Verketten von Methodenaufrufen nach dem
<code>?</code>-Operator</span></p>
<p>Wir haben das Erstellen des neuen <code>String</code> in <code>username</code> an den Anfang der
Funktion verlegt; dieser Teil hat sich nicht geändert. Anstatt eine Variable
<code>username_file</code> zu erzeugen, haben wir den Aufruf von <code>read_to_string</code> direkt
an das Ergebnis von <code>File::open("hallo.txt")?</code> gehängt. Wir haben immer noch
ein <code>?</code> am Ende des Aufrufs von <code>read_to_string</code>, und wir geben immer noch
einen <code>Ok</code>-Wert zurück, der <code>username</code> enthält, wenn sowohl <code>File::open</code> als
auch <code>read_to_string</code> erfolgreich sind, anstatt Fehler zurückzugeben. Die
Funktionalität ist wieder die gleiche wie in Codeblock 9-6 und Codeblock 9-7;
das ist nur eine andere, ergonomischere Schreibweise.</p>
<p>Codeblock 9-9 zeigt, dass es einen Weg gibt, diese Funktion noch kürzer zu
machen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string("hallo.txt")
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 9-9: Verwenden von <code>fs::read_to_string</code>,
anstatt die Datei zu öffnen und dann zu lesen</span></p>
<p>Das Einlesen einer Datei in eine Zeichenkette ist eine ziemlich häufig
benötigte Operation, daher bringt die Standardbibliothek die praktische Funktion
<code>fs::read_to_string</code> mit, die die Datei öffnet, einen neuen <code>String</code> erzeugt,
den Inhalt der Datei einliest, den Inhalt in den <code>String</code> einfügt und ihn
zurückgibt. Natürlich gibt uns die Verwendung von <code>fs::read_to_string</code> nicht
die Möglichkeit, die ganze Fehlerbehandlung zu erklären, also haben wir es
zuerst auf dem längeren Weg gemacht.</p>
<h4 id="wo-der-operator--verwendet-werden-kann"><a class="header" href="#wo-der-operator--verwendet-werden-kann">Wo der Operator <code>?</code> verwendet werden kann</a></h4>
<p>Der Operator <code>?</code> kann nur in Funktionen verwendet werden, deren Rückgabetyp mit
dem Wert, auf den <code>?</code> angewendet wird, kompatibel ist. Das liegt daran, dass
der Operator <code>?</code> so definiert ist, dass er einen Wert frühzeitig aus der
Funktion zurückgibt, genauso wie der Ausdruck <code>match</code>, den wir in Codeblock 9-6
definiert haben. In Codeblock 9-6 verwendet <code>match</code> einen <code>Result</code>-Wert, und
der frühe Rückgabezweig liefert einen <code>Err(e)</code>-Wert. Der Rückgabetyp der
Funktion muss ein <code>Result</code> sein, damit er mit <code>return</code> kompatibel ist.</p>
<p>Schauen wir uns in Codeblock 9-10 an, was passiert, wenn wir den <code>?</code>-Operator
in einer Funktion <code>main</code> verwenden, deren Rückgabetyp nicht mit dem Typ des
Wertes, für den wir <code>?</code> verwenden, kompatibel ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">use std::fs::File;

fn main() {
    let greeting_file = File::open("hallo.txt")?;
}</code></pre></pre>
<p><span class="caption">Codeblock 9-10: Der Versuch, das <code>?</code> in der Funktion
<code>main</code> zu verwenden, die <code>()</code> zurückgibt, lässt sich nicht kompilieren.</span></p>
<p>Dieser Code öffnet eine Datei, was fehlschlagen kann. Der <code>?</code>-Operator folgt
dem <code>Result</code>-Wert, der von <code>File::open</code> zurückgegeben wird, aber diese Funktion
<code>main</code> hat den Rückgabetyp <code>()</code>, nicht <code>Result</code>. Wenn wir diesen Code
kompilieren, erhalten wir folgende Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling playground v0.0.1 (/playground)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hallo.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`
help: consider adding return type
  |
3 ~ fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
4 |     let greeting_file = File::open("hallo.txt")?;
5 +     Ok(())
  |

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin "error-handling") due to 1 previous error
</code></pre>
<p>Dieser Fehler weist darauf hin, dass wir den <code>?</code>-Operator nur in einer Funktion
verwenden dürfen, die <code>Result</code> oder <code>Option</code> oder einen anderen Typ, der
<code>FromResidual</code> implementiert, zurückgibt.</p>
<p>Um den Fehler zu beheben, hast du zwei Möglichkeiten. Eine Möglichkeit besteht
darin, den Rückgabetyp deiner Funktion so zu ändern, dass er mit dem Wert
kompatibel ist, für den du den Operator <code>?</code> verwendest, wenn dem nichts
entgegensteht. Die andere Möglichkeit besteht darin, <code>match</code> oder eine der
Methoden von <code>Result&lt;T, E&gt;</code> zu verwenden, um <code>Result&lt;T, E&gt;</code> in geeigneter Weise
zu behandeln.</p>
<p>Die Fehlermeldung hat auch erwähnt, dass <code>?</code> ebenso mit <code>Option&lt;T&gt;</code>-Werten
verwendet werden kann. Wie bei der Verwendung von <code>?</code> für <code>Result</code>, kannst du
<code>?</code> für <code>Option</code> nur in einer Funktion verwenden, die eine <code>Option</code> zurückgibt.
Das Verhalten des <code>?</code>-Operators beim Aufruf auf eine <code>Option&lt;T&gt;</code> ist ähnlich
dem Verhalten, wenn er auf ein <code>Result&lt;T, E&gt;</code> aufgerufen wird: Wenn der Wert
<code>None</code> ist, wird <code>None</code> zu diesem Zeitpunkt von der Funktion zurückgegeben.
Wenn der Wert <code>Some</code> ist, ist der Wert innerhalb von <code>Some</code> der resultierende
Wert des Ausdrucks und die Funktion wird fortgesetzt. Codeblock 9-11 zeigt ein
Beispiel für eine Funktion, die das letzte Zeichen der ersten Zeile in einem
gegebenen Text findet.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line("Hallo Welt\nWie geht es dir heute?"),
</span><span class="boring">        Some('t')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(""), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line("\nhi"), None);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 9-11: Verwenden des <code>?</code>-Operators auf einem
<code>Option&lt;T&gt;</code>-Wert</span></p>
<p>Diese Funktion gibt <code>Option&lt;char&gt;</code> zurück, weil es möglich ist, dass ein
Zeichen vorhanden ist, aber es ist auch möglich, dass keines vorhanden ist.
Dieser Code nimmt das Zeichenkettenanteilstyp-Argument <code>text</code> und ruft die
Methode <code>lines</code> darauf auf, die einen Iterator über die Zeilen der Zeichenkette
zurückgibt. Da diese Funktion die erste Zeile untersuchen will, ruft sie <code>next</code>
auf dem Iterator auf, um den ersten Wert vom Iterator zu erhalten. Wenn <code>text</code>
die leere Zeichenkette ist, gibt dieser Aufruf von <code>next</code> <code>None</code> zurück, und
hier können wir <code>?</code> benutzen, um zu stoppen und <code>None</code> von
<code>last_char_of_first_line</code> zurückgeben, wenn dies der Fall ist. Wenn <code>text</code>
nicht die leere Zeichenkette ist, gibt <code>next</code> einen <code>Some</code>-Wert zurück, der
einen Zeichenkettenanteilstyp der ersten Zeile in <code>text</code> enthält.</p>
<p>Das <code>?</code> extrahiert den Zeichenkettenanteilstyp, und wir können <code>chars</code> auf
diesem Zeichenkettenanteilstyp aufrufen, um einen Iterator für seine Zeichen zu
erhalten. Wir sind am letzten Zeichen in dieser ersten Zeile interessiert, also
rufen wir <code>last</code> auf, um das letzte Element im Iterator über die Zeichen
zurückzugeben. Dies ist eine <code>Option</code>, weil die erste Zeile die leere
Zeichenkette sein kann, wenn <code>text</code> mit einer Leerzeile beginnt, aber Zeichen
in anderen Zeilen enthält, wie in <code>"\nhi"</code>. Wenn es jedoch ein letztes Zeichen
in der ersten Zeile gibt, wird es in der Variante <code>Some</code> zurückgegeben. Der
<code>?</code>-Operator in der Mitte gibt uns eine prägnante Möglichkeit, diese Logik
auszudrücken, und diese Funktion kann in einer Zeile implementiert werden. Wenn
wir den <code>?</code>-Operator nicht auf <code>Option</code> verwenden könnten, müssten wir diese
Logik mit weiteren Methodenaufrufen oder einem Ausdruck implementieren.</p>
<p>Beachte, dass du den <code>?</code>-Operator auf ein <code>Result</code> in einer Funktion anwenden
kannst, die <code>Result</code> zurückgibt, und du kannst den <code>?</code>-Operator auf eine
<code>Option</code> in einer Funktion anwenden, die <code>Option</code> zurückgibt, aber du kannst
nicht beides mischen. Der Operator <code>?</code> konvertiert nicht automatisch ein
<code>Result</code> in eine <code>Option</code> oder umgekehrt; in diesen Fällen kannst du Methoden
wie <code>ok</code> für <code>Result</code> oder <code>ok_or</code> für <code>Option</code> verwenden, die die Umwandlung
explizit vornehmen.</p>
<p>Bis jetzt haben alle <code>main</code>-Funktionen, die wir benutzt haben, <code>()</code>
zurückgegeben. Die Funktion <code>main</code> ist etwas Besonderes, weil sie der Ein- und
Ausstiegspunkt von ausführbaren Programmen ist, und es gibt Einschränkungen
hinsichtlich ihres Rückgabetyps, damit sich die Programme wie erwartet
verhalten.</p>
<p>Glücklicherweise kann <code>main</code> auch ein <code>Result&lt;(), E&gt;</code> zurückgeben. Codeblock
9-12 enthält den Code aus Codeblock 9-10, aber wir haben den Rückgabetyp von
<code>main</code> in <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> geändert und am Ende einen Rückgabewert
<code>Ok(())</code> hinzugefügt. Dieser Code wird nun kompilieren:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open("hallo.txt")?;

    Ok(())
}</code></pre>
<p><span class="caption">Codeblock 9-12: Die Änderung von <code>main</code> zur Rückgabe von
<code>Result&lt;(), E&gt;</code> erlaubt die Verwendung des <code>?</code>-Operators für
<code>Result</code>-Werte.</span></p>
<p>Der Typ <code>Box&lt;dyn Error&gt;</code> ist ein <em>Merkmalsobjekt</em> (trait object), über das wir
in <a href="ch18-02-trait-objects.html">„Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen
erlauben“</a> in Kapitel 18 sprechen werden. Vorerst kannst du
<code>Box&lt;dyn Error&gt;</code> als „eine beliebige Fehlerart“ ansehen. Das Verwenden von <code>?</code>
auf einen <code>Result</code>-Wert in einer Funktion <code>main</code> mit dem Fehlertyp <code>Box&lt;dyn Error&gt;</code> ist erlaubt, weil dadurch ein <code>Err</code>-Wert frühzeitig zurückgegeben
werden kann. Obwohl der Rumpf dieser Funktion <code>main</code> nur Fehler des Typs
<code>std::io::Error</code> zurückgibt, ist diese Signatur durch die Angabe von
<code>Box&lt;dyn Error&gt;</code> auch dann noch korrekt, wenn weiterer Code, der andere Fehler
zurückgibt, dem Rumpf von <code>main</code> hinzugefügt wird.</p>
<p>Wenn eine Funktion <code>main</code> ein <code>Result&lt;(), E&gt;</code> zurückgibt, beendet sich die
ausführbare Datei mit einem Wert von <code>0</code>, wenn <code>main</code> den Wert <code>Ok(())</code>
zurückgibt, und mit einem Wert ungleich Null, wenn <code>main</code> einen <code>Err</code>-Wert
zurückgibt. In C geschriebene ausführbare Programme geben beim Beenden ganze
Zahlen zurück: Programme, die erfolgreich beendet werden, geben die Zahl <code>0</code>
zurück, und Programme, die einen Fehler machen, geben eine Zahl ungleich <code>0</code>
zurück. Rust gibt ebenfalls ganze Zahlen aus ausführbaren Dateien zurück, um
mit dieser Konvention kompatibel zu sein.</p>
<p>Die Funktion <code>main</code> kann jeden Typ zurückgeben, der das <a href="https://doc.rust-lang.org/std/process/trait.Termination.html">Merkmal
<code>std::process::Termination</code></a> implementiert, das eine Funktion
<code>report</code> enthält, die einen <code>ExitCode</code> zurückgibt. Weitere Informationen zur
Implementierung des Merkmals <code>Termination</code> für deine eigenen Typen findest du
in der Dokumentation der Standardbibliothek.</p>
<p>Nachdem wir nun die Einzelheiten des Aufrufs von <code>panic!</code> und der Rückgabe von
<code>Result</code> besprochen haben, wollen wir zum Thema zurückkehren, wie wir
entscheiden können, was in welchen Fällen geeignet ist.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="wann-panic-aufrufen-und-wann-nicht"><a class="header" href="#wann-panic-aufrufen-und-wann-nicht">Wann <code>panic!</code> aufrufen und wann nicht?</a></h2>
<p>Wie entscheidest du also, wann du <code>panic!</code> aufrufen und wann <code>Result</code>
zurückgeben sollst? Wenn Code abbricht, gibt es keine Möglichkeit sich vom
Fehler zu erholen. Du könntest <code>panic!</code> in jeder Fehlersituation aufrufen,
unabhängig davon, ob es eine Möglichkeit zur Fehlerbehebung gibt oder nicht,
aber dann triffst du die Entscheidung für den aufrufenden Code, dass eine
Situation nicht rettbar ist. Wenn du dich dafür entscheidest, einen
<code>Result</code>-Wert zurückzugeben, überlässt du dem aufrufenden Code die
Wahlmöglichkeit, anstatt die Entscheidung für ihn zu treffen. Der aufrufende
Code könnte sich dafür entscheiden, sich vom Fehler auf eine sinnvolle Weise
zu erholen, oder er könnte sich dafür entscheiden, dass ein <code>Err</code>-Wert in
diesem Fall nicht behebbar ist und <code>panic!</code> aufrufen, und so deinen behebbaren
Fehler in einen nicht behebbaren verwandeln. Daher ist die Rückgabe von
<code>Result</code> eine gute Standardwahl, wenn du eine Funktion definierst, die
fehlschlagen könnte.</p>
<p>In Beispielen, Prototyp-Code und Tests ist es sinnvoller, Code zu schreiben,
der das Programm abbricht, anstatt ein <code>Result</code> zurückzugeben. Lass uns
herausfinden, warum das so ist, und dann Situationen besprechen, in denen der
Compiler nicht feststellen kann, dass ein Fehler unmöglich ist, du als Mensch
aber schon. Das Kapitel schließt mit einigen allgemeinen Richtlinien zur
Entscheidung, ob in Bibliothekscode ein Programm abgebrochen werden soll.</p>
<h3 id="beispiele-code-prototypen-und-tests"><a class="header" href="#beispiele-code-prototypen-und-tests">Beispiele, Code-Prototypen und Tests</a></h3>
<p>Wenn du ein Beispiel schreibst, um ein Konzept zu veranschaulichen, kann die
Einbeziehung von robustem Fehlerbehandlungscode das Beispiel unklarer machen.
In Beispielen wird davon ausgegangen, dass der Aufruf einer Methode wie
<code>unwrap</code>, die das Programm abbrechen könnte, als Platzhalter für die Art und
Weise gedacht ist, wie deine Anwendung mit Fehlern umgehen soll, die je
nachdem, was der Rest deines Codes tut, unterschiedlich sein können.</p>
<p>In ähnlicher Weise sind die Methoden <code>unwrap</code> und <code>expect</code> bei Prototypen sehr
praktisch, wenn du noch nicht entscheiden willst, wie mit Fehlern umzugehen
ist. Du hinterlässt klare Markierungen in deinem Code für später, wenn du dein
Programm robuster machst.</p>
<p>Wenn ein Methodenaufruf in einem Test fehlschlägt, würdest du wollen, dass der
gesamte Test fehlschlägt, auch wenn diese Methode nicht die zu testende
Funktionalität ist. Da ein Test mit <code>panic!</code> als fehlgeschlagen markiert wird,
ist der Aufruf von <code>unwrap</code> und <code>expect</code> genau das, was passieren sollte.</p>
<h3 id="fälle-in-denen-du-mehr-informationen-als-der-compiler-hast"><a class="header" href="#fälle-in-denen-du-mehr-informationen-als-der-compiler-hast">Fälle, in denen du mehr Informationen als der Compiler hast</a></h3>
<p>Es wäre auch sinnvoll, <code>unwrap</code> oder <code>expect</code> aufzurufen, wenn du eine andere
Logik hast, die sicherstellt, dass <code>Result</code> einen <code>Ok</code>-Wert hat, aber die Logik
kann vom Compiler nicht verstanden werden. Du wirst immer noch ein <code>Result</code>
haben, mit dem du umgehen musst: Welche Operation auch immer du aufrufst, es
besteht immer noch die Möglichkeit, dass sie im Allgemeinen scheitert, auch
wenn es in deiner speziellen Situation logischerweise unmöglich ist. Wenn du
durch manuelle Codeinspektion sicherstellen kannst, dass du niemals eine
<code>Err</code>-Variante haben wirst, ist es vollkommen akzeptabel, <code>unwrap</code> aufzurufen,
und noch besser ist es, den Grund, warum du glaubst, dass du niemals eine
<code>Err</code>-Variante haben wirst, im <code>expect</code>-Text zu dokumentieren. Hier ist ein
Beispiel:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::IpAddr;

let home: IpAddr = "127.0.0.1"
    .parse()
    .expect("Fest programmierte IP-Adresse sollte gültig sein");
<span class="boring">}</span></code></pre></pre>
<p>Wir erstellen eine <code>IpAddr</code>-Instanz, indem wir eine hartkodierte Zeichenkette
parsen. Wir können sehen, dass <code>127.0.0.1</code> eine gültige IP-Adresse ist, sodass
es akzeptabel ist, hier <code>expect</code> zu verwenden. Eine hartkodierte, gültige
Zeichenkette ändert jedoch nicht den Rückgabetyp der Methode <code>parse</code>: Wir
erhalten immer noch einen <code>Result</code>-Wert und der Compiler wird von uns
verlangen, <code>Result</code> so zu behandeln, als ob die <code>Err</code>-Variante möglich wäre,
weil der Compiler nicht klug genug ist, um zu erkennen, dass diese
Zeichenkette stets eine gültige IP-Adresse ist. Wenn die
IP-Adressen-Zeichenkette von einem Benutzer kam, anstatt fest im Programm
kodiert zu sein, und daher möglicherweise fehlschlagen könnte, würden wir
stattdessen definitiv <code>Result</code> auf eine robustere Weise behandeln wollen.</p>
<h3 id="richtlinien-zur-fehlerbehandlung"><a class="header" href="#richtlinien-zur-fehlerbehandlung">Richtlinien zur Fehlerbehandlung</a></h3>
<p>Es ist ratsam, dass dein Code abbricht, wenn es möglich ist, dass dein Code in
einem schlechten Zustand enden könnte. In diesem Zusammenhang ist ein
<em>schlechter Zustand</em> (bad state) dann gegeben, wenn eine Annahme, eine
Garantie, ein Vertrag oder eine Invariante gebrochen wurde, z.B. wenn ungültige
Werte, widersprüchliche Werte oder fehlende Werte an deinen Code übergeben
werden – sowie einer oder mehrere der folgenden Punkte zutreffen:</p>
<ul>
<li>Der schlechte Zustand ist etwas Unerwartetes, im Gegensatz zu etwas, das
wahrscheinlich gelegentlich vorkommt, wie die Eingabe von Daten in einem
falschen Format durch einen Benutzer.</li>
<li>Dein Code muss sich nach diesem Punkt darauf verlassen können, dass er sich
in keinem schlechten Zustand befindet, anstatt bei jedem Schritt auf das
Problem zu prüfen.</li>
<li>Es gibt keine gute Möglichkeit, diese Informationen in den von dir
verwendeten Typen zu kodieren. Wir werden in <a href="ch18-03-oo-design-patterns.html#kodieren-von-zust%C3%A4nden-und-verhalten-als-typen">„Kodieren von Zuständen und
Verhalten als Typen“</a> in Kapitel 18 ein Beispiel dafür
durcharbeiten.</li>
</ul>
<p>Wenn jemand deinen Code aufruft und Werte übergibt, die keinen Sinn ergeben,
ist es am besten, einen Fehler zurückzugeben, damit der Benutzer der Bibliothek
entscheiden kann, was er in diesem Fall tun möchte. In Fällen, in denen eine
Fortsetzung unsicher oder schädlich sein könnte, ist es jedoch am besten,
<code>panic!</code> aufzurufen und die Person, die deine Bibliothek verwendet, auf den
Fehler in ihrem Code hinzuweisen, damit sie ihn während der Entwicklung beheben
kann. In ähnlicher Weise ist <code>panic!</code> oft angebracht, wenn du externen Code
aufrufst, der sich deiner Kontrolle entzieht und einen ungültigen Zustand
zurückgibt, den du nicht beheben kannst.</p>
<p>Wenn jedoch ein Fehler erwartet wird, ist es sinnvoller, ein <code>Result</code>
zurückzugeben, als <code>panic!</code> aufzurufen. Beispiele hierfür sind ein Parser, dem
fehlerhafte Daten übergeben werden, oder eine HTTP-Anfrage, die einen Status
zurückgibt, der anzeigt, dass du ein Aufruflimit erreicht hast. In diesen
Fällen zeigt der Rückgabetyp <code>Result</code> an, dass ein Fehler eine erwartete
Möglichkeit ist, bei der der aufrufende Code entscheiden muss, wie er damit
umgeht.</p>
<p>Wenn dein Code einen Vorgang ausführt, der einen Benutzer gefährden könnte,
wenn er mit ungültigen Werten aufgerufen wird, sollte dein Code zuerst
überprüfen, ob die Werte gültig sind, und das Programm abbrechen, wenn die
Werte nicht gültig sind. Dies geschieht hauptsächlich aus Sicherheitsgründen:
Der Versuch, mit ungültigen Daten zu operieren, kann deinen Code Schwachstellen
aussetzen. Dies ist der Hauptgrund dafür, dass die Standardbibliothek <code>panic!</code>
aufruft, wenn du versuchst, einen unzulässigen Speicherzugriff durchzuführen:
Der Versuch, auf Speicher zuzugreifen, der nicht zur aktuellen Datenstruktur
gehört, ist ein häufiges Sicherheitsproblem. Funktionen haben oft <em>Verträge</em>
(contracts): Ihr Verhalten ist nur dann garantiert, wenn die Eingaben bestimmte
Anforderungen erfüllen. Abzubrechen, wenn der Vertrag verletzt wird, ist
sinnvoll, weil eine Vertragsverletzung immer auf einen Fehler auf der
Aufruferseite hinweist und es sich nicht um eine Fehlerart handelt, die der
aufgerufende Code explizit behandeln sollte. Tatsächlich gibt es keinen
vernünftigen Weg, wie sich der aufrufende Code vom Fehler erholen kann; die
aufrufenden <em>Programmierer</em> müssen den Code reparieren. Verträge zu einer
Funktion sollten in der API-Dokumentation der Funktion erläutert werden,
insbesondere wenn deren Verletzung zu einem Programmabbruch führt.</p>
<p>Zahlreiche Fehlerprüfungen in deinen Funktionen wären jedoch langatmig und
störend. Glücklicherweise kannst du das Typsystem von Rust (und damit die
Typprüfung durch den Compiler) verwenden, um viele Prüfungen für dich zu
übernehmen. Wenn deine Funktion einen besonderen Typ als Parameter hat, kannst
du mit der Logik deines Codes fortfahren, da du weißt, dass der Compiler
bereits sichergestellt hat, dass du einen gültigen Wert hast. Wenn du zum
Beispiel einen Typ anstatt einer <code>Option</code> hast, erwartet dein Programm <em>etwas</em>
statt <em>nichts</em>. Dein Code muss dann nicht zwei Fälle für die Varianten <code>Some</code>
und <code>None</code> behandeln: Er wird nur einen Fall mit definitiv einem Wert haben.
Code, der versucht, nichts an deine Funktion zu übergeben, lässt sich nicht
einmal kompilieren, sodass deine Funktion diesen Fall zur Laufzeit nicht prüfen
muss. Ein anderes Beispiel ist die Verwendung eines vorzeichenlosen
Ganzzahl-Typs wie <code>u32</code>, der sicherstellt, dass der Parameter niemals negativ
ist.</p>
<h3 id="benutzerdefinierte-typen-für-die-validierung-erstellen"><a class="header" href="#benutzerdefinierte-typen-für-die-validierung-erstellen">Benutzerdefinierte Typen für die Validierung erstellen</a></h3>
<p>Gehen wir noch einen Schritt weiter, indem wir das Typsystem von Rust verwenden,
um sicherzustellen, dass wir einen gültigen Wert haben, und betrachten wir die
Erstellung eines benutzerdefinierten Typs für die Validierung. Erinnere
dich an das Ratespiel in Kapitel 2, bei dem unser Code den Benutzer
aufforderte, eine Zahl zwischen 1 und 100 zu erraten. Wir haben nie überprüft,
ob die Schätzung des Benutzers zwischen diesen Zahlen lag, bevor wir sie mit
unserer Geheimzahl verglichen haben; wir haben nur überprüft, ob die Schätzung
richtig war. In diesem Fall waren die Folgen nicht sehr gravierend: Unsere
Ausgabe von „zu groß“ oder „zu klein“ wäre immer noch richtig. Aber es wäre
eine nützliche Erweiterung, um den Benutzer zu gültigen Rateversuchen zu führen
und ein unterschiedliches Verhalten zu zeigen, wenn der Benutzer eine Zahl
eingibt, die außerhalb des Bereichs liegt, als wenn der Benutzer stattdessen
z.B. Buchstaben eingibt.</p>
<p>Eine Möglichkeit, dies zu tun, wäre, die Eingabe als <code>i32</code> statt nur als <code>u32</code>
zu parsen, um potenziell negative Zahlen zuzulassen, und dann eine
Bereichsprüfung der Zahl zu ergänzen, etwa so:</p>
<p><span class="Dateiname">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Rate eine Zahl!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span>    loop {
        // --abschneiden--

<span class="boring">        println!("Bitte gib deine Vermutung ein.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Fehler beim Lesen der Zeile");
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!("Die geheime Zahl wird zwischen 1 und 100 liegen.");
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --abschneiden--
<span class="boring">            Ordering::Less =&gt; println!("Zu klein!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Zu groß!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("Du hast gewonnen!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
<p>Der <code>if</code>-Ausdruck prüft, ob unser Wert außerhalb des Bereichs liegt, informiert
den Benutzer über das Problem und ruft <code>continue</code> auf, um die nächste Iteration
der Schleife zu starten und um eine weitere Schätzung zu bitten. Nach dem
<code>if</code>-Ausdruck können wir mit dem Vergleich zwischen <code>guess</code> und der Geheimzahl
fortfahren, wobei wir wissen, dass <code>guess</code> zwischen 1 und 100 liegt.</p>
<p>Dies ist jedoch keine ideale Lösung: Wenn es zwingend erforderlich wäre, dass das
Programm nur mit Werten zwischen 1 und 100 arbeitet, und wir viele Funktionen
mit dieser Anforderung haben, wäre eine solche Prüfung in jeder Funktion mühsam
(und könnte die Leistung beeinträchtigen).</p>
<p>Stattdessen können wir einen neuen Typ in einem bestimmten Modul erstellen und
die Validierungen in eine Funktion geben, um eine Instanz des Typs zu erzeugen,
anstatt die Validierungen überall zu wiederholen. Auf diese Weise ist es für
die Funktionen sicher, den neuen Typ in ihren Signaturen zu verwenden und die
erhaltenen Werte bedenkenlos zu nutzen. Codeblock 9-13 zeigt eine Möglichkeit,
einen Typ <code>Guess</code> zu definieren, der nur dann eine Instanz von <code>Guess</code> erzeugt,
wenn die Funktion <code>new</code> einen Wert zwischen 1 und 100 erhält.</p>
<p><span class="Dateiname">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Der Schätzwert muss zwischen 1 und 100 liegen, ist jedoch {value}.");
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 9-13: Ein Typ <code>Guess</code>, der nur bei Werten
zwischen 1 und 100 fortsetzt</span></p>
<p>Zuerst erstellen wir ein neues Modul namens <code>guessing_game</code>. Danach definieren
wir in diesem Modul eine Struktur <code>Guess</code>, die ein Feld <code>value</code> hat, das einen
<code>i32</code> enthält. Hier wird die Nummer gespeichert.</p>
<p>Dann implementieren wir die zugehörige Funktion <code>new</code> für <code>Guess</code>, die
Instanzen von <code>Guess</code> erzeugt. Die Funktion <code>new</code> ist so definiert, dass sie
einen Parameter <code>value</code> vom Typ <code>i32</code> entgegen nimmt und eine <code>Guess</code>-Instanz
zurückgibt. Der Code im Funktionsrumpf von <code>new</code> testet den Wert in <code>value</code>, um
sicherzustellen, dass er zwischen 1 und 100 liegt. Wenn <code>value</code> diesen Test
nicht besteht, rufen wir <code>panic!</code> auf, was den Programmierer des aufrufenden
Codes darauf aufmerksam macht, dass er einen Fehler hat, den er beheben muss,
denn ein <code>Guess</code> mit einem Wert außerhalb dieses Bereichs zu erzeugen, würde
den Vertrag verletzen, auf den sich <code>Guess::new</code> verlässt. Die Bedingungen,
unter denen <code>Guess::new</code> das Programm abbricht, sollten in der öffentlich
zugänglichen API-Dokumentation genannt werden; wir werden die
Dokumentationskonventionen, die auf die Möglichkeit eines <code>panic!</code>-Aufrufs
hinweisen, in der API-Dokumentation behandeln, die du in Kapitel 14 erstellst.
Wenn <code>value</code> den Test besteht, erstellen wir eine neue <code>Guess</code>-Instanz, deren
Feld <code>value</code> den Parameterwert <code>value</code> erhält, und geben die Instanz zurück.</p>
<p>Als nächstes implementieren wir eine Methode namens <code>value</code>, die <code>self</code>
ausleiht, keine anderen Parameter hat und ein <code>i32</code> zurückgibt. Diese
Methodenart wird manchmal als <em>Abfragemethode</em> (getter) bezeichnet, weil ihr
Zweck darin besteht, Daten aus ihren Feldern zurückzugeben. Diese öffentliche
Methode ist notwendig, weil das Feld <code>value</code> der Struktur <code>Guess</code> privat ist.
Es ist wichtig, dass das Feld <code>value</code> privat ist, damit Code, der die Struktur
<code>Guess</code> verwendet, <code>value</code> nicht direkt setzen kann: Code außerhalb des Moduls
<code>guessing_game</code> <em>muss</em> die Funktion <code>Guess::new</code> verwenden, um eine Instanz von
<code>Guess</code> zu erzeugen, wodurch sichergestellt wird, dass es keine Möglichkeit
gibt, dass <code>Guess</code> einen <code>Wert</code> hat, der nicht durch die Bedingungen in der
Funktion <code>Guess::new</code> überprüft wurde.</p>
<p>Eine Funktion, die einen Parameter hat oder nur Zahlen zwischen 1 und 100
zurückgibt, könnte dann in ihrer Signatur angeben, dass sie ein <code>Guess</code>
anstelle eines <code>i32</code> entgegennimmt oder zurückgibt und bräuchte dann in ihrem
Rumpf keine zusätzlichen Prüfungen durchzuführen.</p>
<h2 id="zusammenfassung-8"><a class="header" href="#zusammenfassung-8">Zusammenfassung</a></h2>
<p>Die Fehlerbehandlungsfunktionen von Rust sollen dir helfen, robusteren Code zu
schreiben. Das Makro <code>panic!</code> signalisiert, dass sich dein Programm in einem
Zustand befindet, mit dem es nicht umgehen kann, und ermöglicht es dir, den
Prozess anzuhalten, anstatt zu versuchen, mit ungültigen oder falschen Werten
fortzufahren. Die Aufzählung <code>Result</code> verwendet das Typsystem von Rust, um
anzuzeigen, dass Operationen so fehlschlagen könnten, dass dein Code sich davon
wieder erholen könnte. Du kannst <code>Result</code> verwenden, um dem Code, der deinen
Code aufruft, mitzuteilen, dass er auch mit potentiellem Erfolg und Misserfolg
umgehen muss. Das Verwenden von <code>panic!</code> und <code>Result</code> in den entsprechenden
Situationen wird deinen Code angesichts unvermeidlicher Probleme zuverlässiger
machen.</p>
<p>Nachdem du nun nützliche Möglichkeiten gesehen hast, wie die Standardbibliothek
generische Datentypen mit den Enums <code>Option</code> und <code>Result</code> verwendet, werden wir
darüber sprechen, wie generische Datentypen funktionieren und wie du sie in
deinem Code verwenden kannst.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generische-typen-merkmale-traits-und-lebensdauer"><a class="header" href="#generische-typen-merkmale-traits-und-lebensdauer">Generische Typen, Merkmale (traits) und Lebensdauer</a></h1>
<p>Jede Programmiersprache verfügt über Werkzeuge, mit denen die Duplizierung von
Konzepten (duplication of concepts) effektiv gehandhabt werden kann. In Rust
ist ein solches Werkzeug der <em>generische Datentyp</em> (generics): Abstrakte
Stellvertreter für konkrete Typen oder andere Eigenschaften. Wir können das
Verhalten generischer Datentypen oder ihre Beziehung zu anderen generischen
Datentypen ausdrücken, ohne zu wissen, was an ihrer Stelle beim Kompilieren und
Ausführen des Codes stehen wird.</p>
<p>Funktionen können Parameter eines generischen Typs anstelle eines konkreten
Typs wie <code>i32</code> oder <code>String</code> annehmen, so wie sie Parameter mit unbekannten
Werten annehmen, um denselben Code auf mehrere konkrete Werte anzuwenden.
Tatsächlich haben wir generische Datentypen bereits in Kapitel 6 mit
<code>Option&lt;T&gt;</code>, in Kapitel 8 mit <code>Vec&lt;T&gt;</code> und <code>HashMap&lt;K, V&gt;</code> und in Kapitel 9 mit
<code>Result&lt;T, E&gt;</code> verwendet. In diesem Kapitel erfährst du, wie du deine eigenen
Typen, Funktionen und Methoden mit generischen Datentypen definieren kannst!</p>
<p>Zunächst werden wir uns anschauen, wie eine Funktion extrahiert werden kann, um
Code-Duplizierung zu reduzieren. Danach verwenden wir dieselbe Technik, um aus
zwei Funktionen, die sich nur im Datentyp ihrer Parameter unterscheiden, eine
generische Funktion zu machen. Wir werden auch erklären, wie generische Typen
in Struktur- (struct) und Aufzählungsdefinitionen (enum) verwendet werden
können.</p>
<p>Dann wirst du lernen, wie man <em>Merkmale</em> (traits) verwendet, um Verhalten auf
generische Weise zu definieren. Du kannst Merkmale mit generischen Typen
kombinieren, um einen generischen Typ auf solche Typen einzuschränken, die ein
bestimmtes Verhalten aufweisen, im Gegensatz zu einem beliebigen Typ.</p>
<p>Schließlich werden wir die <em>Lebensdauer</em> (lifetimes) besprechen: Eine Spielart
generischer Typen, die dem Compiler Informationen darüber gibt, wie
Referenzen zueinander in Beziehung stehen. Lebensdauern ermöglichen es uns, dem
Compiler genügend Informationen über ausgeliehene Werte zu geben, sodass er
sicherstellen kann, dass Referenzen in mehr Situationen gültig sind, als er es
ohne unsere Hilfe könnte.</p>
<h2 id="duplikate-entfernen-durch-extrahieren-einer-funktion"><a class="header" href="#duplikate-entfernen-durch-extrahieren-einer-funktion">Duplikate entfernen durch Extrahieren einer Funktion</a></h2>
<p>Mit Hilfe von generischen Typen können wir spezifische Typen durch einen
Platzhalter ersetzen, der mehrere Typen repräsentiert, um Code-Duplizierung zu
vermeiden. Bevor wir uns mit der generischen Syntax befassen, wollen wir uns
ansehen, wie man Duplikate auf eine Weise entfernt, die keine generischen Typen
erfordert, indem man eine Funktion extrahiert, die spezifische Werte durch
einen Platzhalter ersetzt, der mehrere Werte repräsentiert. Dann wenden wir die
gleiche Technik an, um eine generische Funktion zu extrahieren! Wenn du dir
ansiehst, wie du doppelten Code erkennst, den du in eine Funktion extrahieren
kannst, wirst du beginnen, doppelten Code zu erkennen, der generische Typen
verwenden kann.</p>
<p>Wir werden mit dem kurzen Programm in Codeblock 10-1 beginnen, das die größte
Zahl in einer Liste findet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("Die größte Zahl ist {largest}");
<span class="boring">    assert_eq!(*largest, 100);
</span>}</code></pre></pre>
<p><span class="caption">Codeblock 10-1: Finden der größten Zahl in einer Liste
von Zahlen</span></p>
<p>Wir speichern eine Liste von ganzen Zahlen in der Variablen <code>number_list</code> und
weisen eine Referenz der ersten Zahl der Liste einer Variablen namens <code>largest</code>
zu. Dann iterieren wir über alle Zahlen in der Liste und wenn die aktuelle Zahl
größer als die in <code>largest</code> gespeicherte Zahl ist, ersetzen wir die Referenz in
dieser Variablen. Wenn die aktuelle Zahl jedoch kleiner oder gleich der größten
bisher gefundenen Zahl ist, ändert sich die Variable nicht, und der Code geht
zur nächsten Zahl in der Liste weiter. Nach dem Durchlaufen aller Zahlen in der
Liste sollte <code>largest</code> auf die größte Zahl referenzieren, in diesem Fall 100.</p>
<p>Wir haben nun die Aufgabe bekommen, die größte Zahl in zwei verschiedenen
Zahlenlisten zu finden. Zu diesem Zweck können wir den Code in Codeblock 10-1
duplizieren und dieselbe Logik an zwei verschiedenen Stellen im Programm
verwenden, wie in Codeblock 10-2 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("Die größte Zahl ist {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("Die größte Zahl ist {largest}");
}</code></pre></pre>
<p><span class="caption">Codeblock 10-2: Code zum Auffinden der größten Zahl in
<em>zwei</em> Zahlenlisten</span></p>
<p>Obwohl dieser Code funktioniert, ist das Duplizieren von Code mühsam und
fehleranfällig. Außerdem müssen wir daran denken, den Code an mehreren Stellen
zu aktualisieren, wenn wir ihn ändern wollen.</p>
<p>Um diese Redundanz zu eliminieren, können wir eine Abstraktion schaffen, indem
wir eine Funktion definieren, die auf einer beliebigen Liste ganzer Zahlen
operiert, die ihr als Parameter übergeben wird. Diese Lösung macht unseren Code
klarer und lässt uns das Konzept, die größte Zahl in einer Liste zu finden,
abstrakter ausdrücken.</p>
<p>In Codeblock 10-3 extrahieren wir den Code, der die größte Zahl findet, in eine
Funktion namens <code>largest</code>. Dann rufen wir die Funktion auf, um die größte Zahl
in den beiden Listen aus Codeblock 10-2 zu finden. Wir könnten die Funktion
auch auf jede andere Liste von <code>i32</code>-Werten anwenden, die wir in Zukunft haben
könnten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("Die größte Zahl ist {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!("Die größte Zahl ist {result}");
<span class="boring">    assert_eq!(*result, 6000);
</span>}</code></pre></pre>
<p><span class="caption">Codeblock 10-3: Abstrahierter Code, um die größte Zahl in
zwei Listen zu finden</span></p>
<p>Die Funktion <code>largest</code> hat einen Parameter <code>list</code>, der einen beliebigen
Anteilstyp von <code>i32</code>-Werten repräsentiert, die wir an die Funktion übergeben
könnten. Wenn wir die Funktion aufrufen, läuft der Code also auf den
spezifischen Werten, die wir übergeben.</p>
<p>Zusammenfassend hier die Schritte, die wir unternommen haben, um den Code aus
Codeblock 10-2 in Codeblock 10-3 zu überführen:</p>
<ol>
<li>Identifiziere doppelten Code.</li>
<li>Extrahiere den doppelten Code in den Funktionskörper und spezifiziere die
Eingabe- und Rückgabewerte dieses Codes in der Funktionssignatur.</li>
<li>Aktualisiere die beiden Instanzen des doppelten Codes, um stattdessen die
Funktion aufzurufen.</li>
</ol>
<p>Als Nächstes werden wir dieselben Schritte auf generische Datentypen anwenden,
um doppelten Code zu reduzieren. Ähnlich wie der Funktionsrumpf auf einer
abstrakten Liste anstelle spezifischer Werte arbeiten kann, erlauben es
generische Datentypen, auf abstrakten Typen zu arbeiten.</p>
<p>Nehmen wir zum Beispiel an, wir hätten zwei Funktionen: Eine, die das größte
Element in einem Anteilstyp mit <code>i32</code>-Werten findet, und eine, die das größte
Element in einem Anteilstyp mit <code>char</code>-Werten findet. Wie würden wir diese
Duplizierung beseitigen? Lass es uns herausfinden!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="generische-datentypen"><a class="header" href="#generische-datentypen">Generische Datentypen</a></h2>
<p>Wir verwenden generische Datentypen (generics), um Definitionen für Elemente
wie Funktionssignaturen oder Strukturen (structs) zu erstellen, die wir dann
mit vielen verschiedenen konkreten Datentypen verwenden können. Sehen wir uns
zunächst an, wie Funktionen, Strukturen, Aufzählungen und Methoden mithilfe von
generischen Datentypen definiert werden können. Danach werden wir uns ansehen,
wie generische Datentypen die Code-Performanz beeinflussen.</p>
<h3 id="in-funktionsdefinitionen"><a class="header" href="#in-funktionsdefinitionen">In Funktionsdefinitionen</a></h3>
<p>Bei der Definition einer Funktion, die generische Datentypen verwendet,
platzieren wir die generischen Datentypen in der Signatur der Funktion, wo wir
normalerweise die Datentypen der Parameter und des Rückgabewerts angeben
würden. Dadurch wird unser Code flexibler und bietet den Aufrufern unserer
Funktion mehr Funktionalität, während gleichzeitig Code-Duplikate verhindert
werden.</p>
<p>Um mit unserer Funktion <code>largest</code> fortzufahren, zeigt Codeblock 10-4 zwei
Funktionen, die beide den größten Wert in einem Anteilstyp finden. Wir werden
diese dann in einer einzigen Funktion kombinieren, die generische Typen
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!("Die größte Zahl ist {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!("Das größte Zeichen ist {result}");
<span class="boring">    assert_eq!(*result, 'y');
</span>}</code></pre></pre>
<p><span class="caption">Codeblock 10-4: Zwei Funktionen, die sich nur in ihren
Namen und den Typen in ihren Signaturen unterscheiden</span></p>
<p>Die Funktion <code>largest_i32</code> ist diejenige, die wir in Codeblock 10-3 extrahiert
haben und die den größten <code>i32</code> in einem Anteilstyp findet. Die Funktion
<code>largest_char</code> findet das größte <code>char</code> in einem Anteilstyp. Die
Funktionsrümpfe haben den gleichen Code, also lass uns die Duplizierung
eliminieren, indem wir einen generischen Typparameter in einer einzigen
Funktion einführen.</p>
<p>Um die Typen in einer neuen, einzigen Funktion zu parametrisieren, müssen wir
den Typparameter benennen, so wie wir es für die Wertparameter einer Funktion
tun. Du kannst jeden beliebigen Bezeichner als Typparametername verwenden. Aber
wir werden <code>T</code> verwenden, weil die Typparameternamen gemäß Konvention in Rust
kurz sind, oft nur ein Buchstabe, und Rusts Typbezeichnungskonvention verwendet
CamelCase. Als Abkürzung für „Typ“ ist <code>T</code> die Standardwahl der meisten
Rust-Programmierer.</p>
<p>Wenn wir einen Parameter im Funktionsrumpf verwenden, müssen wir den
Parameternamen in der Signatur deklarieren, damit der Compiler weiß, was
dieser Name bedeutet. In ähnlicher Weise müssen wir den Typ-Parameternamen
deklarieren, bevor wir ihn in einer Funktionssignatur verwenden können. Um die
generische Funktion <code>largest</code> zu definieren, platzieren wir die
Typnamen-Deklarationen innerhalb spitzer Klammern <code>&lt;&gt;</code>, zwischen dem
Funktionsnamen und der Parameterliste, so wie hier:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>Wir lesen diese Definition wie folgt: Die Funktion <code>largest</code> ist generisch über
einen Typ <code>T</code>. Sie hat einen Parameter namens <code>list</code>, der ein Anteilstyp von
Werten des Typs <code>T</code> ist. Die Funktion <code>largest</code> gibt eine Referenz auf denn
Wert des gleichen Typs <code>T</code> zurück.</p>
<p>Codeblock 10-5 zeigt die kombinierte Funktionsdefinition <code>largest</code>, die den
generischen Datentyp in ihrer Signatur verwendet. Der Codeblock zeigt auch, wie
wir die Funktion entweder mit einem Anteilstyp von <code>i32</code>-Werten oder
<code>char</code>-Werten aufrufen können. Beachte, dass sich dieser Code noch nicht
kompilieren lässt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("Die größte Zahl ist {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("Das größte Zeichen ist {result}");
}</code></pre></pre>
<p><span class="caption">Codeblock 10-5: Die Funktion <code>largest</code> mit generischen
Typparametern; diese kompiliert aber noch nicht</span></p>
<p>Wenn wir diesen Code kompilieren, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Der Hilfetext erwähnt <code>std::cmp::PartialOrd</code>, was ein <em>Merkmal</em> (trait) ist,
und wir werden im nächsten Abschnitt über Merkmale sprechen. Vorerst bedeutet
dieser Fehler, dass der Rumpf von <code>largest</code> nicht für alle möglichen Typen
funktioniert, die <code>T</code> sein könnten. Da wir Werte des Typs <code>T</code> im Rumpf
vergleichen wollen, können wir nur Typen verwenden, deren Werte sortiert werden
können. Um Vergleiche zu ermöglichen, hat die Standardbibliothek das Merkmal
<code>std::cmp::PartialOrd</code>, das du auf Typen implementieren kannst (siehe Anhang C
für weitere Informationen zu diesem Merkmal). Um den obigen Beispielcode zu
korrigieren, müssten wir den Vorschlägen des Hilfetextes folgen und die für <code>T</code>
gültigen Typen auf diejenigen beschränken, die <code>PartialOrd</code> implementieren. Das
Beispiel würde dann kompilieren, weil die Standardbibliothek <code>PartialOrd</code>
sowohl für <code>i32</code> als auch für <code>char</code> implementiert.</p>
<h3 id="in-struktur-definitionen"><a class="header" href="#in-struktur-definitionen">In Struktur-Definitionen</a></h3>
<p>Wir können auch Strukturen definieren, um einen generischen Typparameter in
einem oder mehreren Feldern mit der <code>&lt;&gt;</code> Syntax zu verwenden. Codeblock 10-6
definiert eine Struktur <code>Point&lt;T&gt;</code>, um Koordinatenwerte <code>x</code> und <code>y</code> eines
beliebigen Typs aufzunehmen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Codeblock 10-6: Eine Struktur <code>Point&lt;T&gt;</code>, die Werte <code>x</code>
und <code>y</code> vom Typ <code>T</code> enthält</span></p>
<p>Die Syntax zum Verwenden von generischen Datentypen in Strukturdefinitionen
ähnelt der Syntax, die in Funktionsdefinitionen verwendet wird. Zuerst
deklarieren wir den Namen des Typparameters innerhalb spitzer Klammern direkt
nach dem Namen der Struktur. Dann verwenden wir den generischen Typ in der
Strukturdefinition, wo wir sonst konkrete Datentypen angeben würden.</p>
<p>Beachte, da wir nur einen generischen Typ zur Definition von <code>Point&lt;T&gt;</code>
verwendet haben, besagt diese Definition, dass die Struktur <code>Point&lt;T&gt;</code>
generisch über einen Typ <code>T</code> ist, und die beiden Felder <code>x</code> und <code>y</code> <em>denselben</em>
Typ haben, welcher Typ das auch immer sein mag. Wenn wir eine Instanz von
<code>Point&lt;T&gt;</code> erzeugen, die Werte unterschiedlichen Typs hat, wie in Codeblock
10-7, wird sich unser Code nicht kompilieren lassen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Codeblock 10-7: Die Felder <code>x</code> und <code>y</code> müssen vom
gleichen Typ sein, da beide den gleichen generischen Datentyp <code>T</code> haben.</span></p>
<p>Wenn wir in diesem Beispiel <code>x</code> den Integer-Wert 5 zuweisen, lassen wir den
Compiler wissen, dass der generische Typ <code>T</code> für diese Instanz von
<code>Point&lt;T&gt;</code> ein Integer sein wird. Wenn wir dann 4.0 für <code>y</code> angeben, das wir so
definiert haben, dass es den gleichen Typ wie <code>x</code> hat, erhalten wir einen
Typfehler wie diesen:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Um eine Struktur <code>Point</code> zu definieren, bei der <code>x</code> und <code>y</code> generische, aber
unterschiedliche, Typen haben können, können wir mehrere generische
Typparameter verwenden. Zum Beispiel ändern wir in Codeblock 10-8 die
Definition von <code>Point</code> so, dass sie über den Typen <code>T</code> und <code>U</code> generisch ist,
wobei <code>x</code> vom Typ <code>T</code> und <code>y</code> vom Typ <code>U</code> ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Codeblock 10-8: <code>Point&lt;T, U&gt;</code> ist generisch über zwei
Typen, sodass <code>x</code> und <code>y</code> Werte unterschiedlichen Typs haben können</span></p>
<p>Jetzt sind alle gezeigten Instanzen von <code>Point</code> erlaubt! Du kannst so viele
generische Typparameter in einer Definition verwenden, wie du willst, aber das
Verwenden von mehr als einigen wenigen macht deinen Code schwer lesbar. Wenn du
denkst, dass du in deinem Code viele generische Typen benötigst, könnte dies
darauf hinweisen, dass dein Code in kleinere Teile zerlegt werden muss.</p>
<h3 id="in-aufzählungsdefinitionen"><a class="header" href="#in-aufzählungsdefinitionen">In Aufzählungsdefinitionen</a></h3>
<p>Wie wir es bei Strukturen gemacht haben, können wir Aufzählungen definieren, um
generische Datentypen in ihren Varianten zu verwenden. Werfen wir noch einmal
einen Blick auf die Aufzählung <code>Option&lt;T&gt;</code>, die die Standardbibliothek bietet
und die wir in Kapitel 6 verwendet haben:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>Diese Definition dürfte für dich jetzt mehr Sinn machen. Wie du sehen kannst,
ist die Aufzählung <code>Option&lt;T&gt;</code> über dem Typ <code>T</code> generisch und hat zwei
Varianten: <code>Some</code>, die einen Wert vom Typ <code>T</code> enthält, und <code>None</code>, die keinen
Wert enthält. Durch das Verwenden der Aufzählung <code>Option&lt;T&gt;</code> können wir das
abstrakte Konzept eines optionalen Wertes ausdrücken und da <code>Option&lt;T&gt;</code>
generisch ist, können wir diese Abstraktion unabhängig vom Typ des
optionalen Wertes verwenden.</p>
<p>Aufzählungen können auch mehrere generische Typen verwenden. Die Definition der
Aufzählung <code>Result</code>, die wir in Kapitel 9 verwendet haben, ist ein Beispiel
dafür:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>Die Aufzählung <code>Result</code> ist generisch über zwei Typen <code>T</code> und <code>E</code> und hat zwei
Varianten: <code>Ok</code>, die einen Wert vom Typ <code>T</code> enthält, und <code>Err</code>, die einen Wert
vom Typ <code>E</code> enthält. Diese Definition macht es bequem, die Aufzählung <code>Result</code>
überall dort zu verwenden, wo wir eine Operation haben, die erfolgreich sein
(gibt einen Wert vom Typ <code>T</code> zurück) oder fehlschlagen (gibt einen Fehler vom
Typ <code>E</code> zurück) könnte. Tatsächlich haben wir dies beim Öffnen einer Datei in
Codeblock 9-3 verwendet, wobei für <code>T</code> der Typ <code>std::fs::File</code> verwendet wurde,
wenn die Datei erfolgreich geöffnet wurde, und für <code>E</code> der Typ
<code>std::io::Error</code>, wenn es Probleme beim Öffnen der Datei gab.</p>
<p>Wenn du in deinem Code Situationen mit mehreren Struktur- oder
Aufzählungsdefinitionen erkennst, die sich nur in den Typen der darin
enthaltenen Werte unterscheiden, kannst du doppelten Code vermeiden, indem du
stattdessen generische Typen verwendest.</p>
<h3 id="in-methodendefinitionen"><a class="header" href="#in-methodendefinitionen">In Methodendefinitionen</a></h3>
<p>Wir können Methoden auf Strukturen und Aufzählungen implementieren (wie wir es
in Kapitel 5 getan haben) und auch generische Typen in ihren Definitionen
verwenden. Codeblock 10-9 zeigt die Struktur <code>Point&lt;T&gt;</code>, die wir in Codeblock
10-6 definiert haben, mit einer darauf implementierten Methode namens <code>x</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}</code></pre></pre>
<p><span class="caption">Codeblock 10-9: Implementierung einer Methode <code>x</code> auf der
Struktur <code>Point&lt;T&gt;</code>, die eine Referenz auf das Feld <code>x</code> vom Typ <code>T</code>
zurückgibt</span></p>
<p>Hier haben wir eine Methode <code>x</code> auf <code>Point&lt;T&gt;</code> definiert, die eine Referenz auf
den Wert im Feld <code>x</code> zurückgibt.</p>
<p>Beachte, dass wir <code>T</code> direkt nach <code>impl</code> deklarieren müssen, damit wir Methoden
zum Typ <code>Point&lt;T&gt;</code> implementieren können. Durch das Deklarieren von <code>T</code> als
generischen Typ hinter <code>impl</code> kann Rust erkennen, dass der Typ in spitzen
Klammern in <code>Point</code> ein generischer und kein konkreter Typ ist. Wir hätten
einen anderen Namen für den generischen Parameter wählen können als den in der
Strukturdefinition deklarierten generischen Parameter, aber die Verwendung
desselben Namens ist üblich. Wenn du eine Methode innerhalb eines <code>impl</code>
schreibst, die einen generischen Typ deklariert, wird diese Methode auf jeder
Instanz des Typs definiert, unabhängig davon, welcher konkrete Typ am Ende den
generischen Typ ersetzt.</p>
<p>Wir können auch Einschränkungen für generische Typen angeben, wenn wir Methoden
auf dem Typ definieren. Wir könnten zum Beispiel Methoden nur auf
<code>Point&lt;f32&gt;</code>-Instanzen implementieren und nicht auf <code>Point&lt;T&gt;</code>-Instanzen mit
einem beliebigen generischen Typ. In Codeblock 10-10 verwenden wir den
konkreten Typ <code>f32</code>, d.h. wir deklarieren keinen Typ hinter <code>impl</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!("p.x = {}", p.x());
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-10: Ein <code>impl</code>-Block, der nur für eine
Struktur mit einem bestimmten konkreten Typ für den generischen Typparameter
<code>T</code> gilt</span></p>
<p>Dieser Code bedeutet, dass der Typ <code>Point&lt;f32&gt;</code> eine Methode
<code>distance_from_origin</code> hat und andere Instanzen von <code>Point&lt;T&gt;</code>, bei denen <code>T</code>
nicht vom Typ <code>f32</code> ist, haben diese Methode nicht. Die Methode misst, wie weit
unser Punkt vom Punkt mit den Koordinaten (0,0, 0,0) entfernt ist, und
verwendet mathematische Operationen, die nur für Fließkomma-Typen zur Verfügung
stehen.</p>
<p>Generische Typparameter in einer Strukturdefinition sind nicht immer die
gleichen wie die, die du in denselben Methodensignaturen für diese Struktur
verwendest. In Codeblock 10-11 werden die generischen Typen <code>X1</code> und <code>Y1</code> für
die Struktur <code>Point</code> und <code>X2</code> und <code>Y2</code> für die Signatur der Methode <code>mixup</code>
verwendet, um das Beispiel zu verdeutlichen. Die Methode erzeugt eine neue
<code>Point</code>-Instanz mit dem Wert <code>x</code> aus <code>self</code> (vom Typ <code>X1</code>) und dem Wert <code>y</code> aus
dem übergebenen <code>Point</code> (vom Typ <code>Y2</code>).</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hallo", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}</code></pre></pre>
<p><span class="caption">Codeblock 10-11: Eine Methode, die generische Typen aus
der Definition ihrer Struktur anders verwendet</span></p>
<p>In <code>main</code> haben wir einen <code>Point</code> definiert, bei dem <code>x</code> den Typ <code>i32</code> (mit dem
Wert <code>5</code>) und <code>y</code> den Typ <code>f64</code> (mit dem Wert <code>10.4</code>) hat. Die Variable <code>p2</code>
ist eine Struktur <code>Point</code>, bei der <code>x</code> einen Zeichenkettenanteilstyp (mit dem
Wert <code>"Hallo"</code>) und <code>y</code> den Typ <code>char</code> (mit dem Wert <code>c</code>) hat. Wenn wir <code>mixup</code>
auf <code>p1</code> mit dem Argument <code>p2</code> aufrufen, erhalten wir <code>p3</code>, das ein <code>i32</code> für
<code>x</code> haben wird, weil <code>x</code> von <code>p1</code> kam. Die Variable <code>p3</code> wird ein <code>char</code> für
<code>y</code> haben, weil <code>y</code> von <code>p2</code> stammt. Der Makroaufruf <code>println!</code> gibt
<code>p3.x = 5, p3.y = c</code> aus.</p>
<p>Der Zweck dieses Beispiels ist es, eine Situation zu demonstrieren, in der
einige generische Parameter mit <code>impl</code> und einige mit der Methodendefinition
deklariert werden. Hier werden die generischen Parameter <code>X1</code> und <code>Y1</code> nach
<code>impl</code> deklariert, weil sie zur Strukturdefinition gehören. Die generischen
Parameter <code>X2</code> und <code>Y2</code> werden nach <code>fn mixup</code> deklariert, da sie nur für die
Methode relevant sind.</p>
<h3 id="code-performanz-beim-verwenden-generischer-datentypen"><a class="header" href="#code-performanz-beim-verwenden-generischer-datentypen">Code-Performanz beim Verwenden generischer Datentypen</a></h3>
<p>Du fragst dich vielleicht, ob beim Verwenden generischer Typparameter
Laufzeitkosten anfallen. Die gute Nachricht ist, dass die Verwendung
generischer Typen die Ausführung deines Programms nicht langsamer macht als bei
konkreten Typen.</p>
<p>Rust erreicht dies durch Duplizierung von Code mit generischen Datentypen zur
Kompilierzeit. <em>Codeduplizierung</em> (monomorphization) ist der Vorgang der
Umwandlung von generischem Code in spezifischen Code durch Ausfüllen der
konkreten Typen, die bei der Kompilierung verwendet werden. Bei diesem Vorgang
führt der Compiler das Gegenteil der Schritte aus, die wir beim Erstellen der
generischen Funktion in Codeblock 10-5 angewendet haben: Der Compiler schaut
sich alle Stellen an, an denen generischer Code aufgerufen wird, und generiert
Code für die konkreten Typen, mit denen der generische Code aufgerufen wird.</p>
<p>Betrachten wir die Funktionsweise bei der Aufzählung <code>Option&lt;T&gt;</code> der
Standardbibliothek:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>Wenn Rust diesen Code kompiliert, führt es eine Codeduplizierung durch. Während
dieses Vorgangs liest der Compiler die Werte ein, die in
<code>Option&lt;T&gt;</code>-Instanzen verwendet wurden, und identifiziert zwei Arten von
<code>Option&lt;T&gt;</code>: Eine verwendet den Typ <code>i32</code> und die andere <code>f64</code>. Als solches
erweitert es die allgemeine Definition von <code>Option&lt;T&gt;</code> in zwei auf <code>i32</code> und
<code>f64</code> spezialisierte Definitionen, wodurch die allgemeine Definition durch die
spezifische ersetzt wird.</p>
<p>Die duplizierte Codeversion sieht ähnlich aus wie die folgende (der Compiler
verwendet andere Namen als die, die wir hier zur Veranschaulichung verwenden):</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
<p>Der generische Typ <code>Option&lt;T&gt;</code> wird durch die vom Compiler erstellten
spezifischen Definitionen ersetzt. Da Rust generischen Code in Code kompiliert,
der den Typ in jedem Fall spezifiziert, zahlen wir keine Laufzeitkosten beim
Verwenden von generischen Datentypen. Wenn der Code läuft, verhält er sich
genauso, wie wenn wir jede Definition von Hand dupliziert hätten. Der Vorgang
der Codeduplizierung macht Rusts generische Datentypen zur Laufzeit äußerst
effizient.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="merkmale-traits-gemeinsames-verhalten-definieren"><a class="header" href="#merkmale-traits-gemeinsames-verhalten-definieren">Merkmale (traits): Gemeinsames Verhalten definieren</a></h2>
<p>Ein <em>Merkmal</em> (trait) definiert die Funktionalität, den ein bestimmter Typ hat
und mit anderen Typen teilen kann. Wir können Merkmale verwenden, um
gemeinsames Verhalten auf abstrakte Weise zu definieren. Wir können
Merkmalsabgrenzungen (trait bounds) verwenden, um anzugeben, dass ein
generischer Typ jeder Typ sein kann, der ein bestimmtes Verhalten aufweist.</p>
<blockquote>
<p>Anmerkung: Merkmale sind einer Funktionalität recht ähnlich, die in anderen
Sprachen oft <em>Schnittstelle</em> (interface) genannt wird, wenn auch mit einigen
Unterschieden.</p>
</blockquote>
<h3 id="ein-merkmal-definieren"><a class="header" href="#ein-merkmal-definieren">Ein Merkmal definieren</a></h3>
<p>Das Verhalten eines Typs besteht aus den Methoden, die wir auf diesen Typ
anwenden können. Verschiedene Typen haben das gleiche Verhalten, wenn wir bei
allen die gleichen Methoden aufrufen können. Merkmalsdefinitionen sind eine
Möglichkeit, Methodensignaturen zu gruppieren, um eine Reihe von
Verhaltensweisen zu definieren, die zum Erreichen eines bestimmten Zwecks
erforderlich sind.</p>
<p>Nehmen wir zum Beispiel an, wir haben mehrere Strukturen (structs), die
verschiedene Arten und Mengen von Text enthalten: Eine Struktur <code>NewsArticle</code>,
die eine Nachricht enthält, die sich auf einen bestimmten Ort bezieht, und ein
<code>SocialPost</code>, der maximal 280 Zeichen umfassen kann, sowie Metadaten, die
angeben, ob es sich um eine neue Nachricht, eine Wiederholung oder eine Antwort
auf eine andere Nachricht handelt.</p>
<p>Wir wollen eine Medienaggregator-Bibliothekskiste namens <code>aggregator</code>
erstellen, die Zusammenfassungen von Daten anzeigen kann, die in einer
<code>NewsArticle</code>- oder <code>SocialPost</code>-Instanz gespeichert sein könnten. Dazu
brauchen wir eine Zusammenfassung von jedem Typ, und wir werden diese
Zusammenfassung anfordern, indem wir eine Methode <code>summarize</code> auf einer Instanz
aufrufen. Codeblock 10-12 zeigt die Definition eines öffentlichen
<code>Summary</code>-Merkmals, das dieses Verhalten zum Ausdruck bringt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-12: Ein Merkmal <code>Summary</code>, dessen Verhalten
aus der Methode <code>summarize</code> besteht</span></p>
<p>Hier deklarieren wir ein Merkmal mit dem Schlüsselwort <code>trait</code> und dann den
Namen des Merkmals, der in diesem Fall <code>Summary</code> lautet. Wir deklarieren das
Merkmal auch als <code>pub</code>, sodass Kisten, die von dieser Kiste abhängen, dieses
Merkmal ebenfalls nutzen können, wie wir in einigen Beispielen sehen werden.
Innerhalb der geschweiften Klammern deklarieren wir die Methodensignaturen, die
das Verhalten der Typen beschreiben, die dieses Merkmal implementieren, was in
diesem Fall <code>fn summarize(&amp;self) -&gt; String</code> ist.</p>
<p>Nach der Methodensignatur verwenden wir statt einer Implementierung in
geschweiften Klammern ein Semikolon. Jeder Typ, der dieses Merkmal
implementiert, muss sein eigenes benutzerdefiniertes Verhalten für den
Methodenrumpf bereitstellen. Der Compiler wird sicherstellen, dass jeder
Typ, der das Merkmal <code>Summary</code> hat, die Methode <code>summarize</code> mit genau dieser
Signatur hat.</p>
<p>Ein Merkmal kann mehrere Methoden umfassen: Die Methodensignaturen werden
zeilenweise aufgelistet und jede Zeile endet mit einem Semikolon.</p>
<h3 id="ein-merkmal-für-einen-typ-implementieren"><a class="header" href="#ein-merkmal-für-einen-typ-implementieren">Ein Merkmal für einen Typ implementieren</a></h3>
<p>Nachdem wir nun die gewünschten Signaturen der Methoden des Merkmals <code>Summary</code>
definiert haben, können wir sie für die Typen in unserem Medienaggregator
implementieren. Codeblock 10-13 zeigt eine Implementierung des Merkmals
<code>Summary</code> für die Struktur <code>NewsArticle</code>, die die Überschrift, den Autor und
den Ort verwendet, um den Rückgabewert von <code>summarize</code> zu erzeugen. Für die
Struktur <code>SocialPost</code> definieren wir <code>summarize</code> als den Benutzernamen, gefolgt
vom gesamten Text der Nachricht, wobei wir davon ausgehen, dass der Inhalt der
Nachricht bereits auf 280 Zeichen begrenzt ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, von {} ({})", self.headline, self.author, self.location)
    }
}

pub struct SocialPost {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub repost: bool,
}

impl Summary for SocialPost {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-13: Implementierung des Merkmals <code>Summary</code>
für die Typen <code>NewsArticle</code> und <code>SocialPost</code></span></p>
<p>Die Implementierung eines Merkmals für einen Typ ist ähnlich zur
Implementierung regulärer Methoden. Der Unterschied besteht darin, dass wir
nach <code>impl</code> den Namen des Merkmals schreiben, das wir implementieren wollen
und dann das Schlüsselwort <code>for</code> gefolgt vom Namen des Typs, für den wir
das Merkmal implementieren wollen. Innerhalb des <code>impl</code>-Blocks geben wir die
Methodensignaturen an, die das Merkmal vorgibt. Anstatt nach jeder Signatur ein
Semikolon zu schreiben, verwenden wir geschweifte Klammern und füllen den
Methodenrumpf mit dem spezifischen Verhalten, das die Methoden des Merkmals für
den jeweiligen Typ haben sollen.</p>
<p>Da die Bibliothek nun das Merkmal <code>Summary</code> auf <code>NewsArticle</code> und <code>SocialPost</code>
implementiert hat, können Benutzer der Kiste die Merkmals-Methoden auf
Instanzen von <code>NewsArticle</code> und <code>SocialPost</code> auf die gleiche Weise aufrufen,
wie wir reguläre Methoden aufrufen. Der einzige Unterschied besteht darin, dass
der Benutzer das Merkmal sowie die Typen in den Gültigkeitsbereich bringen
muss, um die zusätzlichen Merkmals-Methoden zu erhalten. Hier ist ein Beispiel
dafür, wie eine binäre Kiste unsere <code>aggregator</code>-Bibliothekskiste verwenden
könnte:</p>
<pre><code class="language-rust ignore">use aggregator::{self, Summary, SocialPost};

fn main() {
    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from("natürlich, wie du wahrscheinlich schon weißt"),
        reply: false,
        repost: false,
    };

    println!("1 neue Nachricht: {}", post.summarize());
}</code></pre>
<p>Dieser Code gibt <code>1 neue Nachricht: horse_ebooks: natürlich, wie du wahrscheinlich schon weißt</code> aus.</p>
<p>Andere Kisten, die von der <code>aggregator</code>-Kiste abhängen, können auch das Merkmal
<code>Summary</code> in den Gültigkeitsbereich bringen, um <code>Summary</code> auf ihren eigenen
Typen zu implementieren. Eine Einschränkung ist, dass wir ein Merkmal für einen
Typ nur dann implementieren können, wenn entweder das Merkmal und/oder der Typ
lokal in unserer Kiste vorhanden ist. Zum Beispiel können wir
Standard-Bibliotheksmerkmale wie <code>Display</code> auf einem benutzerdefinierten Typ
wie <code>SocialPost</code> als Teil unserer <code>aggregator</code>-Kistenfunktionalität
implementieren, weil der Typ <code>SocialPost</code> lokal zu unserer <code>aggregator</code>-Kiste
gehört. Wir können auch <code>Summary</code> auf <code>Vec&lt;T&gt;</code> in unserer <code>aggregator</code>-Kiste
implementieren, weil das Merkmal <code>Summary</code> lokal zu unserer <code>aggregator</code>-Kiste
gehört.</p>
<p>Aber wir können externe Merkmale nicht auf externe Typen anwenden. Zum Beispiel
können wir das Merkmal <code>Display</code> auf <code>Vec&lt;T&gt;</code> in unserer <code>aggregator</code>-Kiste
nicht implementieren, weil <code>Display</code> und <code>Vec&lt;T&gt;</code> in der Standardbibliothek
definiert sind und nicht lokal zu unserer <code>aggregator</code>-Kiste gehören. Diese
Beschränkung ist Teil einer Eigenschaft von Programmen namens <em>Kohärenz</em>
(coherence), genauer gesagt der <em>Waisenregel</em> (orphan rule), die so genannt
wird, weil der übergeordnete Typ nicht vorhanden ist. Diese Regel stellt
sicher, dass der Code anderer Personen deinen Code nicht brechen kann und
umgekehrt. Ohne diese Regel könnten zwei Kisten dasselbe Merkmal für denselben
Typ implementieren und Rust wüsste nicht, welche Implementierung es verwenden
sollte.</p>
<h3 id="standard-implementierungen"><a class="header" href="#standard-implementierungen">Standard-Implementierungen</a></h3>
<p>Manchmal ist es nützlich, ein Standardverhalten für einige oder alle Methoden
eines Merkmals zu haben, anstatt Implementierungen für alle Methoden für jeden
Typ zu verlangen. Wenn wir dann das Merkmal für einen bestimmten Typ
implementieren, können wir das Standardverhalten jeder Methode beibehalten oder
überschreiben.</p>
<p>In Codeblock 10-14 geben wir eine Standard-Zeichenkette für die Methode
<code>summarize</code> des Merkmals <code>Summary</code> an, anstatt nur die Methodensignatur zu
definieren, wie wir es in Codeblock 10-12 getan haben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(Lies mehr ...)")
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-14: Definieren eines Merkmals <code>Summary</code> mit
einer Standard-Implementierung der Methode <code>summarize</code></span></p>
<p>Um eine Standard-Implementierung zu verwenden, um Instanzen von <code>NewsArticle</code>
zusammenzufassen, geben wir einen leeren <code>impl</code>-Block mit <code>impl Summary for NewsArticle {}</code> an.</p>
<p>Auch wenn wir die Methode <code>summarize</code> nicht mehr direkt für <code>NewsArticle</code>
definieren, haben wir eine Standard-Implementierung bereitgestellt und
festgelegt, dass <code>NewsArticle</code> das Merkmal <code>Summary</code> implementiert.
Infolgedessen können wir immer noch die Methode <code>summarize</code> einer
<code>NewsArticle</code>-Instanz aufrufen, etwa so:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from("Penguins gewinnen die Stanley-Cup-Meisterschaft!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from("Die Pittsburgh Penguins sind erneut die beste \
                               Eishockeymannschaft in der NHL.",
        ),
    };

    println!("Neuer Artikel verfügbar! {}", article.summarize());
<span class="boring">}</span></code></pre>
<p>Dieser Code gibt <code>Neuer Artikel verfügbar! (Lies mehr ...)</code> aus.</p>
<p>Das Erstellen einer Standard-Implementierung erfordert nicht, dass wir an der
Implementierung von <code>Summary</code> für <code>SocialPost</code> in Codeblock 10-13 etwas ändern.
Der Grund dafür ist, dass die Syntax für das Überschreiben einer
Standard-Implementierung die gleiche ist wie die Syntax für die Implementierung
einer Merkmalsmethode, die keine Standard-Implementierung hat.</p>
<p>Standard-Implementierungen können andere Methoden desselben Merkmals aufrufen,
selbst wenn diese anderen Methoden keine Standard-Implementierung haben. Auf
diese Weise kann ein Merkmal eine Menge nützlicher Funktionalität bereitstellen
und von den Implementierern nur die Angabe eines kleinen Teils verlangen. Zum
Beispiel könnten wir das Merkmal <code>Summary</code> so definieren, dass wir eine Methode
<code>summarize_author</code> haben, deren Implementierung erforderlich ist, und dann eine
Methode <code>summarize</code> definieren, die eine Standard-Implementierung hat und die
Methode <code>summarize_author</code> aufruft:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(Lies mehr von {}...)", self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!("@{}", self.username)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Um diese Version von <code>Summary</code> zu verwenden, müssen wir <code>summarize_author</code> nur
dann definieren, wenn wir das Merkmal für einen Typ implementieren:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("(Lies mehr von {}...)", self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for SocialPost {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Nachdem wir <code>summarize_author</code> definiert haben, können wir <code>summarize</code> auf
Instanzen der <code>SocialPost</code>-Struktur aufrufen, und die Standard-Implementierung
von <code>summarize</code> wird die Definition von <code>summarize_author</code> aufrufen, die wir
bereitgestellt haben. Da wir <code>summarize_author</code> implementiert haben, hat uns
das Merkmal <code>Summary</code> das Verhalten der Methode <code>summarize</code> mitgeliefert, ohne
dass wir weiteren Code schreiben müssen. Das sieht dann so aus:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, SocialPost};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from("natürlich, wie du wahrscheinlich schon weißt"),
        reply: false,
        repost: false,
    };

    println!("1 neue Nachricht: {}", post.summarize());
<span class="boring">}</span></code></pre>
<p>Dieser Code gibt <code>1 neue Nachricht: (Lies mehr von @horse_ebooks...)</code> aus.</p>
<p>Beachte, dass es nicht möglich ist, die Standardimplementierung von einer
übergeordneten Implementierung derselben Methode aus aufzurufen.</p>
<h3 id="merkmale-als-parameter"><a class="header" href="#merkmale-als-parameter">Merkmale als Parameter</a></h3>
<p>Da du jetzt weißt, wie man Merkmale definiert und implementiert, können wir
untersuchen, wie man Merkmale zur Definition von Funktionen verwendet, die
viele verschiedene Typen akzeptieren. Wir verwenden das Merkmal <code>Summary</code>, das
wir für die Typen <code>NewsArticle</code> und <code>SocialPost</code> in Codeblock 10-13
implementiert haben, um eine Funktion <code>notify</code> zu definieren, die die Methode
<code>summarize</code> für ihren Parameter <code>item</code> aufruft, der von einem Typ ist, der das
Merkmal <code>Summary</code> implementiert. Um dies zu tun, können wir die Syntax <code>impl  Trait</code> verwenden, etwa so:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, von {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!("Eilmeldung! {}", item.summarize());
}
<span class="boring">}</span></code></pre></pre>
<p>Anstelle eines konkreten Typs für den Parameter <code>item</code> geben wir das
Schlüsselwort <code>impl</code> und den Merkmalsnamen an. Dieser Parameter akzeptiert
jeden Typ, der das angegebene Merkmal implementiert. Im Rumpf von <code>notify</code>
können wir alle Methoden von <code>item</code> aufrufen, die vom Merkmal <code>Summary</code>
herrühren, zum Beispiel <code>summarize</code>. Wir können <code>notify</code> aufrufen und jede
Instanz von <code>NewsArticle</code> und <code>SocialPost</code> angeben. Code, der die Funktion mit
einem anderen Typ aufruft, z.B. <code>String</code> oder <code>i32</code>, lässt sich nicht
kompilieren, da diese Typen kein <code>Summary</code> implementieren.</p>
<h4 id="merkmalsabgrenzungs-syntax"><a class="header" href="#merkmalsabgrenzungs-syntax">Merkmalsabgrenzungs-Syntax</a></h4>
<p>Die Syntax <code>impl Trait</code> funktioniert für einfache Fälle, ist aber eigentlich
syntaktischer Zucker für eine längere Form, die <em>Merkmalsabgrenzung</em> (trait
bound) genannt wird; sie sieht so aus:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("Eilmeldung! {}", item.summarize());
}
<span class="boring">}</span></code></pre></pre>
<p>Diese längere Form entspricht dem Beispiel im vorigen Abschnitt, ist aber
wortreicher. Wir platzieren Merkmalsabgrenzungen in der Deklaration des
generischen Typparameters nach einem Doppelpunkt und innerhalb spitzer
Klammern.</p>
<p>Die Syntax <code>impl Trait</code> ist bequem und ermöglicht in einfachen Fällen einen
prägnanteren Code, während die umfassendere Merkmalsabgrenzungs-Syntax mehr
Komplexität ausdrücken kann. Zum Beispiel können wir zwei Parameter haben, die
<code>Summary</code> implementieren. Das Verwenden der Syntax <code>impl Trait</code> sieht
folgendermaßen aus:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p>Die Verwendung von <code>impl Trait</code> ist angemessen, wenn wir wollten, dass diese
Funktion bei <code>item1</code> und <code>item2</code> unterschiedliche Typen haben kann (solange
beide Typen <code>Summary</code> implementieren). Wenn beide Parameter aber den gleichen
Typ haben sollen, müssen wir eine Merkmalsabgrenzung verwenden, so wie hier:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p>Der als Parametertyp für <code>item1</code> und <code>item2</code> angegebene generische Typ <code>T</code>
schränkt die Funktion so ein, dass der konkrete Typ der als Argument für
<code>item1</code> und <code>item2</code> übergebenen Werte derselbe sein muss.</p>
<h4 id="angeben-mehrerer-merkmalsabgrenzungen-mit-der-syntax-"><a class="header" href="#angeben-mehrerer-merkmalsabgrenzungen-mit-der-syntax-">Angeben mehrerer Merkmalsabgrenzungen mit der Syntax <code>+</code></a></h4>
<p>Wir können auch mehr als eine Merkmalsabgrenzung angeben. Nehmen wir an, wir
wollen, dass sowohl <code>notify</code> als auch die Methode <code>summarize</code> die
Bildschirmausgabe für <code>item</code> formatieren: Spezifizieren wir in der
<code>notify</code>-Definition, dass <code>item</code> sowohl <code>Display</code> als auch <code>Summary</code>
implementieren muss. Wir können dies mit der Syntax <code>+</code> tun:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p>Die Syntax <code>+</code> ist auch bei Merkmalsabgrenzungen mit generischen Typen gültig:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>Mit den beiden angegebenen Merkmalsabgrenzungen kann der Rumpf von <code>notify</code> die
Methode <code>summarize</code> aufrufen und <code>{}</code> verwenden, um <code>item</code> zu formatieren.</p>
<h4 id="klarere-merkmalsabgrenzungen-mit-where-klauseln"><a class="header" href="#klarere-merkmalsabgrenzungen-mit-where-klauseln">Klarere Merkmalsabgrenzungen mit <code>where</code>-Klauseln</a></h4>
<p>Zu viele Merkmalsabgrenzungen zu verwenden, hat seine Schattenseiten. Jeder
generische Datentyp hat seine eigenen Merkmalsabgrenzungen, sodass Funktionen
mit mehreren generischen Typparametern viele Merkmalsabgrenzungsangaben
zwischen Funktionsname und Parameterliste enthalten können, wodurch die
Funktionssignatur schwer lesbar wird. Aus diesem Grund hat Rust für die Angabe
von Merkmalsabgrenzungen eine alternative Syntax in Form einer <code>where</code>-Klausel
nach der Funktionssignatur. Anstatt das hier zu schreiben:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>können wir eine <code>where</code>-Klausel wie folgt verwenden:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>Die Signatur dieser Funktion ist übersichtlicher: Der Funktionsname, die
Parameterliste und der Rückgabetyp liegen nahe beieinander, ähnlich wie bei
einer Funktion ohne viele Merkmalsabgrenzungen.</p>
<h3 id="rückgabetypen-die-merkmale-implementieren"><a class="header" href="#rückgabetypen-die-merkmale-implementieren">Rückgabetypen, die Merkmale implementieren</a></h3>
<p>Wir können die Syntax <code>impl Trait</code> auch für den Rückgabetyp verwenden, wie hier
gezeigt:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, von {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from("natürlich, wie du wahrscheinlich schon weißt"),
        reply: false,
        repost: false,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Durch Verwenden von <code>impl Summary</code> für den Rückgabetyp legen wir fest, dass die
Funktion <code>returns_summarizable</code> einen Typ zurückgibt, der das Merkmal <code>Summary</code>
implementiert, ohne den konkreten Typ zu nennen. In diesem Fall gibt
<code>returns_summarizable</code> einen <code>SocialPost</code> zurück, aber der Code, der diese
Funktion aufruft, muss das nicht wissen.</p>
<p>Die Fähigkeit, einen Rückgabetyp nur durch das Merkmal, das er implementiert,
zu spezifizieren, ist besonders nützlich im Zusammenhang mit
Funktionsabschlüssen und Iteratoren, die wir in Kapitel 13 behandeln.
Funktionsabschlüsse und Iteratoren erzeugen Typen, die nur der Compiler
kennt oder deren Spezifikation sehr lang ist. Mit der Syntax <code>impl Trait</code>
kannst du prägnant angeben, dass eine Funktion einen Typ zurückgibt, der das
Merkmal <code>Iterator</code> implementiert, ohne dass du einen sehr langen Typ schreiben
musst.</p>
<p>Du kannst <code>impl Trait</code> jedoch nur verwenden, wenn du einen einzigen Typ
zurückgibst. Beispielsweise würde dieser Code, der entweder einen <code>NewsArticle</code>
oder einen <code>SocialPost</code> mit dem Rückgabetyp <code>impl Summary</code> zurückgibt, nicht
funktionieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, von {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins gewinnen die Stanley-Cup-Meisterschaft!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "Die Pittsburgh Penguins sind erneut die beste \
                 Eishockeymannschaft in der NHL.",
            ),
        }
    } else {
        SocialPost {
            username: String::from("horse_ebooks"),
            content: String::from("natürlich, wie du wahrscheinlich schon weißt"),
            reply: false,
            repost: false,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Die Rückgabe entweder eines <code>NewsArticle</code> oder eines <code>SocialPost</code> ist aufgrund
von Einschränkungen hinsichtlich der Implementierung der Syntax <code>impl Trait</code> im
Compiler nicht erlaubt. Wie man eine Funktion mit diesem Verhalten schreibt,
wird in <a href="ch18-02-trait-objects.html">„Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen
erlauben“</a> in
Kapitel 18 behandelt.</p>
<h3 id="verwenden-von-merkmalsabgrenzungen-zur-bedingten-implementierung-von-methoden"><a class="header" href="#verwenden-von-merkmalsabgrenzungen-zur-bedingten-implementierung-von-methoden">Verwenden von Merkmalsabgrenzungen zur bedingten Implementierung von Methoden</a></h3>
<p>Durch Verwenden einer Merkmalsabgrenzung mit einem <code>impl</code>-Block, der generische
Typparameter verwendet, können wir Methoden bedingt für Typen implementieren,
die das angegebene Merkmal implementieren. Beispielsweise implementiert der Typ
<code>Pair&lt;T&gt;</code> in Codeblock 10-15 immer die Funktion <code>new</code>, um eine neue Instanz von
<code>Pair&lt;T&gt;</code> zurückzugeben (erinnere dich an <a href="ch05-03-method-syntax.html#definieren-von-methoden">„Definieren von Methoden“</a>
in Kapitel 5, dass <code>Self</code> ein Typ-Alias für den Typ des <code>impl</code>-Blocks ist, der
in diesem Fall <code>Pair&lt;T&gt;</code> ist). Aber im nächsten <code>impl</code>-Block implementiert
<code>Pair&lt;T&gt;</code> die Methode <code>cmp_display</code> nur, wenn ihr innerer Typ <code>T</code> die Merkmale
<code>PartialOrd</code> <em>und</em> <code>Display</code> implementiert, die den Vergleich bzw. eine Ausgabe
ermöglichen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("Das größte Element ist x = {}", self.x);
        } else {
            println!("Das größte Element ist y = {}", self.y);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-15: Bedingte Implementierung von Methoden
für einen generischen Typ in Abhängigkeit von Merkmalsabgrenzungen</span></p>
<p>Wir können auch ein Merkmal für beliebige Typen bedingt implementieren, die ein
anderes Merkmal implementieren. Implementierungen eines Merkmals für Typen, die
Merkmalsabgrenzungen erfüllen, werden als <em>Pauschal-Implementierungen</em> (blanket
implementations) bezeichnet und kommen in der Rust-Standardbibliothek ausgiebig
zur Anwendung. Beispielsweise implementiert die Standardbibliothek das Merkmal
<code>ToString</code> für jeden Typ, der das Merkmal <code>Display</code> implementiert. Der
<code>impl</code>-Block in der Standardbibliothek sieht in etwa so aus:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --abschneiden--
}</code></pre>
<p>Da die Standardbibliothek diese Pauschal-Implementierungen hat, können wir die
Methode <code>to_string</code>, die durch das Merkmal <code>ToString</code> definiert ist, bei jedem
Typ aufrufen, der das Merkmal <code>Display</code> implementiert. Zum Beispiel können wir
ganze Zahlen in ihre entsprechenden <code>String</code>-Werte umwandeln, weil ganze
Zahlen <code>Display</code> implementieren:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>Pauschal-Implementierungen erscheinen in der Dokumentation des Merkmals im
Abschnitt „Implementierer“ (implementors).</p>
<p>Mithilfe von Merkmalen und Merkmalsabgrenzungen können wir Code schreiben, der
generische Typparameter verwendet, um Duplikationen zu reduzieren, aber auch
dem Compiler gegenüber angeben, dass der generische Typ ein bestimmtes
Verhalten haben soll. Der Compiler kann dann die Merkmalsabgrenzungen
verwenden, um zu überprüfen, ob alle konkreten Typen, die von unserem Code
verwendet werden, das richtige Verhalten aufweisen. In dynamisch typisierten
Sprachen würden wir einen Laufzeitfehler erhalten, wenn wir eine Methode bei
einem Typ aufrufen, der die Methode nicht definiert hat. Rust verschiebt diese
Fehler jedoch in die Kompilierzeit und verlangt damit, dass wir die Probleme
beheben, bevor unser Code überhaupt lauffähig ist. Außerdem müssen wir keinen
Code schreiben, der das Verhalten zur Laufzeit überprüft, da wir es bereits zur
Kompilierzeit überprüft haben. Auf diese Weise wird die Performanz verbessert,
ohne die Flexibilität der generischen Datentypen aufgeben zu müssen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referenzen-validieren-mit-lebensdauern"><a class="header" href="#referenzen-validieren-mit-lebensdauern">Referenzen validieren mit Lebensdauern</a></h2>
<p><em>Lebensdauer</em> (lifetimes) sind eine weitere generische Funktionalität, die wir
bereits verwendet haben. Anstatt sicherzustellen, dass ein Typ das von uns
gewünschte Verhalten hat, stellen wir durch die Lebensdauer sicher, dass
Referenzen so lange gültig sind, wie wir sie brauchen.</p>
<p>Ein Detail, das wir im Abschnitt <a href="ch04-02-references-and-borrowing.html">„Referenzen und Ausleihen
(borrowing)“</a> in Kapitel 4 nicht erörtert haben, ist,
dass jede Referenz in Rust eine <em>Lebensdauer</em> (lifetime) hat, d.h. einen
Gültigkeitsbereich, in dem diese Referenz gültig ist. In den meisten Fällen
sind Lebensdauern implizit und abgeleitet, ebenso wie in den meisten Fällen
Typen abgeleitet werden. Wir müssen Typen nur dann mit Annotationen versehen,
wenn mehrere Typen möglich sind. In ähnlicher Weise müssen wir Lebensdauern
annotieren, wenn die Lebensdauern von Referenzen auf verschiedene Weise
miteinander in Beziehung gesetzt werden könnten. Rust verlangt von uns, die
Beziehungen mit generischen Lebensdauerparametern zu annotieren, um
sicherzustellen, dass die tatsächlich zur Laufzeit verwendeten Referenzen
definitiv gültig sind.</p>
<p>Das Annotieren von Lebensdauern ist ein Konzept, das die meisten anderen
Programmiersprachen nicht einmal kennen, sodass es sich ungewohnt anfühlen
wird. Auch wenn wir in diesem Kapitel die Lebensdauern nicht in ihrer
Gesamtheit behandeln werden, so werden wir doch allgemeine Möglichkeiten
erörtern, mit denen du dich mit der Syntax der Lebensdauer und den Konzepten
vertraut machen kannst.</p>
<h3 id="verhindern-hängender-referenzen-mit-lebensdauern"><a class="header" href="#verhindern-hängender-referenzen-mit-lebensdauern">Verhindern hängender Referenzen mit Lebensdauern</a></h3>
<p>Das Hauptziel der Lebensdauer ist es, <em>hängende Referenzen</em> (dangling
references) zu verhindern, die dazu führen, dass ein Programm auf andere
Daten referenziert als die, auf die es referenzieren soll. Betrachte das
Programm in Codeblock 10-16, das einen äußeren und einen inneren
Gültigkeitsbereich hat.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!("r: {r}");
}</code></pre></pre>
<p><span class="caption">Codeblock 10-16: Ein Versuch, eine Referenz zu verwenden,
deren Wert außerhalb des Gültigkeitsbereichs liegt</span></p>
<blockquote>
<p>Hinweis: Die Beispiele in den Codeblöcken 10-16, 10-17 und 10-23 deklarieren
Variablen ohne Initialwert, sodass der Variablenname im äußeren
Gültigkeitsbereich existiert. Auf den ersten Blick mag dies im Widerspruch
dazu stehen, dass Rust keine Nullwerte hat. Wenn wir jedoch versuchen, eine
Variable zu verwenden, bevor wir ihr einen Wert geben, erhalten wir einen
Kompilierfehler, der zeigt, dass Rust tatsächlich keine Nullwerte zulässt.</p>
</blockquote>
<p>Der äußere Gültigkeitsbereich deklariert eine Variable <code>r</code> ohne Initialwert und
der innere Gültigkeitsbereich deklariert eine Variable <code>x</code> mit dem Initialwert
5. Im inneren Gültigkeitsbereich versuchen wir, den Wert von <code>r</code> als Referenz
auf <code>x</code> zu setzen. Dann endet der innere Gültigkeitsbereich und wir versuchen,
den Wert in <code>r</code> auszugeben. Dieser Code lässt sich nicht kompilieren, weil der
Wert, auf den sich <code>r</code> bezieht, den Gültigkeitsbereich verlassen hat, bevor wir
versuchen, ihn zu verwenden. Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Die Fehlermeldung besagt, dass die Variable <code>x</code> „nicht lange genug lebt“. Der
Grund dafür ist, dass <code>x</code> den Gültigkeitsbereich verlässt, da der innere
Gültigkeitsbereich bei Zeile 7 endet. Aber <code>r</code> ist im äußeren
Gültigkeitsbereich immer noch gültig; da sein Gültigkeitsbereich größer ist,
sagen wir, dass es „länger lebt“. Wenn Rust diesen Code funktionieren ließe,
würde <code>r</code> auf Speicher verweisen, der freigegeben wurde, als <code>x</code> den
Gültigkeitsbereich verlassen hat, und alles, was wir mit <code>r</code> tun würden, würde
nicht korrekt funktionieren. Wie stellt Rust also fest, dass dieser Code
ungültig ist? Es verwendet einen Ausleihenprüfer (borrow checker).</p>
<h3 id="der-ausleihenprüfer"><a class="header" href="#der-ausleihenprüfer">Der Ausleihenprüfer</a></h3>
<p>Der Rust-Compiler verfügt über einen <em>Ausleihenprüfer</em> (borrow checker), der
Gültigkeitsbereiche vergleicht, um festzustellen, ob alle Ausleihen gültig
sind. Codeblock 10-17 zeigt den gleichen Code wie Codeblock 10-16, jedoch mit
Annotationen, die die Lebensdauer der Variablen angeben.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+</code></pre></pre>
<p><span class="caption">Codeblock 10-17: Annotationen der Lebensdauern von <code>r</code>
und <code>x</code>, genannt <code>'a</code> bzw. <code>'b</code></span></p>
<p>Hier haben wir die Lebensdauer von <code>r</code> mit <code>'a</code> und die Lebensdauer von <code>x</code> mit
<code>'b</code> vermerkt. Wie du sehen kannst, ist der innere <code>'b</code>-Block viel kleiner als
der äußere <code>'a</code>-Lebensdauer-Block. Zur Kompilierzeit vergleicht Rust die Größe
der beiden Lebensdauern und stellt fest, dass <code>r</code> eine Lebensdauer von <code>'a</code>
hat, jedoch auf einen Speicherbereich mit Lebensdauern <code>'b</code> referenziert. Das
Programm wird abgelehnt, weil <code>'b</code> kürzer als <code>'a</code> ist: Der Referenzinhalt lebt
nicht so lange wie die Referenz selbst.</p>
<p>Mit Codeblock 10-18 wird der Code so korrigiert, dass er keine hängende
Referenz hat und fehlerfrei kompiliert werden kann.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+</code></pre></pre>
<p><span class="caption">Codeblock 10-18: Eine gültige Referenz, da die Daten eine
längere Lebensdauer als die Referenz haben</span></p>
<p>Hier hat <code>x</code> die Lebensdauer <code>'b</code>, die in diesem Fall größer ist als <code>'a</code>. Das
bedeutet, dass <code>r</code> auf <code>x</code> referenzieren kann, weil Rust weiß, dass die
Referenz in <code>r</code> immer gültig sein wird, solange <code>x</code> gültig ist.</p>
<p>Da du nun weißt, wo die Lebensdauern von Referenzen sind und wie Rust die
Lebensdauer analysiert, um sicherzustellen, dass Referenzen immer gültig sind,
lass uns die generischen Lebensdauern von Parametern und Rückgabewerten im
Kontext von Funktionen untersuchen.</p>
<h3 id="generische-lebensdauern-in-funktionen"><a class="header" href="#generische-lebensdauern-in-funktionen">Generische Lebensdauern in Funktionen</a></h3>
<p>Wir schreiben eine Funktion, die den längeren von zwei
Zeichenkettenanteilstypen zurückgibt. Diese Funktion nimmt zwei
Zeichenkettenanteilstypen entgegen und gibt einen einzigen
Zeichenkettenanteilstyp zurück. Nachdem wir die Funktion <code>longest</code>
implementiert haben, sollte der Code in Codeblock 10-19 <code>Die längere Zeichenkette ist abcd</code> ausgeben.</p>
<p><span class="filename">Datei: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("Die längere Zeichenkette ist {result}");
}</code></pre>
<p><span class="caption">Codeblock 10-19: Eine Funktion <code>main</code>, die die Funktion
<code>longest</code> aufruft, um die längere von zwei Zeichenkettenanteilstypen zu
bestimmen</span></p>
<p>Beachte, dass wir wollen, dass die Funktion Zeichenkettenanteilstypen nimmt,
die Referenzen sind und keine Zeichenketten, weil wir nicht wollen, dass die
Funktion <code>longest</code> die Eigentümerschaft ihrer Parameter übernimmt. Lies
<a href="ch04-03-slices.html#zeichenkettenanteilstypen-als-parameter">„Zeichenkettenanteilstypen als Parameter“</a> in
Kapitel 4, um mehr darüber zu erfahren, warum die Parameter, die wir in
Codeblock 10-19 verwenden, die von uns gewünschten sind.</p>
<p>Wenn wir versuchen, die Funktion <code>longest</code>, wie in Codeblock 10-20 gezeigt, zu
implementieren, wird sie sich nicht kompilieren lassen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("Die längere Zeichenkette ist {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 10-20: Eine Implementierung der Funktion
<code>longest</code>, die die längere von zwei Zeichenkettenanteilstypen zurückgibt, aber
noch nicht kompiliert</span></p>
<p>Stattdessen erhalten wir folgenden Fehler, der von Lebensdauern spricht:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Aus dem Hilfetext geht hervor, dass der Rückgabetyp einen generischen
Lebensdauer-Parameter benötigt, da Rust nicht sagen kann, ob sich die
zurückgegebene Referenz auf <code>x</code> oder auf <code>y</code> bezieht. Eigentlich wissen wir es
auch nicht, weil der <code>if</code>-Zweig im Funktionsrumpf eine Referenz auf <code>x</code> und der
<code>else</code>-Zweig eine Referenz auf <code>y</code> zurückgibt!</p>
<p>Wenn wir diese Funktion definieren, kennen wir die konkreten Werte nicht, die
an diese Funktion übergeben werden, also wissen wir nicht, ob der <code>if</code>-Zweig
oder der <code>else</code>-Zweig ausgeführt wird. Wir kennen auch nicht die konkreten
Lebensdauern der Referenzen, die weitergegeben werden, sodass wir nicht wie in
den Codeblöcken 10-17 und 10-18 die Gültigkeitsbereiche betrachten können, um
festzustellen, ob die von uns zurückgegebene Referenz immer gültig sein wird.
Der Ausleihenprüfer kann dies auch nicht feststellen, weil er nicht weiß, wie
die Lebensdauer von <code>x</code> und <code>y</code> mit der Lebensdauer des Rückgabewertes
zusammenhängt. Um diesen Fehler zu beheben, geben wir generische
Lebensdauerparameter an, die die Beziehung zwischen den Referenzen definieren,
damit der Ausleihenprüfer seine Analyse durchführen kann.</p>
<h3 id="lebensdauer-annotationssyntax"><a class="header" href="#lebensdauer-annotationssyntax">Lebensdauer-Annotationssyntax</a></h3>
<p>Lebensdauer-Annotationen ändern nichts daran, wie lange eine Referenz lebt.
Vielmehr beschreiben sie die Beziehungen der Lebensdauern mehrerer Referenzen
zueinander, ohne die Lebensdauern zu beeinflussen. Genauso wie Funktionen jeden
Typ entgegennehmen können, wenn die Signatur einen generischen Typparameter
angibt, können Funktionen Referenzen mit beliebiger Lebensdauer akzeptieren,
indem sie einen generischen Lebensdauerparameter angeben.</p>
<p>Lebensdauer-Annotationen haben eine etwas ungewöhnliche Syntax: Die Namen der
Lebensdauer-Parameter müssen mit einem Apostroph (<code>'</code>) beginnen und sind
normalerweise kleingeschrieben und sehr kurz, wie generische Typen. Die meisten
Menschen verwenden den Namen <code>'a</code> für die erste Lebensdauer-Annotationen. Wir
platzieren Lebensdauer-Parameter-Annotationen hinter dem <code>&amp;</code> einer Referenz,
wobei wir ein Leerzeichen verwenden, um die Annotation vom Typ der Referenz zu
trennen.</p>
<p>Hier sind einige Beispiele: Eine Referenz auf einen <code>i32</code> ohne
Lebensdauer-Parameter, eine Referenz auf einen <code>i32</code>, die einen
Lebensdauer-Parameter namens <code>'a</code> hat, und eine veränderbarer Referenz auf
einen <code>i32</code>, die ebenfalls die Lebensdauer <code>'a</code> hat.</p>
<pre><code class="language-rust ignore">&amp;i32        // eine Referenz
&amp;'a i32     // eine Referenz mit expliziter Lebensdauer
&amp;'a mut i32 // eine veränderbare Referenz mit expliziter Lebensdauer</code></pre>
<p>Eine Lebensdauer-Annotation an sich hat nicht viel Bedeutung, da die
Annotationen Rust mitteilen sollen, wie sich generische
Lebensdauer-Parameter mehrerer Referenzen zueinander verhalten. Untersuchen
wir, wie sich die Lebensdauer-Annotationen im Zusammenhang mit der Funktion
<code>longest</code> zueinander verhalten.</p>
<h3 id="lebensdauer-annotationen-in-funktionssignaturen"><a class="header" href="#lebensdauer-annotationen-in-funktionssignaturen">Lebensdauer-Annotationen in Funktionssignaturen</a></h3>
<p>Um Lebensdauer-Annotationen in Funktionssignaturen zu verwenden, müssen wir die
generischen <em>Lebensdauer</em>-Parameter in spitzen Klammern zwischen dem
Funktionsnamen und der Parameterliste deklarieren, genau wie wir es mit den
generischen <em>Typ</em>-Parametern gemacht haben.</p>
<p>Wir möchten, dass die Signatur die folgende Bedingung ausdrückt: Die
zurückgegebene Referenz ist gültig, solange die beiden Parameter gültig sind.
Dies ist die Beziehung zwischen den Lebensdauern der Parameter und des
Rückgabewerts. Wir nennen die Lebensdauer <code>'a</code> und fügen sie dann jeder
Referenz hinzu, wie in Codeblock 10-21 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("Die längere Zeichenkette ist {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 10-21: Die Funktionsdefinition <code>longest</code> gibt
an, dass alle Referenzen in der Signatur die gleiche Lebensdauer <code>'a</code> haben
müssen</span></p>
<p>Dieser Code sollte kompilierbar sein und das gewünschte Ergebnis liefern, wenn
wir ihn mit der Funktion <code>main</code> in Codeblock 10-19 verwenden.</p>
<p>Die Funktionssignatur sagt Rust, dass die Funktion für eine gewisse Lebensdauer
<code>'a</code> zwei Parameter benötigt, die beide den Zeichenkettenanteilstyp haben und
mindestens so lange leben wie die Lebensdauer <code>'a</code>. Die Funktionssignatur sagt
Rust auch, dass der von der Funktion zurückgegebene Zeichenkettenanteilstyp
mindestens so lange leben wird wie die Lebensdauer <code>'a</code>. In der Praxis bedeutet
dies, dass die Lebensdauer der Referenz, die von der Funktion <code>longest</code>
zurückgegeben wird, der kleineren der Lebensdauern der Werte entspricht, auf
die sich die Funktionsargumente beziehen. Diese Beziehungen sollen von Rust
verwendet werden, wenn es diesen Code analysiert.</p>
<p>Denke daran, indem wir die Lebensdauerparameter in dieser Funktionssignatur
angeben, ändern wir nicht die Lebensdauer der übergebenen oder zurückgegebenen
Werte. Vielmehr legen wir fest, dass der Ausleihenprüfer alle Werte ablehnen
soll, die sich nicht an diese Bedingung halten. Beachte, dass die Funktion
<code>longest</code> nicht genau wissen muss, wie lange <code>x</code> und <code>y</code> leben werden, nur dass
ein gewisser Gültigkeitsbereich für <code>'a</code> eingesetzt werden kann, der dieser
Signatur genügt.</p>
<p>Wenn Funktionen mit Lebensdauern annotiert werden, gehören die Annotationen zur
Funktionssignatur, nicht zum Funktionsrumpf. Die Lebensdauer-Annotationen werden
Teil des Funktionsvertrags, ähnlich wie die Typen in der Signatur. Wenn
Funktionssignaturen den Lebensdauervertrag enthalten, kann die Analyse des
Rust-Compilers einfacher sein. Wenn es ein Problem mit der Art und Weise gibt,
wie eine Funktion annotiert ist oder wie sie aufgerufen wird, können die
Compilerfehler auf den Teil unseres Codes und die Beschränkungen genauer
hinweisen. Wenn der Rust-Compiler stattdessen mehr Rückschlüsse auf die von uns
beabsichtigten Beziehungen der Lebensdauern ziehen würde, könnte der Compiler
nur auf eine Verwendung unseres Codes hinweisen, die viele Schritte von der
Ursache des Problems entfernt ist.</p>
<p>Wenn wir der Funktion <code>longest</code> konkrete Referenzen übergeben, ist die konkrete
Lebensdauer, die an die Stelle von <code>'a</code> tritt, der Teil des Gültigkeitsbereichs
von <code>x</code>, der sich mit dem Gültigkeitsbereich von <code>y</code> überschneidet. Mit anderen
Worten bekommt die generische Lebensdauer <code>'a</code> die konkrete Lebensdauer, die
der kürzeren der Lebensdauern von <code>x</code> und <code>y</code> entspricht. Da wir die
zurückgegebene Referenz mit dem gleichen Lebensdauer-Parameter <code>'a</code> annotiert
haben, wird die zurückgegebene Referenz auch für die Dauer der kürzeren
Lebensdauer von <code>x</code> und <code>y</code> gültig sein.</p>
<p>Schauen wir uns an, wie die Lebensdauer-Annotationen die Funktion <code>longest</code>
beschränken, indem wir Referenzen mit unterschiedlichen konkreten Lebensdauern
übergeben. Codeblock 10-22 ist ein einfaches Beispiel.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let string1 = String::from("lange Zeichenkette ist lang");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("Die längere Zeichenkette ist {result}");
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-22: Verwenden der Funktion <code>longest</code> mit
Referenzen auf Zeichenketten, die unterschiedliche konkrete Lebensdauern
haben</span></p>
<p>In diesem Beispiel ist <code>string1</code> bis zum Ende des äußeren Gültigkeitsbereichs
gültig, <code>string2</code> ist bis zum Ende des inneren Gültigkeitsbereichs gültig, und
<code>result</code> referenziert auf etwas, das bis zum Ende des inneren
Gültigkeitsbereichs gültig ist. Führe diesen Code aus und du wirst sehen, dass
der Ausleihenprüfer diesen Code akzeptiert; er kompiliert und gibt <code>Die längere Zeichenkette ist lange Zeichenkette ist lang</code> aus.</p>
<p>Versuchen wir als nächstes ein Beispiel, das zeigt, dass die Lebensdauer der
Referenz in <code>result</code> die kürzere Lebensdauer der beiden Argumente sein muss.
Wir verschieben die Deklaration der Variable <code>result</code> oberhalb des inneren
Gültigkeitsbereichs, lassen aber die Zuweisung des Wertes an die Variable
<code>result</code> innerhalb des Gültigkeitsbereichs mit <code>string2</code>. Dann verschieben wir
<code>println!</code>, das <code>result</code> verwendet, unterhalb des inneren Gültigkeitsbereichs.
Der Code in Codeblock 10-23 lässt sich nicht kompilieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let string1 = String::from("lange Zeichenkette ist lang");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("Die längere Zeichenkette ist {result}");
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-23: Der Versuch, <code>result</code> zu verwenden,
nachdem <code>string2</code> den Gültigkeitsbereich verlassen hat</span></p>
<p>Wenn wir versuchen, diesen Code zu kompilieren, erhalten wir folgenden Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("Die längere Zeichenkette ist {result}");
  |                                            -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Der Fehler zeigt, dass <code>string2</code> bis zum Ende des äußeren Gültigkeitsbereichs
gültig sein müsste, damit <code>result</code> in der Anweisung <code>println!</code> noch gültig ist.
Rust weiß das, weil wir die Lebensdauer der Funktionsparameter und
Rückgabewerte mit dem gleichen Lebensdauerparameter <code>'a</code> annotiert haben.</p>
<p>Als Menschen können wir uns diesen Code ansehen und erkennen, dass <code>string1</code>
länger als <code>string2</code> ist und deshalb wird <code>result</code> eine Referenz auf <code>string1</code>
enthalten. Da <code>string1</code> den Gültigkeitsbereich noch nicht verlassen hat, wird
eine Referenz auf <code>string1</code> in der <code>println!</code>-Anweisung noch gültig sein. Der
Compiler kann jedoch nicht sehen, dass die Referenz in diesem Fall gültig
ist. Wir haben Rust gesagt, dass die Lebensdauer der Referenz, die von der
Funktion <code>longest</code> zurückgegeben wird, die gleiche ist wie die kürzere der
Lebensdauern der entgegengenommenen Referenzen. Daher lehnt der Ausleihenprüfer
den Code in Codeblock 10-23 als möglicherweise ungültige Referenz ab.</p>
<p>Versuche, dir weitere Experimente auszudenken, die die Werte und die
Lebensdauern der an die Funktion <code>longest</code> übergebenen Referenzen variieren und
wie die zurückgegebene Referenz verwendet wird. Stelle Hypothesen darüber auf,
ob deine Experimente den Ausleihenprüfer bestehen oder nicht, bevor du
kompilierst; prüfe dann, ob du Recht hast!</p>
<h3 id="denken-in-lebensdauern"><a class="header" href="#denken-in-lebensdauern">Denken in Lebensdauern</a></h3>
<p>Die Art und Weise, in der du Lebensdauerparameter angeben musst, hängt davon
ab, was deine Funktion tut. Wenn wir zum Beispiel die Implementierung der
Funktion <code>longest</code> so ändern würden, dass sie immer den ersten Parameter
zurückgibt und nicht den längsten Zeichenkettenanteilstyp, bräuchten wir keine
Lebensdauer für den Parameter <code>y</code> anzugeben. Der folgende Code wird
kompilieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "efghijklmnopqrstuvwxyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("Die längere Zeichenkette ist {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
<p>Wir haben einen Lebensdauer-Parameter <code>'a</code> für den Parameter <code>x</code> und den
Rückgabetyp angegeben, aber nicht für den Parameter <code>y</code>, weil die Lebensdauer
von <code>y</code> in keiner Beziehung zur Lebensdauer von <code>x</code> oder dem Rückgabewert
steht.</p>
<p>Wenn eine Funktion eine Referenz zurückgibt, muss der Lebensdauerparameter für
den Rückgabetyp mit dem Lebensdauerparameter für einen der Parameter
übereinstimmen. Wenn sich die zurückgegebene Referenz <em>nicht</em> auf einen der
Parameter bezieht, muss er sich auf einen innerhalb dieser Funktion erzeugten
Wert beziehen. Dies wäre jedoch eine hängende Referenz, da der Wert am Ende der
Funktion den Gültigkeitsbereich verlässt. Betrachte diesen Versuch einer
Implementierung der Funktion <code>longest</code>, die sich nicht kompilieren lässt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("Die längere Zeichenkette ist {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from("wirklich lange Zeichenkette");
    result.as_str()
}</code></pre></pre>
<p>Auch wenn wir hier einen Lebensdauer-Parameter <code>'a</code> für den Rückgabetyp
angegeben haben, wird diese Implementierung nicht kompilieren, weil die
Lebensdauer des Rückgabewerts überhaupt nicht mit der Lebensdauer der Parameter
zusammenhängt. Hier ist die Fehlermeldung, die wir erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Das Problem ist, dass <code>result</code> den Gültigkeitsbereich verlässt und am Ende der
Funktion <code>longest</code> aufgeräumt wird. Wir versuchen auch, eine Referenz auf den
Wert in <code>result</code> zurückzugeben. Es gibt keine Möglichkeit, Lebensdauerparameter
so anzugeben, dass die hängende Referenz beseitigt wird, Rust lässt uns also
keine hängende Referenz erstellen. In diesem Fall wäre die beste Lösung, einen
eigenen Datentyp statt einer Referenz zurückzugeben, sodass die aufrufende
Funktion dann für das Aufräumen des Wertes verantwortlich ist.</p>
<p>Letztlich geht es bei der Lebensdauersyntax darum, die Lebensdauern
verschiedener Parameter und Rückgabewerte von Funktionen miteinander zu
verbinden. Sobald sie verbunden sind, verfügt Rust über genügend Informationen,
um speichersichere Operationen zu ermöglichen und Operationen zu unterbinden,
die hängende Zeiger erzeugen oder anderweitig die Speichersicherheit verletzen
würden.</p>
<h3 id="lebensdauer-annotationen-in-struktur-definitionen"><a class="header" href="#lebensdauer-annotationen-in-struktur-definitionen">Lebensdauer-Annotationen in Struktur-Definitionen</a></h3>
<p>Bisher haben wir nur Strukturen (structs) definiert, die aneigenbare Typen
enthalten. Es ist möglich, dass Strukturen Referenzen enthalten, aber in diesem
Fall müssten wir Lebensdauer-Annotationen zu jeder Referenz in der
Strukturdefinition angeben. Codeblock 10-24 hat eine Struktur namens
<code>ImportantExcerpt</code>, die einen Zeichenkettenanteilstyp enthält.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Nennen Sie mich Ishmael. Vor einigen Jahren ...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
<p><span class="caption">Codeblock 10-24: Eine Struktur, die eine Referenz
enthält, sodass ihre Definition eine Lebensdauer-Annotationen benötigt</span></p>
<p>Diese Struktur hat das einzige Feld <code>part</code>, das einen Zeichenkettenanteilstyp
enthält, der eine Referenz ist. Wie bei generischen Datentypen deklarieren wir
den Namen des generischen Lebensdauerparameters innerhalb spitzer Klammern
hinter dem Strukturnamen, damit wir den Lebensdauerparameter im Rumpf der
Strukturdefinition verwenden können. Diese Annotation bedeutet, dass eine
Instanz von <code>ImportantExcerpt</code> die Referenz, die sie in ihrem Feld <code>part</code>
enthält, nicht überleben kann.</p>
<p>Die Funktion <code>main</code> erzeugt hier eine Instanz der Struktur <code>ImportantExcerpt</code>,
die eine Referenz auf den ersten Satz des <code>String</code> enthält, der der Variablen
<code>novel</code> gehört. Die Daten in <code>novel</code> existieren, bevor die Instanz
<code>ImportantExcerpt</code> erzeugt wird. Darüber hinaus verlässt <code>novel</code> den
Gültigkeitsbereich erst, nachdem <code>ImportantExcerpt</code> den Gültigkeitsbereich
verlassen hat, sodass die Referenz in der <code>ImportantExcerpt</code>-Instanz gültig
ist.</p>
<h3 id="lebensdauer-elision"><a class="header" href="#lebensdauer-elision">Lebensdauer-Elision</a></h3>
<p>Du hast gelernt, dass jede Referenz eine Lebensdauer hat und dass du
Lebensdauerparameter für Funktionen oder Strukturen angeben musst, die
Referenzen verwenden. In Kapitel 4 hatten wir jedoch eine Funktion in Codeblock
4-9, die wiederum in Codeblock 10-25 gezeigt wird, die ohne
Lebensdauer-Annotationen kompiliert.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("Hallo Welt");
</span><span class="boring">
</span><span class="boring">    // first_word funktioniert mit Anteilstypen von `String`
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "Hallo Welt";
</span><span class="boring">
</span><span class="boring">    // first_word funktioniert mit Anteilstypen von Zeichenkettenliteralen
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
</span><span class="boring">    // funktioniert dies auch ohne die Anteilstypensyntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-25: Eine Funktion, die wir in Codeblock 4-9
definiert haben und die ohne Lebensdauer-Annotationen kompiliert, obwohl
Parameter und Rückgabetyp Referenzen sind</span></p>
<p>Der Grund, warum diese Funktion ohne Lebensdauer-Annotationen kompiliert, ist
historisch bedingt: In frühen Versionen (vor 1.0) von Rust hätte sich dieser
Code nicht kompilieren lassen, da jede Referenz eine explizite Lebensdauer
benötigte. Damals wäre die Funktionssignatur so geschrieben worden:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Nachdem jede Menge Rust-Code geschrieben wurde, stellte das Rust-Team fest,
dass die Rust-Programmierer in bestimmten Situationen immer wieder die gleichen
Lebensdauer-Annotationen angaben. Diese Situationen waren vorhersehbar und
folgten einigen wenigen deterministischen Mustern. Die Entwickler
programmierten diese Muster in den Code des Compilers, sodass der
Ausleihenprüfer in diesen Situationen auf die Lebensdauer schließen konnte und
keine expliziten Annotationen benötigte.</p>
<p>Dieses Stück Rust-Geschichte ist relevant, weil es möglich ist, dass weitere
deterministische Muster auftauchen und dem Compiler hinzugefügt werden. In
Zukunft könnten noch weniger Lebensdauer-Annotationen erforderlich sein.</p>
<p>Die Muster, die in Rusts Referenzanalyse programmiert sind, werden die
<em>Lebensdauer-Elisionsregeln</em> (lifetime elision rules) genannt. Dies sind keine
Regeln, die Programmierer befolgen müssen; es handelt sich um eine Reihe
besonderer Fälle, die der Compiler berücksichtigt, und wenn dein Code zu
einem dieser Fälle passt, brauchst du die Lebensdauer nicht explizit anzugeben.</p>
<p>Die Elisionsregeln bieten keine vollständige Schlussfolgerung. Wenn Rust die
Regeln deterministisch anwendet, aber immer noch Unklarheit darüber besteht,
welche Lebensdauer die Referenzen haben, wird der Compiler nicht erraten,
wie lang die Lebensdauer der verbleibenden Referenzen sein sollte. Statt einer
Vermutung gibt dir der Compiler einen Fehler an, den du beheben kannst, indem
du die Lebensdauer-Annotationen angibst, die festlegen, wie sich die Referenzen
zueinander verhalten.</p>
<p>Die Lebensdauern der Funktions- oder Methodenparameter werden als
<em>Eingangslebensdauern</em> (input lifetimes) bezeichnet, und die Lebensdauern der
Rückgabewerte als <em>Ausgangslebensdauern</em> (output lifetimes) bezeichnet.</p>
<p>Der Compiler verwendet drei Regeln, um herauszufinden, welche Lebensdauer
Referenzen haben, wenn keine expliziten Annotationen vorhanden sind. Die erste
Regel gilt für Eingangslebensdauern und die zweite und dritte Regel gelten für
Ausgangslebensdauern. Wenn der Compiler das Ende der drei Regeln erreicht
und es immer noch Referenzen gibt, für die er keine Lebensdauern ermitteln
kann, bricht der Compiler mit einem Fehler ab. Diese Regeln gelten sowohl
für <code>fn</code>-Definitionen als auch für <code>impl</code>-Blöcke.</p>
<p>Die erste Regel ist, dass der Compiler jedem Parameter, der eine Referenz ist,
seinen eigenen Lebensdauerparameter zuweist. Mit anderen Worten, eine Funktion
mit einem Parameter erhält einen Lebensdauerparameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; eine Funktion mit zwei Parametern erhält zwei separate
Lebensdauerparameter: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; und so weiter.</p>
<p>Die zweite Regel lautet: Wenn es genau einen Eingangslebensdauer-Parameter
gibt, wird diese Lebensdauer allen Ausgangslebensdauer-Parametern zugewiesen:
<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>Die dritte Regel lautet: Wenn es mehrere Eingangslebensdauer-Parameter gibt,
aber einer davon <code>&amp;self</code> oder <code>&amp;mut self</code> ist, weil dies eine Methode ist, wird
die Lebensdauer von <code>self</code> allen Ausgangslebensdauer-Parametern zugewiesen.
Diese dritte Regel macht Methoden viel angenehmer zu lesen und zu schreiben,
weil weniger Symbole erforderlich sind.</p>
<p>Tun wir so, als wären wir der Compiler. Wir werden diese Regeln anwenden, um
herauszufinden, wie lang die Lebensdauer der Referenzen in der Signatur der
Funktion <code>first_word</code> in Codeblock 10-26 ist. Die Signatur beginnt ohne
Lebensdauern:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>Dann wendet der Compiler die erste Regel an, die festlegt, dass jeder
Parameter seine eigene Lebensdauer erhält. Wir nennen sie wie üblich <code>'a</code>, also
sieht die Signatur jetzt so aus:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>Die zweite Regel trifft zu, weil es genau eine Eingangslebensdauer gibt. Die
zweite Regel legt fest, dass die Lebensdauer des einen Eingabeparameters der
Ausgangslebensdauer zugeordnet wird, sodass die Signatur nun wie folgt
aussieht:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Jetzt haben alle Referenzen in dieser Funktionssignatur eine Lebensdauer und
der Compiler kann seine Analyse fortsetzen, ohne dass der Programmierer die
Lebensdauer in dieser Funktionssignatur annotieren muss.</p>
<p>Schauen wir uns ein anderes Beispiel an, diesmal mit der Funktion <code>longest</code>,
die keine Lebensdauerparameter hatte, als wir in Codeblock 10-20 mit ihr zu
arbeiten begannen:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>Wenden wir die erste Regel an: Jeder Parameter erhält seine eigene Lebensdauer.
Diesmal haben wir zwei Parameter anstelle von einem, also haben wir zwei
Lebensdauern:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>Du siehst, dass die zweite Regel nicht gilt, weil es mehr als eine
Eingangslebensdauer gibt. Auch die dritte Regel trifft nicht zu, weil <code>longest</code>
eine Funktion ist, keine Methode, sodass keiner der Parameter <code>self</code> ist.
Nachdem wir alle drei Regeln durchgearbeitet haben, haben wir immer noch nicht
herausgefunden, wie lang die Lebensdauer des Rückgabetyps ist. Aus diesem Grund
haben wir beim Versuch, den Code in Codeblock 10-20 zu kompilieren, einen
Fehler erhalten: Der Compiler arbeitete die Lebensdauer-Elisionsregeln
durch, konnte aber immer noch nicht alle Lebensdauern der Referenzen in der
Signatur ermitteln.</p>
<p>Da die dritte Regel eigentlich nur für Methodensignaturen gilt, werden wir uns
als nächstes die Lebensdauern in diesem Zusammenhang ansehen, um zu sehen,
warum die dritte Regel bedeutet, dass wir die Lebensdauer in Methodensignaturen
nicht sehr oft annotieren müssen.</p>
<h3 id="lebensdauer-annotationen-in-methodendefinitionen"><a class="header" href="#lebensdauer-annotationen-in-methodendefinitionen">Lebensdauer-Annotationen in Methodendefinitionen</a></h3>
<p>Wenn wir Methoden auf einer Struktur mit Lebensdauer implementieren, verwenden
wir die gleiche Syntax wie die in Codeblock 10-11 gezeigten generischen
Typparameter. Wo wir die Lebensdauerparameter deklarieren und verwenden, hängt
davon ab, ob sie sich auf die Strukturfelder oder auf die Methodenparameter und
Rückgabewerte beziehen.</p>
<p>Lebensdauer-Namen für Struktur-Felder müssen immer nach dem
<code>impl</code>-Schlüsselwort deklariert und dann hinter dem Namen der Struktur verwendet
werden, da diese Lebensdauern Teil des Typs der Struktur sind.</p>
<p>In Methodensignaturen innerhalb des <code>impl</code>-Blocks können Referenzen an die
Lebensdauern der Referenzen in den Feldern der Struktur gebunden sein oder sie
können unabhängig sein. Darüber hinaus sorgen die Lebensdauer-Elisionsregeln
oft dafür, dass Lebensdauer-Annotationen in Methodensignaturen nicht
erforderlich sind. Betrachten wir einige Beispiele mit der Struktur
<code>ImportantExcerpt</code>, die wir in Codeblock 10-24 definiert haben.</p>
<p>Zuerst werden wir eine Methode namens <code>level</code> verwenden, deren einziger
Parameter eine Referenz auf <code>self</code> ist und deren Rückgabewert ein <code>i32</code> ist,
was keine Referenz ist:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!("Bitte um Aufmerksamkeit: {announcement}");
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Nennen Sie mich Ishmael. Vor einigen Jahren ...");
</span><span class="boring">    let first_sentence = novel.split('.').next().expect("Konnte keinen '.' finden.");
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>Die Lebensdauer-Parameter-Deklaration nach <code>impl</code> und ihre Verwendung hinter dem
Typnamen sind erforderlich, aber wir sind nicht verpflichtet, die Lebensdauer der
Referenz auf <code>self</code> wegen der ersten Elisionsregel zu annotieren.</p>
<p>Hier ist ein Beispiel, bei dem die dritte Lebensdauer-Elisionsregel gilt:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Bitte um Aufmerksamkeit: {announcement}");
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Nennen Sie mich Ishmael. Vor einigen Jahren ...");
</span><span class="boring">    let first_sentence = novel.split('.').next().expect("Konnte keinen '.' finden.");
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>Es gibt zwei Eingangslebensdauern, sodass Rust die erste
Lebensdauer-Elisionsregel anwendet und sowohl <code>&amp;self</code> als auch <code>announcement</code>
ihre eigene Lebensdauer gibt. Da einer der Parameter <code>&amp;self</code> ist, erhält der
Rückgabetyp die Lebensdauer von <code>&amp;self</code>, und alle Lebensdauern sind
berücksichtigt worden.</p>
<h3 id="statische-lebensdauer"><a class="header" href="#statische-lebensdauer">Statische Lebensdauer</a></h3>
<p>Eine besondere Lebensdauer, die wir besprechen müssen, ist <code>'static</code>, was
bedeutet, dass diese Referenz während der gesamten Dauer des Programms bestehen
kann. Alle Zeichenkettenliterale haben die Lebensdauer <code>'static</code>. Sie wird wie
folgt annotiert:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "Ich habe eine statische Lebensdauer.";
<span class="boring">}</span></code></pre></pre>
<p>Der Text dieser Zeichenkette wird direkt in der Binärdatei des Programms
gespeichert, die immer verfügbar ist. Daher ist die Lebensdauer aller
Zeichenkettenliterale <code>'static</code>.</p>
<p>Möglicherweise siehst du in Fehlermeldungen Hinweise zur Verwendung der
Lebensdauer <code>'static</code>. Aber bevor du <code>'static</code> als Lebensdauer für eine
Referenz angibst, denke darüber nach, ob deine Referenz tatsächlich während der
gesamten Lebensdauer deines Programms lebt oder nicht, und ob du das so willst.
In den meisten Fällen resultiert eine Fehlermeldung, die auf die Lebensdauer
<code>'static</code> hindeutet, aus dem Versuch, eine hängende Referenz zu erstellen, oder
aus einer Nichtübereinstimmung der verfügbaren Lebensdauern. In solchen Fällen
besteht die Lösung darin, diese Probleme zu beheben und nicht darin, die
Lebensdauer als <code>'static</code> festzulegen.</p>
<h2 id="generische-typparameter-merkmalsabgrenzungen-und-lebensdauern-zusammen"><a class="header" href="#generische-typparameter-merkmalsabgrenzungen-und-lebensdauern-zusammen">Generische Typparameter, Merkmalsabgrenzungen und Lebensdauern zusammen</a></h2>
<p>Schauen wir uns kurz die Syntax zu Angabe generischer Typparameter,
Merkmalsabgrenzungen und Lebensdauern in einer Funktion an!</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        "Heute hat jemand Geburtstag!",
</span><span class="boring">    );
</span><span class="boring">    println!("Die längere Zeichenkette ist {result}");
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!("Bekanntmachung! {ann}");
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>Dies ist die Funktion <code>longest</code> aus Codeblock 10-21, die die längere von zwei
Zeichenkettenanteilstypen zurückgibt. Aber jetzt hat sie einen zusätzlichen
Parameter namens <code>ann</code> vom generischen Typ <code>T</code>, der jeder beliebige Typ sein
kann, der das Merkmal <code>Display</code> implementiert, wie in der <code>where</code>-Klausel
spezifiziert ist. Dieser zusätzliche Parameter wird unter Verwendung von
<code>{ann}</code> ausgegeben, weshalb die Merkmalsabgrenzung <code>Display</code> erforderlich ist.
Da die Lebensdauer ein generischer Typ ist, stehen die Deklarationen des
Lebensdauer-Parameters <code>'a</code> und des generischen Typ-Parameters <code>T</code> in der
gleichen Liste innerhalb spitzer Klammern hinter dem Funktionsnamen.</p>
<h2 id="zusammenfassung-9"><a class="header" href="#zusammenfassung-9">Zusammenfassung</a></h2>
<p>Wir haben in diesem Kapitel viel behandelt! Jetzt, da du über generische
Typparameter, Merkmale und Merkmalsabgrenzungen sowie generische
Lebensdauerparameter Bescheid weißt, bist du bereit, Code ohne Wiederholungen
zu schreiben, der in vielen verschiedenen Situationen funktioniert. Merkmale
und Merkmalsabgrenzungen stellen sicher, dass die Typen, auch wenn sie
generisch sind, das Verhalten haben, das der Code benötigt. Du hast gelernt,
wie man Lebensdauer-Annotationen verwendet, um sicherzustellen, dass dieser
flexible Code keine hängenden Referenzen hat. Und all diese Analysen finden zur
Kompilierzeit statt, was die Laufzeitperformanz nicht beeinträchtigt!</p>
<p>Ob du es glaubst oder nicht, es gibt zu den Themen, die wir in diesem Kapitel
besprochen haben, noch viel mehr zu sagen: In Kapitel 18 werden Merkmalsobjekte
erörtert, die eine weitere Möglichkeit zur Verwendung von Merkmalen darstellen.
Es gibt auch komplexere Szenarien mit Lebensdauer-Annotationen, die du nur in
sehr fortgeschrittenen Szenarien benötigst; für diese solltest du die
<a href="https://doc.rust-lang.org/reference/index.html">Rust-Referenz</a> lesen. Aber als Nächstes wirst du lernen, wie man
Tests in Rust schreibt, damit du sicherstellen kannst, dass dein Code so
funktioniert, wie er es soll.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatisierte-tests-schreiben"><a class="header" href="#automatisierte-tests-schreiben">Automatisierte Tests schreiben</a></h1>
<p>In seinem Essay „Der bescheidene Programmierer“ von 1972 sagte Edsger W.
Dijkstra, dass „Programmtests eine sehr effektive Methode sein können, das
Vorhandensein von Fehlern zu zeigen, aber sie sind hoffnungslos unzureichend,
um deren Abwesenheit zu zeigen“. Das bedeutet nicht, dass wir nicht versuchen
sollten, so viel wie möglich zu testen!</p>
<p>Korrektheit unserer Programme ist das Maß, inwieweit unser Code das tut, was
wir beabsichtigen. Bei der Entwicklung von Rust wird der Korrektheit von
Programmen große Bedeutung beigemessen, aber Korrektheit ist komplex und nicht
leicht zu beweisen. Das Typsystem von Rust trägt einen großen Teil dieser Last,
aber das Typsystem kann nicht alles erkennen. Rust beinhaltet Unterstützung für
das Schreiben automatisierter Softwaretests.</p>
<p>Nehmen wir an, wir schreiben eine Funktion namens <code>add_two</code>, die 2 zu jeder
Zahl addiert, die ihr übergeben wird. Die Signatur dieser Funktion akzeptiert
eine ganze Zahl als Parameter und gibt als Ergebnis eine ganze Zahl zurück.
Wenn wir diese Funktion implementieren und kompilieren, führt Rust die gesamte
Typ- und Ausleihenprüfung durch, die du bisher kennengelernt hast, um
sicherzustellen, dass wir z.B. keinen <code>String</code>-Wert oder eine ungültige
Referenz an diese Funktion übergeben. Aber Rust kann <em>nicht</em> überprüfen, ob
diese Funktion genau das tut, was wir beabsichtigen, nämlich den Parameter plus
2 zurückzugeben und nicht etwa den Parameter plus 10 oder den Parameter minus
50! Hier kommen Tests ins Spiel.</p>
<p>Wir können Tests schreiben, die zum Beispiel sicherstellen, dass der
Rückgabewert <code>5</code> ist, wenn wir <code>3</code> an die Funktion <code>add_two</code> übergeben. Wir
können diese Tests immer dann durchführen, wenn wir Änderungen an unserem Code
vornehmen, um sicherzustellen, dass sich ein bestehendes korrektes Verhalten
nicht geändert hat.</p>
<p>Testen ist eine komplexe Fähigkeit: Obwohl wir in einem Kapitel nicht jedes
Detail, wie man gute Tests schreibt, behandeln können, werden wir in diesem
Kapitel die Mechanismen der Rust-Testmöglichkeiten besprechen. Wir werden über
Annotationen und Makros sprechen, die dir beim Schreiben deiner Tests zur
Verfügung stehen, über das Standardverhalten und die Optionen, die es bei der
Ausführung deiner Tests gibt, und darüber, wie du Tests in Modultests (unit
tests) und Integrationstests organisieren kannst.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tests-schreiben"><a class="header" href="#tests-schreiben">Tests schreiben</a></h2>
<p>Tests sind Funktionen in Rust, die überprüfen, ob der zu testende Code in der
erwarteten Weise funktioniert. Der Rumpf von Testfunktionen führt in der Regel
diese drei Aktionen aus:</p>
<ul>
<li>Bereite die benötigten Daten und Zustände vor.</li>
<li>Führe den Code aus, den du testen möchtest.</li>
<li>Stelle sicher, dass die Ergebnisse die sind, was du erwartest.</li>
</ul>
<p>Schauen wir uns die Funktionalität an, die Rust speziell für das Schreiben von
Tests bereitstellt, die diese Aktionen ausführen. Dazu gehören das Attribut
<code>test</code>, einige Makros und das Attribut <code>should_panic</code>.</p>
<h3 id="anatomie-einer-testfunktion"><a class="header" href="#anatomie-einer-testfunktion">Anatomie einer Testfunktion</a></h3>
<p>Im einfachsten Fall ist ein Test in Rust eine Funktion, die mit dem Attribut
<code>test</code> annotiert wird. Attribute sind Metadaten über Teile des Rust-Codes; ein
Beispiel ist das Attribut <code>derive</code>, das wir in Kapitel 5 bei Strukturen
verwendet haben. Um eine Funktion in eine Testfunktion zu verwandeln, füge
<code>#[test]</code> oberhalb der Zeile mit <code>fn</code> ein. Wenn du deine Tests mit dem Befehl
<code>cargo test</code> ausführst, erstellt Rust eine Testausführungs-Binärdatei (test
runner binary), die die annotierte Funktionen ausführt und darüber berichtet,
ob jede Testfunktion erfolgreich war oder nicht.</p>
<p>Wann immer wir ein neues Bibliotheksprojekt mit Cargo durchführen, wird für uns
automatisch ein Testmodul mit einer Testfunktion darin generiert. Dieses Modul
gibt dir eine Vorlage, um deine Tests zu schreiben, sodass du nicht jedes Mal,
wenn du ein neues Projekt startest, die genaue Struktur und Syntax nachschlagen
musst. Du kannst so viele zusätzliche Testfunktionen und Testmodule hinzufügen,
wie du möchtest!</p>
<p>Wir werden einige Aspekte der Funktionsweise von Tests untersuchen, indem wir
mit der Testvorlage experimentieren, bevor wir tatsächlich Code testen. Dann
schreiben wir einige Tests aus der realen Welt, die einen von uns geschriebenen
Code aufrufen und sicherstellen, dass sein Verhalten korrekt ist.</p>
<p>Lass uns ein neues Bibliotheksprojekt namens <code>adder</code> erstellen, das zwei Zahlen
addiert:</p>
<pre><code class="language-console noplayground">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>Der Inhalt der Datei <em>src/lib.rs</em> in deiner Bibliothek <code>adder</code> sollte wie
Codeblock 11-1 aussehen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 11-1: Das Testmodul und die Funktion, die
automatisch von <code>cargo new</code> generiert werden</span></p>
<p>Die Datei beginnt mit einer Beispielfunktion <code>add</code>, damit wir etwas zum Testen
haben.</p>
<p>Konzentrieren wir uns zunächst nur auf die Funktion <code>it_works</code>. Beachte die
Annotation <code>#[test]</code>: Dieses Attribut zeigt an, dass es sich um eine
Testfunktion handelt, sodass die Testausführung weiß, dass es diese Funktion
als einen Test behandeln soll. Wir könnten auch Nicht-Test-Funktionen im Modul
<code>tests</code> haben, um gängige Szenarien aufzusetzen oder gängige Operationen
durchzuführen, daher müssen wir immer angeben, welche Funktionen Tests sind.</p>
<p>Der Beispiel-Funktionsrumpf verwendet das Makro <code>assert_eq!</code>, um
sicherzustellen, dass <code>result</code>, das das Ergebnis des Funktionsaufrufs von <code>add</code>
mit 2 und 2 enthält, gleich 4 ist. Diese Prüfung dient als Beispiel für den
Aufbau eines typischen Tests. Lassen wir ihn laufen, um zu sehen, dass dieser
Test erfolgreich ist.</p>
<p>Das Kommando <code>cargo test</code> führt alle Tests in unserem Projekt aus, wie in
Codeblock 11-2 zu sehen ist.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p><span class="caption">Codeblock 11-2: Ergebnis der Ausführung des automatisch
generierten Tests</span></p>
<p>Cargo hat den Test kompiliert und ausgeführt. Nach den Zeilen <code>Compiling</code>,
<code>Finished</code> und <code>Running</code> folgt die Zeile <code>running 1 test</code>. Die nächste Zeile
zeigt den Namen der generierten Testfunktion <code>tests::it_works</code> und das Ergebnis
der Testausführung: <code>ok</code>. Als nächstes wird die Gesamtzusammenfassung der
Testausführung angegeben. Der Text <code>test result: ok.</code> bedeutet, dass alle Tests
bestanden wurden, und der Teil <code>1 passed; 0 failed</code> gibt die Anzahl der Tests
an, die bestanden oder nicht bestanden wurden.</p>
<p>Es ist möglich, einen Test als ignoriert zu markieren, sodass er in einer
bestimmten Instanz nicht ausgeführt wird; wir werden dies im Abschnitt <a href="ch11-02-running-tests.html#tests-ignorieren-die-nicht-ausdr%C3%BCcklich-verlangt-werden">„Tests
ignorieren, die nicht ausdrücklich verlangt werden“</a> später in
diesem Kapitel behandeln. Da wir das hier nicht getan haben, zeigt die
Zusammenfassung <code>0 ignored</code>. Wir können auch ein Argument an den Befehl <code>cargo  test</code> übergeben, um nur Tests auszuführen, deren Name mit einer Zeichenkette
übereinstimmt; dies wird <em>Filtern</em> genannt und wir werden dies in <a href="ch11-02-running-tests.html#ausf%C3%BChren-einer-test-teilmenge-mittels-name">„Ausführen
einer Test-Teilmenge mittels Name“</a> behandeln. Außerdem haben wir die
durchgeführten Tests nicht gefiltert, sodass am Ende der Zusammenfassung <code>0 filtered out</code> steht.</p>
<p>Die Statistik <code>0 measured</code> ist für Benchmark-Tests, die die Performanz messen.
Benchmark-Tests sind zum Zeitpunkt, als dieser Text verfasst wurde, nur im
nächtlichen (nightly) Rust verfügbar. Siehe <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">„Dokumentation über
Benchmark-Tests“</a>, um mehr zu erfahren.</p>
<p>Der nächste Teil der Testausgabe, der mit <code>Doc-tests adder</code> beginnt, ist für
die Ergebnisse von Dokumentationstests. Wir haben noch keine
Dokumentationstests, aber Rust kann alle Code-Beispiele kompilieren, die in
unserer API-Dokumentation erscheinen. Diese Funktionalität hilft dabei,
deine Dokumentation und deinen Code synchron zu halten! Wie man
Dokumentationstests schreibt, werden wir im Abschnitt
<a href="ch14-02-publishing-to-crates-io.html#dokumentationskommentare-als-tests">„Dokumentationskommentare als Tests“</a> in Kapitel 14 besprechen.
Vorerst ignorieren wir die Ausgabe von <code>Doc-tests</code>.</p>
<p>Beginnen wir damit, den Test an unsere eigenen Bedürfnisse anzupassen. Ändere
zunächst den Namen der Funktion <code>it_works</code> in einen anderen Namen, z.B.
<code>exploration</code>, wie folgt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Dann führe <code>cargo test</code> erneut aus. Die Ausgabe zeigt nun <code>exploration</code>
anstelle von <code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Fügen wir einen weiteren Test hinzu, aber dieses Mal machen wir einen Test, der
fehlschlägt! Tests schlagen fehl, wenn etwas die Testfunktion zum Abbrechen
bringt. Jeder Test wird in einem neuen Strang (thread) ausgeführt und wenn der
Hauptstrang (main thread) sieht, dass ein Teststrang (test thread) abgebrochen
wurde, wird der Test als fehlgeschlagen markiert. Über den einfachsten Weg, ein
Programm abzubrechen, sprachen wir in Kapitel 9, und zwar durch den Aufruf des
Makros <code>panic!</code>. Erstelle einen neuen Test <code>another</code>, sodass deine Datei
<em>src/lib.rs</em> wie in Codeblock 11-3 aussieht.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("Lasse diesen Test fehlschlagen");
    }
}</code></pre>
<p><span class="caption">Codeblock 11-3: Hinzufügen eines zweiten Tests, der
fehlschlägt, weil wir das Makro <code>panic!</code> aufrufen</span></p>
<p>Führe die Tests erneut mit <code>cargo test</code> aus. Die Ausgabe sollte wie in
Codeblock 11-4 aussehen, was zeigt, dass unser Test <code>exploration</code> bestanden und
<code>another</code> fehlgeschlagen ist.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at src/lib.rs:10:9:
Lasse diesen Test fehlschlagen
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p><span class="caption">Codeblock 11-4: Testergebnisse, wenn ein Test bestanden
und ein Test nicht bestanden wird</span></p>
<p>Statt <code>ok</code> zeigt die Zeile <code>test tests::another</code> das Ergebnis <code>FAILED</code>.
Zwischen den Einzelergebnissen und der Zusammenfassung erscheinen zwei neue
Abschnitte: Der erste zeigt die detaillierte Ursache für jeden fehlgeschlagenen
Test an. In diesem Fall erhalten wir Details, dass <code>another</code> scheiterte mit der
Meldung <code>panicked at 'Lasse diesen Test fehlschlagen'</code> in Zeile 17 der Datei
<em>src/lib.rs</em>. Der nächste Abschnitt listet nur die Namen aller fehlgeschlagenen
Tests auf, was nützlich ist, wenn es viele Tests und viele detaillierte
Ausgaben von fehlgeschlagenen Tests gibt. Wir können den Namen eines
fehlgeschlagenen Tests verwenden, um genau diesen Test auszuführen, um ihn
leichter zu debuggen; wir werden im Abschnitt <a href="ch11-02-running-tests.html">„Steuern wie Tests ausgeführt
werden“</a> mehr über Möglichkeiten zur Ausführung
von Tests sprechen.</p>
<p>Die Zusammenfassungszeile zeigt am Ende an: Insgesamt ist unser Testergebnis
<code>FAILED</code>. Wir hatten einen Test bestanden und einen Test nicht bestanden.</p>
<p>Da du nun gesehen hast, wie die Testergebnisse in verschiedenen Szenarien
aussehen, wollen wir uns einige Makros neben <code>panic!</code> ansehen, die bei Tests
nützlich sind.</p>
<h3 id="ergebnisse-überprüfen-mit-dem-makro-assert"><a class="header" href="#ergebnisse-überprüfen-mit-dem-makro-assert">Ergebnisse überprüfen mit dem Makro <code>assert!</code></a></h3>
<p>Das Makro <code>assert!</code>, das von der Standardbibliothek bereitgestellt wird, ist
nützlich, wenn du sicherstellen willst, dass eine Bedingung in einem Test als
wahr (true) bewertet wird. Wir geben dem Makro <code>assert!</code> ein Argument, das
boolesch ausgewertet wird. Wenn der Wert <code>true</code> ist, passiert nichts und der
Test ist bestanden. Wenn der Wert <code>false</code> ist, ruft das Makro <code>assert!</code> das
Makro <code>panic!</code> auf, um den Test fehlschlagen zu lassen. Das Verwenden des
Makros <code>assert!</code> hilft uns zu überprüfen, ob unser Code so funktioniert, wie
wir es beabsichtigen.</p>
<p>In Codeblock 5-15 in Kapitel 5 haben wir eine Struktur <code>Rectangle</code> und eine
Methode <code>can_hold</code> verwendet, die hier in Codeblock 11-5 wiederholt werden.
Lass uns diesen Code in die Datei <em>src/lib.rs</em> packen und dann einige Tests
dafür mit dem Makro <code>assert!</code> schreiben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
<p><span class="caption">Codeblock 11-5: Verwenden der Struktur <code>Rectangle</code> und
ihrer Methode <code>can_hold</code> aus Kapitel 5</span></p>
<p>Die Methode <code>can_hold</code> gibt ein Boolean zurück, was bedeutet, dass es ein
perfekter Anwendungsfall für das Makro <code>assert!</code> ist. In Codeblock 11-6
schreiben wir einen Test, der die Methode <code>can_hold</code> überprüft, indem wir eine
<code>Rectangle</code>-Instanz mit einer Breite von 8 und einer Höhe von 7 erstellen und
sicherstellen, dass es eine weitere <code>Rectangle</code>-Instanz mit einer Breite von 5
und einer Höhe von 1 enthalten kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
<span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
<p><span class="caption">Codeblock 11-6: Ein Test für <code>can_hold</code>, der prüft, ob in
ein größeres Rechteck tatsächlich ein kleineres Rechteck passt</span></p>
<p>Beachte die Zeile <code>use super::*;</code> im Modul <code>tests</code>. Das Modul <code>tests</code> ist ein
reguläres Modul, das den üblichen Sichtbarkeitsregeln folgt, die wir in Kapitel
7 im Abschnitt <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit Pfaden auf ein Element im Modulbaum
verweisen“</a> behandelt haben.
Da das Modul <code>tests</code> ein inneres Modul ist, müssen wir den Code, der im äußeren
Modul getestet wird, in den Gültigkeitsbereich des inneren Moduls bringen. Wir
verwenden hier einen Stern (glob), sodass alles, was wir im äußeren Modul
definieren, auch in diesem Modul <code>tests</code> zur Verfügung steht.</p>
<p>Wir haben unseren Test <code>larger_can_hold_smaller</code> genannt und wir haben die
beiden <code>Rectangle</code>-Instanzen erzeugt, die wir benötigen. Dann haben wir das
Makro <code>assert!</code> aufgerufen und ihm das Aufrufergebnis von
<code>larger.can_hold(&amp;smaller)</code> übergeben. Dieser Ausdruck soll <code>true</code> zurückgeben,
also sollte unser Test erfolgreich sein. Lass es uns herausfinden!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Es funktioniert! Fügen wir noch einen weiteren Test hinzu, diesmal mit der
Zusicherung, dass ein kleineres Rechteck nicht in ein größeres Rechteck passt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --abschneiden--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>Da das korrekte Ergebnis der Funktion <code>can_hold</code> in diesem Fall <code>false</code> ist,
müssen wir dieses Ergebnis negieren, bevor wir es an das Makro <code>assert!</code>
übergeben. Als Ergebnis wird unser Test bestehen, wenn <code>can_hold</code> den
Rückgabewert <code>false</code> hat:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Zwei Tests, die erfolgreich sind! Nun wollen wir sehen, was mit unseren
Testergebnissen passiert, wenn wir einen Fehler in unseren Code einbringen.
Wir ändern die Implementierung der Methode <code>can_hold</code>, indem wir das
größer-als-Zeichen durch ein kleiner-als-Zeichen ersetzen, wenn sie die Breiten
vergleicht:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Das Ausführen der Tests ergibt nun Folgendes:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Unsere Tests haben den Fehler entdeckt! Da <code>larger.width</code> gleich <code>8</code> ist und
<code>smaller.width</code> gleich <code>5</code>, ergibt der Vergleich der Breiten in <code>can_hold</code> jetzt
<code>false</code>: 8 ist nicht kleiner als 5.</p>
<h3 id="prüfung-auf-gleichheit-mit-den-makros-assert_eq-und-assert_ne"><a class="header" href="#prüfung-auf-gleichheit-mit-den-makros-assert_eq-und-assert_ne">Prüfung auf Gleichheit mit den Makros <code>assert_eq!</code> und <code>assert_ne!</code></a></h3>
<p>Eine übliche Methode zum Verifizieren von Funktionalität besteht darin, das
Ergebnis des zu testenden Codes auf Gleichheit mit dem Wert zu testen, den du
vom Code erwartest, um sicherzustellen. Du könntest dies mit dem Makro
<code>assert!</code> tun und ihm einen Ausdruck mit dem Operator <code>==</code> übergeben. Dies ist
jedoch ein so häufiger Testfall, dass die Standardbibliothek zwei Makros zur
Verfügung stellt, um diesen Test bequemer durchzuführen: <code>assert_eq!</code> und
<code>assert_ne!</code>. Diese Makros vergleichen zwei Argumente auf Gleichheit bzw.
Ungleichheit. Sie geben auch die beiden Werte aus, wenn die Zusicherung
fehlschlägt, was es einfacher macht zu erkennen, <em>warum</em> der Test
fehlgeschlagen ist; umgekehrt zeigt das Makro <code>assert!</code> nur an, dass der
Ausdruck <code>==</code> den Wert <code>false</code> ergeben hat, ohne die Werte auszugeben, die zum
falschen Testergebnis geführt haben.</p>
<p>In Codeblock 11-7 schreiben wir eine Funktion namens <code>add_two</code>, die zu ihrem
Parameter <code>2</code> addiert, dann testen wir diese Funktion mit dem Makro
<code>assert_eq!</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p><span class="caption">Codeblock 11-7: Testen der Funktion <code>add_two</code> mit dem
Makro <code>assert_eq!</code></span></p>
<p>Lass uns prüfen, ob sie den Test besteht!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Wir erstellen eine Variable namens <code>result</code>, die das Ergebnis des Aufrufs von
<code>add_two(2)</code> enthält. Dann übergeben wir <code>result</code> und <code>4</code> als Argumente an
<code>assert_eq!</code>. Die Ausgabezeile für diesen Test lautet <code>test tests::it_adds_two  ... ok</code>, und das Wort <code>ok</code> gibt an, dass unser Test bestanden wurde!</p>
<p>Lass uns einen Fehler in unseren Code einbringen, um zu sehen, wie <code>assert_eq!</code>
aussieht, wenn es fehlschlägt. Ändern wir die Implementierung der Funktion
<code>add_two</code>, sodass sie stattdessen <code>3</code> addiert:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}

<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Führe die Tests erneut aus:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at src/lib.rs:11:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Unser Test hat den Fehler entdeckt! Der Test <code>it_adds_two</code> schlug fehl und die
Meldung sagt uns, dass die fehlgeschlagene Zusicherung <code>assertion `left == right` failed</code> ist und welche Werte <code>left</code> und <code>right</code> hatten. Diese Nachricht
hilft uns, mit der Fehlersuche zu beginnen: Das Argument <code>left</code> mit dem
Ergebnis von <code>add_two(2)</code> war <code>5</code>, aber das Argument <code>right</code> war <code>4</code>. Du kannst
dir vorstellen, dass dies besonders hilfreich ist, wenn wir viele Tests
durchführen.</p>
<p>Beachte, dass in einigen Sprachen und Test-Bibliotheken die Parameter der
Gleichheitszusicherung <code>expected</code> und <code>actual</code> genannt werden und deren
Reihenfolge wichtig ist. In Rust werden sie jedoch <code>left</code> und <code>right</code> genannt
und die Reihenfolge, in der wir den erwarteten Wert und den vom Code
produzierten Wert angeben, spielt keine Rolle. Wir könnten die Zusicherung in
diesem Test als <code>assert_eq!(add_two(2), result)</code> schreiben, was zur selben
Fehlermeldung <code>assertion failed: `(left == right)` </code> führen würde.</p>
<p>Das Makro <code>assert_ne!</code> prüft, ob die beiden Werte, die wir ihm übergeben,
ungleich sind und scheitert, wenn sie gleich sind. Dieses Makro ist am
nützlichsten in Fällen, in denen wir nicht sicher sind, <em>welchen</em> Wert wir
bekommen werden, aber wir wissen, welcher Wert es definitiv <em>nicht</em> sein sollte.
Wenn wir zum Beispiel eine Funktion testen, die ihre Eingabe garantiert in
irgendeiner Weise verändert, aber die Art und Weise, wie die Eingabe verändert
wird, vom Wochentag abhängt, an dem wir unsere Tests ausführen, ist es
vielleicht am besten sicherzustellen, dass die Ausgabe der Funktion nicht
gleich der Eingabe ist.</p>
<p>Unter der Haube verwenden die Makros <code>assert_eq!</code> und <code>assert_ne!</code> die
Operatoren <code>==</code> bzw. <code>!=</code>. Wenn die Zusicherungen fehlschlagen, geben diese
Makros ihre Argumente unter Verwendung der Debug-Formatierung aus, was
bedeutet, dass die zu vergleichenden Werte die Merkmale <code>PartialEq</code> und
<code>Debug</code> implementieren müssen. Alle primitiven Typen und die meisten
Standardbibliothekstypen implementieren diese Merkmale. Für Strukturen und
Aufzählungen, die du definierst, musst du <code>PartialEq</code> implementieren, um
die Gleichheit dieser Typen sicherzustellen. Du musst auch <code>Debug</code>
implementieren, um die Werte auszugeben, wenn die Zusicherung fehlschlägt. Da
es sich bei beiden Merkmalen um ableitbare Merkmale handelt, wie in Codeblock
5-12 in Kapitel 5 erwähnt, genügt normalerweise das Ergänzen der Annotation
<code>#[derive(PartialEq, Debug)]</code> bei deiner Struktur- und Aufzählungsdefinition.
Siehe Anhang C <a href="appendix-03-derivable-traits.html">„Ableitbare Merkmale (traits)“</a> für weitere
Einzelheiten über diese und andere ableitbare Merkmale.</p>
<h3 id="benutzerdefinierte-fehlermeldungen-angeben"><a class="header" href="#benutzerdefinierte-fehlermeldungen-angeben">Benutzerdefinierte Fehlermeldungen angeben</a></h3>
<p>Du kannst den Makros <code>assert!</code>, <code>assert_eq!</code> und <code>assert_ne!</code> optional auch
eine benutzerdefinierte Nachricht mitgeben, die mit der Fehlermeldungen
ausgegeben wird. Alle Argumente, die nach den erforderlichen Argumenten
angegeben werden, werden an das Makro <code>format!</code> übergeben (siehe
<a href="ch08-02-strings.html#aneinanderh%C3%A4ngen-mit-dem-operator--und-dem-makro-format">„Aneinanderhängen mit dem Operator <code>+</code> und dem Makro
<code>format!</code>“</a> in Kapitel
8), sodass du eine Formatierungs-Zeichenkette übergeben kannst, die Platzhalter
<code>{}</code> und Werte enthält, die in diese Platzhalter gehören. Benutzerdefinierte
Nachrichten sind nützlich, um zu dokumentieren, was eine Zusicherung bedeutet;
wenn ein Test fehlschlägt, hast du eine bessere Vorstellung davon, wo das
Problem im Code liegt.</p>
<p>Nehmen wir zum Beispiel an, wir haben eine Funktion, die Leute mit Namen
begrüßt, und wir wollen testen, ob der Name, den wir an die Funktion übergeben,
in der Ausgabe auftaucht:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hallo {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>Die Anforderungen für dieses Programm sind noch nicht abgestimmt worden und wir
sind ziemlich sicher, dass sich der Text <code>Hallo</code> zu Beginn der Begrüßung ändern
wird. Wir haben beschlossen, dass wir den Test nicht aktualisieren wollen, wenn
sich die Anforderungen ändern. Anstatt also zu prüfen, ob der Test exakt dem
von der Funktion <code>greeting</code> zurückgegebenen Wert entspricht, stellen wir
einfach sicher, dass die Ausgabe den Text des Eingabeparameters enthält.</p>
<p>Lass uns nun einen Fehler in diesen Code einbringen, indem wir <code>greeting</code> so
ändern, dass <code>name</code> nicht enthalten ist, um zu sehen, wie das
Standard-Testversagen aussieht:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hallo!")
}

<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Das Ausführen dieses Tests führt zu folgender Ausgabe:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Dieses Ergebnis zeigt nur an, dass die Zusicherung fehlgeschlagen ist und in
welcher Zeile die Zusicherung steht. Eine nützlichere Fehlermeldung würde den
Wert der Funktion <code>greeting</code> ausgeben. Fügen wir eine benutzerdefinierte
Fehlermeldung hinzu, die aus einer Formatierungszeichenkette mit einem
Platzhalter besteht, der mit dem tatsächlichen Wert aus der Funktion <code>greeting</code>
gefüllt ist:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hallo!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Begrüßung enthielt nicht den Namen, Wert war `{result}`"
        );
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Wenn wir jetzt den Test ausführen, erhalten wir eine aussagekräftigere
Fehlermeldung:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Begrüßung enthielt nicht den Namen, Wert war `Hallo!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Wir können den Wert, den wir tatsächlich erhalten haben, in der Testausgabe
sehen, was uns helfen wird, das zu debuggen, was passiert ist, anstatt das,
was wir erwartet hatten.</p>
<h3 id="mit-should_panic-auf-programmabbrüche-prüfen"><a class="header" href="#mit-should_panic-auf-programmabbrüche-prüfen">Mit <code>should_panic</code> auf Programmabbrüche prüfen</a></h3>
<p>Neben der Prüfung von Rückgabewerten ist es auch wichtig zu prüfen, ob unser
Code Fehlerbedingungen so behandelt, wie wir es erwarten. Denke zum Beispiel an
den Typ <code>Guess</code>, den wir in Kapitel 9 in Codeblock 9-13 erstellt haben. Anderer
Code, der <code>Guess</code> verwendet, hängt von der Garantie ab, dass <code>Guess</code>-Instanzen
nur Werte zwischen 1 und 100 enthalten. Wir können einen Test schreiben, der
sicherstellt, dass der Versuch, eine <code>Guess</code>-Instanz mit einem Wert außerhalb
dieses Bereichs zu erzeugen, zum Programmabbrucht führt.</p>
<p>Wir tun dies, indem wir das Attribut <code>should_panic</code> zu unserer Testfunktion
hinzufügen. Der Test gilt als bestanden, wenn der Code innerhalb der Funktion
abbricht; der Test schlägt fehl, wenn der Code innerhalb der Funktion nicht
abbricht.</p>
<p>Codeblock 11-8 zeigt einen Test, der prüft, ob die Fehlerbedingungen von
<code>Guess::new</code> eintreten, wenn wir dies erwarten.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Schätzwert muss zwischen 1 und 100 liegen, ist {value}.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<p><span class="caption">Codeblock 11-8: Testet, dass eine Bedingung zum
Programmabbruch führt</span></p>
<p>Wir setzen das Attribut <code>#[should_panic]</code> hinter das Attribut <code>#[test]</code> und vor
die Testfunktion, auf die sie sich bezieht. Schauen wir uns das Ergebnis an,
wenn dieser Test bestanden ist:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Sieht gut aus! Lass uns nun einen Fehler in unseren Code einbringen, indem wir
die Bedingung entfernen, bei der die Funktion <code>new</code> das Programm abbricht, wenn
der Wert größer als 100 ist:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!("Schätzwert muss zwischen 1 und 100 liegen, ist {value}.");
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Wenn wir den Test in Codeblock 11-8 ausführen, wird er fehlschlagen:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Wir erhalten in diesem Fall keine sehr hilfreiche Meldung, aber wenn wir uns
die Testfunktion ansehen, sehen wir, dass sie mit <code>#[should_panic]</code> annotiert
ist. Der Fehler, den wir erhielten, bedeutet, dass der Code in der Testfunktion
keinen Programmabbruch verursacht hat.</p>
<p>Tests, die <code>should_panic</code> verwenden, können ungenau sein. Ein Test mit
<code>should_panic</code> würde auch dann bestanden werden, wenn der Test aus einem
anderen Grund zum Programmabbrucht führt als dem, den wir erwartet haben. Um
Tests mit <code>should_panic</code> präziser zu machen, können wir beim
<code>should_panic</code>-Attribut einen optionalen Parameter <code>expected</code> ergänzen. Das
Testsystem stellt sicher, dass die Fehlermeldung den angegebenen Text enthält.
Betrachte zum Beispiel den modifizierten Code für <code>Guess</code> in Codeblock 11-9, wo
die Funktion <code>new</code> mit unterschiedlichen Meldungen das Programm abbricht, je
nachdem, ob der Wert zu klein oder zu groß ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!("Schätzwert muss größer oder gleich 1 sein, ist {value}.");
        } else if value &gt; 100 {
            panic!("Schätzwert muss kleiner oder gleich 100 sein, ist {value}.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "kleiner oder gleich 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<p><span class="caption">Codeblock 11-9: Testen eines Programmabbruchs mit einer
bestimmten Teilzeichenkette in der Meldung</span></p>
<p>Dieser Test wird bestanden werden, weil der Wert, den wir beim Parameter
<code>expected</code> des <code>should_panic</code>-Attributs angeben, eine Teilzeichenkette der
Nachricht ist, mit der die Funktion <code>Guess::new</code> das Programm abbricht. Wir
hätten die gesamte erwartete Abbruchsnachricht angeben können, in diesem Fall
also <code>Schätzwert muss kleiner oder gleich 100 sein, ist 200</code>. Was du angibst,
hängt davon ab, wie viel von der Abbruchsnachricht eindeutig oder dynamisch ist
und wie präzise dein Test sein soll. In diesem Fall reicht eine
Teilzeichenkette der Abbruchsnachricht aus, um sicherzustellen, dass der Code
in der Testfunktion den Fall <code>else if value &gt; 100</code> ausführt.</p>
<p>Um zu sehen, was passiert, wenn ein Test mit <code>should_panic</code> und einer
<code>expected</code>-Nachricht fehlschlägt, wollen wir wieder einen Fehler in unseren
Code einbringen, indem wir die Zweige <code>if value &lt; 1</code>  und <code>else if value &gt; 100</code>
vertauschen:</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!("Schätzwert muss kleiner oder gleich 100 sein, ist {value}.");
        } else if value &gt; 100 {
            panic!("Schätzwert muss größer oder gleich 1 sein, ist {value}.");
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "kleiner oder gleich 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Wenn wir diesmal den <code>should_panic</code>-Test ausführen, wird er fehlschlagen:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at src/lib.rs:13:13:
Schätzwert muss größer oder gleich 1 sein, ist 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Schätzwert muss größer oder gleich 1 sein, ist 200."`,
 expected substring: `"kleiner oder gleich 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Die Fehlermeldung zeigt an, dass dieser Test tatsächlich wie erwartet das
Programm abgebrochen hat, aber die Abbruchsmeldung enthielt nicht die erwartete
Zeichenfolge <code>"kleiner oder gleich 100"</code>. Die Abbruchsmeldung, die wir in
diesem Fall erhielten, lautete: <code>Schätzwert muss größer oder gleich 1 sein, ist 200.</code> Jetzt können wir anfangen herauszufinden, wo unser Fehler liegt!</p>
<h3 id="verwenden-von-resultt-e-in-tests"><a class="header" href="#verwenden-von-resultt-e-in-tests">Verwenden von <code>Result&lt;T, E&gt;</code> in Tests</a></h3>
<p>Bei unseren bisherigen Tests sind alle abgebrochen, wenn sie fehlgeschlagen
sind. Wir können auch Tests schreiben, die <code>Result&lt;T, E&gt;</code> verwenden! Hier ist
der Test aus Codeblock 11-1 so umgeschrieben, dass er <code>Result&lt;T, E&gt;</code> verwendet
und <code>Err</code> zurückgibt, anstatt das Programm abzubrechen:</p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: usize, right: usize) -&gt; usize {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("zwei plus zwei ist nicht gleich vier"))
        }
    }
<span class="boring">}</span></code></pre>
<p>Die Funktion <code>it_works</code> hat jetzt den Rückgabetyp <code>Result&lt;(), String&gt;</code>. Anstatt
das Makro <code>assert_eq!</code> aufzurufen, geben wir im Funktionsrumpf <code>Ok(())</code> zurück,
wenn der Test bestanden ist, und ein <code>Err</code> mit einem <code>String</code> im Inneren, wenn
der Test fehlschlägt.</p>
<p>Wenn du Tests so schreibst, dass sie ein <code>Result&lt;T, E&gt;</code> zurückgeben, kannst du
den Fragezeichen-Operator im Testrumpf verwenden, was eine bequeme Möglichkeit
sein kann, Tests zu schreiben, die fehlschlagen sollten, wenn irgendeine
Operation darin eine <code>Err</code>-Variante zurückgibt.</p>
<p>Du kannst die Annotation <code>#[should_panic]</code> nicht für Tests verwenden, die
<code>Result&lt;T, E&gt;</code> verwenden. Um sicherzustellen, dass eine Operation eine
<code>Err</code>-Variante zurückgibt, verwende <em>nicht</em> den Fragezeichen-Operator auf den
<code>Result&lt;T, E&gt;</code>-Wert. Verwende stattdessen <code>assert!(value.is_err())</code>.</p>
<p>Da du nun verschiedene Möglichkeiten kennst, Tests zu schreiben, lass uns einen
Blick darauf werfen, was passiert, wenn wir unsere Tests ausführen, und die
verschiedenen Optionen untersuchen, die wir mit <code>cargo test</code> verwenden können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="steuern-wie-tests-ausgeführt-werden"><a class="header" href="#steuern-wie-tests-ausgeführt-werden">Steuern wie Tests ausgeführt werden</a></h2>
<p>So wie <code>cargo run</code> deinen Code kompiliert und dann die resultierende Binärdatei
ausführt, kompiliert <code>cargo test</code> deinen Code im Testmodus und führt die
resultierende Testbinärdatei aus. Das Standardverhalten der von <code>cargo test</code>
erzeugten Binärdatei besteht darin, alle Tests parallel auszuführen und die
während der Testläufe generierte Ausgabe zu erfassen, wodurch verhindert wird,
dass die Ausgabe angezeigt wird, und das Lesen der Ausgabe bezüglich der
Testergebnisse erleichtert wird. Du kannst jedoch Kommandozeilen-Optionen
angeben, um dieses Standardverhalten zu ändern.</p>
<p>Einige Kommandozeilen-Optionen betreffen <code>cargo test</code> und einige betreffen die
resultierende Testbinärdatei. Um diese beiden Argumentarten
auseinanderzuhalten, gibst du zuerst die Argumente für <code>cargo test</code>, gefolgt
vom Trennzeichen <code>--</code>, und danach die der Testbinärdatei an. Wenn du <code>cargo test --help</code> ausführst, werden die Optionen angezeigt, die du für <code>cargo test</code>
verwenden kannst, und wenn du <code>cargo test -- --help</code> ausführst, werden die
Optionen angezeigt, die du nach dem Trennzeichen verwenden kannst. Diese
Optionen sind auch im <a href="https://doc.rust-lang.org/rustc/tests/index.html">Abschnitt „Tests“</a> des <a href="https://doc.rust-lang.org/rustc/index.html">rustc-Buchs</a>
dokumentiert.</p>
<h3 id="tests-parallel-oder-nacheinander-ausführen"><a class="header" href="#tests-parallel-oder-nacheinander-ausführen">Tests parallel oder nacheinander ausführen</a></h3>
<p>Wenn du mehrere Tests ausführst, werden diese standardmäßig parallel in
Strängen (threads) ausgeführt, das bedeutet, dass die Tests schneller
abgeschlossen werden und du schneller Rückmeldung erhältst. Da die Tests
gleichzeitig ausgeführt werden, musst du sicherstellen, dass deine Tests nicht
voneinander oder von einem gemeinsam genutzten Zustand abhängen, einschließlich
einer gemeinsam genutzten Umgebung, z.B. dem aktuellen Arbeitsverzeichnis oder
Umgebungsvariablen.</p>
<p>Angenommen, jeder deiner Tests führt einen Code aus, der eine Datei auf der
Festplatte mit dem Namen <em>test-output.txt</em> erstellt und einige Daten in diese
Datei schreibt. Dann liest jeder Test Daten aus dieser Datei und stellt fest,
dass die Datei einen bestimmten Wert enthält, der bei jedem Test anders ist. Da
die Tests zur gleichen Zeit laufen, kann es vorkommen, dass ein Test die Datei
überschreibt, während ein anderer Test die Datei schreibt und liest. Der zweite
Test wird dann fehlschlagen, nicht weil der Code falsch ist, sondern weil sich
die Tests bei der parallelen Ausführung gegenseitig beeinflusst haben. Eine
Lösung besteht darin, dafür zu sorgen, dass jeder Test in eine eigene Datei
schreibt; eine andere Lösung besteht darin, die Tests einzeln nacheinander
auszuführen.</p>
<p>Wenn du die Tests nicht parallel ausführen möchtest oder wenn du eine
feingranularere Kontrolle über die Anzahl der verwendeten Stränge haben willst,
kannst du den Schalter <code>--test-threads</code> mit der Anzahl der Stränge, die du
verwenden möchtest, an die Testbinärdatei übergeben. Sieh dir das folgende
Beispiel an:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>Wir setzen die Anzahl der Teststränge auf <code>1</code> und weisen das Programm an, keine
Parallelität zu verwenden. Die Ausführung der Tests mit einem Strang dauert
länger als die parallele Ausführung, aber die Tests stören sich nicht
gegenseitig, wenn sie den gleichen Zustand verwenden.</p>
<h3 id="anzeigen-der-funktionsausgabe"><a class="header" href="#anzeigen-der-funktionsausgabe">Anzeigen der Funktionsausgabe</a></h3>
<p>Standardmäßig erfasst die Testbibliothek von Rust bei einem bestandenen Test
alles, was in die Standardausgabe ausgegeben wurde. Wenn wir beispielsweise
<code>println!</code> in einem Test aufrufen und der Test erfolgreich ist, sehen wir die
Ausgabe von <code>println!</code> im Terminal nicht; wir sehen nur die Zeile, die den
bestandenen Test anzeigt. Wenn ein Test fehlschlägt, sehen wir das, was in die
Standardausgabe ausgegeben wurde, mit dem Rest der Fehlermeldung.</p>
<p>Als Beispiel hat Codebock 11-10 eine dumme Funktion, die den Wert ihres
Parameters ausgibt und 10 zurückgibt, sowie einen Test, der bestanden wird, und
einen Test, der fehlschlägt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!("Ich habe den Wert {a} erhalten.");
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(value, 10);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(value, 5);
    }
}</code></pre>
<p><span class="caption">Codebock 11-10: Tests einer Funktion, die <code>println!</code>
aufruft</span></p>
<p>Wenn wir diese Tests mit <code>cargo test</code> ausführen, werden wir folgende Ausgabe
sehen:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
Ich habe den Wert 8 erhalten.
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Beachte, dass wir nirgendwo in dieser Ausgabe <code>Ich habe den Wert 4 erhalten.</code>
sehen, was beim erfolgreichen Testlauf ausgegeben wird. Diese Ausgabe wurde
aufgefangen. Die Ausgabe <code>Ich habe den Wert 8 erhalten.</code> des fehlgeschlagenen
Tests erscheint im Abschnitt der Testzusammenfassung, der auch die Ursache des
Testfehlers anzeigt.</p>
<p>Wenn wir auch die ausgegebenen Werte der bestandenen Tests sehen wollen, können
wir Rust mit <code>--show-output</code> anweisen, die Ausgabe erfolgreicher Tests mit
anzuzeigen:</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>Wenn wir die Tests in Codeblock 11-10 mit dem Schalter <code>--show-output</code> erneut
ausführen, sehen wir folgende Ausgabe:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
Ich habe den Wert 4 erhalten.


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
Ich habe den Wert 8 erhalten.
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="ausführen-einer-test-teilmenge-mittels-name"><a class="header" href="#ausführen-einer-test-teilmenge-mittels-name">Ausführen einer Test-Teilmenge mittels Name</a></h3>
<p>Manchmal kann die Ausführung einer vollständigen Testsammlung sehr lange
dauern. Wenn du an Code in einem bestimmten Bereich arbeitest, solltest du
vielleicht nur die Tests ausführen, die diesen Code betreffen. Du kannst
wählen, welche Tests ausgeführt werden sollen, indem du <code>cargo test</code> den oder
die Namen der Tests, die du ausführen willst, als Argument übergibst.</p>
<p>Um zu demonstrieren, wie man eine Teilmenge von Tests ausführt, werden wir
zuerst drei Tests für unsere Funktion <code>add_two</code> erstellen, wie in Codeblock
11-11 zu sehen ist, und auswählen, welche wir ausführen wollen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_two(a: usize) -&gt; usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = add_two(3);
        assert_eq!(result, 5);
    }

    #[test]
    fn one_hundred() {
        let result = add_two(100);
        assert_eq!(result, 102);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 11-11: Drei Tests mit drei verschiedenen
Namen</span></p>
<p>Wenn wir die Tests ohne Argumente durchführen, wie vorhin gesehen, werden alle
Tests parallel laufen:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<h4 id="ausführen-einzelner-tests"><a class="header" href="#ausführen-einzelner-tests">Ausführen einzelner Tests</a></h4>
<p>Wir können den Namen einer beliebigen Testfunktion an <code>cargo test</code> übergeben,
um nur diesen Test auszuführen:</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s
</code></pre>
<p>Nur der Test mit dem Namen <code>one_hundred</code> lief; die beiden anderen Tests passten
nicht zu diesem Namen. Die Testausgabe lässt uns wissen, dass wir mehrere Tests
hatten, als dieser Befehl ausgeführt wurde, indem am Ende der
Zusammenfassungszeile <code>2 filtered out</code> angezeigt wird.</p>
<p>Wir können die Namen mehrerer Tests nicht auf diese Weise angeben; es wird nur
der erste Wert verwendet, der bei <code>cargo test</code> angegeben wird. Aber es gibt
eine Möglichkeit, mehrere Tests auszuführen.</p>
<h4 id="filtern-um-mehrerer-tests-auszuführen"><a class="header" href="#filtern-um-mehrerer-tests-auszuführen">Filtern um mehrerer Tests auszuführen</a></h4>
<p>Wir können einen Teil eines Testnamens angeben und jeder Test, dessen Name zu
diesem Wert passt, wird ausgeführt. Da zum Beispiel zwei der Namen unserer
Tests <code>add</code> enthalten, können wir diese beiden Tests ausführen, indem wir
<code>cargo test add</code> ausführen:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
</code></pre>
<p>Dieser Befehl führte alle Tests mit <code>add</code> im Namen aus und filterte den Test
mit dem Namen <code>one_hundred</code> heraus. Beachte auch, dass das Modul, in dem sich
ein Test befindet, Teil des Testnamens wird, sodass wir alle Tests in einem
Modul ausführen können, indem wir nach dem Namen des Moduls filtern.</p>
<h3 id="tests-ignorieren-die-nicht-ausdrücklich-verlangt-werden"><a class="header" href="#tests-ignorieren-die-nicht-ausdrücklich-verlangt-werden">Tests ignorieren, die nicht ausdrücklich verlangt werden</a></h3>
<p>Manchmal kann die Ausführung einiger spezifischer Tests sehr zeitaufwendig
sein, sodass du diese bei den meisten <code>cargo test</code>-Aufrufen ausschließen
solltest. Anstatt alle Tests, die du ausführen möchtest, als Argumente
aufzulisten, kannst du die zeitaufwendigen Tests stattdessen mit dem Attribut
<code>ignore</code> annotieren, um sie auszuschließen, wie hier gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: usize, right: usize) -&gt; usize {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // code that takes an hour to run
    }
}</code></pre>
<p>Unterhalb <code>#[test]</code> fügen wir die Zeile <code>#[ignore]</code> beim Test ein, den wir
ausschließen wollen. Wenn wir nun unsere Tests ausführen, läuft <code>it_works</code>,
aber <code>expensive_test</code> nicht:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Die Funktion <code>expensive_test</code> wird als <code>ignored</code> aufgeführt. Wenn wir nur die
ignorierten Tests ausführen wollen, können wir <code>cargo test -- --ignored</code>
angeben:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Indem du kontrollierst, welche Tests durchgeführt werden, kannst du
sicherstellen, dass dein Aufruf von <code>cargo test</code> schnell Ergebnisse zurückgibt.
Wenn du an einem Punkt angelangt bist, an dem es sinnvoll ist, die Ergebnisse
der <code>ignored</code>-Tests zu überprüfen, und du Zeit hast, auf die Ergebnisse zu
warten, kannst du stattdessen <code>cargo test -- --ignored</code> ausführen. Wenn du alle
Tests ausführen willst, egal ob sie ignoriert werden oder nicht, kannst du
<code>cargo test -- --include-ignored</code> ausführen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="testverwaltung"><a class="header" href="#testverwaltung">Testverwaltung</a></h2>
<p>Wie zu Beginn des Kapitels erwähnt, ist das Testen eine komplexe Disziplin, und
verschiedene Personen verwenden unterschiedliche Terminologien und
Organisationen. Die Rust-Gemeinschaft teilt Tests in zwei Hauptkategorien ein:
Modultests und Integrationstests. <em>Modultests</em> (unit tests) sind klein und
zielgerichteter, testen jeweils ein Modul isoliert und können private
Schnittstellen testen. <em>Integrationstests</em> (integration tests) sind völlig
außerhalb deiner Bibliothek und verwenden deinen Code auf die gleiche Weise wie
jeder andere externe Code, wobei nur die öffentliche Schnittstelle verwendet
wird und möglicherweise mehrere Module pro Test ausgeführt werden.</p>
<p>Es ist wichtig, beide Testarten zu schreiben, um sicherzustellen, dass die
Teile deiner Bibliothek einzeln und zusammen das tun, was du von ihnen
erwartest.</p>
<h3 id="modultests"><a class="header" href="#modultests">Modultests</a></h3>
<p>Der Zweck von Modultests besteht darin, jede Code-Einheit isoliert vom Rest des
Codes zu testen, um schnell herauszufinden, welcher Code wie erwartet
funktioniert und welcher nicht. Modultests befinden sich im Verzeichnis <em>src</em>
in den Quellcodedateien, den sie testen. Die Konvention besteht darin, in jeder
Datei ein Modul namens <code>tests</code> zu erstellen, das die Testfunktionen enthält,
und das Modul mit <code>cfg(test)</code> zu annotieren.</p>
<h4 id="das-testmodul-und-cfgtest"><a class="header" href="#das-testmodul-und-cfgtest">Das Testmodul und <code>#[cfg(test)]</code></a></h4>
<p>Die Annotation <code>#[cfg(test)]</code> am Testmodul weist Rust an, den Testcode nur dann
zu kompilieren und auszuführen, wenn du <code>cargo test</code> ausführst, nicht aber,
wenn du <code>cargo build</code> ausführst. Dies spart Kompilierzeit, wenn du nur die
Bibliothek erstellen möchtest, und spart Platz im resultierenden, kompilierten
Artefakt, da die Tests nicht enthalten sind. Du wirst feststellen, dass
Integrationstests die Annotation <code>#[cfg(test)]</code> nicht benötigen, weil sie in
einem anderen Verzeichnis liegen. Da Modultests jedoch in den gleichen Dateien
wie der Code sind, wirst du <code>#[cfg(test)]</code> verwenden, um anzugeben, dass sie
nicht im kompilierten Ergebnis enthalten sein sollen.</p>
<p>Erinnere dich daran, dass Cargo diesen Code für uns generiert hat, als wir das
neue Projekt <code>adder</code> im ersten Abschnitt dieses Kapitels erstellt haben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Im automatisch generierten Modul <code>tests</code> steht das Attribut <code>cfg</code> für
<em>Konfiguration</em> und teilt Rust mit, dass das folgende Element nur bei einer
bestimmten Konfigurationsoption eingebunden werden soll. In diesem Fall ist die
Konfigurationsoption <code>test</code>, die von Rust beim Kompilieren und Ausführen von
Tests verwendet wird. Durch das Verwenden des Attributs <code>cfg</code> kompiliert Cargo
unseren Testcode nur dann, wenn wir die Tests aktiv mit <code>cargo test</code> ausführen.
Dies schließt alle Hilfsfunktionen ein, die sich innerhalb dieses Moduls
befinden könnten, zusätzlich zu den mit <code>#[test]</code> annotierten Funktionen.</p>
<h4 id="testen-privater-funktionen"><a class="header" href="#testen-privater-funktionen">Testen privater Funktionen</a></h4>
<p>In der Testgemeinschaft wird darüber diskutiert, ob private Funktionen direkt
getestet werden sollten oder nicht, und andere Sprachen machen es schwierig
oder gar unmöglich, private Funktionen zu testen. Unabhängig davon, an welcher
Testideologie du festhältst, erlauben dir Rusts Datenschutzregeln, private
Funktionen zu testen. Betrachte den Code in Codeblock 11-12 mit der privaten
Funktion <code>internal_adder</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn add_two(a: usize) -&gt; usize {
    internal_adder(a, 2)
}

fn internal_adder(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p><span class="caption">Codeblock 11-12: Testen einer privaten Funktion</span></p>
<p>Beachte, dass die Funktion <code>internal_adder</code> nicht mit <code>pub</code> markiert ist. Tests
sind einfach nur Rust-Code, und das Modul <code>tests</code> ist nur ein weiteres Modul.
Wie in <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit Pfaden auf ein Element im Modulbaum verweisen“</a>
beschrieben, können Elemente in Kind-Modulen die Elemente ihrer Eltern-Module
verwenden. In diesem Test bringen wir alle Elemente des Eltern-Moduls von
<code>tests</code> mit <code>use super::*</code> in den Gültigkeitsbereich, und dann kann der Test
<code>internal_adder</code> aufrufen. Wenn du der Meinung bist, dass private Funktionen
nicht getestet werden sollten, gibt es in Rust nichts, was dich dazu zwingen
würde.</p>
<h3 id="integrationstests"><a class="header" href="#integrationstests">Integrationstests</a></h3>
<p>In Rust sind Integrationstests völlig außerhalb deiner Bibliothek angesiedelt.
Du verwendest deine Bibliothek auf die gleiche Weise wie jeder andere Code,
d.h. es können nur Funktionen aufgerufen werden, die Teil der öffentlichen
Programmierschnittstelle (API) deiner Bibliothek sind. Ihr Zweck ist es, zu
testen, ob viele Teile deiner Bibliothek korrekt zusammenarbeiten.
Code-Einheiten, die alleine korrekt funktionieren, könnten Probleme nach deren
Integration haben, daher ist auch die Testabdeckung des integrierten Codes
wichtig. Um Integrationstests zu erstellen, benötigst du zunächst ein
Verzeichnis <em>tests</em>.</p>
<h4 id="das-verzeichnis-tests"><a class="header" href="#das-verzeichnis-tests">Das Verzeichnis <em>tests</em></a></h4>
<p>Wir erstellen ein Verzeichnis <em>tests</em> auf der obersten Ebene unseres
Projektverzeichnisses, neben <em>src</em>. Cargo weiß, dass es in diesem Verzeichnis
nach Integrationstestdateien suchen soll. Wir können dann so viele Testdateien
erstellen, wie wir wollen, und Cargo wird jede dieser Dateien als eine
individuelle Kiste (crate) kompilieren.</p>
<p>Lass uns einen Integrationstest erstellen. Wenn sich der Code in Codeblock
11-12 noch in der Datei <em>src/lib.rs</em> befindet, erstelle ein Verzeichnis
<em>tests</em> und eine neue Datei mit dem Namen <em>tests/integration_test.rs</em>. Deine
Verzeichnisstruktur sollte folgendermaßen aussehen:</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>Gib den Code in Codeblock 11-13 in die Datei <em>tests/integration_test.rs</em> ein.</p>
<p><span class="filename">Dateiname: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p><span class="caption">Codeblock 11-13: Integrationstest einer Funktion in der
Kiste <code>adder</code></span></p>
<p>Jede Datei im Verzeichnis <code>tests</code> ist eine separate Kiste, also müssen wir
unsere Bibliothek in den Gültigkeitsbereich jeder Test-Kiste bringen. Aus
diesem Grund fügen wir <code>use adder::add_two;</code> am Anfang des Codes hinzu, was wir
in den Modultests nicht brauchten.</p>
<p>Wir brauchen den Code in <em>tests/integration_test.rs</em> nicht mit <code>#[cfg(test)]</code>
zu annotieren. Cargo behandelt das Verzeichnis <code>tests</code> speziell und kompiliert
Dateien in diesem Verzeichnis nur dann, wenn wir <code>cargo test</code> ausführen. Führe
<code>cargo test</code> jetzt aus:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Die drei Abschnitte der Ausgabe umfassen die Modultests, den Integrationstest
und die Dokumentationstests. Beachte, wenn ein Test in einem Abschnitt
fehlschlägt, dann werden die folgenden Abschnitte nicht ausgeführt. Wenn zum
Beispiel ein Modultest fehlschlägt, gibt es keine Ausgabe für Integrations- und
Dokumentations-Tests, da diese Tests nur ausgeführt werden, wenn alle
Modultests erfolgreich sind.</p>
<p>Der erste Abschnitt für die Modultests ist derselbe, wie wir ihn gesehen haben:
Eine Zeile für jeden Modultest (eine Zeile mit der Bezeichnung <code>internal</code>, die
wir in Codeblock 11-12 hinzugefügt haben) und dann eine zusammenfassende Zeile
für die Modultests.</p>
<p>Der Abschnitt zu den Integrationstests beginnt mit der Zeile <code>Running tests/integration_test.rs</code>. Als nächstes kommt eine Zeile für jede Testfunktion
in diesem Integrationstest und eine Zusammenfassung für die Ergebnisse des
Integrationstests, kurz bevor der Abschnitt <code>Doc-tests adder</code> beginnt.</p>
<p>Jede Integrationstestdatei hat ihren eigenen Abschnitt, wenn wir also weitere
Dateien im Verzeichnis <em>tests</em> hinzufügen, wird es mehr
Integrationstest-Abschnitte geben.</p>
<p>Wir können immer noch eine bestimmte Integrationstestfunktion ausführen, indem
wir den Namen der Testfunktion als Argument bei <code>cargo test</code> angeben. Um alle
Tests in einer bestimmten Integrationstestdatei auszuführen, verwenden bei
<code>cargo test</code> das Argument <code>--test</code>, gefolgt vom Namen der Datei:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Dieses Kommando führt nur die Tests in der Datei <em>tests/integration_test.rs</em>
aus.</p>
<h4 id="untermodule-in-integrationstests"><a class="header" href="#untermodule-in-integrationstests">Untermodule in Integrationstests</a></h4>
<p>Wenn du weitere Integrationstests hinzufügst, möchtest du vielleicht mehr als
eine Datei im Verzeichnis <em>tests</em> erstellen, um sie besser organisieren zu
können; beispielsweise kannst du die Testfunktionen nach der Funktionalität
gruppieren, die sie testen. Wie bereits erwähnt, wird jede Datei im Verzeichnis
<em>tests</em> als eigene Kiste kompiliert, was nützlich ist, um getrennte Bereiche zu
erstellen, um die Art und Weise, wie die Endbenutzer deine Kiste verwenden
werden, besser zu imitieren. Das bedeutet jedoch, dass Dateien im Verzeichnis
<em>tests</em> nicht dasselbe Verhalten aufweisen wie Dateien im Verzeichnis <em>src</em>,
wie du in Kapitel 7 über die Trennung von Code in Module und Dateien gelernt
hast.</p>
<p>Das unterschiedliche Verhalten von Dateien im Verzeichnis <em>tests</em> ist am
deutlichsten, wenn du eine Reihe Hilfsfunktionen hast, die bei mehreren
Integrationstestdateien verwendest, und du versuchst, die Schritte in <a href="ch07-05-separating-modules-into-different-files.html">„Module
in verschiedene Dateien aufteilen“</a> in Kapitel 7
zu befolgen, um sie in ein gemeinsames Modul zu extrahieren. Wenn wir zum
Beispiel <em>tests/common.rs</em> erstellen und eine Funktion namens <code>setup</code> darin
platzieren, können wir <code>setup</code> etwas Code hinzufügen, den wir von mehreren
Testfunktionen in mehreren Testdateien aufrufen wollen:</p>
<p><span class="filename">Dateiname: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // Vorbereitungscode speziell für die Tests deiner Bibliothek
}</code></pre>
<p>Wenn wir die Tests erneut ausführen, werden wir für die Datei <em>common.rs</em> einen
neuen Abschnitt in der Testausgabe sehen, obwohl diese Datei keine
Testfunktionen enthält und wir die Funktion <code>setup</code> nicht von irgendwo
aufgerufen haben:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Dass in den Testergebnissen <code>common</code> erscheint und dabei <code>running 0 tests</code>
angezeigt wird, ist nicht das, was wir wollten. Wir wollten nur etwas Code mit
den anderen Integrationstestdateien teilen. Um zu vermeiden, dass <code>common</code> in
der Testausgabe erscheint, werden wir statt <em>tests/common.rs</em> die Datei
<em>tests/common/mod.rs</em> erstellen. Das Projektverzeichnis sieht nun wie folgt
aus:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
</code></pre>
<p>Dies ist die ältere Namenskonvention, die auch Rust versteht, die wir in
<a href="ch07-05-separating-modules-into-different-files.html#alternative-dateipfade">„Alternative Dateipfade“</a> in Kapitel 7 erwähnt haben. Durch diese
Benennung der Datei wird Rust angewiesen, das Modul <code>common</code> nicht als
Integrationstestdatei zu behandeln. Wenn wir den Funktionscode <code>setup</code> in
<em>tests/common/mod.rs</em> verschieben und die Datei <em>tests/common.rs</em> löschen,
erscheint der Abschnitt in der Testausgabe nicht mehr. Dateien in
Unterverzeichnissen des Verzeichnisses <em>tests</em> werden nicht als separate Kisten
kompiliert und erzeugen keine Abschnitte in der Testausgabe.</p>
<p>Nachdem wir <em>tests/common/mod.rs</em> erstellt haben, können wir es von jeder der
Integrationstestdateien als Modul verwenden. Hier ist ein Beispiel für den
Aufruf der Funktion <code>setup</code> aus dem Test <code>it_adds_two</code> in
<em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Dateiname: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p>Beachte, dass die Deklaration <code>mod common;</code> die gleiche ist wie die
Moduldeklaration, die wir in Codeblock 7-21 gezeigt haben. In der Testfunktion
können wir dann die Funktion <code>common::setup()</code> aufrufen.</p>
<h4 id="integrationstests-für-binäre-kisten"><a class="header" href="#integrationstests-für-binäre-kisten">Integrationstests für binäre Kisten</a></h4>
<p>Wenn unser Projekt eine binäre Kiste ist, die nur eine Datei <em>src/main.rs</em>
enthält und keine Datei <em>src/lib.rs</em>, können wir keine Integrationstests im
<em>tests</em>-Verzeichnis erstellen und Funktionen, die in der <em>src/main.rs</em>-Datei
definiert sind, mit einer <code>use</code>-Anweisung in den Gültigkeitsbereich bringen.
Nur Bibliothekskisten stellen Funktionen zur Verfügung, die auch von anderen
Kisten verwendet werden können; binäre Kisten sind für den eigenständigen
Betrieb gedacht.</p>
<p>Dies ist einer der Gründe, warum Rust-Projekte, die eine Binärdatei
bereitstellen, eine einfache <em>src/main.rs</em>-Datei haben, die Logik aufruft, die
in der <em>src/lib.rs</em>-Datei lebt. Unter Verwendung dieser Struktur können
Integrationstests die Bibliothekskiste mit <code>use</code> testen, um wichtige
Funktionalität verfügbar zu machen. Wenn die Hauptfunktionalität korrekt ist,
funktionieren auch die kleinen Codestücke in der Datei <em>src/main.rs</em>, und diese
kleinen Codestücke müssen nicht getestet werden.</p>
<h2 id="zusammenfassung-10"><a class="header" href="#zusammenfassung-10">Zusammenfassung</a></h2>
<p>Die Testfunktionalitäten von Rust bieten eine Möglichkeit, zu spezifizieren,
wie der Code funktionieren soll, um sicherzustellen, dass er weiterhin so
funktioniert, wie du es erwartest, auch wenn du Änderungen vornimmst. Modultests prüfen
verschiedene Teile einer Bibliothek separat und können private
Implementierungsdetails testen. Integrationstests prüfen, ob viele Teile der
Bibliothek korrekt zusammenarbeiten, und sie verwenden die öffentliche
Programmierschnittstelle (API) der Bibliothek, um den Code auf die gleiche
Weise zu testen, wie externer Code ihn verwenden wird. Auch wenn das Typsystem
und die Eigentumsregeln von Rust dazu beitragen, einige Fehlerarten zu
verhindern, sind Tests immer noch wichtig, um Logikfehler zu reduzieren, die
damit zu tun haben, wie sich dein Code voraussichtlich verhalten wird.</p>
<p>Lass uns das Wissen, das du in diesem und in den vorhergehenden Kapiteln
gelernt hast, für die Arbeit an einem Projekt einsetzen!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ein-ea-projekt-ein-kommandozeilenprogramm-erstellen"><a class="header" href="#ein-ea-projekt-ein-kommandozeilenprogramm-erstellen">Ein E/A-Projekt: Ein Kommandozeilenprogramm erstellen</a></h1>
<p>Dieses Kapitel ist eine Zusammenfassung der vielen Fähigkeiten, die du bisher
gelernt hast, und eine Erkundung einiger weiterer
Standard-Bibliotheks-Funktionalitäten. Wir werden ein Kommandozeilenwerkzeug
erstellen, das mit der Datei- und der Terminal-Ein- und -Ausgabe interagiert,
um einige der Rust-Konzepte zu üben, die du bereits gelernt hast.</p>
<p>Rusts Geschwindigkeit, Sicherheit, Ausgabe in eine einzelne Binärdatei und
plattformübergreifende Unterstützung machen es zu einer idealen Sprache zum
Erstellen von Kommandozeilenwerkzeugen. Für unser Projekt werden wir daher eine
eigene Version des klassischen Kommandozeilenwerkzeugs <code>grep</code> (<strong>g</strong>lobally
search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint) erstellen. Im einfachsten
Anwendungsfall durchsucht <code>grep</code> eine angegebene Datei nach einer bestimmten
Zeichenkette. Dazu nimmt <code>grep</code> als Argumente einen Dateipfad und eine
Zeichenkette. Dann liest es die Datei, findet Zeilen in dieser Datei, die das
Zeichenketten-Argument enthalten, und gibt diese Zeilen aus.</p>
<p>Auf dem Weg dorthin werden wir zeigen, wie wir unser Kommandozeilenwerkzeug
dazu bringen können, Funktionalitäten des Terminals zu nutzen, die viele
Kommandozeilenwerkzeuge nutzen. Wir werden den Wert einer Umgebungsvariablen
lesen, die es dem Benutzer ermöglicht, das Verhalten unseres Werkzeugs zu
konfigurieren. Wir werden Fehlermeldungen auch auf der Standardfehlerausgabe
(<code>stderr</code>) statt auf der Standardausgabe (<code>stdout</code>) ausgeben, sodass der
Benutzer z.B. eine erfolgreiche Ausgabe in eine Datei umleiten kann, während er
weiterhin Fehlermeldungen auf dem Bildschirm sieht.</p>
<p>Ein Mitglied der Rust-Gemeinschaft, Andrew Gallant, hat bereits eine voll
ausgestattete, sehr schnelle Version von <code>grep</code>, genannt <code>ripgrep</code>, erstellt.
Im Vergleich dazu wird unsere Version von <code>grep</code> ziemlich einfach sein, aber
dieses Kapitel wird dir einiges an Hintergrundwissen vermitteln, das du
benötigst, um ein reales Projekt wie <code>ripgrep</code> zu verstehen.</p>
<p>Unser <code>grep</code>-Projekt wird eine Reihe von Konzepten kombinieren, die du bisher
gelernt hast:</p>
<ul>
<li>Code organisieren (<a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Kapitel 7</a>)</li>
<li>Verwenden von Vektoren und Zeichenketten (<a href="ch08-00-common-collections.html">Kapitel 8</a>)</li>
<li>Fehlerbehandlung (<a href="ch09-00-error-handling.html">Kapitel 9</a>)</li>
<li>Verwenden von Merkmalen (traits) und Lebensdauer (lifetimes) soweit möglich
(<a href="ch10-00-generics.html">Kapitel 10</a>)</li>
<li>Schreiben von Tests (<a href="ch11-00-testing.html">Kapitel 11</a>)</li>
</ul>
<p>Wir werden auch kurz Funktionsabschlüsse (closures), Iteratoren und
Merkmalsobjekte (trait objects) vorstellen, die in den <a href="ch13-00-functional-features.html">Kapitel 13</a>
und <a href="ch18-00-oop.html">Kapitel 18</a> ausführlich behandelt werden.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kommandozeilenargumente-entgegennehmen"><a class="header" href="#kommandozeilenargumente-entgegennehmen">Kommandozeilenargumente entgegennehmen</a></h2>
<p>Lass uns ein neues Projekt, wie immer, mit <code>cargo new</code> erstellen. Wir werden
unser Projekt <code>minigrep</code> nennen, um es vom <code>grep</code>-Werkzeug zu unterscheiden,
das du vielleicht schon auf deinem System hast.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>Die erste Aufgabe besteht darin, <code>minigrep</code> dazu zu bringen, seine beiden
Kommandozeilenargumente entgegennehmen: Den Dateipfad und eine Zeichenkette,
nach der gesucht werden soll. Das heißt, wir wollen in der Lage sein, unser
Programm mit <code>cargo run</code>, einer zu suchenden Zeichenkette und einem Pfad zu
einer Datei, in der gesucht werden soll, auszuführen:</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>Im Moment kann das von <code>cargo new</code> generierte Programm die Argumente, die wir
ihm geben, nicht verarbeiten. Einige vorhandene Bibliotheken auf
<a href="https://crates.io/">crates.io</a> können beim Schreiben eines Programms, das
Kommandozeilenargumente akzeptiert, helfen, aber da du dieses Konzept gerade
erst erlernst, sollten wir diese Fähigkeit selbst implementieren.</p>
<h3 id="lesen-der-argumentwerte"><a class="header" href="#lesen-der-argumentwerte">Lesen der Argumentwerte</a></h3>
<p>Um <code>minigrep</code> in die Lage zu versetzen, die Werte der Kommandozeilenargumente
zu lesen, die wir ihm übergeben, benötigen wir die Funktion <code>std::env::args</code>,
die in der Standardbibliothek von Rust bereitgestellt wird. Diese Funktion gibt
einen Iterator der Befehlszeilenargumente zurück, die an <code>minigrep</code> übergeben
wurden. Iteratoren werden wir in <a href="ch13-00-functional-features.html">Kapitel 13</a> ausführlich behandeln. Im
Moment brauchst du nur zwei Details über Iteratoren zu wissen: Iteratoren
erzeugen eine Reihe von Werten und wir können die Methode <code>collect</code> auf einem
Iterator aufrufen, um ihn in eine Kollektion, z.B. einen Vektor, zu verwandeln,
der alle Elemente enthält, die der Iterator erzeugt.</p>
<p>Der Code in Codeblock 12-1 ermöglicht deinem <code>minigrep</code>-Programm, alle ihm
übergebenen Befehlszeilenargumente zu lesen und die Werte dann in einem Vektor
zu sammeln.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}</code></pre></pre>
<p><span class="caption">Codeblock 12-1: Sammeln der Befehlszeilenargumente in
einem Vektor und Ausgeben dieser Werte</span></p>
<p>Zuerst bringen wir das Modul <code>std::env</code> mit einer <code>use</code>-Anweisung in den
Gültigkeitsbereich, damit wir seine Funktion <code>args</code> verwenden können. Beachte,
dass die Funktion <code>std::env::args</code> in zwei Modulebenen verschachtelt ist. Wie
wir in <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#idiomatische-use-pfade-erstellen">Kapitel 7</a> besprochen haben, haben wir in Fällen, in
denen die gewünschte Funktion in mehreren Modulebenen verschachtelt ist, das
die Funktion enthaltende Modul in den Gültigkeitsbereich gebracht, anstatt nur
die Funktion selbst zu importieren. Auf diese Weise können wir leicht andere
Funktionen aus <code>std::env</code> verwenden. Es ist auch nicht so vieldeutig wie beim
Importieren von <code>use std::env::args</code> und dem anschließenden Aufrufen der
Funktion nur mit <code>args</code>, weil <code>args</code> leicht mit einer Funktion verwechselt
werden könnte, die im aktuellen Modul definiert ist.</p>
<blockquote>
<h3 id="die-funktion-args-und-ungültiger-unicode"><a class="header" href="#die-funktion-args-und-ungültiger-unicode">Die Funktion <code>args</code> und ungültiger Unicode</a></h3>
<p>Beachte, dass <code>std::env::args</code> abstürzt, wenn ein Argument einen ungültigen
Unicode enthält. Wenn dein Programm Argumente mit ungültigem Unicode
akzeptieren muss, verwende stattdessen <code>std::env::args_os</code>. Diese Funktion
gibt einen Iterator zurück, der <code>OsString</code>-Werte anstelle von <code>String</code>-Werten
erzeugt. Wir haben uns hier aus Gründen der Einfachheit für die Verwendung
von <code>std::env::args</code> entschieden, weil <code>OsString</code>-Werte sich je nach
Plattform unterscheiden und die Arbeit mit ihnen komplexer ist als mit
<code>String</code>-Werten.</p>
</blockquote>
<p>In der ersten Zeile von <code>main</code> rufen wir <code>env::args</code> auf und wir verwenden
sofort <code>collect</code>, um den Iterator in einen Vektor zu verwandeln, der alle vom
Iterator erzeugten Werte enthält. Wir können die Funktion <code>collect</code> verwenden,
um viele Arten von Kollektionen zu erstellen, also vermerken wir explizit den
Typ von <code>args</code>, um anzugeben, dass wir einen Vektor mit Zeichenketten wollen.
Obwohl du in Rust nur sehr selten Typen mit Annotationen versehen musst, ist
<code>collect</code> eine Funktion, die du häufig mit Annotationen versehen musst, da Rust
nicht in der Lage ist, auf die Art der gewünschten Kollektion zu schließen.</p>
<p>Zum Schluss geben wir den Vektor mit dem Debug-Makro aus. Versuchen wir, den
Code zuerst ohne Argumente und dann mit zwei Argumenten laufen zu lassen:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
]
</code></pre>
<pre><code class="language-console">$ cargo run -- Nadel Heuhaufen
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep Nadel Heuhaufen`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
    "Nadel",
    "Heuhaufen",
]
</code></pre>
<p>Beachte, dass der erste Wert im Vektor <code>"target/debug/minigrep"</code> ist, was der
Name unserer Binärdatei ist. Dies entspricht dem Verhalten der Argumentliste in
C, sodass Programme bei ihrer Ausführung den Namen verwenden können, unter dem
sie aufgerufen wurden. Es ist oft praktisch, Zugriff auf den Programmnamen zu
haben, falls du ihn in Meldungen ausgeben oder das Verhalten des Programms
ändern möchtest, je nachdem, welcher Befehlszeilen-Alias zum Aufruf des
Programms verwendet wurde. Aber für die Zwecke dieses Kapitels ignorieren wir
ihn und speichern nur die beiden Argumente, die wir brauchen.</p>
<h3 id="speichern-der-argumentwerte-in-variablen"><a class="header" href="#speichern-der-argumentwerte-in-variablen">Speichern der Argumentwerte in Variablen</a></h3>
<p>Das Programm ist derzeit in der Lage, auf die als Kommandozeilenargumente
angegebenen Werte zuzugreifen. Jetzt müssen wir die Werte der beiden Argumente
in Variablen speichern, damit wir die Werte im restlichen Programm verwenden
können. Das tun wir in Codeblock 12-2.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!("Suche nach {query}");
    println!("In Datei {file_path}");
}</code></pre>
<p><span class="caption">Codeblock 12-2: Erstellen von Variablen zur Aufnahme des
Such-Arguments und des Dateipfad-Arguments</span></p>
<p>Wie wir gesehen haben, als wir den Vektor ausgegeben haben, nimmt der
Programmname den ersten Wert im Vektor bei <code>args[0]</code> ein, also beginnen wir
beim Index <code>1</code>. Das erste Argument, das <code>minigrep</code> annimmt, ist die
Zeichenkette, nach der wir suchen, also setzen wir eine Referenz auf das erste
Argument in die Variable <code>query</code>. Das zweite Argument wird der Dateipfad sein,
also setzen wir eine Referenz auf das zweite Argument in die Variable
<code>file_path</code>.</p>
<p>Wir geben vorübergehend die Werte dieser Variablen aus, um zu belegen, dass der
Code so funktioniert, wie wir es beabsichtigen. Lassen wir dieses Programm mit
den Argumenten <code>test</code> und <code>sample.txt</code> noch einmal laufen:</p>
<pre><code class="language-console">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Suche nach test
In Datei sample.txt
</code></pre>
<p>Toll, das Programm funktioniert! Die Werte der Argumente, die wir brauchen,
werden in den richtigen Variablen gespeichert. Später fügen wir eine
Fehlerbehandlung hinzu, um mit bestimmten potentiellen Fehlersituationen
umzugehen, z.B. wenn der Benutzer keine Argumente angibt; für den Moment
ignorieren wir diese Situation und arbeiten stattdessen daran, die
Datei-Lesefunktion hinzuzufügen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="eine-datei-einlesen"><a class="header" href="#eine-datei-einlesen">Eine Datei einlesen</a></h2>
<p>Jetzt fügen wir Funktionalität zum Lesen der Datei hinzu, die im
Befehlszeilenargument <code>file_path</code> angegeben ist. Zuerst brauchen wir eine
Beispieldatei, um sie zu testen: Die beste Art von Datei, die wir benutzen
können, um sicherzustellen, dass <code>minigrep</code> funktioniert, ist eine Datei mit
einer kleinen Menge Text über mehrere Zeilen mit einigen sich wiederholenden
Wörtern. In Codeblock 12-3 ist ein Gedicht von Emily Dickinson, das gut
funktionieren wird! Erstelle eine Datei namens <em>poem.txt</em> im Hauptverzeichnis
deines Projekts und gib das Gedicht „I'm Nobody! Who are you?“ ein.</p>
<p><span class="filename">Dateiname: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Codeblock 12-3: Ein Gedicht von Emily Dickinson ist ein
guter Testfall</span></p>
<p>Wenn der Text vorhanden ist, editiere <em>src/main.rs</em> und füge Code zum Lesen der
Datei hinzu, wie in Codeblock 12-4 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust noplayground">use std::env;
use std::fs;

fn main() {
    // --abschneiden--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let file_path = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!("Suche nach {query}");
</span>    println!("In Datei {file_path}");

    let contents = fs::read_to_string(file_path)
        .expect("Etwas ging beim Lesen der Datei schief");

    println!("Mit text:\n{contents}");
}</code></pre>
<p><span class="caption">Codeblock 12-4: Lesen des Inhalts der Datei, die durch
das zweite Argument angegeben wurde</span></p>
<p>Zuerst fügen wir eine weitere <code>use</code>-Anweisung hinzu, um einen relevanten Teil
der Standardbibliothek einzubringen: Wir brauchen <code>std::fs</code>, um Dateien zu
verwenden.</p>
<p>In <code>main</code> nimmt die neue Anweisung <code>fs::read_to_string</code> den <code>file_path</code>, öffnet
diese Datei und gibt einen Wert von Typ <code>Result&lt;String&gt;</code> zurück, der den Inhalt
der Datei enthält.</p>
<p>Nach dieser Anweisung haben wir wieder eine temporäre <code>println!</code>-Anweisung
hinzugefügt, die den Wert von <code>contents</code> ausgibt, nachdem die Datei eingelesen
wurde, sodass wir überprüfen können, ob das Programm soweit funktioniert.</p>
<p>Lassen wir diesen Code mit einer beliebigen Zeichenkette als erstes
Kommandozeilenargument laufen (weil wir den Suchteil noch nicht implementiert
haben) und die Datei <em>poem.txt</em> als zweites Argument:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Suche nach the
In Datei poem.txt
Mit text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Großartig! Der Code wurde eingelesen und dann der Inhalt der Datei ausgegeben.
Aber der Code hat ein paar Mängel. Die Funktion <code>main</code> hat momentan mehrere
Verantwortlichkeiten: Im Allgemeinen sind Funktionen klarer und einfacher zu
warten, wenn jede Funktion nur für eine Idee verantwortlich ist. Das andere
Problem ist, dass wir mit Fehlern nicht so gut umgehen, wie wir es könnten. Das
Programm ist noch klein, sodass diese Fehler kein großes Problem darstellen,
aber je größer das Programm wird, desto schwieriger wird es, sie sauber zu
beheben. Es ist eine gute Praxis, schon früh mit dem Umformen (refactor) zu
beginnen, wenn man ein Programm entwickelt, denn es ist viel einfacher,
kleinere Code-Mengen umzuformen. Das werden wir als Nächstes tun.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refaktorierung-um-die-modularität-und-fehlerbehandlung-zu-verbessern"><a class="header" href="#refaktorierung-um-die-modularität-und-fehlerbehandlung-zu-verbessern">Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern</a></h2>
<p>Um unser Programm zu verbessern, werden wir vier Probleme beheben, die mit der
Struktur des Programms und dem Umgang mit potenziellen Fehlern zu tun haben.
Erstens erfüllt unsere Funktion <code>main</code> jetzt zwei Aufgaben: Sie parst Argumente
und liest Dateien. Für eine so kleine Funktion ist dies kein großes Problem.
Wenn wir jedoch unser Programm innerhalb der Funktion <code>main</code> weiter ausbauen,
wird die Anzahl der einzelnen Aufgaben, die die Funktion <code>main</code> bearbeitet,
zunehmen. In dem Maße, wie eine Funktion an Verantwortung hinzugewinnt, wird es
schwieriger sie zu verstehen, schwieriger sie zu testen und schwieriger sie zu
ändern, ohne dass eines ihrer Teile kaputtgeht. Am besten ist es, die
Funktionalität so aufzuteilen, dass jede Funktion für eine Aufgabe zuständig
ist.</p>
<p>Diese Frage hängt auch mit dem zweiten Problem zusammen: Obwohl <code>query</code> und
<code>file_path</code> Konfigurationsvariablen unseres Programms sind, werden Variablen
wie <code>contents</code> verwendet, um die Logik des Programms umzusetzen. Je länger
<code>main</code> wird, desto mehr Variablen müssen wir in den Gültigkeitsbereich bringen;
je mehr Variablen wir im Gültigkeitsbereich haben, desto schwieriger wird es,
den Zweck der einzelnen Variablen im Auge zu behalten. Es ist am besten, die
Konfigurationsvariablen in einer Struktur zu gruppieren, um ihren Zweck zu
verdeutlichen.</p>
<p>Das dritte Problem ist, dass wir <code>expect</code> benutzt haben, um eine Fehlermeldung
auszugeben, wenn das Lesen der Datei fehlschlägt, aber die Fehlermeldung gibt
nur <code>Sollte die Datei lesen können</code> aus. Das Lesen einer Datei kann
auf verschiedene Arten fehlschlagen: Zum Beispiel könnte die Datei fehlen oder
wir haben keine Berechtigung, sie zu öffnen. Im Moment würden wir unabhängig
von der Situation die Fehlermeldung „Etwas ging beim Lesen der Datei schief“
ausgeben, die dem Benutzer keinerlei Informationen geben würde!</p>
<p>Viertens verwenden wir <code>expect</code> erneut, um einen Fehler zu behandeln, und wenn
der Benutzer unser Programm ausführt, ohne genügend Argumente anzugeben, erhält
er einen <code>Index out of bounds</code>-Fehler von Rust, der das Problem nicht eindeutig
erklärt. Am besten wäre es, wenn sich der gesamte Fehlerbehandlungscode an
einer Stelle befände, sodass zukünftige Entwickler nur eine Stelle im Code
konsultieren bräuchten, falls sich die Fehlerbehandlungslogik ändern sollte.
Wenn sich der gesamte Fehlerbehandlungscode an einer Stelle befindet, wird auch
sichergestellt, dass wir Meldungen ausgeben, die für unsere Endbenutzer
aussagekräftig sind.</p>
<p>Lass uns diese vier Probleme angehen, indem wir unser Projekt refaktorieren.</p>
<h3 id="trennen-der-zuständigkeiten-bei-binärprojekten"><a class="header" href="#trennen-der-zuständigkeiten-bei-binärprojekten">Trennen der Zuständigkeiten bei Binärprojekten</a></h3>
<p>Das organisatorische Problem der Zuweisung der Verantwortung für mehrere
Aufgaben an die Funktion <code>main</code> ist vielen Binärprojekten gemein.
Infolgedessen hat die Rust-Gemeinschaft eine Richtlinie für die Aufteilung der
einzelnen Aufgaben eines Binärprogramms entwickelt, wenn die Funktion <code>main</code>
groß wird. Dieser Prozess umfasst die folgenden Schritte:</p>
<ul>
<li>Teile dein Programm in die Dateien <em>main.rs</em> und <em>lib.rs</em> auf und verschiebe
die Logik deines Programms in <em>lib.rs</em>.</li>
<li>Solange deine Kommandozeilen-Parselogik klein ist, kann sie in <em>main.rs</em>
bleiben.</li>
<li>Wenn die Kommandozeilen-Parselogik anfängt, kompliziert zu werden, extrahiere
sie aus <em>main.rs</em> und verschiebe sie in <em>lib.rs</em>.</li>
</ul>
<p>Die Verantwortlichkeiten, die nach diesem Prozess in der Funktion <code>main</code>
verbleiben, sollten sich auf Folgendes beschränken:</p>
<ul>
<li>Aufrufen der Kommandozeilen-Parselogik mit den Argumentwerten</li>
<li>Aufbauen weiterer Konfiguration</li>
<li>Aufrufen einer Funktion <code>run</code> in <em>lib.rs</em></li>
<li>Behandeln des Fehlers, wenn <code>run</code> einen Fehler zurückgibt</li>
</ul>
<p>Bei diesem Muster geht es darum, Verantwortlichkeiten zu trennen: <em>main.rs</em>
kümmert sich um die Ausführung des Programms und <em>lib.rs</em> kümmert sich um die
gesamte Logik der anstehenden Aufgabe. Da du die Funktion <code>main</code> nicht direkt
testen kannst, kannst du mit dieser Struktur die gesamte Logik deines Programms
testen, indem du sie in Funktionen in <em>lib.rs</em> verschiebst. Der Code, der in
<em>main.rs</em> verbleibt, wird klein genug sein, um seine Korrektheit durch Lesen zu
überprüfen. Lass uns unser Programm überarbeiten, indem wir diesem Prozess
folgen.</p>
<h4 id="extrahieren-des-argument-parsers"><a class="header" href="#extrahieren-des-argument-parsers">Extrahieren des Argument-Parsers</a></h4>
<p>Wir werden die Funktionalität für das Parsen von Argumenten in eine Funktion
extrahieren, die von <code>main</code> aufgerufen wird, um das Verschieben der
Kommandozeilen-Parselogik nach <em>src/lib.rs</em> vorzubereiten. Codeblock 12-5 zeigt
den neuen Anfang von <code>main</code>, der eine neue Funktion <code>parse_config</code> aufruft, die
wir vorerst in <em>src/main.rs</em> definieren werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --abschneiden--
<span class="boring">
</span><span class="boring">    println!("Suche nach {query}");
</span><span class="boring">    println!("In Datei {file_path}");
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect("Etwas ging beim Lesen der Datei schief");
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
<p><span class="caption">Codeblock 12-5: Extrahieren einer Funktion <code>parse_config</code>
aus <code>main</code></span></p>
<p>Wir sammeln immer noch die Kommandozeilenargumente in einem Vektor, aber
anstatt den Argumentwert am Index 1 der Variablen <code>query</code> und den Argumentwert
am Index 2 der Variablen <code>file_path</code> innerhalb der Funktion <code>main</code> zuzuweisen,
übergeben wir den gesamten Vektor an die Funktion <code>parse_config</code>. Die Funktion
<code>parse_config</code> enthält dann die Logik, die bestimmt, welches Argument in welche
Variable geht und die Werte an <code>main</code> zurückgibt. Wir erstellen immer noch die
Variablen <code>query</code> und <code>file_path</code> in <code>main</code>, aber <code>main</code> hat nicht mehr die
Verantwortung zu bestimmen, wie die Kommandozeilenargumente und Variablen
zusammenpassen.</p>
<p>Dieses Überarbeiten mag für unser kleines Programm übertrieben erscheinen, aber
wir führen die Refactoring-Maßnahmen in kleinen, inkrementellen Schritten
durch. Nachdem du diese Änderung vorgenommen hast, führe das Programm erneut
aus, um zu überprüfen, ob das Argumentparsen noch funktioniert. Es ist gut, den
Fortschritt oft zu überprüfen, um die Ursache von Problemen zu erkennen, wenn
sie auftreten.</p>
<h4 id="gruppieren-von-konfigurationswerten"><a class="header" href="#gruppieren-von-konfigurationswerten">Gruppieren von Konfigurationswerten</a></h4>
<p>Wir können einen weiteren kleinen Schritt tun, um die Funktion <code>parse_config</code>
weiter zu verbessern. Im Moment geben wir ein Tupel zurück, aber dann zerlegen
wir dieses Tupel sofort wieder in einzelne Teile. Das ist ein Zeichen dafür,
dass wir vielleicht noch nicht die richtige Abstraktion haben.</p>
<p>Ein weiterer Indikator, der zeigt, dass es Raum für Verbesserungen gibt, ist
der <code>config</code>-Teil von <code>parse_config</code>, der impliziert, dass die beiden von uns
zurückgegebenen Werte miteinander in Beziehung stehen und beide Teil eines
Konfigurationswertes sind. Diese Bedeutung vermitteln wir derzeit nur durch die
Gruppierung der beiden Werte in einem Tupel. Geben wir daher die beiden Werte
in einer Struktur an und geben jedem der Strukturfelder einen aussagekräftigen
Namen. Auf diese Weise wird es künftigen Entwicklern dieses Codes leichter
fallen, zu verstehen, wie die verschiedenen Werte miteinander in Beziehung
stehen und was ihr Zweck ist.</p>
<p>Codeblock 12-6 zeigt die Verbesserungen der Funktion <code>parse_config</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic edition2024"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!("Suche nach {}", config.query);
    println!("In Datei {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Etwas ging beim Lesen der Datei schief");

    // --abschneiden--
<span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre></pre>
<p><span class="caption">Codeblock 12-6: Refactorieren von <code>parse_config</code> zur
Rückgabe einer Instanz einer <code>Config</code>-Struktur</span></p>
<p>Wir haben eine Struktur namens <code>Config</code> hinzugefügt, die so definiert ist, dass
sie Felder mit den Namen <code>query</code> und <code>file_path</code> enthält. Die Signatur von
<code>parse_config</code> zeigt nun an, dass sie einen <code>Config</code>-Wert zurückgibt. Im
Rumpf von <code>parse_config</code>, wo wir früher Zeichenkettenanteilstypen (string
slices) zurückgegeben haben, die auf <code>String</code>-Werte in <code>args</code> referenzieren,
definieren wir <code>Config</code> jetzt so, dass es aneigenbare (owned) <code>String</code>-Werte
enthält. Die <code>args</code>-Variable in <code>main</code> ist der Eigentümer der Argumentwerte und
lässt die Funktion <code>parse_config</code> diese nur ausleihen, was bedeutet, dass wir
Rusts Regeln für das Ausleihen verletzen würden, wenn <code>Config</code> versucht, die
Eigentümerschaft für die Werte in <code>args</code> zu nehmen.</p>
<p>Wir könnten die <code>String</code>-Daten auf verschiedene Weise verwalten, aber der
einfachste, wenn auch etwas ineffiziente Weg ist es, die Methode <code>clone</code> der
Werte aufzurufen. Dadurch wird eine vollständige Kopie der Daten erstellt, die
die <code>Config</code>-Instanz besitzen soll, was mehr Zeit und Speicherplatz in Anspruch
nimmt als das Speichern einer Referenz auf die Zeichenkettendaten. Das Klonen
der Daten macht unseren Code jedoch auch sehr unkompliziert, weil wir die
Lebensdauer der Referenzen nicht verwalten müssen; unter diesen Umständen ist
es ein lohnender Kompromiss, ein wenig Leistung aufzugeben, um Einfachheit zu
bekommen.</p>
<blockquote>
<h3 id="die-kompromisse-beim-verwenden-von-clone"><a class="header" href="#die-kompromisse-beim-verwenden-von-clone">Die Kompromisse beim Verwenden von <code>clone</code></a></h3>
<p>Viele Rust-Entwickler neigen dazu, das Verwenden von <code>clone</code> zur Lösung von
Eigentümerschaftsproblemen wegen der Laufzeitkosten zu vermeiden. In <a href="ch13-00-functional-features.html">Kapitel
13</a> erfährst du, wie du in solchen Situationen effizientere Methoden
einsetzen kannst. Aber für den Moment ist es in Ordnung, ein paar
Zeichenketten zu kopieren, um weiter voranzukommen, da du diese Kopien nur
einmal erstellen wirst und dein Dateipfad und deine Suchzeichenkette sehr
klein sind. Es ist besser, ein funktionierendes Programm zu haben, das ein
bisschen ineffizient ist, als zu versuchen, den Code beim ersten Durchgang zu
hyperoptimieren. Je mehr Erfahrung du mit Rust sammelst, desto einfacher wird
es, mit der effizientesten Lösung zu beginnen, aber im Moment ist es völlig
akzeptabel, <code>clone</code> aufzurufen.</p>
</blockquote>
<p>Wir haben <code>main</code> aktualisiert, sodass es die Instanz von <code>Config</code>, die von
<code>parse_config</code> zurückgegeben wird, in eine Variable namens <code>config</code> setzt, und
wir haben den Code aktualisiert, der vorher die separaten Variablen <code>query</code> und
<code>file_path</code> verwendet hat, sodass er jetzt stattdessen die Felder der
<code>Config</code>-Struktur verwendet.</p>
<p>Nun vermittelt unser Code deutlicher, dass <code>query</code> und <code>file_path</code> zueinander
gehören und dass ihr Zweck darin besteht, die Funktionsweise des Programms zu
konfigurieren. Jeder Code, der diese Werte verwendet, weiß, dass er sie in der
<code>config</code>-Instanz in den für ihren Zweck benannten Feldern findet.</p>
<h4 id="erstellen-eines-konstruktors-für-config"><a class="header" href="#erstellen-eines-konstruktors-für-config">Erstellen eines Konstruktors für <code>Config</code></a></h4>
<p>Bisher haben wir die Logik, die für das Parsen der Kommandozeilenargumente
verantwortlich ist, aus <code>main</code> extrahiert und in die Funktion <code>parse_config</code>
verschoben. Dies half uns zu erkennen, dass die Werte <code>query</code> und <code>file_path</code>
miteinander in Beziehung stehen und diese Beziehung in unserem Code vermittelt
werden sollte. Wir fügten dann eine <code>Config</code>-Struktur hinzu, um das
Zusammengehören von <code>query</code> und <code>file_path</code> zu benennen und um die Namen der
Werte als Feldnamen der Struktur von der Funktion <code>parse_config</code> zurückgeben zu
können.</p>
<p>Da nun der Zweck der Funktion <code>parse_config</code> darin besteht, eine
<code>Config</code>-Instanz zu erzeugen, können wir <code>parse_config</code> von einer einfachen
Funktion in eine Funktion namens <code>new</code> ändern, die mit der <code>Config</code>-Struktur
assoziiert ist. Durch diese Änderung wird der Code idiomatischer. Wir können
Instanzen von Typen in der Standardbibliothek erstellen, wie bei <code>String</code>,
indem wir <code>String::new</code> aufrufen. In ähnlicher Weise können wir durch Ändern
von <code>parse_config</code> in eine Funktion <code>new</code>, die mit <code>Config</code> assoziiert ist,
Instanzen von <code>Config</code> durch Aufrufen von <code>Config::new</code> erzeugen. Codeblock
12-7 zeigt die Änderungen, die wir vornehmen müssen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic edition2024"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

<span class="boring">    println!("Suche nach {}", config.query);
</span><span class="boring">    println!("In Datei {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Etwas ging beim Lesen der Datei schief");
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span><span class="boring">
</span>    // --abschneiden--
}

// --abschneiden--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 12-7: Ändern von <code>parse_config</code> in
<code>Config::new</code></span></p>
<p>Wir haben <code>main</code> aktualisiert, wo wir <code>parse_config</code> aufgerufen haben, um
stattdessen <code>Config::new</code> aufzurufen. Wir haben den Namen von <code>parse_config</code> in
<code>new</code> geändert und ihn innerhalb eines <code>impl</code>-Blocks verschoben, der die
Funktion <code>new</code> mit <code>Config</code> assoziiert. Versuche, diesen Code erneut zu
kompilieren, um sicherzustellen, dass er funktioniert.</p>
<h3 id="korrigieren-der-fehlerbehandlung"><a class="header" href="#korrigieren-der-fehlerbehandlung">Korrigieren der Fehlerbehandlung</a></h3>
<p>Jetzt werden wir daran arbeiten, unsere Fehlerbehandlung zu korrigieren.
Erinnere dich, dass der Versuch, auf die Werte im <code>args</code>-Vektor bei Index 1
oder Index 2 zuzugreifen, das Programm zum Absturz bringt, wenn der Vektor
weniger als drei Elemente enthält. Versuche, das Programm ohne irgendwelche
Argumente laufen zu lassen; es wird so aussehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Die Zeile <code>index out of bounds: the len is 1 but the index is 1</code> ist eine für
Programmierer bestimmte Fehlermeldung. Sie wird unseren Endbenutzern nicht
helfen zu verstehen, was sie stattdessen tun sollten. Lass uns das jetzt
korrigieren.</p>
<h4 id="verbessern-der-fehlermeldung"><a class="header" href="#verbessern-der-fehlermeldung">Verbessern der Fehlermeldung</a></h4>
<p>In Codeblock 12-8 fügen wir eine Prüfung in der Funktion <code>new</code> hinzu, die
überprüft, ob der Anteilstyp lang genug ist, bevor auf Index 1 und Index 2
zugegriffen wird. Wenn der Anteilstyp nicht lang genug ist, stürzt das Programm
ab und zeigt eine bessere Fehlermeldung an.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Suche nach {}", config.query);
</span><span class="boring">    println!("In Datei {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Etwas ging beim Lesen der Datei schief");
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --abschneiden--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!("Nicht genügend Argumente");
        }
        // --abschneiden--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-8: Hinzufügen einer Prüfung für die Anzahl
der Argumente</span></p>
<p>Dieser Code ähnelt <a href="ch09-03-to-panic-or-not-to-panic.html#benutzerdefinierte-typen-f%C3%BCr-die-validierung-erstellen">der Funktion <code>Guess::new</code>, die wir in Codeblock
9-13</a> geschrieben haben, wo wir <code>panic!</code> aufgerufen haben,
wenn das Argument <code>value</code> außerhalb des gültigen Wertebereichs lag. Anstatt
hier auf einen Wertebereich zu prüfen, prüfen wir, ob die Länge von <code>args</code>
mindestens <code>3</code> beträgt und der Rest der Funktion unter der Annahme arbeiten
kann, dass diese Bedingung erfüllt ist. Wenn <code>args</code> weniger als drei Elemente
hat, wird diese Bedingung <code>true</code> und wir rufen das Makro <code>panic!</code> auf, um das
Programm sofort zu beenden.</p>
<p>Mit diesen zusätzlichen wenigen Zeilen Code in <code>new</code> lassen wir das Programm
ohne Argumente erneut laufen, um zu sehen, wie der Fehler jetzt aussieht:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:26:13:
Nicht genügend Argumente
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Diese Ausgabe ist besser: Wir haben jetzt eine vernünftige Fehlermeldung. Wir
haben jedoch auch irrelevante Informationen, die wir unseren Benutzern nicht
geben wollen. Vielleicht ist die Technik, die wir in Codeblock 9-13 verwendet
haben, hier nicht die beste: Das Aufrufen von <code>panic!</code> ist für ein
Programmierproblem besser geeignet als für ein Nutzungsproblem, <a href="ch09-03-to-panic-or-not-to-panic.html#richtlinien-zur-fehlerbehandlung">wie in Kapitel
9 besprochen</a>. Stattdessen können wir die andere Technik
verwenden, über die du in Kapitel 9 gelernt hast – <a href="ch09-02-recoverable-errors-with-result.html">Rückgabe eines
<code>Result</code></a> um entweder Erfolg oder einen Fehler anzuzeigen.</p>
<h4 id="zurückgeben-eines-result-anstatt-panic-aufzurufen"><a class="header" href="#zurückgeben-eines-result-anstatt-panic-aufzurufen">Zurückgeben eines <code>Result</code> anstatt <code>panic!</code> aufzurufen</a></h4>
<p>Wir können stattdessen einen <code>Result</code>-Wert zurückgeben, der im erfolgreichen
Fall eine <code>Config</code>-Instanz enthält und im Fehlerfall das Problem beschreibt.
Wir werden auch den Namen der Funktion von <code>new</code> in <code>build</code> ändern, weil viele
Programmierer erwarten, dass <code>new</code>-Funktionen niemals fehlschlagen. Wenn
<code>Config::build</code> mit <code>main</code> kommuniziert, können wir den <code>Result</code>-Typ verwenden,
um zu signalisieren, dass ein Problem aufgetreten ist. Dann können wir <code>main</code>
ändern, um eine <code>Err</code>-Variante in einen praktikableren Fehler für unsere
Benutzer umzuwandeln, ohne den umgebenden Text über <code>thread 'main'</code> und
<code>RUST_BACKTRACE</code>, den ein Aufruf von <code>panic!</code> verursacht.</p>
<p>Codeblock 12-9 zeigt die Änderungen, die wir am Rückgabewert der Funktion, die
nun <code>Config::build</code> aufruft, und am Funktionsrumpf vornehmen müssen, um ein
<code>Result</code> zurückzugeben. Beachte, dass dies nicht kompiliert werden kann, bis
wir auch <code>main</code> aktualisieren, was wir im nächsten Codeblock tun werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Suche nach {}", config.query);
</span><span class="boring">    println!("In Datei {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Etwas ging beim Lesen der Datei schief");
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("Nicht genügend Argumente");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
<p><span class="caption">Codeblock 12-9: Rückgabe eines <code>Result</code> von
<code>Config::build</code></span></p>
<p>Unsere Funktion <code>build</code> liefert ein <code>Result</code> mit einer <code>Config</code>-Instanz im
Erfolgsfall und ein Zeichenkettenliteral im Fehlerfall. Unsere Fehlerwerte
werden immer Zeichenketten-Literale sein, die eine <code>'static</code> Lebensdauer haben.</p>
<p>Wir haben zwei Änderungen im Rumpf der Funktion vorgenommen: Anstatt <code>panic!</code>
aufzurufen, wenn der Benutzer nicht genug Argumente übergibt, geben wir jetzt
einen <code>Err</code>-Wert zurück, und wir haben den <code>Config</code>-Rückgabewert in ein <code>Ok</code>
verpackt. Diese Änderungen machen die Funktion konform mit ihrer neuen
Typsignatur.</p>
<p>Die Rückgabe eines <code>Err</code>-Wertes aus <code>Config::build</code> erlaubt es der Funktion
<code>main</code>, den von der Funktion <code>build</code> zurückgegebenen <code>Result</code>-Wert zu verarbeiten
und den Prozess im Fehlerfall sauberer zu beenden.</p>
<h4 id="aufrufen-von-configbuild-und-behandeln-von-fehlern"><a class="header" href="#aufrufen-von-configbuild-und-behandeln-von-fehlern">Aufrufen von <code>Config::build</code> und Behandeln von Fehlern</a></h4>
<p>Um den Fehlerfall zu behandeln und eine benutzerfreundliche Meldung auszugeben,
müssen wir <code>main</code> aktualisieren, um das von <code>Config::build</code> zurückgegebene
<code>Result</code> zu behandeln, wie in Codeblock 12-10 gezeigt. Wir werden auch die
Verantwortung dafür übernehmen, das Kommandozeilenwerkzeug mit einem Fehlercode
ungleich Null wie bei <code>panic!</code> zu beenden und es von Hand zu implementieren.
Ein Exit-Status ungleich Null ist eine Konvention, um dem Prozess, der unser
Programm aufgerufen hat, zu signalisieren, dass das Programm mit einem
Fehlerstatus beendet wurde.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!("Fehler beim Parsen der Argumente: {err}");
        process::exit(1);
    });

    // --abschneiden--
<span class="boring">
</span><span class="boring">    println!("Suche nach {}", config.query);
</span><span class="boring">    println!("In Datei {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Etwas ging beim Lesen der Datei schief");
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-10: Beenden mit einem Fehlercode, wenn das
Erstellen einer <code>Config</code> fehlschlägt</span></p>
<p>In diesem Codeblock haben wir eine Methode verwendet, die wir bisher noch
nicht behandelt haben: <code>unwrap_or_else</code>, die in der Standardbibliothek unter
<code>Result&lt;T, E&gt;</code> definiert ist. Das Verwenden von <code>unwrap_or_else</code> erlaubt es
uns, eine benutzerdefinierte nicht-<code>panic!</code>-Fehlerbehandlung zu definieren.
Wenn das <code>Result</code> ein <code>Ok</code>-Wert ist, verhält sich diese Methode ähnlich wie
<code>unwrap</code>: Sie gibt den inneren Wert von <code>Ok</code> zurück. Wenn der Wert jedoch ein
<code>Err</code>-Wert ist, ruft diese Methode den Code im <em>Funktionsabschluss</em> (closure)
auf, die eine anonyme Funktion ist, die wir definieren und als Argument an
<code>unwrap_or_else</code> übergeben. Auf Funktionsabschlüsse gehen wir ausführlicher in
<a href="ch13-00-functional-features.html">Kapitel 13</a> ein. Im Moment musst du nur wissen, dass <code>unwrap_or_else</code>
den inneren Wert des <code>Err</code>, in diesem Fall die statische Zeichenkette <code>Nicht genügend Argumente</code>, die wir in Codeblock 12-9 hinzugefügt haben, an unseren
Funktionsabschluss im Argument <code>err</code>, das zwischen den senkrechten Strichen
erscheint, weitergibt. Der Code im Funktionsabschluss kann dann den <code>err</code>-Wert
verwenden, wenn sie ausgeführt wird.</p>
<p>Wir haben eine neue Zeile <code>use</code> hinzugefügt, um <code>process</code> aus der
Standardbibliothek in den Gültigkeitsbereich zu bringen. Der Code im
Funktionsabschluss, der im Fehlerfall ausgeführt wird, besteht nur aus zwei
Zeilen: Wir geben den <code>err</code>-Wert aus und rufen dann <code>process::exit</code> auf. Die
Funktion <code>process::exit</code> stoppt das Programm sofort und gibt die Zahl zurück,
die als Exit-Statuscode übergeben wurde. Dies ähnelt der <code>panic!</code>-basierten
Behandlung, die wir in Codeblock 12-8 verwendet haben, aber wir erhalten nicht
mehr die gesamte zusätzliche Ausgabe. Lass es uns versuchen:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Fehler beim Parsen der Argumente: Nicht genügend Argumente
</code></pre>
<p>Großartig! Diese Ausgabe ist viel benutzerfreundlicher.</p>
<h3 id="extrahieren-von-logik-aus-main"><a class="header" href="#extrahieren-von-logik-aus-main">Extrahieren von Logik aus <code>main</code></a></h3>
<p>Da wir mit dem Refaktorieren des Konfigurations-Parsers nun fertig sind, wollen
wir uns der Logik des Programms zuwenden. Wie wir in <a href="ch12-03-improving-error-handling-and-modularity.html#trennen-der-zust%C3%A4ndigkeiten-bei-bin%C3%A4rprojekten">„Trennen der
Zuständigkeiten bei
Binärprojekten“</a> erklärt
haben, werden wir eine Funktion namens <code>run</code> extrahieren, die die gesamte Logik
enthält, die sich derzeit in der Funktion <code>main</code> befindet und nicht mit dem
Aufsetzen der Konfiguration oder dem Behandeln von Fehlern zu tun hat. Wenn wir
fertig sind, wird die Funktion <code>main</code> übersichtlich und leicht zu verifizieren
sein. Zudem werden wir in der Lage sein, Tests für all die andere Logik zu
schreiben.</p>
<p>Codeblock 12-11 zeigt die extrahierte Funktion <code>run</code>. Im Moment machen wir nur
die kleine, inkrementelle Verbesserung durch Extrahieren der Funktion. Wir sind
immer noch dabei, die Funktion in <em>src/main.rs</em> zu definieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --abschneiden--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Fehler beim Parsen der Argumente: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Suche nach {}", config.query);
    println!("In Datei {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("Etwas ging beim Lesen der Datei schief");

    println!("Mit text:\n{contents}");
}

// --abschneiden--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-11: Extrahieren einer Funktion <code>run</code>, die
den Rest der Programmlogik enthält</span></p>
<p>Die Funktion <code>run</code> enthält nun die gesamte restliche Logik von <code>main</code>,
beginnend mit dem Lesen der Datei. Die Funktion <code>run</code> nimmt die
<code>Config</code>-Instanz als Argument.</p>
<h4 id="rückgabe-von-fehlern-aus-der-funktion-run"><a class="header" href="#rückgabe-von-fehlern-aus-der-funktion-run">Rückgabe von Fehlern aus der Funktion <code>run</code></a></h4>
<p>Wenn die verbleibende Programmlogik in die Funktion <code>run</code> separiert wird,
können wir die Fehlerbehandlung verbessern, wie wir es mit <code>Config::build</code> in
Codeblock 12-9 getan haben. Anstatt das Programm durch den Aufruf von <code>expect</code>
abstürzen zu lassen, gibt die Funktion <code>run</code> ein <code>Result&lt;T, E&gt;</code> zurück, wenn
etwas schief läuft. Auf diese Weise können wir in <code>main</code> die Logik rund um den
Umgang mit Fehlern auf benutzerfreundliche Weise weiter konsolidieren.
Codeblock 12-12 zeigt die Änderungen, die wir an der Signatur und dem Rumpf von
<code>run</code> vornehmen müssen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --abschneiden--

<span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Fehler beim Parsen der Argumente: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Suche nach {}", config.query);
</span><span class="boring">    println!("In Datei {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!("Mit text:\n{contents}");

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-12: Ändern der Funktion <code>run</code>, um ein
<code>Result</code> zurückzugeben</span></p>
<p>Wir haben hier drei wesentliche Änderungen vorgenommen. Erstens haben wir den
Rückgabetyp der Funktion <code>run</code> in <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> geändert. Diese
Funktion gab zuvor den Einheitstyp <code>()</code> zurück und wir behalten diesen als
Rückgabewert im Fall <code>Ok</code> bei.</p>
<p>Für den Fehlertyp haben wir das <em>Merkmalsobjekt</em> (trait object) <code>Box&lt;dyn Error&gt;</code> verwendet (und wir haben <code>std::error::Error</code> mit einer <code>use</code>-Anweisung
am Anfang des Gültigkeitsbereichs eingebunden). Wir werden Merkmalsobjekte in
<a href="ch18-00-oop.html">Kapitel 18</a> behandeln. Für den Moment solltest du nur wissen, dass
<code>Box&lt;dyn Error&gt;</code> bedeutet, dass die Funktion einen Typ zurückgibt, der das
Merkmal <code>Error</code> implementiert, aber wir müssen nicht angeben, welcher bestimmte
Typ der Rückgabewert sein wird. Das gibt uns die Flexibilität, Fehlerwerte
zurückzugeben, die in verschiedenen Fehlerfällen von unterschiedlichem Typ sein
können. Das Schlüsselwort <code>dyn</code> ist die Abkürzung für <em>dynamisch</em>.</p>
<p>Zweitens haben wir den Aufruf von <code>expect</code> zugunsten des <code>?</code>-Operators
entfernt, wie wir in <a href="ch09-02-recoverable-errors-with-result.html#abk%C3%BCrzung-zum-weitergeben-von-fehlern-der-operator-">Kapitel 9</a> besprochen haben. Statt
<code>panic!</code> bei einem Fehler aufzurufen gibt <code>?</code> den Fehlerwert aus der aktuellen
Funktion zurück, den der Aufrufer behandeln muss.</p>
<p>Drittens gibt die Funktion <code>run</code> jetzt im Erfolgsfall einen <code>Ok</code>-Wert zurück.
Wir haben den Erfolgstyp der Funktion <code>run</code> mit <code>()</code> in der Signatur
deklariert, was bedeutet, dass wir den Wert des Einheitstyps in den Wert <code>Ok</code>
einpacken müssen. Diese Syntax <code>Ok(())</code> mag zunächst etwas merkwürdig
aussehen, aber wenn wir <code>()</code> so verwenden, ist das der idiomatische Weg, um
anzuzeigen, dass wir <code>run</code> nur wegen seiner Seiteneffekte aufrufen; es gibt
keinen Wert zurück, den wir brauchen.</p>
<p>Wenn du diesen Code ausführst, wird er kompiliert, aber es wird eine Warnung
angezeigt:</p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Suche nach the
In Datei poem.txt
Mit text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Rust sagt uns, dass unser Code den <code>Result</code>-Wert ignoriert hat, und der
<code>Result</code>-Wert könnte darauf hinweisen, dass ein Fehler aufgetreten ist. Aber
wir überprüfen nicht, ob ein Fehler aufgetreten ist oder nicht, und der
Compiler erinnert uns daran, dass wir wahrscheinlich gemeint haben, hier etwas
Fehlerbehandlungscode zu haben! Lass uns dieses Problem jetzt beheben.</p>
<h4 id="behandeln-von-fehlern-die-von-run-in-main-zurückgegeben-wurden"><a class="header" href="#behandeln-von-fehlern-die-von-run-in-main-zurückgegeben-wurden">Behandeln von Fehlern, die von <code>run</code> in <code>main</code> zurückgegeben wurden</a></h4>
<p>Wir werden nach Fehlern suchen und sie mit einer Technik behandeln, die ähnlich
der Technik ist, die wir mit <code>Config::build</code> in Codeblock 12-10 verwendet
haben, aber mit einem kleinen Unterschied:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --abschneiden--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Fehler beim Parsen der Argumente: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Suche nach {}", config.query);
    println!("In Datei {}", config.file_path);

    if let Err(e) = run(config) {
        println!("Anwendungsfehler: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>Wir benutzen <code>if let</code> statt <code>unwrap_or_else</code>, um zu prüfen, ob <code>run</code> einen
<code>Err</code>-Wert zurückgibt und rufen <code>process::exit(1)</code> auf, wenn dies der Fall ist.
Die Funktion <code>run</code> gibt keinen Wert zurück, den wir mit <code>unwrap</code> auspacken
wollen, auf die gleiche Weise, wie <code>Config::build</code> die <code>Config</code>-Instanz
zurückgibt. Da <code>run</code> im Erfolgsfall <code>()</code> zurückgibt, geht es uns nur darum,
einen Fehler zu entdecken, wir brauchen also nicht <code>unwrap_or_else</code>, um den
ausgepackten Wert zurückzugeben, der nur <code>()</code> wäre.</p>
<p>Die Rümpfe von <code>if let</code> und der <code>unwrap_or_else</code>-Funktionen sind in beiden
Fällen gleich: Wir geben den Fehler aus und beenden.</p>
<h3 id="code-in-eine-bibliothekskiste-aufteilen"><a class="header" href="#code-in-eine-bibliothekskiste-aufteilen">Code in eine Bibliothekskiste aufteilen</a></h3>
<p>Unser <code>minigrep</code>-Projekt sieht soweit gut aus! Jetzt teilen wir die Datei
<em>src/main.rs</em> auf und fügen etwas Code in die Datei <em>src/lib.rs</em> ein. Auf
diese Weise können wir den Code testen und haben eine Datei <em>src/main.rs</em> mit
weniger Verantwortlichkeiten.</p>
<p>Lass uns den ganzen Code, der nicht in der Funktion <code>main</code> ist, von
<em>src/main.rs</em> nach <em>src/lib.rs</em> verschieben:</p>
<ul>
<li>Die Definition der Funktion <code>run</code></li>
<li>Die relevanten <code>use</code>-Anweisungen</li>
<li>Die Definition von <code>Config</code></li>
<li>Die Funktionsdefinition <code>Config::build</code></li>
</ul>
<p>Der Inhalt von <em>src/lib.rs</em> sollte die in Codeblock 12-13 gezeigten Signaturen
haben (wir haben die Rümpfe der Funktionen der Kürze halber weggelassen).
Beachte, dass dies nicht kompiliert werden kann, bis wir <em>src/main.rs</em> in
Codeblock 12-14 modifiziert haben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --abschneiden--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --abschneiden--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("Mit text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Codeblock 12-13: Verschieben von <code>Config</code> und <code>run</code> in
<em>src/lib.rs</em></span></p>
<p>Wir haben das Schlüsselwort <code>pub</code> großzügig verwendet: Bei <code>Config</code>, bei seinen
Feldern und seiner Methode <code>build</code> und bei der Funktion <code>run</code>. Wir haben jetzt
eine Bibliothekskiste, die eine öffentliche API hat, die wir testen können!</p>
<p>Jetzt müssen wir den Code, den wir nach <em>src/lib.rs</em> verschoben haben, in den
Gültigkeitsbereich der Binärkiste in <em>src/main.rs</em> bringen, wie in Codeblock
12-14 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --abschneiden--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Fehler beim Parsen der Argumente: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Suche nach {}", config.query);
</span><span class="boring">    println!("In Datei {}", config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --abschneiden--
<span class="boring">        println!("Anwendungsfehler: {e}");
</span><span class="boring">        process::exit(1);
</span>    }
}</code></pre>
<p><span class="caption">Codeblock 12-14: Verwenden der
<code>minigrep</code>-Bibliothekskiste in <em>src/main.rs</em></span></p>
<p>Wir fügen eine Zeile <code>use minigrep::Config</code> hinzu, um den Typ <code>Config</code> aus der
Bibliothekskiste in den Gültigkeitsbereich der Binärkiste zu bringen, und wir
stellen der Funktion <code>run</code> unseren Kistennamen voran. Nun sollte die gesamte
Funktionalität verbunden sein und funktionieren. Starte das Programm mit <code>cargo run</code> und stelle sicher, dass alles korrekt funktioniert.</p>
<p>Puh! Das war eine Menge Arbeit, aber wir haben uns für den Erfolg in der
Zukunft gerüstet. Jetzt ist es viel einfacher, mit Fehlern umzugehen, und wir
haben den Code modularer gestaltet. Fast unsere gesamte Arbeit wird von nun an
in <em>src/lib.rs</em> durchgeführt.</p>
<p>Lass uns diese neu gewonnene Modularität nutzen, indem wir etwas tun, was mit
dem alten Code schwierig gewesen wäre, mit dem neuen Code aber einfach ist: Wir
schreiben ein paar Tests!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="bibliotheksfunktionalität-mit-testgetriebener-entwicklung-erstellen"><a class="header" href="#bibliotheksfunktionalität-mit-testgetriebener-entwicklung-erstellen">Bibliotheksfunktionalität mit testgetriebener Entwicklung erstellen</a></h2>
<p>Jetzt, da wir die Logik nach <em>src/lib.rs</em> extrahiert haben und die
Argumentkollektion und Fehlerbehandlung in <em>src/main.rs</em> belassen haben, ist es
viel einfacher, Tests für die Kernfunktionalität unseres Codes zu schreiben.
Wir können Funktionen direkt mit verschiedenen Argumenten aufrufen und
Rückgabewerte überprüfen, ohne unsere Binärdatei vom Terminal aus aufrufen zu
müssen.</p>
<p>In diesem Abschnitt fügen wir dem <code>minigrep</code>-Programm die Suchlogik hinzu,
indem wir die Methode der testgetriebenen Entwicklung (TDD) verwenden. Diese
Softwareentwicklungstechnik folgt diesen Schritten:</p>
<ol>
<li>Schreibe einen Test, der fehlschlägt, und führe ihn aus, um sicherzustellen,
dass er aus dem von dir erwarteten Grund fehlschlägt.</li>
<li>Schreibe oder modifiziere gerade genug Code, um den neuen Test zu bestehen.</li>
<li>Refaktoriere den Code, den du gerade hinzugefügt oder geändert hast, und
stelle sicher, dass die Tests weiterhin bestanden werden.</li>
<li>Wiederhole ab Schritt 1!</li>
</ol>
<p>Obwohl es nur eine von vielen Möglichkeiten ist, Software zu schreiben, kann
TDD auch beim Code-Design helfen. Das Schreiben der Tests vor dem Schreiben des
Codes, der den Test bestehen lässt, trägt dazu bei, während des gesamten
Entwicklungsprozesses eine hohe Testabdeckung aufrechtzuerhalten.</p>
<p>Wir werden die Implementierung der Funktionalität testen, die tatsächlich die
Suche nach der Suchzeichenkette im Dateiinhalt durchführt und eine Liste von
Zeilen erzeugt, die der Suchabfrage entsprechen. Wir werden diese
Funktionalität in einer Funktion namens <code>search</code> hinzufügen.</p>
<h3 id="schreiben-eines-fehlschlagenden-tests"><a class="header" href="#schreiben-eines-fehlschlagenden-tests">Schreiben eines fehlschlagenden Tests</a></h3>
<p>Da wir sie nicht mehr benötigen, entfernen wir die <code>println!</code> -Anweisungen aus
<em>src/lib.rs</em> und <em>src/main.rs</em>, die wir zum Überprüfen des Programmverhaltens
verwendet haben. Dann füge in <em>src/lib.rs</em> ein Modul <code>tests</code> mit einer
Testfunktion hinzu, wie wir es in <a href="ch11-01-writing-tests.html#anatomie-einer-testfunktion">Kapitel 11</a> getan haben. Die
Testfunktion spezifiziert das Verhalten, das die Funktion <code>search</code> haben soll:
Sie nimmt eine Suchabfrage und den Text, in dem gesucht werden soll, entgegen
und gibt nur die Zeilen aus dem Text zurück, die die Suchabfrage enthalten.
Codeblock 12-15 zeigt diesen Test, der sich noch nicht kompilieren lässt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "dukt";
        let contents = "\
Rust:
sicher, schnell, produktiv.
Nimm drei.";

        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
    }
}</code></pre>
<p><span class="caption">Codeblock 12-15: Erstellen eines fehlschlagenden Tests
für die Funktion <code>search</code>, die wir uns wünschen</span></p>
<p>Dieser Test sucht nach der Zeichenkette <code>"dukt"</code>. Der Text, den wir
durchsuchen, besteht aus drei Zeilen, von denen nur eine <code>"dukt"</code> enthält.
(Beachte, dass der Backslash nach dem öffnenden doppelten Anführungszeichen
Rust anweist, keinen Zeilenumbruch an den Anfang des Zeichenkettenliterals zu
setzen.) Wir verlangen, dass der von der Funktion <code>search</code> zurückgegebene Wert
nur die Zeile enthält, die wir erwarten.</p>
<p>Wir sind noch nicht in der Lage, diesen Test auszuführen und zuzusehen, wie er
fehlschlägt, weil der Test noch nicht mal kompiliert: Die Funktion <code>search</code>
existiert noch nicht! In Übereinstimmung mit den TDD-Prinzipien werden wir
jetzt gerade genug Code hinzufügen, um den Test zum Kompilieren und Ausführen
zu bringen, indem wir eine Definition der Funktion <code>search</code> hinzufügen, die
immer einen leeren Vektor zurückgibt, wie in Codeblock 12-16 gezeigt. Dann
sollte der Test kompiliert werden können und fehlschlagen, weil ein leerer
Vektor nicht mit einem Vektor übereinstimmt, der die Zeile <code>"sicher, schnell, produktiv."</code> enthält.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-16: Definiere gerade genug von der Funktion
<code>search</code>, damit unser Test kompiliert</span></p>
<p>Beachte, dass wir eine explizite Lebensdauer <code>'a</code> in der Signatur von <code>search</code>
definieren müssen und diese Lebensdauer beim Argument <code>contents</code> und dem
Rückgabewert verwenden. Erinnere dich in <a href="ch10-03-lifetime-syntax.html">Kapitel 10</a> daran,
dass die Lebensdauer-Parameter angeben, welche Argument-Lebensdauer mit der
Lebensdauer des Rückgabewertes verbunden ist. In diesem Fall geben wir an, dass
der zurückgegebene Vektor Zeichenkettenanteilstypen enthalten sollte, die auf
Anteilstypen des Arguments <code>contents</code> (und nicht auf das Argument <code>query</code>)
referenzieren.</p>
<p>Mit anderen Worten sagen wir Rust, dass die von der Funktion <code>search</code>
zurückgegebenen Daten so lange leben, wie die Daten, die im Argument <code>contents</code>
an die Funktion <code>search</code> übergeben werden. Das ist wichtig! Die Daten, auf die
durch einen Anteilstyp <em>referenziert</em> wird, müssen gültig sein, damit die
Referenz gültig ist; wenn der Compiler annimmt, dass wir
Zeichenkettenanteilstypen aus <code>query</code> statt aus <code>contents</code> erstellen, wird er
seine Sicherheitsprüfung falsch durchführen.</p>
<p>Wenn wir die Lebensdauer-Annotationen vergessen und versuchen, diese Funktion
zu kompilieren, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to 1 previous error
</code></pre>
<p>Rust kann unmöglich wissen, welches der beiden Argumente wir brauchen, also
müssen wir es ihm explizit sagen. Da <code>contents</code> das Argument ist, das unseren
gesamten Text enthält, und wir diejenigen Teile dieses Textes zurückgeben
wollen, die passen, wissen wir, dass <code>contents</code> das Argument ist, das mit dem
Rückgabewert unter Verwendung der Lebensdauer-Syntax verbunden werden sollte.</p>
<p>Bei anderen Programmiersprachen ist es nicht erforderlich, Argumente zu
verbinden, um Werte in der Signatur zurückzugeben, aber dieses Vorgehen wird
mit der Zeit einfacher werden. Vergleiche dieses Beispiel mit den Beispielen im
Abschnitt <a href="ch10-03-lifetime-syntax.html">„Referenzen validieren mit
Lebensdauern“</a> in Kapitel 10.</p>
<p>Lass uns jetzt den Test ausführen:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'tests::one_result' panicked at src/lib.rs:44:9:
assertion `left == right` failed
  left: ["sicher, schnell, produktiv."]
 right: []
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Toll, der Test schlägt fehl, genau wie wir erwartet haben. Bringen wir den Test
zum Bestehen!</p>
<h3 id="code-schreiben-um-den-test-zu-bestehen"><a class="header" href="#code-schreiben-um-den-test-zu-bestehen">Code schreiben, um den Test zu bestehen</a></h3>
<p>Derzeit scheitert unser Test, weil wir immer einen leeren Vektor zurückgeben.
Um dies zu korrigieren und <code>search</code> zu implementieren, muss unser Programm die
folgenden Schritte befolgen:</p>
<ol>
<li>Iteriere über jede Zeile des Inhalts.</li>
<li>Prüfe, ob die Zeile unseren Abfragetext enthält.</li>
<li>Wenn ja, füge sie der Liste der Werte hinzu, die wir zurückgeben.</li>
<li>Wenn nicht, tue nichts.</li>
<li>Gib die Liste der passenden Ergebnisse zurück.</li>
</ol>
<p>Lass uns jeden Schritt durcharbeiten, beginnend mit dem Iterieren über die
Zeilen.</p>
<h4 id="iterieren-über-zeilen-mit-der-methode-lines"><a class="header" href="#iterieren-über-zeilen-mit-der-methode-lines">Iterieren über Zeilen mit der Methode <code>lines</code></a></h4>
<p>Rust hat eine hilfreiche Methode zum zeilenweisen Iterieren von Zeichenketten,
bequemerweise <code>lines</code> genannt, die wie in Codeblock 12-17 gezeigt funktioniert.
Beachte, dass dies noch nicht kompiliert.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // mache etwas mit line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 12-17: Iteriere über jede Zeile in
<code>contents</code></span></p>
<p>Die Methode <code>lines</code> gibt einen Iterator zurück. Wir werden in <a href="ch13-02-iterators.html">Kapitel
13</a> ausführlich über Iteratoren sprechen, aber erinnere dich
daran, dass du diese Art der Verwendung eines Iterators in <a href="ch03-05-control-flow.html#durchlaufen-einer-kollektion-mit-for">Codeblock
3-5</a> gesehen hast, wo wir eine <code>for</code>-Schleife mit einem Iterator
benutzt haben, um etwas Code für jedes Element in einer Kollektion auszuführen.</p>
<h4 id="durchsuchen-aller-zeilen-nach-dem-abfragetext"><a class="header" href="#durchsuchen-aller-zeilen-nach-dem-abfragetext">Durchsuchen aller Zeilen nach dem Abfragetext</a></h4>
<p>Als nächstes prüfen wir, ob die aktuelle Zeile unsere Abfragezeichenkette
enthält. Glücklicherweise haben Zeichenketten eine hilfreiche Methode namens
<code>contains</code>, die dies für uns erledigt! Füge einen Aufruf der Methode <code>contains</code>
in der Funktion <code>search</code> hinzu, wie in Codeblock 12-18 gezeigt. Beachte, dass
dies noch nicht kompiliert werden kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // mache etwas mit line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 12-18: Hinzufügen von Funktionalität, um zu
sehen, ob die Zeile die Zeichenkette in <code>query</code> enthält</span></p>
<p>Im Moment bauen wir die Funktionalität auf. Damit sie kompiliert werden kann,
müssen wir einen Wert aus dem Rumpf zurückgeben, wie wir es in der
Funktionssignatur angegeben haben.</p>
<h4 id="speichern-passender-zeilen"><a class="header" href="#speichern-passender-zeilen">Speichern passender Zeilen</a></h4>
<p>Um diese Funktion zu vervollständigen, brauchen wir auch eine Möglichkeit, die
passenden Zeilen zu speichern, die wir zurückgeben wollen. Dafür können wir
einen veränderbaren Vektor vor der <code>for</code>-Schleife erstellen und die Methode
<code>push</code> aufrufen, um eine <code>line</code> im Vektor zu speichern. Nach der <code>for</code>-Schleife
geben wir den Vektor zurück, wie in Codeblock 12-19 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 12-19: Speichern der passenden Zeilen, damit
wir sie zurückgeben können</span></p>
<p>Jetzt sollte die Funktion <code>search</code> nur noch die Zeilen zurückgeben, die <code>query</code>
enthalten, und unser Test sollte erfolgreich sein. Lass uns den Test ausführen:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Unser Test war erfolgreich, also wissen wir, dass es funktioniert!</p>
<p>An diesem Punkt könnten wir Möglichkeiten für eine Refaktorierung der
Implementierung der Suchfunktion in Betracht ziehen, während die Tests
weiterlaufen, um die gleiche Funktionalität zu erhalten. Der Code in der
Suchfunktion ist nicht allzu schlecht, aber er macht sich einige nützliche
Funktionen der Iteratoren nicht zunutze. Wir kehren zu diesem Beispiel in
<a href="ch13-02-iterators.html">Kapitel 13</a> zurück, wo wir Iteratoren im Detail untersuchen
und uns ansehen, wie man sie verbessern kann.</p>
<h4 id="verwenden-der-funktion-search-in-der-funktion-run"><a class="header" href="#verwenden-der-funktion-search-in-der-funktion-run">Verwenden der Funktion <code>search</code> in der Funktion <code>run</code></a></h4>
<p>Da die Funktion <code>search</code> nun funktioniert und getestet ist, müssen wir <code>search</code>
von unserer Funktion <code>run</code> aus aufrufen. Wir müssen den Wert <code>config.query</code> und
den Wert <code>contents</code>, den <code>run</code> aus der Datei liest, an die Funktion <code>search</code>
übergeben. Dann wird <code>run</code> jede von <code>search</code> zurückgegebene Zeile ausgeben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Wir benutzen immer noch eine <code>for</code>-Schleife, um jede Zeile von <code>search</code>
zurückzugeben und auszugeben.</p>
<p>Jetzt sollte das gesamte Programm funktionieren! Lass es uns ausprobieren,
zunächst mit einem Wort, das genau eine Zeile aus dem Emily-Dickinson-Gedicht
wiedergeben sollte: <em>frog</em></p>
<pre><code class="language-console">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Cool! Versuchen wir nun ein Wort, das zu mehreren Zeilen passt, wie <em>body</em>:</p>
<pre><code class="language-console">$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Und schließlich sollten wir sicherstellen, dass wir keine Zeilen bekommen, wenn
wir nach einem Wort suchen, das nirgendwo im Gedicht vorkommt, zum Beispiel
<em>monomorphization</em>:</p>
<pre><code class="language-console">$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Ausgezeichnet! Wir haben unsere eigene Miniversion eines klassischen Tools
gebaut und viel darüber gelernt, wie man Anwendungen strukturiert. Wir haben
auch ein wenig über Dateieingabe und -ausgabe, Lebensdauer, Testen und
Kommandozeilen-Parsen gelernt.</p>
<p>Um dieses Projekt abzurunden, werden wir kurz demonstrieren, wie man mit
Umgebungsvariablen arbeitet und wie man Standardfehler ausgibt, beides ist
nützlich, wenn du Kommandozeilenprogramme schreibst.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mit-umgebungsvariablen-arbeiten"><a class="header" href="#mit-umgebungsvariablen-arbeiten">Mit Umgebungsvariablen arbeiten</a></h2>
<p>Wir werden <code>minigrep</code> verbessern, indem wir eine zusätzliche Funktionalität
hinzufügen: Eine Option für die Suche unabhängig von der Groß-/Kleinschreibung,
die der Benutzer über eine Umgebungsvariable einschalten kann. Wir könnten
diese Funktion zu einer Kommandozeilenoption machen und verlangen, dass die
Benutzer sie jedes Mal eingeben müssen, wenn sie angewendet werden soll, aber
stattdessen werden wir eine Umgebungsvariable verwenden. Auf diese Weise können
unsere Benutzer die Umgebungsvariable einmal setzen und alle Suchvorgänge in
dieser Terminalsitzung ohne Berücksichtigung der Groß-/Kleinschreibung
durchführen.</p>
<h3 id="schreiben-eines-fehlschlagenden-tests-für-die-suche-unabhängig-von-der-groß-kleinschreibung"><a class="header" href="#schreiben-eines-fehlschlagenden-tests-für-die-suche-unabhängig-von-der-groß-kleinschreibung">Schreiben eines fehlschlagenden Tests für die Suche unabhängig von der Groß-/Kleinschreibung</a></h3>
<p>Wir fügen zuerst eine neue Funktion <code>search_case_insensitive</code> hinzu, die
aufgerufen wird, wenn die Umgebungsvariable einen Wert hat. Wir werden die
TDD-Methode weiter verfolgen, sodass der erste Schritt wieder darin besteht,
einen fehlschlagenden Test zu schreiben. Wir werden einen neuen Test für die
neue Funktion <code>search_case_insensitive</code> hinzufügen und unseren alten Test von
<code>one_result</code> in <code>case_sensitive</code> umbenennen, um die Unterschiede zwischen den
beiden Tests zu verdeutlichen, wie in Codeblock 12-20 gezeigt wird.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "dukt";
        let contents = "\
Rust:
sicher, schnell, produktiv.
Nimm drei.
PRODUKTION.";

        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
sicher, schnell, produktiv.
Nimm drei.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
<p><span class="caption">Codeblock 12-20: Hinzufügen eines neuen fehlschlagenden
Tests für die Funktion <code>search_case_insensitive</code>, die wir gleich hinzufügen
werden</span></p>
<p>Beachte, dass wir auch den Inhalt des alten Tests bearbeitet haben. Wir haben
eine neue Zeile mit dem Text <code>"PRODUKTION."</code> in Großbuchstaben hinzugefügt,
die nicht mit dem Abfragetext <code>"dukt"</code> übereinstimmen sollte, wenn wir bei der
Suche die Groß-/Kleinschreibung beachten. Wenn wir den alten Test auf diese
Weise ändern, stellen wir sicher, dass wir nicht versehentlich die bereits
implementierte Suchfunktionalität unter Berücksichtigung der
Groß-/Kleinschreibung kaputt machen. Dieser Test sollte jetzt erfolgreich sein
und er sollte es auch bleiben, während wir an der Suche unabhängig von der
Groß-/Kleinschreibung arbeiten.</p>
<p>Der neue Test <code>case_insensitive</code> verwendet <code>"rUsT"</code> als Suchabfrage. In der
Funktion <code>search_case_insensitive</code>, die wir gerade hinzufügen wollen, sollte
der Abfragetext <code>"rUsT"</code> zur Zeile, die <code>"Rust:"</code> mit einem großen R enthält,
passen und zur Zeile <code>"Trust me."</code>, obwohl beide eine andere Schreibweise haben
als der Abfragetext. Dies ist unser fehlschlagender Test und er wird sich nicht
kompilieren lassen, weil wir die Funktion <code>search_case_insensitive</code> noch nicht
definiert haben. Es steht dir frei, eine Skelett-Implementierung hinzuzufügen,
die immer einen leeren Vektor zurückgibt, ähnlich wie wir es für die Funktion
<code>search</code> in Codeblock 12-16 getan haben, um zu sehen, wie der Test kompilieren
wird und fehlschlägt.</p>
<h3 id="implementieren-der-funktion-search_case_insensitive"><a class="header" href="#implementieren-der-funktion-search_case_insensitive">Implementieren der Funktion <code>search_case_insensitive</code></a></h3>
<p>Die Funktion <code>search_case_insensitive</code>, die in Codeblock 12-21 gezeigt wird,
wird fast die gleiche sein wie die Funktion <code>search</code>. Der einzige Unterschied
besteht darin, dass wir <code>query</code> und <code>line</code> in Kleinbuchstaben umwandeln, sodass
sie unabhängig von der Groß-/Kleinschreibung der Eingabe-Argumente sind, wenn
wir prüfen, ob die Zeile die Abfrage enthält.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 12-21: Definieren der Funktion
<code>search_case_insensitive</code>, um den Abfragetext und die Zeile vor dem Vergleich
in Kleinbuchstaben umzuwandeln</span></p>
<p>Zuerst wandeln wir die Zeichenkette <code>query</code> in Kleinbuchstaben um und speichern
ihn in einer neuen Variablen mit dem gleichen Namen, die die ursprüngliche
Variable <code>query</code> verschattetet. Der Aufruf von <code>to_lowercase</code> beim Abfragetext
ist notwendig, sodass wir unabhängig davon, ob die Abfrage des Benutzers
<code>"rust"</code>, <code>"RUST"</code>, <code>"RUST"</code> oder <code>"rUsT"</code> ist, die Abfrage so behandeln, als
ob sie <code>"rust"</code> wäre, und die Groß-/Kleinschreibung nicht beachten. Obwohl
<code>to_lowercase</code> mit einfachem Unicode umgehen kann, wird es nicht 100% genau
sein. Wenn wir eine echte Anwendung schreiben würden, würden wir hier etwas
mehr Arbeit spendieren wollen, aber in diesem Abschnitt geht es um
Umgebungsvariablen, nicht um Unicode, also belassen wir es hier dabei.</p>
<p>Beachte, dass <code>query</code> jetzt ein <code>String</code> und nicht mehr ein
Zeichenkettenanteilstyp ist, weil der Aufruf von <code>to_lowercase</code> neue Daten
erzeugt, anstatt auf bestehende Daten zu referenzieren. Nehmen wir als Beispiel
an, der Abfragetext sei <code>"rUsT"</code>, dieser Zeichenkettenanteilstyp enthält kein
kleingeschriebenes <code>u</code> oder <code>t</code>, das wir verwenden könnten, also müssen wir
einen neuen <code>String</code> zuweisen, der <code>"rust"</code> enthält. Wenn wir nun <code>query</code> als
Argument an die Methode <code>contains</code> übergeben, müssen wir ein <code>&amp;</code>-Zeichen
angeben, weil die Signatur von <code>contains</code> so definiert ist, dass sie einen
Zeichenkettenanteilstyp nimmt.</p>
<p>Als nächstes fügen wir einen Aufruf von <code>to_lowercase</code> für jede <code>line</code> ein,
um alle Zeichen kleinzuschreiben. Da wir nun <code>line</code> und <code>query</code> in
Kleinbuchstaben umgewandelt haben, werden wir passende Zeilen finden, egal wie
die Groß-/Kleinschreibung der Abfrage ist.</p>
<p>Warten wir ab, ob diese Implementierung die Tests besteht:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Großartig! Sie haben bestanden. Lass uns nun die neue Funktion
<code>search_case_insensitive</code> von der Funktion <code>run</code> aufrufen. Zuerst fügen wir
eine Konfigurationsoption zur <code>Config</code>-Struktur hinzu, um zwischen der Suche
mit und ohne Berücksichtigung der Groß- und Kleinschreibung umzuschalten. Das
Hinzufügen dieses Feldes führt zu Kompilierfehlern, da wir dieses Feld noch
nirgendwo initialisiert haben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Wir haben das Feld <code>ignore_case</code> hinzugefügt, das ein Boolean enthält. Als
Nächstes benötigen wir die Funktion <code>run</code>, um den Wert des Feldes <code>ignore_case</code>
auszuwerten, und verwenden diese, um zu entscheiden, ob die Funktion <code>search</code>
oder die Funktion <code>search_case_insensitive</code> aufgerufen werden soll, wie in
Codeblock 12-22 gezeigt. Dies kompiliert noch immer nicht.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 12-22: Aufruf von entweder <code>search</code> oder
<code>search_case_insensitive</code> basierend auf dem Wert in <code>config.ignore_case</code></span></p>
<p>Schließlich müssen wir nach der Umgebungsvariablen suchen. Die Funktionen zum
Arbeiten mit Umgebungsvariablen befinden sich im Modul <code>env</code> in der
Standardbibliothek, daher bringen wir dieses Modul am Anfang von <em>src/lib.rs</em>
in den Gültigkeitsbereich. Dann werden wir die Funktion <code>var</code> aus dem Modul
<code>env</code> verwenden, um zu prüfen ob eine Umgebungsvariable namens <code>IGNORE_CASE</code>
einen Wert hat, wie in Codeblock 12-23 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::env;
// --abschneiden--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("Nicht genügend Argumente");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 12-23: Prüfen, ob eine Umgebungsvariable namens
<code>IGNORE_CASE</code> einen Wert hat</span></p>
<p>Hier erstellen wir eine neue Variable <code>ignore_case</code>. Um ihren Wert zu setzen,
rufen wir die Funktion <code>env::var</code> auf und übergeben ihr den Namen der
Umgebungsvariablen <code>IGNORE_CASE</code>. Die Funktion <code>env::var</code> gibt ein <code>Result</code>
zurück, das die erfolgreiche <code>Ok</code>-Variante ist, die den Wert der
Umgebungsvariablen enthält, wenn die Umgebungsvariable einen Wert hat. Sie gibt
die Variante <code>Err</code> zurück, wenn die Umgebungsvariable nicht gesetzt ist.</p>
<p>Wir benutzen die Methode <code>is_ok</code> auf <code>Result</code>, um zu prüfen, ob die
Umgebungsvariable gesetzt ist, was bedeutet, dass das Programm die Suche
ohne Berücksichtigung der Groß-/Kleinschreibung durchführen soll. Wenn
die Umgebungsvariable <code>IGNORE_CASE</code> keinen Wert hat, gibt <code>is_ok</code> den Wert
<code>false</code> zurück und das Programm führt eine Suche mit Berücksichtigung der
Groß-/Kleinschreibung durch. Wir kümmern uns nicht um den <em>Wert</em> der
Umgebungsvariablen, nur darum, ob sie gesetzt ist oder nicht, also prüfen wir
mit <code>is_ok</code>, anstatt mit <code>unwrap</code>, <code>expect</code> oder einer der anderen Methoden,
die wir bei <code>Result</code> gesehen haben.</p>
<p>Wir übergeben den Wert in der Variablen <code>ignore_case</code> an die
<code>Config</code>-Instanz, sodass die Funktion <code>run</code> diesen Wert lesen und entscheiden
kann, ob sie <code>search_case_insensitive</code> oder <code>search</code> aufrufen soll, wie wir es
in Codeblock 12-22 implementiert haben.</p>
<p>Lass es uns versuchen! Zuerst führen wir unser Programm ohne die gesetzte
Umgebungsvariable und mit dem Abfragetext <code>to</code> aus, die zu den Zeilen passen
sollte, die das Wort <em>to</em> in Kleinbuchstaben enthalten:</p>
<pre><code class="language-console">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Sieht so aus, als ob das immer noch funktioniert! Lass uns nun das Programm mit
<code>IGNORE_CASE</code> auf <code>1</code> gesetzt ausführen, aber mit dem gleichen Abfragetext
<em>to</em>.</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>Wenn du die PowerShell verwendest, sind das Setzen der Umgebungsvariable und
das Ausführen des Programms separate Befehle:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run to poem.txt
</code></pre>
<p>Dadurch bleibt <code>IGNORE_CASE</code> für den Rest deiner Shell-Sitzung bestehen. Sie
kann mit <code>Remove-Item</code> zurückgesetzt werden:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>Wir sollten Zeilen erhalten, die <em>to</em> enthalten, die Großbuchstaben haben
könnten:</p>
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Ausgezeichnet, wir haben auch Zeilen mit <em>To</em>! Unser <code>minigrep</code>-Programm kann
jetzt ohne Berücksichtigung von Groß-/Kleinschreibung suchen, gesteuert durch
eine Umgebungsvariable. Jetzt weißt du, wie man Optionen verwaltet, die
entweder mit Kommandozeilenargumenten oder Umgebungsvariablen gesetzt werden.</p>
<p>Einige Programme erlauben Argumente <em>und</em> Umgebungsvariablen für die gleiche
Konfiguration. In diesen Fällen entscheiden die Programme, dass das eine oder
das andere Vorrang hat. Versuche für eine weitere eigene Übung, die Steuerung,
ob die Groß-/Kleinschreibung berücksichtigt werden soll, entweder über ein
Kommandozeilenargument oder eine Umgebungsvariable zu ermöglichen. Entscheide,
ob das Kommandozeilenargument oder die Umgebungsvariable Vorrang haben soll,
wenn das Programm mit widersprüchlichen Optionen ausgeführt wird.</p>
<p>Das Modul <code>std::env</code> enthält viele weitere nützliche Funktionalitäten für den
Umgang mit Umgebungsvariablen: Schaue in seine Dokumentation, um zu sehen, was
verfügbar ist.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fehlermeldungen-in-die-standardfehlerausgabe-anstatt-der-standardausgabe-schreiben"><a class="header" href="#fehlermeldungen-in-die-standardfehlerausgabe-anstatt-der-standardausgabe-schreiben">Fehlermeldungen in die Standardfehlerausgabe anstatt der Standardausgabe schreiben</a></h2>
<p>Im Moment schreiben wir unsere gesamte Ausgabe mit dem Makro <code>println!</code> auf das
Terminal. In den meisten Terminals gibt es zwei Arten von Ausgaben:
Die <em>Standardausgabe</em> (<code>stdout</code>) für allgemeine Informationen und die
<em>Standardfehlerausgabe</em> (<code>stderr</code>) für Fehlermeldungen. Diese Unterscheidung
ermöglicht es dem Benutzer, die erfolgreiche Ausgabe eines Programms in eine
Datei zu leiten, aber dennoch Fehlermeldungen auf dem Bildschirm auszugeben.</p>
<p>Das Makro <code>println!</code> ist nur in der Lage, auf die Standardausgabe zu schreiben,
also müssen wir etwas anderes verwenden, um auf die Standardfehlerausgabe zu
schreiben.</p>
<h3 id="prüfen-wo-fehler-ausgegeben-werden"><a class="header" href="#prüfen-wo-fehler-ausgegeben-werden">Prüfen, wo Fehler ausgegeben werden</a></h3>
<p>Lass uns zunächst beobachten, wie der von <code>minigrep</code> ausgegebene Inhalt derzeit
in die Standardausgabe geschrieben wird, einschließlich aller Fehlermeldungen,
die wir stattdessen in die Standardfehlerausgabe schreiben wollen. Wir tun
dies, indem wir die Standardausgabe in eine Datei umleiten und dabei
absichtlich einen Fehler verursachen. Wir werden die Standardfehlerausgabe
nicht umleiten, sodass alle Inhalte, die an die Standardfehlerausgabe gesendet
werden, weiterhin auf dem Bildschirm angezeigt werden.</p>
<p>Von Kommandozeilenprogrammen wird erwartet, dass sie Fehlermeldungen an die
Standardfehlerausgabe senden, sodass wir Fehlermeldungen auch dann noch auf dem
Bildschirm sehen können, wenn wir die Standardausgabe in eine Datei umleiten.
Unser Programm ist zur Zeit nicht sehr brav: Wir werden gleich sehen, dass es
die ausgegebenen Fehlermeldungen stattdessen in eine Datei speichert!</p>
<p>Der Weg, dieses Verhalten zu demonstrieren, besteht darin, das Programm mit <code>&gt;</code>
und dem Dateipfad <em>output.txt</em> laufen zu lassen, zu dem wir die
Standardausgabe umleiten wollen. Wir werden keine Argumente übergeben, was
einen Fehler verursachen sollte:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p>Die Syntax <code>&gt;</code> weist die Shell an, den Inhalt der Standardausgabe anstelle des
Bildschirms in <em>output.txt</em> zu schreiben. Wir haben die erwartete Fehlermeldung
nicht gesehen, die auf den Bildschirm ausgegeben werden sollte, also muss sie
in der Datei gelandet sein. Dies ist der Inhalt von <em>output.txt</em>:</p>
<pre><code class="language-text">Fehler beim Parsen der Argumente: Nicht genügend Argumente
</code></pre>
<p>Ja, unsere Fehlermeldung wird in die Standardausgabe geschrieben. Es ist viel
nützlicher, wenn Fehlermeldungen wie diese auf der Standardfehlerausgabe
ausgegeben werden, sodass nur Daten aus einem erfolgreichen Lauf in der Datei
landen. Das werden wir ändern.</p>
<h3 id="fehler-auf-der-standardfehlerausgabe-ausgeben"><a class="header" href="#fehler-auf-der-standardfehlerausgabe-ausgeben">Fehler auf der Standardfehlerausgabe ausgeben</a></h3>
<p>Wir werden den Code in Codeblock 12-24 verwenden, um zu ändern, wie
Fehlermeldungen ausgegeben werden. Aufgrund der Refaktorierung, die wir früher
in diesem Kapitel vorgenommen haben, befindet sich der gesamte Code, der
Fehlermeldungen ausgibt, in einer einzigen Funktion, nämlich der Funktion
<code>main</code>. Die Standardbibliothek stellt das Makro <code>eprintln!</code> zur Verfügung, das
in die Standardfehlerausgabe schreibt. Lass uns also die beiden Stellen, an
denen wir <code>println!</code> aufgerufen haben, um Fehler auszugeben, ändern und
stattdessen <code>eprintln!</code> verwenden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("Fehler beim Parsen der Argumente: {err}");
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Anwendungsfehler: {e}");
        process::exit(1);
    }
}</code></pre>
<p><span class="caption">Codeblock 12-24: Schreiben von Fehlermeldungen auf die
Standardfehlerausgabe anstelle der Standardausgabe durch Verwenden von
<code>eprintln!</code></span></p>
<p>Lassen wir das Programm nun auf die gleiche Art und Weise erneut laufen, ohne
Argumente und mit Umleitung der Standardausgabe mit <code>&gt;</code>:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Fehler beim Parsen der Argumente: Nicht genügend Argumente
</code></pre>
<p>Jetzt sehen wir den Fehler auf dem Bildschirm und <em>output.txt</em> enthält nichts,
was dem Verhalten entspricht, das wir von Kommandozeilenprogrammen erwarten.</p>
<p>Lassen wir das Programm erneut mit Argumenten laufen, die keinen Fehler
verursachen, aber dennoch die Standardausgabe in eine Datei umleiten, etwa so:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>Wir werden keine Ausgabe auf dem Terminal sehen und <em>output.txt</em> wird unsere
Ergebnisse enthalten:</p>
<p><span class="filename">Dateiname: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Dies zeigt, dass wir jetzt die Standardausgabe für die erfolgreiche Ausgabe und
gegebenenfalls die Standardfehlerausgabe für die Fehlerausgabe verwenden.</p>
<h2 id="zusammenfassung-11"><a class="header" href="#zusammenfassung-11">Zusammenfassung</a></h2>
<p>Dieses Kapitel rekapituliert einige der wichtigsten Konzepte, die du bisher
gelernt hast, und behandelt das Durchführen gängiger E/A-Operationen in Rust.
Durch das Verwenden von Kommandozeilenargumenten, Dateien, Umgebungsvariablen
und des Makros <code>eprintln!</code> für die Fehlerausgabe bist du jetzt bereit,
Kommandozeilenanwendungen zu schreiben. Wenn du die Konzepte mit denen in den
vorhergehenden Kapiteln kombinierst, wird dein Code gut organisiert sein, Daten
effektiv in den entsprechenden Datenstrukturen speichern, Fehler gut behandeln
und gut getestet sein.</p>
<p>Als Nächstes werden wir einige Rust-Funktionalitäten untersuchen, die von
funktionalen Sprachen beeinflusst wurden: Funktionsabschlüsse (closures) und
Iteratoren.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funktionale-sprachelemente-iteratoren-und-funktionsabschlüsse-closures"><a class="header" href="#funktionale-sprachelemente-iteratoren-und-funktionsabschlüsse-closures">Funktionale Sprachelemente: Iteratoren und Funktionsabschlüsse (closures)</a></h1>
<p>Das Design von Rust wurde von einer Vielzahl von vorhandenen Programmiersprachen
und Techniken beeinflusst und einen signifikanter Einfluss hat die <em>funktionale
Programmierung</em>. Programmieren im funktionalen Stil beinhaltet oft das
Verwenden von Funktionen als Werte, die in Argumenten übergeben, von anderen
Funktionen zurückgegeben, Variablen zur späteren Ausführung zugewiesen werden
und so weiter.</p>
<p>In diesem Kapitels soll nicht erörtert werden, was funktionale
Programmierung ist oder nicht, stattdessen werden wir einige Funktionalitäten von
Rust besprechen, die denen vieler anderer Sprachen ähneln und häufig als
funktional bezeichnet werden.</p>
<p>Im Einzelnen wird Folgendes behandelt:</p>
<ul>
<li><em>Funktionsabschlüsse</em>, ein Konstrukt, das einer Funktion ähnelt und in einer
Variable gespeichert werden kann.</li>
<li><em>Iteratoren</em>, ein Mechanismus, eine Reihe von Elementen abzuarbeiten.</li>
<li>Wie wir Funktionsabschlüsse und Iteratoren einsetzen, um unser E/A-Projekt
aus Kapitel 12 zu verbessern</li>
<li>Die Performanz von Funktionsabschlüssen und Iteratoren (Spoiler-Alarm: Sie
sind schneller, als du vielleicht denken magst!)</li>
</ul>
<p>Wir haben uns bereits andere Rust-Funktionalitäten wie Aufzählungen (enums) und
Musterabgleich (pattern matching) angesehen, die ebenfalls vom funktionalen
Stil beeinflusst sind. Da das Beherrschen von Funktionsabschlüssen und
Iteratoren ein wichtiger Bestandteil für das Schreiben von idiomatischem,
schnellem Rust-Programmcode ist, wird ihnen das gesamte Kapitel gewidmet.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="funktionsabschlüsse-closures-anonyme-funktionen-die-ihre-umgebung-erfassen"><a class="header" href="#funktionsabschlüsse-closures-anonyme-funktionen-die-ihre-umgebung-erfassen">Funktionsabschlüsse (closures): Anonyme Funktionen, die ihre Umgebung erfassen</a></h2>
<p>Rusts Funktionsabschlüsse sind anonyme Funktionen, die du in einer Variable
speichern oder anderen Funktionen als Argument übergeben kannst. Du kannst einen
Funktionsabschluss erstellen und dann in einem anderen Zusammenhang aufrufen
und auswerten. Im Gegensatz zu Funktionen können Funktionsabschlüsse auf Werte
(values) im Gültigkeitsbereich (scope) zugreifen, in dem sie erstellt wurden.
Wir werden im Folgenden zeigen, wie die Funktionalität von Funktionsabschlüssen
die Wiederverwendung von Code erlaubt und sein Verhalten anpassen kann.</p>
<h3 id="erfassen-der-umgebung-mit-funktionsabschlüssen"><a class="header" href="#erfassen-der-umgebung-mit-funktionsabschlüssen">Erfassen der Umgebung mit Funktionsabschlüssen</a></h3>
<p>Wir werden zunächst untersuchen, wie wir Funktionsabschlüsse verwenden können,
um Werte aus der Umgebung, in der sie definiert sind, zur späteren Verwendung
zu erfassen. Hier ist das Szenario: Von Zeit zu Zeit verschenkt unsere
T-Shirt-Firma ein exklusives T-Shirt in limitierter Auflage an jemanden aus
unserer Mailingliste als Werbeaktion. Die Personen auf der Mailingliste können
optional ihre Lieblingsfarbe zu ihrem Profil hinzufügen. Wenn die Person, die
das kostenlose Shirt erhalten soll, ihre Lieblingsfarbe in ihrem Profil
angegeben hat, erhält sie das Hemd in dieser Farbe. Wenn die Person keine
Lieblingsfarbe angegeben hat, erhält sie die Farbe, in der das Unternehmen
derzeit die meisten Exemplare hat.</p>
<p>Es gibt viele Möglichkeiten, dies zu implementieren. Für dieses Beispiel werden
wir eine Aufzählung namens <code>ShirtColor</code> verwenden, die die Varianten <code>Red</code> und
<code>Blue</code> hat (der Einfachheit halber wird die Anzahl der verfügbaren Farben
begrenzt). Das Inventar des Unternehmens wird durch eine Struktur <code>Inventory</code>
repräsentiert, die ein Feld mit dem Namen <code>shirts</code> hat, das ein
<code>Vec&lt;ShirtColor&gt;</code> mit den derzeit vorrätigen Hemden enthält. Die Methode
<code>giveaway</code>, die auf <code>Inventory</code> definiert ist, erhält die optionale
Shirtfarbe der Person, die das kostenlose Shirt erhält, und gibt die Shirtfarbe
zurück, die die Person erhalten wird. Dies wird in Codeblock 13-1 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!("Der Benutzer mit Präferenz {user_pref1:?} erhält {giveaway1:?}");

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!("Der Benutzer mit Präferenz {user_pref2:?} erhält {giveaway2:?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 13-1: Werbegeschenk der Shirtfirma</span></p>
<p>Der in <code>main</code> definierte <code>store</code> hat zwei blaue Shirts und ein rotes Shirt
übrig, die für diese limitierte Aktion verteilt werden sollen. Wir rufen die
Methode <code>giveaway</code> für einen Benutzer mit einer Präferenz für ein rotes Hemd
und einen Benutzer ohne jegliche Präferenz auf.</p>
<p>Auch dieser Code könnte auf viele Arten implementiert werden. Um uns auf
Funktionsabschlüsse zu konzentrieren, haben wir uns an die Konzepte gehalten,
die du bereits gelernt hast, mit Ausnahme des Methodenrumpfs von <code>giveaway</code>,
der einen Funktionsabschluss verwendet. In der Methode <code>giveaway</code> erhalten wir
die Benutzerpräferenz als einen Parameter vom Typ <code>Option&lt;ShirtColor&gt;</code> und
rufen die Methode <code>unwrap_or_else</code> auf <code>user_preference</code> auf. Die <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else">Methode
<code>unwrap_or_else</code> auf <code>Option&lt;T&gt;</code></a> ist in der Standardbibliothek
definiert. Sie nimmt ein Argument entgegen: Einen Funktionsabschluss ohne
Argument, der einen Wert <code>T</code> zurückgibt (denselben Typ, der in der Variante
<code>Some</code> von <code>Option&lt;T&gt;</code> gespeichert ist, in diesem Fall <code>ShirtColor</code>). Wenn
<code>Option&lt;T&gt;</code> die Variante <code>Some</code> ist, gibt <code>unwrap_or_else</code> den Wert aus <code>Some</code>
zurück. Wenn <code>Option&lt;T&gt;</code> die Variante <code>None</code> ist, ruft <code>unwrap_or_else</code> den
Funktionsabschluss auf und gibt den Wert zurück, der vom Funktionsabschluss
zurückgegeben wurde.</p>
<p>Wir geben den Funktionsabschluss-Ausdruck <code>|| self.most_stocked()</code> als Argument
bei <code>unwrap_or_else</code> an. Dies ist ein Funktionsabschluss, die selbst keine
Parameter hat (wenn der Funktionsabschluss Parameter hätte, würden sie zwischen
den beiden vertikalen Strichen erscheinen). Der Rumpf des Funktionsabschlusses
ruft <code>self.most_stocked()</code> auf. Wir definieren den Funktionsabschluss hier, und
die Implementierung von <code>unwrap_or_else</code> wird den Funktionsabschluss später
auswerten, wenn das Ergebnis benötigt wird.</p>
<p>Die Ausführung dieses Codes gibt aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
Der Benutzer mit Präferenz Some(Red) erhält Red
Der Benutzer mit Präferenz None erhält Blue
</code></pre>
<p>Ein interessanter Aspekt ist hier, dass wir einen Funktionsabschluss übergeben
haben, der <code>self.most_stocked()</code> für die aktuelle <code>Inventory</code>-Instanz aufruft.
Die Standardbibliothek musste nichts über die von uns definierten Typen
<code>Inventory</code> oder <code>ShirtColor</code> oder die Logik, die wir in diesem Szenario
verwenden wollen, wissen. Der Funktionsabschluss hat eine unveränderbare
Referenz auf die <code>self</code>-Instanz von <code>Inventory</code> erfasst und sie mit dem von uns
angegebenen Code an die Methode <code>unwrap_or_else</code> übergeben. Funktionen sind
andererseits nicht in der Lage, ihre Umgebung auf diese Weise zu erfassen.</p>
<h3 id="funktionsabschluss-typinferenz-und-annotation"><a class="header" href="#funktionsabschluss-typinferenz-und-annotation">Funktionsabschluss-Typinferenz und Annotation</a></h3>
<p>Es gibt weitere Unterschiede zwischen Funktionen und Funktionsabschlüssen. Bei
Funktionsabschlüssen ist es normalerweise nicht erforderlich, die Typen der
Parameter oder des Rückgabewertes zu annotieren, wie es bei <code>fn</code>-Funktionen der
Fall ist. Typ-Annotationen sind bei Funktionen erforderlich, weil die Typen
Teil einer expliziten Schnittstelle sind, die für deine Benutzer sichtbar ist.
Die strikte Definition dieser Schnittstelle ist wichtig, um sicherzustellen,
dass alle Beteiligten sich darüber einig sind, welche Arten von Werten eine
Funktion verwendet und zurückgibt. Funktionsabschlüsse werden hingegen nicht in
einer offengelegten Schnittstelle wie dieser verwendet: Sie werden in Variablen
gespeichert und verwendet, ohne sie zu benennen und den Benutzern unserer
Bibliothek offenzulegen.</p>
<p>Funktionsabschlüsse sind in der Regel kurz und nur in einem engen Kontext und
nicht in jedem beliebigen Szenario relevant. Innerhalb dieser begrenzten
Kontexte kann der Compiler die Typen der Parameter und des Rückgabetyps
ableiten, ähnlich wie er die Typen der meisten Variablen ableiten kann (es gibt
seltene Fälle, in denen der Compiler auch Funktionsabschluss-Typannotationen
benötigt).</p>
<p>Wie bei Variablen können wir Typ-Annotationen hinzufügen, wenn wir die
Explizitheit und Klarheit erhöhen wollen, auch wenn wir dafür ausführlicher
sind als unbedingt nötig. Die Annotation der Typen für einen Funktionsabschluss
würde wie die in Codeblock 13-2 gezeigte Definition aussehen. In diesem
Beispiel definieren wir einen Funktionsabschluss und speichern ihn in einer
Variablen, anstatt den Funktionsabschluss an der Stelle zu definieren, an der
wir ihn als Argument übergeben, wie wir es in Codeblock 13-1 getan haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!("rechnet langsam...");
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("Mach heute {} Liegestütze!", expensive_closure(intensity));
</span><span class="boring">        println!("Als nächstes {} Sit-ups!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Mach heute eine Pause! Denk daran, ausreichend zu trinken!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "Heute, {} Minuten Lauftraining!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-2: Hinzufügen optionaler Datentypangabe der
Parameter- und Rückgabewert-Typen im Funktionsabschluss</span></p>
<p>Mit Typ-Annotationen ähnelt die Syntax eines Funktionsabschlusses sehr der
Syntax einer Funktion. Hier definieren wir eine Funktion, die zu ihrem
Parameter den Wert 1 addiert, und zum Vergleich einen Funktionsabschluss mit
identischem Verhalten. Zur besseren Darstellung der relevanten Teile haben wir
einige Leerzeichen eingefügt. Dies zeigt, wie ähnlich die Syntax von Funktionen
der von Funktionsabschlüssen ist, abgesehen von den senkrechten Strichen und
der Möglichkeit, einen Teil der Syntax wegzulassen:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>Die erste Zeile zeigt eine Funktionsdefinition und die zweite eine Definition
eines Funktionsabschlusses mit allen Datentypangaben. In der dritten Zeile
werden die Datentypangaben aus der Funktionsabschluss-Definition entfernt,
und in der vierten Zeile werden die geschweiften Klammern weggelassen, die
optional sind, da der Funktionsabschluss-Rumpf nur einen Ausdruck beinhaltet.
All diese Ausdrücke sind gültig und verhalten sich beim Aufruf gleich. Von
<code>add_one_v3</code> und <code>add_one_v4</code> wird ein Aufruf zum Kompilieren des Codes
benötigt, da hier die Typen abhängig von der Verwendung abgeleitet werden. Dies
ist vergleichbar mit <code>let v = Vec::new();</code>, bei dem entweder Typ-Annotationen
oder Werte eines bestimmten Typs in den <code>Vec</code> eingefügt werden müssen, damit
Rust den Typ ableiten kann.</p>
<p>Bei Funktionsabschlussdefinitionen wird für jeden Parameter und für den
Rückgabewert ein konkreter Typ abgeleitet. Codeblock 13-3 zeigt zum Beispiel
die Definition eines kurzen Funktionsabschlusses, der nur den Wert des
übergebenen Parameters zurückgibt. Dieser Funktionsabschluss ist außer für
dieses Beispiel nicht weiter nützlich. Beachte, dass wir der Definition keine
Datentypangaben hinzugefügt haben. Da es keine Typ-Annotationen gibt, können
wir den Funktionsabschluss mit einem beliebigen Typ aufrufen, was wir hier mit
<code>String</code> das erste Mal getan haben. Wenn wir dann versuchen, <code>example_closure</code>
mit einer Ganzzahl aufzurufen, erhalten wir einen Fehler.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let example_closure = |x| x;

let s = example_closure(String::from("hallo"));
let n = example_closure(5);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-3: Versuchter Aufruf eines
Funktionsabschlusses, dem zwei unterschiedliche Typen übergeben wurden</span></p>
<p>Der Compiler gibt diesen Fehler aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
</code></pre>
<p>Beim ersten Aufruf von <code>example_closure</code> wird dem Typ von <code>x</code> und dem
Rückgabewert des Funktionsabschlusses der Typ <code>String</code> zugewiesen. Diese Typen
sind dann für den Funktionsabschluss <code>example_closure</code> festgeschrieben. Daher
bekommen wir eine Fehlermeldung, wenn wir versuchen einen anderen Typ mit dem
gleichen Funktionsabschluss zu benutzen.</p>
<h3 id="erfassen-von-referenzen-oder-verschieben-der-eigentümerschaft"><a class="header" href="#erfassen-von-referenzen-oder-verschieben-der-eigentümerschaft">Erfassen von Referenzen oder Verschieben der Eigentümerschaft</a></h3>
<p>Funktionsabschlüsse können Werte aus ihrer Umgebung auf drei Arten erfassen,
die direkt den drei Möglichkeiten entsprechen, wie eine Funktion einen
Parameter aufnehmen kann: Unveränderbare Ausleihen (borrowing immutably),
veränderbare Ausleihen (borrowing mutably) und Eigentümerschaft übernehmen
(taking ownership). Der Funktionsabschluss entscheidet, welche dieser
Möglichkeiten verwendet wird, je nachdem, was der Rumpf der Funktion mit den
erfassten Werten macht.</p>
<p>In Codeblock 13-4 definieren wir einen Funktionsabschluss, der eine
unveränderbare Referenz an den Vektor mit dem Namen <code>list</code> erfasst, weil er
nur eine unveränderbare Referenz benötigt, um den Wert auszugeben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let list = vec![1, 2, 3];
    println!("Vor der Funktionsabschlussdefinition: {list:?}");

    let only_borrows = || println!("Im Funktionsabschluss: {list:?}");

    println!("Vor dem Funktionsabschluss-Aufruf: {list:?}");
    only_borrows();
    println!("Nach dem Funktionsabschluss-Aufruf: {list:?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 13-4: Definieren und Aufrufen eines
Funktionsabschlusses, der eine unveränderbare Referenz erfasst</span></p>
<p>Dieses Beispiel veranschaulicht auch, dass eine Variable an eine
Funktionsabschlussdefinition gebunden werden kann, und wir den
Funktionsabschluss später aufrufen können, indem wir den Variablennamen und die
Klammern verwenden, als ob der Variablenname ein Funktionsname wäre.</p>
<p>Da wir mehrere unveränderbare Referenzen auf <code>list</code> zur gleichen Zeit haben
können, ist <code>list</code> immer noch vom Code vor der Funktionsabschlussdefinition
zugreifbar, sowie nach der Funktionsabschlussdefinition und vor dem Aufruf des
Funktionsabschlusses, und nach dem Aufruf des Funktionsabschlusses. Dieser Code
kompiliert, läuft und gibt folgendes aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Vor der Funktionsabschlussdefinition: [1, 2, 3]
Vor dem Funktionsabschluss-Aufruf: [1, 2, 3]
Im Funktionsabschluss: [1, 2, 3]
Nach dem Funktionsabschluss-Aufruf: [1, 2, 3]
</code></pre>
<p>In Codeblock 13-5 wird die Definition des Funktionsabschlusses so geändert,
dass er ein Element zum Vektor <code>list</code> hinzufügt. Der Funktionsabschluss erfasst
nun eine veränderbare Referenz:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut list = vec![1, 2, 3];
    println!("Vor der Funktionsabschlussdefinition: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("Nach dem Funktionsabschluss-Aufruf: {list:?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 13-5: Definieren und Aufrufen eines
Funktionsabschlusses, der eine veränderbare Referenz erfasst</span></p>
<p>Dieser Code kompiliert, läuft und gibt aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Vor der Funktionsabschlussdefinition: [1, 2, 3]
Nach dem Funktionsabschluss-Aufruf: [1, 2, 3, 7]
</code></pre>
<p>Beachte, dass es kein <code>println!</code> mehr zwischen der Definition und dem Aufruf
des Funktionsabschlusses <code>borrows_mutably</code> gibt: Wenn <code>borrows_mutably</code>
definiert ist, erfasst es eine veränderbare Referenz auf <code>list</code>. Der
Funktionsabschluss wird nicht mehr verwendet, nachdem er aufgerufen wurde,
daher endet die veränderbare Ausleihe. Zwischen der
Funktionsabschlussdefinition und dem Funktionsabschluss-Aufruf ist eine
unveränderbare Ausleihe für die Ausgabe nicht erlaubt, weil keine anderen
Ausleihen erlaubt sind, wenn es eine veränderbare Ausleihe gibt. Versuche,
dort ein <code>println!</code> hinzuzufügen, um zu sehen, welche Fehlermeldung du
erhältst!</p>
<p>Wenn du den Funktionsabschluss zwingen willst, die Eigentümerschaft der Werte,
die er in der Umgebung verwendet, zu übernehmen, obwohl der Rumpf des
Funktionsabschlusses nicht unbedingt Eigentümer sein muss, kannst du das
Schlüsselwort <code>move</code> vor der Parameterliste verwenden.</p>
<p>Diese Technik ist vor
allem nützlich, wenn ein Funktionsabschluss an einen neuen Strang (thread)
übergeben wird, um die Daten zu verschieben, sodass sie dem neuen Strang
gehören. Wir werden in Kapitel 16, wenn wir über Nebenläufigkeit (concurrency)
sprechen, detailliert auf Stränge eingehen und erläutern, warum man sie
verwenden sollte, aber jetzt wollen wir uns kurz mit dem Erzeugen eines neuen
Strangs mithilfe eines Funktionsabschlusses befassen, der das Schlüsselwort
<code>move</code> benötigt. Codeblock 13-6 zeigt Codeblock 13-4 modifiziert, um den Vektor
in einem neuen Strang statt im Hauptstrang auszugeben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Vor der Funktionsabschlussdefinition: {list:?}");

    thread::spawn(move || println!("Im Strang: {list:?}"))
        .join()
        .unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 13-6: Verwenden von <code>move</code>, um den
Funktionsabschluss des Strangs zu erzwingen, die Eigentümerschaft an <code>list</code> zu
übernehmen</span></p>
<p>Wir starten einen neuen Strang und geben ihm einen Funktionsabschluss als
Argument mit. Der Rumps des Funktionsabschlusses gibt die Liste aus. In
Codeblock 13-4 hat der Funktionsabschluss nur <code>list</code> mit einer unveränderbaren
Referenz erfasst, weil das die kleinste Zugriffmenge auf <code>list</code> ist, die
benötigt wird, um sie auszugeben. In diesem Beispiel müssen wir, obwohl der
Funktionsabschluss-Rumpf nur eine unveränderbare Referenz benötigt, angeben,
dass <code>list</code> in den Funktionsabschluss verschoben werden soll, indem wir das
Schlüsselwort <code>move</code> an den Anfang der Funktionsabschlussdefinition setzen.
Der neue Strang könnte beendet werden, bevor der Rest des Hauptstrangs beendet
wird, oder der Hauptstrang könnte zuerst beendet werden. Wenn der Hauptstrang
die Eigentümerschaft von <code>list</code> beibehält, aber vor dem neuen Strang endet und
<code>list</code> aufräumt, wäre die unveränderbare Referenz im Strang ungültig. Daher
verlangt der Compiler, dass <code>list</code> in den Funktionsabschluss im neuen Strang
verschoben wird, damit die Referenz gültig bleibt. Versuche, das Schlüsselwort
<code>move</code> zu entfernen oder <code>list</code> im Hauptstrang zu verwenden, nachdem der
Funktionsabschluss definiert wurde, um zu sehen, welche Compilerfehler du
erhältst!</p>
<h3 id="verschieben-erfasster-werte-aus-funktionsabschlüssen-und-fn-merkmalen"><a class="header" href="#verschieben-erfasster-werte-aus-funktionsabschlüssen-und-fn-merkmalen">Verschieben erfasster Werte aus Funktionsabschlüssen und <code>Fn</code>-Merkmalen</a></h3>
<p>Sobald ein Funktionsabschluss eine Referenz oder die Eigentümerschaft eines
Werts aus der Umgebung, in der der Funktionsabschluss definiert ist, erfasst
hat (und damit beeinflusst, was <em>in</em> den Funktionsabschluss verschoben wird),
definiert der Code im Rumpf des Funktionsabschlusses, was mit den Referenzen
oder Werten passiert, wenn der Funktionsabschluss später ausgewertet wird (und
damit beeinflusst, was <em>aus</em> dem Funktionsabschluss verschoben wird). Ein
Funktionsabschluss-Rumpf kann eine der folgenden Aktionen ausführen: Einen
erfassten Wert aus dem Funktionsabschluss herausbewegen, den erfassten Wert
verändern, den Wert weder bewegen noch verändern oder zunächst nichts aus der
Umgebung erfassen.</p>
<p>Die Art und Weise, wie ein Funktionsabschluss Werte aus der Umgebung erfasst
und verarbeitet, wirkt sich darauf aus, welche Merkmale (traits) der
Funktionsabschluss implementiert, und mit Hilfe von Merkmalen können Funktionen
und Strukturen angeben, welche Arten von Funktionsabschlüssen sie verwenden
können. Funktionsabschlüsse implementieren automatisch eine, zwei oder alle
drei dieser <code>Fn</code>-Merkmale, und zwar in additiver Weise, je nachdem, wie der
Rumpf des Funktionsabschlusses die Werte behandelt:</p>
<ol>
<li><code>FnOnce</code> gilt für Funktionsabschlüsse, die einmal aufgerufen
werden können. Alle Funktionsabschlüsse implementieren zumindest dieses
Merkmal, weil alle Funktionsabschlüsse aufgerufen werden können. Ein
Funktionsabschluss, der erfasste Werte aus seinem Rumpf herausverschiebt,
implementiert nur <code>FnOnce</code> und keine der anderen <code>Fn</code>-Merkmale, weil er nur
einmal aufgerufen werden kann.</li>
<li><code>FnMut</code> gilt für Funktionsabschlüsse, die die erfassten Werte nicht aus
ihrem Rumpf herausverschieben, aber die erfassten Werte möglicherweise
verändern. Diese Funktionsabschlüsse können mehr als einmal aufgerufen
werden.</li>
<li><code>Fn</code> gilt für Funktionsabschlüsse, die die erfassten Werte nicht aus ihrem
Rumpf herausverschieben und die erfassten Werte nicht verändern, sowie
Funktionsabschlüsse, die nichts aus ihrer Umgebung erfassen. Diese
Funktionsabschlüsse können mehr als einmal aufgerufen werden, ohne ihre
Umgebung zu verändern, was wichtig ist, wenn z.B. ein Funktionsabschluss
mehrere Male gleichzeitig aufgerufen wird.</li>
</ol>
<p>Schauen wir uns die Definition der Methode <code>unwrap_or_else</code> auf <code>Option&lt;T&gt;</code> an,
die wir in Codeblock 13-1 verwendet haben:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Erinnere dich, dass <code>T</code> der generische Typ ist, der den Typ des Wertes in der
<code>Some</code>-Variante einer <code>Option</code> darstellt. Dieser Typ <code>T</code> ist auch der
Rückgabetyp der Funktion <code>unwrap_or_else</code>: Code, der <code>unwrap_or_else</code> auf einer
<code>Option&lt;String&gt;</code> aufruft, erhält zum Beispiel einen <code>String</code>.</p>
<p>Als Nächstes ist zu beachten, dass die Funktion <code>unwrap_or_else</code> den
zusätzlichen generischen Typ-Parameter <code>F</code> hat. Der Typ <code>F</code> ist der Typ des
Parameters namens <code>f</code>, der der Funktionsabschluss ist, den wir beim Aufruf von
<code>unwrap_or_else</code> bereitstellen.</p>
<p>Die für den generischen Typ <code>F</code> spezifizierte Merkmalsabgrenzung ist <code>FnOnce() -&gt; T</code>, was bedeutet, dass <code>F</code> mindestens einmal aufgerufen werden können muss,
keine Argumente annimmt und ein <code>T</code> zurückgeben muss. Die Verwendung von
<code>FnOnce</code> in der Merkmalsabgrenzung drückt die Einschränkung aus, dass
<code>unwrap_or_else</code> <code>f</code> höchstens ein Mal aufrufen wird. Im Rumpf von
<code>unwrap_or_else</code> können wir sehen, dass, wenn die <code>Option</code> <code>Some</code> ist, <code>f</code>
nicht aufgerufen wird. Wenn die <code>Option</code> <code>None</code> ist, wird <code>f</code> einmal
aufgerufen. Da alle Funktionsabschlüsse <code>FnOnce</code> implementieren, akzeptiert
<code>unwrap_or_else</code> alle drei Arten von Funktionsabschlüssen und ist so flexibel
wie nur möglich.</p>
<blockquote>
<p>Anmerkung: Wenn das, was wir tun wollen, keine Erfassung eines Wertes aus der
Umgebung erfordert, können wir den Namen einer Funktion anstelle eines
Funktionsabschlüsses verwenden. Zum Beispiel könnten wir
<code>unwrap_or_else(Vec::new)</code> auf einem <code>Option&lt;Vec&lt;T&gt;&gt;</code>-Wert aufrufen, um einen
neuen, leeren Vektor zu erhalten, wenn der Wert <code>None</code> ist. Der Compiler
implementiert automatisch die <code>Fn</code>-Merkmale, die für eine Funktionsdefinition
anwendbar sind.</p>
</blockquote>
<p>Schauen wir uns nun die Standard-Bibliotheksmethode <code>sort_by_key</code> an, die auf
Anteilstypen (slices) definiert ist, um zu sehen, wie sie sich von <code>unwrap_or_else</code>
unterscheidet und warum <code>sort_by_key</code> <code>FnMut</code> statt <code>FnOnce</code> für die
Mermalsabgrenzung verwendet. Der Funktionsabschluss erhält ein Argument, eine
Referenz auf das aktuelle Element im betrachteten Anteilstyp, und gibt einen
Wert vom Typ <code>K</code> zurück, der geordnet werden kann. Diese Funktion ist nützlich,
wenn man einen Anteilstyp nach einem bestimmten Attribut der einzelnen Elemente
sortieren will. In Codeblock 13-7 haben wir eine Liste von
<code>Rectangle</code>-Instanzen und benutzen <code>sort_by_key</code>, um sie nach ihrem
<code>width</code>-Attribut von niedrig nach hoch zu sortieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 13-7: Verwenden von <code>sort_by_key</code> um Rechtecke
nach ihrer Breite zu sortieren</span></p>
<p>Dieser Code gibt aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>Der Grund, warum <code>sort_by_key</code> so definiert ist, dass es einen
<code>FnMut</code>-Funktionsabschluss nimmt, ist, dass es den Funktionsabschluss mehrfach
aufruft: Einmal für jedes Element im Anteilstyp. Der Funktionsabschluss <code>|r| r.width</code> erfasst, verändert oder verschiebt nichts aus seiner Umgebung, sodass
er die Anforderungen der Merkmalsabgrenzung erfüllt.</p>
<p>Im Gegensatz dazu zeigt Codeblock 13-8 ein Beispiel für einen
Funktionsabschluss, der nur das Merkmal <code>FnOnce</code> implementiert, weil er einen
Wert aus der Umgebung verschiebt. Der Compiler lässt uns diesen
Funktionsabschluss nicht mit <code>sort_by_key</code> verwenden:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("Funktionsabschluss aufgerufen");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 13-8: Versuch, einen <code>FnOnce</code>-Funktionsabschluss
mit <code>sort_by_key</code> zu verwenden</span></p>
<p>Dies ist ein ausgeklügelter, verworrener Weg (der nicht funktioniert), der
versucht die Anzahl der Aufrufe des Funktionsabschlusses durch <code>sort_by_key</code>
beim Sortieren von <code>list</code> zu zählen. Dieser Code versucht diese Zählung
durchzuführen, indem er den <code>String</code> <code>value</code> aus der Umgebung des
Funktionsabschlusses in den Vektor <code>sort_operations</code> verschiebt. Der
Funktionsabschluss erfasst <code>value</code> und verschiebt dann <code>value</code> aus dem
Funktionsabschluss heraus, indem er die Eigentümerschaft von <code>value</code> an den
Vektor <code>sort_operations</code> überträgt. Dieser Funktionsabschluss kann einmal
aufgerufen werden; ein zweiter Aufruf würde nicht funktionieren, da <code>value</code>
nicht mehr in der Umgebung wäre, um erneut in <code>sort_operations</code> verschoben zu
werden! Daher implementiert dieser Funktionsabschluss nur <code>FnOnce</code>. Wenn wir
versuchen, diesen Code zu kompilieren, erhalten wir die Fehlermeldung, dass
<code>value</code> nicht aus dem Funktionsabschluss verschoben werden kann, weil der
Funktionsabschluss <code>FnMut</code> implementieren muss:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from("Funktionsabschluss aufgerufen");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
</code></pre>
<p>Der Fehler bezieht sich auf die Zeile im Funktionsabschluss-Rumpf, die <code>value</code>
aus der Umgebung verschiebt. Um dies zu beheben, müssen wir den Rumpf des
Funktionsabschlusses so ändern, dass er keine Werte aus der Umgebung
verschiebt. Es ist einfacher, einen Zähler in der Umgebung zu halten und seinen
Wert im Funktionsabschluss-Rumpf zu erhöhen, um zu zählen, wie oft
<code>sort_by_key</code> aufgerufen wurde. Der Funktionsabschluss in Codeblock 13-9
funktioniert mit <code>sort_by_key</code>, weil er nur eine veränderbare Referenz auf den
<code>num_sort_operations</code>-Zähler erfasst und daher mehr als einmal aufgerufen
werden kann:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sortiert in {num_sort_operations} Operationen");
}</code></pre></pre>
<p><span class="caption">Codeblock 13-9: Verwenden eines
<code>FnMut</code>-Funktionsabschlusses mit <code>sort_by_key</code> ist erlaubt</span></p>
<p>Die <code>Fn</code>-Merkmale sind wichtig bei der Definition oder Verwendung von
Funktionen oder Typen, die Funktionsabschlüsse verwenden. Im nächsten Abschnitt
besprechen wir Iteratoren. Viele Iterator-Methoden nehmen
Funktionsabschluss-Argumente entgegen, also behalte diese Details von
Funktionsabschlüssen im Kopf, wenn wir weitermachen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="eine-reihe-von-elementen-verarbeiten-mit-iteratoren"><a class="header" href="#eine-reihe-von-elementen-verarbeiten-mit-iteratoren">Eine Reihe von Elementen verarbeiten mit Iteratoren</a></h2>
<p>Iteratoren ermöglichen dir, nacheinander eine Aufgabe für eine Folge von
Elementen auszuführen. Der Iterator ist für die Logik verantwortlich, die
Elemente zu durchlaufen und zu bestimmen, wann eine Sequenz beendet ist.
Durch die Verwendung von Iteratoren ist es nicht notwendig, diese Logik selbst
neu zu implementieren.</p>
<p>Die Iteratoren in Rust sind <em>faul</em> (lazy), das bedeutet, dass sie erst durch
Methodenaufrufe konsumiert werden müssen, um einen Effekt zu haben. Der
Programmcode in Codeblock 13-10 erstellt beispielsweise einen Iterator über die
Elemente im Vektor <code>v1</code> indem die in <code>Vec&lt;T&gt;</code> definierte Methode <code>iter</code>
aufgerufen wird. Dieser Programmcode macht nichts Sinnvolles.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-10: Einen Iterator erstellen</span></p>
<p>Der Iterator wird in der Variable <code>v1_iter</code> gespeichert. Sobald wir einen
Iterator erstellt haben, können wir ihn auf verschiedene Weise verwenden.
In Codeblock 3-5 in Kapitel 3 haben wir über ein Array iteriert, indem wir eine
<code>for</code>-Schleife verwendet haben, um einen Code für jedes Element auszuführen.
Unter der Haube wird dabei implizit ein Iterator erzeugt und dann konsumiert,
aber wir haben bis jetzt übersehen, wie das genau funktioniert.</p>
<p>In Codeblock 13-11 wird die Erstellung des Iterators von dessen Verwendung in
der <code>for</code>-Schleife getrennt. Wenn die <code>for</code>-Schleife unter Verwendung des
Iterators in <code>v1_iter</code> aufgerufen wird, wird jedes Element des Iterators in
einer Iteration der Schleife verwendet, die den jeweiligen Wert ausgibt.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("Erhalten: {val}");
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-11: Verwendung eines Iterators in einer
<code>for</code>-Schleife</span></p>
<p>In Sprachen, deren Standardbibliotheken Iteratoren nicht bereitstellen, würde
man diese Funktionalität bereitstellen, indem man eine Variable bei Index 0
startet und diese zum Indizieren im Vektor verwendet und den Wert der
Indexvariable bei jedem Schleifendurchlauf erhöht bis die Gesamtzahl der
Elemente im Vektor erreicht ist.</p>
<p>Iteratoren übernehmen derartige Logik für dich und reduzieren dadurch sich
wiederholenden Code, der zusätzliche Fehlerquellen beinhalten kann. Iteratoren
geben dir mehr Flexibilität bei der Verwendung derselben Logik für viele
verschiedene Arten von Sequenzen, nicht nur für Datenstrukturen, die du wie
Vektoren indizieren kannst. Lass uns herausfinden, wie Iteratoren das
bewerkstelligen.</p>
<h3 id="das-merkmal-trait-iterator-und-die-methode-next"><a class="header" href="#das-merkmal-trait-iterator-und-die-methode-next">Das Merkmal (trait) <code>Iterator</code> und die Methode <code>next</code></a></h3>
<p>Alle Iteratoren implementieren ein Merkmal namens <code>Iterator</code> das in der
Standardbibliothek definiert ist. Die Definition dieses Merkmals sieht wie folgt
aus:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // Methoden mit Standardimplementierung wurden elidiert
}
<span class="boring">}</span></code></pre></pre>
<p>Beachte, dass in der Definition eine neue Syntax verwendet wird: <code>type Item</code> und
<code>Self::Item</code> die einen <em>zugeordneten Typ</em> (associated type) mit diesem Merkmal
definieren. Wir werden zugeordnete Typen im Kapitel 20 besprechen. Im Moment
musst du nur wissen, dass dieser Programmcode bedeutet, dass die Implementierung
des <code>Iterator</code>-Merkmals erfordert, dass du auch einen <code>Item</code>-Typ definierst und
dieser <code>Item</code>-Typ im Rückgabetyp der Methode <code>next</code> benutzt wird. Mit anderen
Worten wird der <code>Item</code>-Typ der vom Iterator zurückgegebene Typ sein.</p>
<p>Für das <code>Iterator</code>-Merkmal muss man bei der Implementierung nur eine Methode
definieren: Die Methode <code>next</code>, die jeweils ein Element des Iterators verpackt
in <code>Some</code> zurückgibt und nach Beendigung der Iteration <code>None</code> zurückgibt.</p>
<p>Wir können für Iteratoren die Methode <code>next</code> direkt aufrufen. Codeblock 13-12
zeigt, welche Werte bei wiederholten Aufrufen von <code>next</code> auf einen aus einem
Vektor erstellten Iterator zurückgegeben werden:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-12: Iterator mit der Methode <code>next</code>
aufrufen</span></p>
<p>Beachte, dass wir <code>v1_iter</code> veränderbar (mutable) machen mussten: Beim Aufrufen
der Methode <code>next</code> auf einen Iterator wird dessen interner Status geändert, der
verwendet wird, um festzustellen, wo sich der Iterator in der Sequenz befindet.
Mit anderen Worten <em>verbraucht</em> dieser Programmcode den Iterator. Jeder Aufruf
von <code>next</code> isst ein Element des Iterators auf. Als wir die <code>for</code>-Schleife
benutzten, mussten wir <code>v1_iter</code> nicht veränderbar machen, da dies schon hinter
den Kulissen geschah, als die Schleife die Eigentümerschaft (ownership) von
<code>v1_iter</code> übernahm.</p>
<p>Merke auch, dass die Werte, die wir von den Aufrufen von <code>next</code> erhalten,
unveränderbare Referenzen (immutable references) auf die Werte im Vektor sind.
Die Methode <code>iter</code> erzeugt einen Iterator über unveränderbare Referenzen. Wenn
wir einen Iterator erzeugen möchten der die Eigentümerschaft von <code>v1</code> übernimmt
und angeeignete Werte (owned values) zurückgibt, können wir die Methode
<code>into_iter</code> anstelle von <code>iter</code> benutzen, und wenn wir über veränderbare
Referenzen iterieren möchten, können wir <code>iter_mut</code> statt <code>iter</code> aufrufen.</p>
<h3 id="methoden-die-den-iterator-verbrauchen"><a class="header" href="#methoden-die-den-iterator-verbrauchen">Methoden die den Iterator verbrauchen</a></h3>
<p>Das <code>Iterator</code>-Merkmal verfügt über eine Vielzahl von Methoden, die in der
Standardbibliothek bereitgestellt werden. Du kannst dich über diese Methoden
informieren, indem du in der Standardbibliothek-API-Dokumentation (standard
library API documentation) nach dem <code>Iterator</code>-Merkmal suchst. Einige dieser
Methoden rufen in ihrer Definition die Methode <code>next</code> auf, daher musst du die
Methode <code>next</code> bei der Implementierung des <code>Iterator</code>-Merkmals einbauen.</p>
<p>Methoden die <code>next</code> aufrufen werden als <em>konsumierende Adapter</em> (consuming
adapters) bezeichnet, da deren Aufruf den Iterator verbraucht. Ein Beispiel ist
die Methode <code>sum</code>, sie übernimmt die Eigentümerschaft des Iterators und
durchläuft die Elemente durch wiederholtes Aufrufen von <code>next</code>, wodurch der
Iterator verbraucht wird. Jedes Element wird während der Iteration zu einer
Summe hinzugefügt, die zurückgegeben wird, sobald die Iteration abgeschlossen
ist. Codeblock 13-13 enthält einen Test, der die Methode <code>sum</code> veranschaulicht:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-13: Aufruf der Methode <code>sum</code> um den Wert der
Summe aller Elemente zu erhalten</span></p>
<p>Man kann <code>v1_iter</code> nach dem Aufruf von <code>sum</code> nicht verwenden, da <code>sum</code> die
Eigentümerschaft des Iterators übernimmt, auf dem sie aufgerufen wird.</p>
<h3 id="methoden-die-andere-iteratoren-erzeugen"><a class="header" href="#methoden-die-andere-iteratoren-erzeugen">Methoden die andere Iteratoren erzeugen</a></h3>
<p><em>Iterator-Adaptoren</em> sind Methoden, die auf dem Merkmal <code>Iterator</code> definiert
sind und den Iterator nicht verbrauchen. Stattdessen erzeugen sie andere
Iteratoren, indem sie einen Aspekt des ursprünglichen Iterators verändern.</p>
<p>Codeblock 13-14 zeigt ein Beispiel für den Aufruf der Iterator-Adaptor-Methode
<code>map</code>, die einen Funktionsabschluss für jedes Element aufruft, während die
Elemente durchlaufen werden. Die Methode <code>map</code> gibt einen neuen Iterator
zurück, der die geänderten Elemente erzeugt. Der Funktionsabschluss erzeugt
hier einen neuen Iterator, der jedes Element des Vektors um 1 erhöht:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-14: Aufruf des Iteratoradapters <code>map</code> um
einen neuen Iterator zu erzeugen</span></p>
<p>Dieser Code führt jedoch zu einer Warnung:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin "iterators") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>Der Programmcode in Codeblock 13-14 hat keine Wirkung, der Funktionsabschluss
wird nie aufgerufen. Die Warnung erinnert uns daran, dass Iteratoradapter faul
sind und dass wir den Iterator verwenden müssen, um etwas zu bewirken.</p>
<p>Um das zu beheben, werden wir die Methode <code>collect</code> verwenden, die wir im Kapitel
12 mit <code>env::args</code> im Codeblock 12-1 benutzt haben. Diese Methode konsumiert den
Iterator und sammelt die Ergebniswerte in einen Kollektionsdatentyp (collection
data type).</p>
<p>In Codeblock 13-15 sammeln wir die Resultate der Iterationen über den Iterator,
der vom Aufruf der Methode <code>map</code> zurückgegeben wird, in einem Vektor. Dieser
Vektor wird dann alle Elemente vom Originalvektor erhöht um 1 beinhalten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-15: Aufruf der Methode <code>map</code> um einen
Iterator zu erzeugen und anschließend der Methode <code>collect</code> um den
Iterator zu verbrauchen und einen Vektor zu erzeugen</span></p>
<p>Da <code>map</code> einen Funktionsabschluss als Parameter annimmt, können wir eine
beliebige Operation spezifizieren, die wir auf jedes Element anwenden wollen.
Dies ist ein gutes Beispiel dafür, wie man mit Funktionsabschlüssen ein
Verhalten anpassen kann, während das vom <code>Iterator</code>-Merkmal bereitgestellte
Iterationsverhalten wiederverwendet wird.</p>
<p>Du kannst mehrere Aufrufe von Iterator-Adaptoren verketten, um komplexe
Aktionen auf lesbare Weise durchzuführen. Da jedoch alle Iteratoren faul sind,
musst du eine der konsumierenden Adaptermethoden aufrufen, um Ergebnisse aus
Aufrufen von Iteratoradaptern zu erhalten.</p>
<h3 id="verwendung-von-funktionsabschlüssen-die-ihre-umgebung-erfassen"><a class="header" href="#verwendung-von-funktionsabschlüssen-die-ihre-umgebung-erfassen">Verwendung von Funktionsabschlüssen die ihre Umgebung erfassen</a></h3>
<p>Viele Iterator-Adapter nehmen Funktionsabschlüsse als Argumente, und in der
Regel werden diese Funktionsabschlüsse solche sein, die ihre Umgebung erfassen.</p>
<p>In diesem Beispiel verwenden wir die Methode <code>filter</code>, die einen
Funktionsabschluss entgegennimmt. Der Funktionsabschluss holt ein Element aus
dem Iterator und gibt ein <code>bool</code> zurück. Wenn der Funktionsabschluss <code>true</code>
zurückgibt, wird der Wert in die von <code>filter</code> erzeugte Iteration aufgenommen.
Wenn der Funktionsabschluss <code>false</code> zurückgibt, wird der Wert nicht
aufgenommen.</p>
<p>Im Codeblock 13-16 benutzen wir <code>filter</code> mit einem Funktionsabschluss, der die
Variable <code>shoe_size</code> aus seiner Umgebung erfasst, um über eine Kollektion von
<code>Shoe</code>-Strukturinstanzen zu iterieren. Er wird nur Schuhe (shoes) einer
bestimmten Größe zurückgeben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}</code></pre>
<p><span class="caption">Codeblock 13-16: Die Methode <code>filter</code> mit einen
Funktionsabschluss benutzen, der <code>shoe_size</code> erfasst</span></p>
<p>Die Funktion <code>shoes_in_size</code> übernimmt die Eigentümerschaft über einen Vektor
aus Schuhen mit der Schuhgröße als Parameter und gibt einen Vektor zurück, der
nur Schuhe einer bestimmten Größe enthält.</p>
<p>Im Funktionsrumpf von <code>shoes_in_size</code> rufen wir <code>into_iter</code> auf, um einen
Iterator zu erzeugen, der die Eigentümerschaft vom Vektor übernimmt. Im Anschluss
rufen wir den <code>filter</code>-Adapter auf, um einen neuen Iterator zu erzeugen, der nur
Elemente enthält, für die der Funktionsabschluss <code>true</code> zurückgibt.</p>
<p>Der Funktionsabschluss erfasst den <code>shoe_size</code>-Parameter aus seiner Umgebung und
vergleicht dessen Wert mit der jeweiligen Schuhgröße und behält nur Schuhe der
gewählten Größe. Zuletzt sammelt der Aufruf der Methode <code>collect</code> die
zurückgegeben Werte des angeschlossenen Adapters in den Vektor, der von der
Funktion zurückgegeben wird.</p>
<p>Der Test zeigt, wenn wir <code>shoes_in_size</code> aufrufen, bekommen wir nur Schuhe
der spezifizierten Größe zurück.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unser-ea-projekt-verbessern"><a class="header" href="#unser-ea-projekt-verbessern">Unser E/A-Projekt verbessern</a></h2>
<p>Mit diesem Wissen über Iteratoren können wir unser E/A-Projekt in Kapitel 12
verbessern. Wir werden Bereiche im Code klarer und prägnanter gestalten. Lass
uns herausfinden wie Iteratoren unsere Implementierung der
Funktion <code>Config::build</code> und der Funktion <code>search</code> optimieren können.</p>
<h3 id="ein-clone-durch-verwendung-eines-iterators-entfernen"><a class="header" href="#ein-clone-durch-verwendung-eines-iterators-entfernen">Ein <code>clone</code> durch Verwendung eines Iterators entfernen</a></h3>
<p>Im Codeblock 12-6 haben wir Programmcode hinzugefügt, der einen Anteilstyp
(slice) von <code>Zeichenketten</code>-Werten (String values) nimmt, und erzeugten eine
<code>Config</code>-Struktur indem wir den Anteilstyp indexierten und die Werte klonten
und der <code>Config</code>-Struktur die Eigentümerschaft dieser Werte gaben. Im Codeblock
13-17 haben wir die Implementierung der Funktion <code>Config::build</code> so reproduziert
wie sie im Codeblock 12-23 aussah.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("Nicht genügend Argumente");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-17: Reproduktion der Funktion <code>Config::build</code>
vom Codeblock 12-23</span></p>
<p>Zu diesem Zeitpunkt sagten wir, dass man sich keine Gedanken wegen der
ineffizienten <code>clone</code>-Aufrufe machen soll, da sie zu einem späteren Zeitpunkt
entfernt werden. Jetzt ist es an der Zeit, dass wir uns darum kümmern!</p>
<p>Wir haben <code>clone</code> benutzt, da wir einen Anteilstyp mit <code>String</code>-Elementen im
Parameter <code>args</code> haben, aber die Funktion <code>build</code> besitzt <code>args</code> nicht. Um die
Eigentümerschaft einer <code>Config</code>-Instanz zurückzugeben, mussten wir die Werte
aus den Feldern <code>query</code> und <code>file_path</code> von <code>Config</code> klonen, damit die
<code>Config</code>-Instanz ihre Werte besitzen kann.</p>
<p>Mithilfe unserer neuen Kenntnisse über Iteratoren können wir die Funktion
<code>build</code> so ändern, dass sie die Eigentümerschaft eines Iterators als Argument
nimmt anstatt sich einen Anteilstyp auszuleihen. Wir werden die
<code>Iterator</code>-Funktionalität benutzen und nicht mehr den Programmcode der die
Länge des Anteilstyps überprüft und an bestimmte Stellen indiziert. Dadurch
wird deutlich, was die Funktion <code>Config::build</code> bewirkt, da der Iterator auf
Werte zugreift.</p>
<p>Sobald <code>Config::build</code> die Eigentümerschaft des Iterators hat und keine
ausleihenden Indexierungsoperationen mehr verwendet, können wir die
<code>String</code>-Werte vom <code>Iterator</code> in <code>Config</code> verschieben anstatt <code>clone</code>
aufzurufen und eine neue Zuweisung vorzunehmen.</p>
<h4 id="direktes-verwenden-des-zurückgegebenen-iterators"><a class="header" href="#direktes-verwenden-des-zurückgegebenen-iterators">Direktes Verwenden des zurückgegebenen Iterators</a></h4>
<p>Öffne die Datei <em>src/main.rs</em> deines E/A-Projekts, sie sollte so aussehen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("Problem beim Parsen der Argumente: {err}");
        process::exit(1);
    });

    // --abschneiden--
<span class="boring">
</span><span class="boring">   if let Err(e) = minigrep::run(config) {
</span><span class="boring">       eprintln!("Anwendungsfehler: {e}");
</span><span class="boring">       process::exit(1);
</span><span class="boring">   }
</span>}</code></pre>
<p>Wir werden zuerst den Anfang der Funktion <code>main</code> von Codeblock 12-24 in den
Programmcode im Codeblock 13-18 ändern, der dieses Mal einen Iterator
verwendet. Dieser Code wird erst kompilieren, wenn wir auch <code>Config::build</code>
abgeändert haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem beim Parsen der Argumente: {err}");
        process::exit(1);
    });

    // --abschneiden--
<span class="boring">  
</span><span class="boring">
</span><span class="boring">   if let Err(e) = minigrep::run(config) {
</span><span class="boring">       eprintln!("Anwendungsfehler: {e}");
</span><span class="boring">       process::exit(1);
</span><span class="boring">   }
</span>}</code></pre>
<p><span class="caption">Codeblock 13-18: Übergabe des Rückgabewerts von
<code>env::args</code> an <code>Config::build</code></span></p>
<p>Die Funktion <code>env::arg</code> gibt einen Iterator zurück! Anstatt die Werte des Iterators
in einem Vektor zu sammeln und dann einen Anteilstyp an <code>Config::build</code> zu
übergeben, geben wir nun die Eigentümerschaft des Iterators, der von <code>env::args</code>
zurückgegeben wird, direkt an <code>Config::build</code>.</p>
<p>Als Nächstes müssen wir die Definition von <code>Config::build</code> aktualisieren.
Ändere in der Datei <em>src/lib.rs</em> deines E/A-Projekts die Signatur von
<code>Config::build</code> um, damit sie so wie im Codeblock 13-26 aussieht. Dies wird
noch immer nicht kompilieren, da der Funktionsrumpf aktualisiert werden muss.</p>
<p><span class="filename">Dateiname src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --abschneiden--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-19: Aktualisieren der Funktion
<code>Config::build</code> damit sie einen Iterator annimmt</span></p>
<p>Laut Dokumentation der Standardbibliothek für die Funktion <code>env::args</code> ist der
Typ des zurückgegebenen Iterators <code>std::env::Args</code>, und dieser Typ
implementiert das Merkmal <code>Iterator</code> und gibt <code>String</code>-Werte zurück.</p>
<p>Wir haben die Signatur der Funktion <code>Config::build</code> aktualisiert, sodass der
Parameter <code>args</code> einen generischen Typ mit den Merkmalsabgrenzungen <code>impl Iterator&lt;Item = String&gt;</code> anstelle von <code>&amp;[String]</code> hat. Diese Verwendung der
Syntax <code>impl Trait</code>, die wir im Abschnitt <a href="ch10-02-traits.html#merkmale-als-parameter">„Merkmale als
Parameter“</a> in Kapitel 10 besprochen haben, bedeutet, dass <code>args</code>
jeder Typ sein kann, der das Merkmal <code>Iterator</code> implementiert und
<code>String</code>-Elemente zurückgibt.</p>
<p>Da wir die Eigentümerschaft von <code>args</code> übernehmen und <code>args</code> beim Iterieren
verändern werden, können wir das Schlüsselwort <code>mut</code> in die Spezifikation des
Parameters <code>args</code> eintragen, um ihn veränderbar (mutable) zu machen.</p>
<h4 id="verwenden-von-iterator-merkmalen-anstelle-von-indizierung"><a class="header" href="#verwenden-von-iterator-merkmalen-anstelle-von-indizierung">Verwenden von <code>Iterator</code>-Merkmalen anstelle von Indizierung</a></h4>
<p>Als Nächstes werden wir den Rumpf von <code>Config::build</code> in Ordnung bringen. Da
<code>args</code> das Merkmal <code>Iterator</code> implementiert, wissen wir, dass wir die Methode
<code>next</code> darauf aufrufen können! Codeblock 13-20 aktualisiert den Code aus
Codeblock 12-23, um die Methode <code>next</code> zu verwenden.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("Keine Abfragezeichenkette erhalten"),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("Keinen Dateinamen erhalten"),
        };

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-20: Ändern des Rumpfes von <code>Config::build</code> um
Iterator-Methoden zu verwenden</span></p>
<p>Denke daran, dass der erste Wert des Rückgabewerts von <code>env::args</code> der Name des
Programms ist, wir wollen das ignorieren und rufen daher gleich <code>next</code> auf um
zum nächsten Wert zu gelangen und den ersten Rückgabewert zu überspringen. Als
Nächstes rufen wir <code>next</code> auf, um den Wert zu erhalten, den wir in das Feld
<code>query</code> von <code>Config</code> einfügen möchten. Falls <code>next</code> ein <code>Some</code> zurückgibt,
benutzen wir <code>match</code>, um den Wert zu extrahieren, wenn es jedoch <code>None</code>
zurückgibt, bedeutet dies, das nicht genügend Argumente eingegeben wurden und
wir kehren vorzeitig mit einem <code>Err</code> zurück. Dasselbe machen wir für den Wert
<code>file_path</code>.</p>
<h3 id="programmcode-mit-iteratorenadapter-klarer-gestalten"><a class="header" href="#programmcode-mit-iteratorenadapter-klarer-gestalten">Programmcode mit Iteratorenadapter klarer gestalten</a></h3>
<p>Wir können die Vorteile der Iteratoren auch in der Funktion <code>search</code> unseres
E/A-Projekts nutzen, die hier im Codeblock 13-21 wiedergegeben ist, wie im
Codeblock 12-19:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-21: Implementierung der Funktion <code>search</code>
aus Codeblock 12-19</span></p>
<p>Wir können diesen Programmcode durch die Verwendung von Iteratoradaptern
prägnanter gestalten und vermeiden, einen veränderbaren Vektor <code>results</code> für
die Zwischenergebnisse zu haben. Bevorzugt wird im funktionalen Programmierstil
die Menge der veränderbaren Werte reduziert, um den Code übersichtlicher zu
machen. Das Entfernen des veränderbar-Status kann uns eventuell zukünftige
Verbesserungen ermöglichen, um die Suche parallel auszuführen, da wir uns nicht
um die Verwaltung des simultanen Zugriffs auf den Vektor <code>results</code> kümmern
müssen. Codeblock 13-22 zeigt diese Änderung:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(
</span><span class="boring">        mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err("Keine Abfragezeichenkette erhalten"),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let file_path = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err("Keinen Dateinamen erhalten"),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-22: Verwendung von Iteratoradapter-Methoden
bei der Implementierung der Funktion <code>search</code></span></p>
<p>Denke daran, der Zweck der Funktion <code>search</code> besteht darin, alle Zeilen in
<code>contents</code> zurückzugeben, die die <code>query</code> enthalten. So ähnlich wie im Beispiel
<code>filter</code> im Codeblock 13-16 verwendet dieser Programmcode den <code>filter</code>-Adapter,
um nur die Zeilen beizubehalten, für die <code>line.contains(query)</code> den Wert <code>true</code>
zurückgibt. Wir sammeln dann die passenden Zeilen mit <code>collect</code> in einen
anderen Vektor. Viel einfacher! Nimm die gleiche Änderung vor, um
Iteratormethoden auch in der Funktion <code>search_case_insensitive</code> zu nutzen.</p>
<h3 id="zwischen-schleifen-und-iteratoren-wählen"><a class="header" href="#zwischen-schleifen-und-iteratoren-wählen">Zwischen Schleifen und Iteratoren wählen</a></h3>
<p>Die nächste logische Frage wäre, welchen Stil du in deinem eigenen Programmcode
wählen solltest und warum. Die ursprüngliche Implementierung im Codeblock 13-21
oder die Version die Iteratoren verwendet im Codeblock 13-22. Die meisten
Rust-Programmierer bevorzugen den Iterator-Stil. Zunächst ist es zwar
schwieriger, den Überblick zu behalten, aber sobald du ein Gefühl für die
verschiedenen Iteratoradapter und deren Funktionsweise hast, können Iteratoren
einfacher zu verstehen sein. Statt mit verschiedensten Schleifen herumzuspielen
und Vektoren zu erstellen, konzentriert sich der Programmcode auf das höhere
Ziel der Schleife. Dadurch wird ein Teil des gewöhnlichen Programmcodes
abstrahiert und die einzigartigen Konzepte, z.B. die Filterbedingung die
jedes Element bestehen muss um durch den Iterator zu kommen, werden leichter
erkennbar.</p>
<p>Aber sind beide Implementierungen wirklich gleichwertig? Die intuitive Annahme
könnte sein, dass die weniger abstrakte Schleife schneller ist. Lass uns über
Performanz sprechen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="performanzvergleich-schleifen-vs-iteratoren"><a class="header" href="#performanzvergleich-schleifen-vs-iteratoren">Performanzvergleich: Schleifen vs. Iteratoren</a></h2>
<p>Um festzustellen, ob man besser Schleifen oder Iteratoren verwendet, solltest
du wissen, welche Implementierung schneller ist: Die Version der Funktion
<code>search</code> mit einer expliziten <code>for</code>-Schleife oder die Version mit Iteratoren.</p>
<p>Wir haben einen Benchmark durchführt, der den gesamten Inhalt von <em>The
Adventures of Sherlock Holmes</em> von Sir Arthur Conan Doyle in eine <code>Zeichenkette</code>
(String) lädt und nach dem Wort <em>the</em> im Inhalt sucht. Hier sind die
Ergebnisse des Benchmarks für die Version von <code>search</code> mit <code>for</code>-Schleife und
der Version die Iteratoren verwendet:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>Die Version mit Iteratoren war ein wenig schneller! Wir werden den Programmcode
des Benchmarks hier nicht erläutern, da es nicht darum geht, nachzuweisen, dass
die beiden Versionen gleichwertig sind, sondern einen allgemeinen Eindruck davon
zu bekommen, wie diese beiden Versionen im Bezug auf Performanz verglichen
werden.</p>
<p>Für einen umfassenderen Benchmark würde man verschiedene Texte
unterschiedlicher Größe als <code>contents</code>, verschiedene Wörter und Wörter
unterschiedlicher Länge als <code>query</code> verwenden und verschiedene Arten anderer
Variationen verwenden. Der Punkt ist folgender: Obwohl Iteratoren eine
hochrangige Abstraktion sind, werden sie ungefähr auf denselben Programmcode
kompiliert, als hättest du diesen selbst auf niedriger Ebene geschrieben.
Iteratoren sind eine von Rusts <em>Zero-Cost Abstraktionen</em>, damit ist gemeint,
dass die Verwendung keinen zusätzlichen Laufzeitaufwand verursacht. Dies
entspricht der Definition von <em>Zero-Overhead</em> in C++ von Bjarne Stroustrup in
"Foundations of C++" (2012):</p>
<blockquote>
<p>Im Allgemeinen folgen C++-Implementierungen dem Zero-Overhead-Prinzip: Was
du nicht verwendest, bezahlst du nicht. Und darüber hinaus: Was du verwendest,
hättest du von Hand nicht besser programmieren können.</p>
</blockquote>
<p>Als anderes Beispiel wird der folgende Programmcode eines Audiodecoders
übernommen. Der Decodierungsalgorithmus verwendet die mathematische Operation
der linearen Vorhersage (linear prediction), um zukünftige Werte aufgrund einer
linearen Funktion der vergangenen Abtastwerte zu schätzen. Der Programmcode
verwendet eine Iteratorkette, die drei Variablen im Gültigkeitsbereich
berechnet, einen Anteilstyp <code>buffer</code>, ein Array mit 12 <code>coefficients</code> und einen
Wert um den die Daten die nach <code>glp_shift</code> verschoben werden sollen. Wir haben
die Variablen in diesem Beispiel deklariert, diesen jedoch keine Werte
zugewiesen, obwohl dieser Programmcode aus seinem Kontext gerissen keine große
Bedeutung hat, ist er dennoch ein gutes Beispiel dafür, wie Rust abstrakte Ideen
im Programmcode auf Code niedriger Ebene übersetzt.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}</code></pre>
<p>Um den Wert von <code>prediction</code> zu berechnen, durchläuft dieser Code jeden der 12
Werte in <code>coefficients</code> und verwendet die Methode <code>zip</code>, um die Werte der
Koeffizienten mit den vorherigen 12 Werten in <code>buffer</code> zu paaren. Anschließend
multiplizieren wir die Werte jedes Paars miteinander, summieren alle
Ergebnisse und verschieben die Bits in der Summe um den Wert von <code>glp_shift</code> nach
rechts.</p>
<p>Bei Berechnungen in Anwendungen wie Audiodecodern wird die Performanz häufig
priorisiert. Hier erstellen wir einen Iterator mit zwei Adaptern und verbrauchen
dann den Wert. Zu welchen Assemblercode würde dieser Rustprogrammcode
kompiliert werden? Er würde auf denselben Programmcode kompiliert werden, als
hättest du das Programm selbst in Assemblersprache geschrieben. Es gibt keine
Schleife, die der Iteration über die Werte von <code>coefficients</code> entsprechen würde.
Rust weiß, dass es 12 Iterationen gibt und „rollt“ daher die Schleife ab.
<em>Abrollen</em> (unrolling) ist eine Optimierung, die den Mehraufwand (overhead) der
Steuerung der Schleife beseitigt und stattdessen sich wiederholenden
Programmcode für jede Iteration der Schleife generiert.</p>
<p>Alle Koeffizienten werden in Registern gespeichert, das bedeutet, dass der
Zugriff auf die Werte sehr schnell ist. Es gibt keine Begrenzungsprüfungen (bounds
checks) für den Zugriff auf Arrays zur Laufzeit. Durch diese Optimierungen, die
Rust anwenden kann, ist der resultierende Programmcode äußerst effizient. Nun,
da du das weißt, kannst du, ohne Angst zu haben, Funktionsabschlüsse und
Iteratoren verwenden! Sie lassen den Code abstrakter erscheinen, verursachen
aber keine Performanzeinbußen zur Laufzeit.</p>
<h2 id="zusammenfassung-12"><a class="header" href="#zusammenfassung-12">Zusammenfassung</a></h2>
<p>Funktionsabschlüsse und Iteratoren sind Rust-Funktionalitäten, die von Ideen der
funktionalen Programmierung inspiriert sind. Sie tragen zu Rusts Fähigkeit bei,
abstrakte Ideen bei guter Performanz zu ermöglichen. Die Implementierungen von
Iteratoren und Funktionsabschlüssen sind so, dass die Performanz der Laufzeit
nicht beeinträchtigt wird. Dies ist ein Teil von Rusts Ziel,
Zero-Cost-Abstraktionen zu ermöglichen.</p>
<p>Nachdem wir die Ausdruckskraft unseres E/A-Projekts verbessert haben, wollen
wir uns nun einige weitere Funktionalitäten von <code>cargo</code> ansehen, die uns helfen
werden, das Projekt mit der Welt zu teilen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mehr-über-cargo-und-cratesio"><a class="header" href="#mehr-über-cargo-und-cratesio">Mehr über Cargo und Crates.io</a></h1>
<p>Bisher haben wir nur die grundlegendsten Funktionalitäten von Cargo für das
Bauen (build), zum Ausführen und für das Testen unseres Programmcodes
verwendet, aber es kann noch vieles mehr. In diesem Kapitel werden einige der
fortgeschrittenen Funktionalitäten erläutern, um zu zeigen, wie man Folgendes
tun kann:</p>
<ul>
<li>Anpassen deines Bauvorgangs mit Freigabeprofilen (release profiles)</li>
<li>Veröffentlichen von Programmbibliotheken auf <a href="https://crates.io/">crates.io</a></li>
<li>Organisieren von großen Projekten mit Arbeitsbereichen (workspaces)</li>
<li>Installieren von Binärdateien (binaries) von <a href="https://crates.io/">crates.io</a></li>
<li>Cargo erweitern mit benutzerdefinierten Befehlen</li>
</ul>
<p>Cargo kann noch einiges mehr als die Funktionalität, die wir in diesem Kapitel
behandeln, eine vollständige Erklärung aller Funktionen findest du in der
<a href="https://doc.rust-lang.org/cargo/">Cargo-Dokumentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="bauvorgang-anpassen-mit-freigabeprofilen-release-profiles"><a class="header" href="#bauvorgang-anpassen-mit-freigabeprofilen-release-profiles">Bauvorgang anpassen mit Freigabeprofilen (release profiles)</a></h2>
<p>In Rust sind <em>Freigabeprofile</em> vordefinierte, anpassbare Profile mit
unterschiedlichen Konfigurationen, durch die ein Programmierer mehr Kontrolle
über verschiedene Optionen zum Kompilieren von Programmcode hat. Jedes Profil
wird von den anderen unabhängig konfiguriert.</p>
<p>Cargo hat zwei Hauptprofile: Das Profil <code>dev</code>, das von Cargo verwendet wird, wenn
du <code>cargo build</code> ausführst, und das Profil <code>release</code>, das Cargo verwendet, wenn
<code>cargo build --release</code> ausgeführt wird. <code>dev</code> ist mit guten
Standardeinstellungen für die Entwicklung (development) definiert und <code>release</code>
hat gute Standardeinstellungen für Releasebuilds. <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<p>Profilnamen die dir möglicherweise aus der Ausgabe beim Bauvorgang bekannt sind:</p>
<pre><code class="language-console">$ cargo build
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<p>Die Angaben <code>dev</code> und <code>release</code> sind diese verschiedenen Profile, die vom
Compiler verwendet werden.</p>
<p>Cargo hat Standardeinstellungen für jedes der Profile, die verwendet werden,
wenn du keine expliziten Abschnitte <code>[profile.*]</code> in der Datei <em>Cargo.toml</em> des
Projekts hast. Durch Hinzufügen eines Abschnitts <code>[profile.*]</code> für Profile, die
du anpassen möchtest, überschreibst du Teile der Standardeinstellungen. Hier
sind zum Beispiel die Standardwerte für die Einstellung <code>opt-level</code> der Profile
<code>dev</code> und <code>release</code>:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>Die Einstellung <code>opt-level</code> steuert die Anzahl der Optimierungen, die Rust auf
den Programmcode anwendet, in einem Bereich 0 bis 3. Das Anwenden zusätzlicher
Optimierungen verlängert die Kompilierzeit. Wenn man in der Entwicklung häufig
den Programmcode kompiliert, wünscht man zumeist weniger Optimierungen, um
schneller zu kompilieren, auch wenn dadurch der resultierende Programmcode
langsamer ausgeführt wird. Das Standard-<code>opt-level</code> für <code>dev</code> ist daher <code>0</code>.
Wenn du bereit bist, deinen Programmcode zu veröffentlichen, ist es besser,
wenn das Kompilieren mehr Zeit benötigt, man wird nur einmal im Releasemodus
kompilieren, aber das Programm oft ausführen, daher tauscht der Releasemodus
eine längere Kompilierzeit gegen Programmcode, der schneller ausgeführt wird.
Aus diesem Grund ist das standardmäßige <code>opt-level</code> für das Profil <code>release</code>
<code>3</code>.</p>
<p>Du kannst eine Standardeinstellung überschreiben, indem du dafür in
<em>Cargo.toml</em> einen anderen Wert hinzufügst. Wenn wir zum Beispiel die
Optimierungsstufe 1 im Entwicklungsprofil verwenden möchten, können wir diese
beiden Zeilen in die Datei <em>Cargo.toml</em> unseres Projekts hinzufügen:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>Dieser Code überschreibt die Standardeinstellung von <code>0</code>. Wenn wir nun <code>cargo build</code> ausführen, verwendet Cargo die Standardeinstellung für das Profil <code>dev</code>
sowie unsere Anpassung <code>1</code> für <code>opt-level</code>. Cargo wird mehr Optimierungen
vornehmen als mit Standardeinstellungen, aber weniger als bei einem
Releasebuild.</p>
<p>Eine vollständige Liste der Konfigurationsoptionen und Standardeinstellungen für
jedes Profil findest du in der <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo-Dokumentation</a>.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p><strong>Release</strong>: Veröffentlichung, <strong>Build</strong>: Kompilierter Quelltext <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="kisten-crate-auf-cratesio-veröffentlichen"><a class="header" href="#kisten-crate-auf-cratesio-veröffentlichen">Kisten (crate) auf crates.io veröffentlichen</a></h2>
<p>Wir haben Pakete von <a href="https://crates.io/">crates.io</a> als Abhängigkeiten (dependencies)
unseres Projekts verwendet. Du kannst deinen Programmcode jedoch auch für
andere Personen freigeben, indem du eigene Pakete veröffentlichst. Die
Registrierung von Kisten auf <a href="https://crates.io/">crates.io</a> verteilt den Quellcode deiner
Pakete, daher wird primär Open Source Programmcode gehostet.</p>
<p>Rust und Cargo verfügen über Funktionalitäten, die es Benutzern erleichtern,
ihr veröffentlichtes Paket zu finden und zu verwenden. Wir werden nun über
einige dieser Funktionalitäten sprechen und dann erklären, wie ein Paket
veröffentlicht wird.</p>
<h3 id="sinnvolle-dokumentationskommentare-erstellen"><a class="header" href="#sinnvolle-dokumentationskommentare-erstellen">Sinnvolle Dokumentationskommentare erstellen</a></h3>
<p>Die genaue Dokumentation deiner Pakete hilft anderen Benutzern zu verstehen,
wie diese zu verwenden sind, daher lohnt es sich, Zeit in das Schreiben von
Dokumentationen zu investieren. In Kapitel 3 haben wir besprochen, wie man
Rust-Code mit zwei Schrägstrichen <code>//</code> kommentiert. Rust hat auch eine eigene
Art von Kommentar für die Dokumentation, die passenderweise als
<em>Dokumentationskommentar</em> bezeichnet wird und HTML-Dokumentation generiert.
Der HTML-Code zeigt den Inhalt von Dokumentationskommentaren für öffentliche
API-Elemente an, die für Programmierer bestimmt sind, die wissen möchten,
wie deine Kiste <em>benutzt</em> wird, und nicht, wie deine Kiste <em>implementiert</em>
ist.</p>
<p>Dokumentationskommentare verwenden drei Schrägstriche <code>///</code> anstelle von zwei
und unterstützen Markdown-Notation zum Formatieren des Textes. Platziere
Dokumentationskommentare nur vor dem zu dokumentierenden Element. Codeblock
14-1 zeigt Dokumentationskommentare für eine Funktion <code>add_one</code> in einer Kiste
mit dem Namen <code>my_crate</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given
///
/// # Examples 
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p><span class="caption">Codeblock 14-1: Ein Dokumentationskommentar für eine
Funktion</span></p>
<p>Hier geben wir eine Beschreibung der Funktionsweise der Funktion <code>add_one</code> an,
beginnen einen Abschnitt mit der Überschrift <code>Examples</code> gefolgt vom
Programmcode, der die Verwendung der Funktion <code>add_one</code> demonstriert. Wir können
die HTML-Dokumentation aus diesem Dokumentationskommentar generieren, indem wir
<code>cargo doc</code> ausführen. Dieser Befehl führt das mit Rust verbreitete Werkzeug
<code>rustdoc</code> aus und legt die generierte HTML-Dokumentation im Verzeichnis
<em>target/doc</em> ab.</p>
<p>Wenn du <code>cargo doc --open</code> ausführst, wird der HTML-Code für die Dokumentation
deiner aktuellen Kiste (und auch die Dokumentation aller Abhängigkeiten
(dependencies) deiner Kiste) erstellt und das Ergebnis in einem Webbrowser
geöffnet. Wenn du zur Funktion <code>add_one</code> navigierst, wirst du sehen wie der Text
in den Dokumentationskommentaren gerendert wird. Siehe Abbildung 14-1:</p>
<img alt="Gerenderte HTML-Dokumentation für die Funktion `add_one` von `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Abbildung 14-1: HTML-Dokumentation für die Funktion
<code>add_one</code></span></p>
<h4 id="häufig-verwendete-abschnitte"><a class="header" href="#häufig-verwendete-abschnitte">Häufig verwendete Abschnitte</a></h4>
<p>Wir haben die Markdown-Überschrift <code># Examples</code> in Codeblock 14-1 verwendet um
einen Abschnitt im HTML-Code mit dem Titel <code>Examples</code> zu erstellen. Hier sind
einige andere Abschnitte, die Autoren von Kisten häufig in ihrer Dokumentation
verwenden:</p>
<ul>
<li><strong>Panics</strong>: Die Szenarien, in denen die dokumentierte Funktion <code>panic</code>
aufruft. Anwender der Funktion, die nicht möchten, dass ihre Programme
<code>panic</code> aufrufen, sollten sicherstellen, dass sie die Funktion in solchen
Situationen nicht aufrufen.</li>
<li><strong>Errors</strong>: Wenn die Funktion einen Typ <code>Result</code> zurückgibt, der die Arten von
Fehlern die auftreten können beschreibt und unter welchen Bedingungen diese
Fehler auftreten können, dies kann für Aufrufende hilfreich sein, um
Programmcode zu schreiben der die verschiedenen Arten von Fehlern auf
unterschiedliche Art behandelt.</li>
<li><strong>Safety</strong>: Wenn die Funktion aufzurufen unsicher (<code>unsafe</code>) ist (wir
behandeln die Unsicherheit im Kapitel 20), sollte ein Abschnitt existieren,
in dem erläutert wird, warum die Funktion unsicher ist, und die Invarianten
behandelt werden die die Funktion vom Aufrufenden erwartet.</li>
</ul>
<p>Die meisten Dokumentationskommentare benötigen nicht alle Abschnitte, aber dies
ist eine gute Checkliste um dich an die Aspekte deines Programmcodes erinnern,
die für Benutzer interessant sein werden.</p>
<h4 id="dokumentationskommentare-als-tests"><a class="header" href="#dokumentationskommentare-als-tests">Dokumentationskommentare als Tests</a></h4>
<p>Das Hinzufügen von Beispiel-Codeblöcken in deinen Dokumentationskommentaren kann
dabei hilfreich sein, die Verwendung deiner Programmbibliothek darzustellen.
Dies hat einen zusätzlichen Bonus: Das Ausführen von <code>cargo test</code> führt die
Codeblöcke in deiner Dokumentation als Test aus! Nichts ist besser als eine
Dokumentation mit Beispielen, aber nichts ist schlimmer als eine Dokumentation
mit Beispielen die nicht funktionieren, da sich der Code seit dem Schreiben der
Dokumentation geändert hat. Wenn wir <code>cargo test</code> für die Dokumentation der
Funktion <code>add_one</code> aus Codeblock 14-1 aufrufen, sehen wir folgenden Abschnitt in
den Testergebnissen:</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Wenn wir nun entweder die Funktion oder das Beispiel so ändern, dass <code>assert_eq!</code>
im Beispiel <code>panic</code> aufruft und erneut <code>cargo test</code> aufrufen, werden wir
bemerken, das <code>cargo test</code> feststellt, dass das Beispiel und der Code nicht
synchron miteinander sind!</p>
<h4 id="enthaltene-elemente-kommentieren"><a class="header" href="#enthaltene-elemente-kommentieren">Enthaltene Elemente kommentieren</a></h4>
<p>Der Stil des Dokumentationskommentars <code>//!</code> fügt dem Element, das die
Kommentare enthält, Dokumentation hinzu, anstatt den Elementen die auf die
Kommentare folgen Dokumentation hinzuzufügen. Wir verwenden diese
Dokumentationskommentare üblicherweise in der Wurzeldatei (laut Konvention
<em>src/lib.rs</em>) oder in einem Modul, um die Kiste oder das Modul als Ganzes zu
dokumentieren.</p>
<p>Um beispielsweise eine Dokumentation hinzuzufügen, die den Zweck der Kiste
<code>my_crate</code> beschreibt, die die Funktion <code>add_one</code> enthält, können wir am Anfang
der Datei <em>src/lib.rs</em> Dokumentationskommentare hinzufügen die mit <code>//!</code>
beginnen. Siehe Codeblock 14-2.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --abschneiden--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 14-2: Dokumentation für die gesamte
<code>my_crate</code>-Kiste</span></p>
<p>Beachte, dass nach der letzten Zeile, die mit <code>//!</code> beginnt, kein Programmcode
mehr vorhanden ist. Da wir die Kommentare mit <code>//!</code> anstatt <code>///</code> begonnen
haben, dokumentieren wir das Element, das diesen Kommentar enthält und nicht
ein Element, das diesem Kommentar folgt. In diesem Fall ist dieses Element die
Datei <em>src/lib.rs</em>, dabei handelt es sich um das Wurzelverzeichnis der Kiste.
Diese Kommentare beschreiben die gesamte Kiste.</p>
<p>Wenn wir <code>cargo doc --open</code> ausführen, werden diese Kommentare auf der
Startseite der Dokumentation für <code>my_crate</code> angezeigt, oberhalb der Liste der
veröffentlichten Elemente in der Kiste. Siehe Abbildung 14-2:</p>
<img alt="Gerenderte HTML-Dokumentation mit einem Kommentar für die gesamte Kiste" src="img/trpl14-02.png" class="center" />
<p><span class="caption">Abbildung 14-2: Gerenderte Dokumentation für <code>my_crate</code>,
einschließlich des Kommentars, der die Kiste als Ganzes beschreibt</span></p>
<p>Dokumentationskommentare innerhalb von Elementen sind besonders nützlich, um
Kisten und Module zu beschreiben. Erkläre anhand dieser Informationen den
allgemeinen Zweck des Containers, damit seine Benutzer die Aufteilung der Kiste
besser verstehen können.</p>
<h3 id="mit-pub-use-eine-benutzerfreundliche-öffentliche-api-exportieren"><a class="header" href="#mit-pub-use-eine-benutzerfreundliche-öffentliche-api-exportieren">Mit <code>pub use</code> eine benutzerfreundliche öffentliche API exportieren</a></h3>
<p>Die Struktur deiner öffentlichen API spielt beim Veröffentlichen einer Kiste
eine wichtige Rolle. Personen, die deine Kiste verwenden, sind mit der Struktur
weniger vertraut als du und haben vielleicht Schwierigkeiten, die Teile zu
finden, die sie verwenden möchten, wenn deine Kiste eine große Modulhierarchie
aufweist.</p>
<p>In Kapitel 7 wurde erläutert, wie wir unseren Programmcode mithilfe des
Schlüsselworts <code>mod</code> in Module organisieren, Elemente mit dem Schlüsselwort
<code>pub</code> veröffentlichen und Elemente mit dem Schlüsselwort <code>use</code> in einen
Gültigkeitsbereich (scope) bringen. Die Struktur, die für dich während der
Entwicklung einer Kiste sinnvoll ist, ist für ihre Benutzer jedoch
möglicherweise nicht sehr benutzerfreundlich. Vielleicht möchtest du Strukturen
in einer Hierarchie mit mehreren Ebenen organisieren, aber Personen, die einen
Typ verwenden möchten, den du tief in der Hierarchie definiert hast, haben
möglicherweise Probleme, herauszufinden, ob dieser Typ vorhanden ist. Sie
könnten sich auch darüber ärgern, dass sie <code>use</code>
<code>my_crate::some_module::another_module::UsefulType;</code> eingeben müssen anstatt
<code>use</code> <code>my_crate::UsefulType;</code>.</p>
<p>Die gute Nachricht ist, dass du die interne Organisation nicht neu anordnen
musst, wenn sie für andere aus einer anderen Bibliothek <em>nicht</em> geeignet ist.
Stattdessen kannst du Elemente erneut exportieren, um mit <code>pub use</code> eine
veränderte öffentliche Struktur von deiner privaten Struktur zu erstellen.
Beim Re-Exportieren wird ein öffentliches Element an einem Speicherort genommen
und an einem anderen Speicherort öffentlich gemacht, als ob es stattdessen am
anderen Speicherort definiert worden wäre.</p>
<p>Nehmen wir zum Beispiel an, wir haben eine Bibliothek mit dem Namen <code>art</code>
erstellt, um künstlerische Konzepte zu modellieren. In dieser Bibliothek sind
zwei Module enthalten: Ein Modul <code>kinds</code> mit zwei Aufzählungen (enums) namens
<code>PrimaryColor</code> und <code>SecondaryColor</code> und ein Modul <code>utils</code> das eine Funktion
namens <code>mix</code> beinhaltet. Siehe Codeblock 14-3:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --abschneiden--
<span class="boring">       unimplemented!();
</span>    }
}</code></pre>
<p><span class="caption">Codeblock 14-3: Eine Bibliothek <code>art</code> mit Elementen die in
Modulen <code>kinds</code> und <code>utils</code> organisiert sind</span></p>
<p>Abbildung 14-3 zeigt wie die Startseite der Dokumentation für diese Kiste
generiert von <code>cargo doc</code> aussehen würde.</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Abbildung 14-3: Startseite der Dokumentation für <code>art</code>
die Module <code>kinds</code> und <code>utils</code> auflistet</span></p>
<p>Beachte, dass die Typen <code>PrimaryColor</code>, <code>SecondaryColor</code> und die Funktion <code>mix</code>
nicht auf der Startseite angeführt sind. Wir müssen auf <code>kinds</code> und <code>utils</code>
klicken um sie zu sehen.</p>
<p>Eine Kiste, die von dieser Bibliothek abhängt, würde <code>use</code>-Anweisungen
benötigen, die die Elemente aus <code>art</code> in den Gültigkeitsbereich bringen und die
derzeit definierte Modulstruktur angeben. Codeblock 14-4 zeigt ein Beispiel für
eine Kiste, in der die Elemente <code>PrimaryColor</code> und <code>mix</code> aus der <code>art</code>-Kiste
verwendet werden:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
<p><span class="caption">Codeblock 14-4: Eine Kiste, die die Gegenstände der
<code>art</code>-Kiste mit ihrer internen Struktur exportiert</span></p>
<p>Der Autor des Programmcodes in Codeblock 14-4, der die Kiste <code>art</code> verwendet,
musste herausfinden, dass sich <code>PrimaryColor</code> im Modul <code>kinds</code> und <code>mix</code> im Modul
<code>utils</code> befindet. Die Modulstruktur der <code>art</code>-Kiste ist für Entwickler, die an
der <code>art</code>-Kiste arbeiten, relevanter als für Entwickler die die <code>art</code>-Kiste
verwenden. Die interne Struktur enthält keine nützlichen Informationen für jemanden,
der diese benutzen möchte, sondern sorgt für Verwirrung, da diese herausfinden
müssen wo sie suchen müssen und die Struktur ist unpraktisch, da Entwickler die
Modulnamen in den <code>use</code>-Anweisungen angeben müssen.</p>
<p>Um die interne Organisation aus der öffentlichen API zu entfernen, können wir den
Programmcode der <code>art</code>-Kiste ändern, um <code>pub use</code>-Anweisungen hinzuzufügen, um
die Elemente der obersten Ebene erneut zu exportieren, wie in Codeblock 14-5
gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
   // --abschneiden--
<span class="boring">   /// The primary colors according to the RYB color model.
</span><span class="boring">   pub enum PrimaryColor {
</span><span class="boring">       Red,
</span><span class="boring">       Yellow,
</span><span class="boring">       Blue,
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   /// The secondary colors according to the RYB color model.
</span><span class="boring">   pub enum SecondaryColor {
</span><span class="boring">       Orange,
</span><span class="boring">       Green,
</span><span class="boring">       Purple,
</span><span class="boring">   }
</span>}

pub mod utils {
    // --abschneiden--
<span class="boring">   use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">   /// Combines two primary colors in equal amounts to create
</span><span class="boring">   /// a secondary color.
</span><span class="boring">   pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">       SecondaryColor::Orange
</span><span class="boring">   }
</span>}</code></pre>
<p><span class="caption">Codeblock 14-5: Hinzufügen von <code>pub use</code>-Anmerkungen um
Elemente erneut zu exportieren</span></p>
<p>Die Dokumentation der API, die von <code>cargo doc</code> generiert wurde, wird nun
aufgelistet und die erneut exportierten Links werden auf der Startseite, wie in
Abbildung 14-4 ersichtlich, angezeigt, so sind die Typen <code>PrimaryColor</code> und
<code>SecondaryColor</code> leichter zu finden.</p>
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
<p><span class="caption">Abbildung 14-4: Die Startseite der Dokumentation von
<code>art</code> mit den aufgelisteten erneuten Exporten</span></p>
<p>Die Benutzer der <code>art</code>-Kiste können weiterhin die interne Struktur aus
Codeblock 14-3 sehen und verwenden, wie es in Codeblock 14-4 gezeigt wurde,
oder sie können die benutzerfreundliche Struktur in Codeblock 14-5 verwenden,
wie es im Codeblock 14-6 gezeigt wurde:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --abschneiden--
<span class="boring">   let red = PrimaryColor::Red;
</span><span class="boring">   let yellow = PrimaryColor::Yellow;
</span><span class="boring">   mix(red, yellow);
</span>}</code></pre>
<p><span class="caption">Codeblock 14-6: Ein Programm, das die erneut exportierten
Elemente der <code>art</code>-Kiste verwendet</span></p>
<p>In Fällen, in denen es viele verschachtelte Module gibt, kann das erneute
Exportieren der Typen auf der obersten Ebene mit <code>pub use</code> die Erfahrung der
Benutzer der Kiste signifikant verbessern. Eine andere häufige Verwendung von
<code>pub use</code> ist es, Definitionen einer Abhängigkeit in der aktuellen Kiste zu
re-exportieren, um die Definitionen dieser Kiste zu einem Teil der öffentlichen
API deiner Kiste zu machen.</p>
<p>Das Erstellen einer sinnvollen öffentlichen API-Struktur ist eher eine Kunst
als eine Wissenschaft, und du kannst iterieren, um die API zu finden, die für
Benutzer am besten geeignet ist. Wenn man <code>pub use</code> wählt, erhält man
Flexibilität bei der internen Strukturierung einer Kiste und entkoppelt diese
interne Struktur von dem, was man ihren Benutzern präsentiert. Sieh dir
einige der Programmcodes von Kisten an die du installiert hast, um
festzustellen, ob sie intern strukturiert sind und ob sich ihre interne
Struktur von der öffentlichen API unterscheidet.</p>
<h3 id="einrichten-eines-kontos-auf-cratesio"><a class="header" href="#einrichten-eines-kontos-auf-cratesio">Einrichten eines Kontos auf crates.io</a></h3>
<p>Bevor man eine Kiste veröffentlichen kann, muss man ein Konto auf
<a href="https://crates.io/">crates.io</a> erstellen um ein API-Token zu erhalten. Besuche dazu die
Homepage auf <a href="https://crates.io/">crates.io</a> und melde dich über ein GitHub-Konto an.
(Derzeit ist ein GitHub-Konto eine Voraussetzung, aber die Seite wird
möglicherweise in Zukunft andere Wege einen Account zu erstellen ermöglichen.)
Sobald du angemeldet bist, gehe zu Kontoeinstellungen (account settings) auf
<a href="https://crates.io/me/">https://crates.io/me/</a> und erhalte deinen API-Schlüssel. Rufe
anschließend das Kommando <code>cargo login</code> mit deinem API-Schlüssel auf:</p>
<pre><code class="language-console">$ cargo login
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>Diese Kommando informiert Cargo über dein API-Token und speichert es lokal in
<em>~/.cargo/credentials</em>. Beachte, dass dieses Token ein <em>Geheimnis</em> ist: Gib es
nicht an andere weiter. Wenn du es aus irgendeinem Grund mit jemandem teilst,
solltest du es widerrufen und ein neues Token auf <a href="https://crates.io/">crates.io</a> erzeugen.</p>
<h3 id="metadaten-zu-einer-neuen-kiste-hinzufügen"><a class="header" href="#metadaten-zu-einer-neuen-kiste-hinzufügen">Metadaten zu einer neuen Kiste hinzufügen</a></h3>
<p>Angenommen, du hast eine Kiste, die du veröffentlichen möchtest. Vor dem
Veröffentlichen musst du deiner Kiste einige Metadaten im Abschnitt <code>[package]</code>
der Datei <em>Cargo.toml</em> der Kiste hinzufügen.</p>
<p>Deine Kiste benötigt einen eindeutigen Namen. Während du vor Ort an einer Kiste
arbeitest, kannst du eine Kiste beliebig benennen. Allerdings werden
Kistennamen auf <a href="https://crates.io/">crates.io</a> nach Verfügbarkeit vergeben. Sobald ein
Kistenname vergeben ist, kann niemand mehr eine Kiste mit diesem Namen
veröffentlichen. Suche vor dem Versuch, eine Kiste zu veröffentlichen, nach dem
Namen, den du verwenden möchtest. Wenn der Name von einer anderen Kiste
verwendet wurde, wirst du einen anderen Namen suchen müssen und das Feld <code>name</code>
in der Datei <em>Cargo.toml</em> im Abschnitt <code>[package]</code> bearbeiten, um den neuen
Namen für die Veröffentlichung zu verwenden:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
</code></pre>
<p>Selbst wenn du einen eindeutigen Namen gewählt hast, wird beim Ausführen von
<code>cargo publish</code> zum Veröffentlichen der Kiste an dieser Stelle eine Warnung und
anschließend ein Fehler angezeigt:</p>
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--abschneiden--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these field
</code></pre>
<p>Dies schlägt fehlt, weile einige wichtige Informationen fehlen: Eine
Beschreibung und eine Lizenz sind erforderlich, damit die Benutzer wissen, was
deine Kiste tut und unter welchen Bedingungen man sie verwenden kann. Ergänze
in der Datei <em>Cargo.toml</em> eine Beschreibung hinzu, die nur ein oder zwei Sätze
umfasst, da sie zusammen mit deiner Kiste in den Suchergebnissen angezeigt
wird. Für das Feld <code>license</code> musst du einen <em>Lizenzkennungswert</em> (licence
identifier value) angeben. In <a href="http://spdx.org/licenses/">Linux Foundation's Software Package Data
Exchange (SPDX)</a> sind die Bezeichner aufgeführt, die Sie für diesen Wert
verwenden können. Um beispielsweise anzugeben, dass du deine Kiste mit der
MIT-Lizenz lizenziert hast, füge die <code>MIT</code>-Identifikation hinzu:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
license = "MIT"
</code></pre>
<p>Wenn man eine Lizenz verwenden möchte, die nicht in SPDX angezeigt wird, muss
man den Text dieser Lizenz in eine Datei einfügen, die Datei in das Projekt
aufnehmen und dann <code>license-file</code> verwenden um den Namen dieser Lizenz zu
spezifizieren anstelle der Verwendung des <code>license</code>-Schlüssels.</p>
<p>Die Anleitung, welche Lizenz für dein Projekt geeignet ist, geht über den
Rahmen dieses Buches hinaus. Viele Leute in der Rust-Gemeinschaft lizenzieren
ihre Projekte genauso wie Rust mit einer Doppellizenz von <code>MIT OR Apache-2.0</code>.
Diese Übung zeigt, dass man durch <code>OR</code> auch mehrere Lizenzkennungen getrennt
angeben kann, um mehrere Lizenzen für ein Projekt zu haben.</p>
<p>Mit einem eindeutigen Namen, der Version, deiner Beschreibung und einer
hinzugefügten Lizenz könnte die Datei <em>Cargo.toml</em> für ein Projekt, das zur
Veröffentlichung bereit ist, folgendermaßen aussehen:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
</code></pre>
<p>Die <a href="https://doc.rust-lang.org/cargo/">Cargo-Documentation</a> beschreibt andere Metadaten, die du
angeben kannst, um sicherzustellen, dass andere deine Kiste leichter entdecken
und verwenden können.</p>
<h3 id="veröffentlichen-auf-cratesio"><a class="header" href="#veröffentlichen-auf-cratesio">Veröffentlichen auf crates.io</a></h3>
<p>Nachdem man ein Konto erstellt, den API-Token gespeichert, einen Namen für
seine Kiste ausgewählt und die erforderlichen Metadaten angegeben hat, kann man
sie veröffentlichen! Durch das Veröffentlichen einer Kiste wird eine bestimmte
Version auf <a href="https://crates.io/">crates.io</a> hochgeladen, damit andere sie verwenden können.</p>
<p>Sei vorsichtig, da eine Veröffentlichung <em>dauerhaft</em> ist. Die Version kann
niemals überschrieben und der Programmcode nicht gelöscht werden. Ein Hauptziel
von <a href="https://crates.io/">crates.io</a> ist es, als permanentes Archiv von Code zu fungieren,
sodass alle Projekte die erstellt werden und von Kisten aus <a href="https://crates.io/">crates.io</a>
abhängen weiter funktionieren werden. Das Zulassen von Versionslöschungen würde
das Erreichen dieses Ziels unmöglich machen. Die Anzahl der Kistenversionen,
die man veröffentlichen kann, ist jedoch unbegrenzt.</p>
<p>Rufe <code>cargo publish</code> erneut auf. Diesmal sollte es funktionieren:</p>
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Herzlichen Glückwunsch! Du hast deinen Programmcode nun für die
Rust-Gemeinschaft freigegeben. Jeder kann deine Kiste einfach als Abhängigkeit
für sein Projekt hinzufügen.</p>
<h3 id="veröffentlichen-einer-neuen-version-einer-vorhandenen-kiste"><a class="header" href="#veröffentlichen-einer-neuen-version-einer-vorhandenen-kiste">Veröffentlichen einer neuen Version einer vorhandenen Kiste</a></h3>
<p>Wenn du Änderungen an deiner Kiste vorgenommen hast und bereit bist, eine neue
Version zu veröffentlichen, ändere den in der <em>Cargo.toml</em>-Datei angegebenen
Versionswert und veröffentliche ihn erneut. Verwende die <a href="https://semver.org/lang/de/">Regeln für die
semantische Versionierung</a>, um auf den von dir vorgenommenen Änderungen
basierend welche neue Versionsnummer geeignet ist. Führe dann <code>cargo publish</code>
aus, um die neue Version hochzuladen.</p>
<h3 id="mit-cargo-yank-versionen-auf-cratesio-als-veraltet-kennzeichnen"><a class="header" href="#mit-cargo-yank-versionen-auf-cratesio-als-veraltet-kennzeichnen">Mit <code>cargo yank</code> Versionen auf crates.io als veraltet kennzeichnen</a></h3>
<p>Obwohl man frühere Versionen einer Kiste nicht entfernen kann, kann man
verhindern, dass zukünftige Projekte sie als neue Abhängigkeit hinzufügen. Dies
ist nützlich, wenn eine Kistenversion aus dem einen oder anderen Grund defekt
ist. In solchen Situationen unterstützt Cargo das Herausziehen (yanking) einer
Kistenversion.</p>
<p>Durch das <em>Herausziehen</em> einer Version wird verhindert, dass neue Projekte von
dieser Version abhängen, während alle vorhandenen Projekte, die davon abhängen,
weiterhin heruntergeladen werden können. Im Wesentlichen bedeutet Herausziehen
(yank), dass alle Projekte mit einem <em>Cargo.lock</em> nicht kaputt gehen und
zukünftige generierte <em>Cargo.lock</em>-Dateien nicht die herausgezogene Version
verwenden.</p>
<p>Um eine Version einer Kiste herauszuziehen, rufe <code>cargo yank</code> auf und
spezifiziere welche Version du herausziehen möchtest. Wenn wir zum Beispiel
eine Kiste mit dem Namen <code>guessing_game</code> in Version 1.0.1 veröffentlicht haben
und sie löschen wollen, würden wir im Projektverzeichnis für <code>guessing_game</code>
folgendes ausführen:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>Durch Hinzufügen von <code>--undo</code>, kann man das Herausziehen rückgängig machen und
Projekten wieder erlauben von der Version abzuhängen:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>Das Herausziehen löscht <em>keinen</em> Programmcode. Es kann zum Beispiel keine
versehentlich hochgeladenen Geheimnisse löschen. Falls das passieren sollte
musst du diese Geheimnisse sofort zurücksetzen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-arbeitsbereiche"><a class="header" href="#cargo-arbeitsbereiche">Cargo-Arbeitsbereiche</a></h2>
<p>In Kapitel 12 haben wir ein Paket erstellt, das eine binäre Kiste und eine
Bibliothekskiste enthält. Während dein Projekt entwickelt wird, wirst du
möglicherweise feststellen, dass die Bibliothekskiste immer größer wird und du
dein Paket weiter in mehrere Bibliothekskisten aufteilen möchtest. Cargo bietet
eine Funktion namens <em>Arbeitsbereiche</em> (workspaces), mit denen mehrere
verwandte Pakete verwaltet werden können, die gemeinsam entwickelt werden.</p>
<h3 id="einen-arbeitsbereich-erstellen"><a class="header" href="#einen-arbeitsbereich-erstellen">Einen Arbeitsbereich erstellen</a></h3>
<p>Ein <em>Arbeitsbereich</em> ist eine Reihe von Paketen, die dieselbe Datei
<em>Cargo.lock</em> sowie dasselbe Ausgabeverzeichnis (output directory) verwenden.
Lass uns mithilfe eines Arbeitsbereiches ein Projekt erstellen. Wir verwenden
einfachen Programmcode, damit wir uns auf die Struktur des Arbeitsbereiches
konzentrieren können. Es gibt verschiedene Möglichkeiten, einen Arbeitsbereich
zu strukturieren. Wir werden nur einen einen üblichen Weg zeigen. Wir haben
einen Arbeitsbereich mit einer Binärdatei und zwei Bibliotheken. Die Binärdatei
stellt die Hauptfunktion bereit und hängt von den beiden Bibliotheken ab. Eine
Bibliothek stellt die Funktion <code>add_one</code> und eine andere Bibliothek die
Funktion <code>add_two</code> zur Verfügung. Diese drei Kisten werden Teil desselben
Arbeitsbereichs sein. Zunächst erstellen wir ein neues Verzeichnis für den
Arbeitsbereich:</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>Als Nächstes erstellen wir im Verzeichnis <em>add</em> die Datei <em>Cargo.toml</em>, mit der
der gesamte Arbeitsbereich konfiguriert wird. Diese Datei enthält keine
Abschnitt <code>[package]</code>. Stattdessen beginnt sie mit einem Abschnitt
<code>[workspace]</code>, in dem wir Mitglieder zum Arbeitsbereich hinzufügen können. Wir
stellen außerdem sicher, dass wir die neueste und beste Version des
Cargo-Auflösungsalgorithmus in unserem Arbeitsbereich verwenden, indem wir
<code>resolver</code> auf <code>"3"</code> setzen.</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]
resolver = "3"
</code></pre>
<p>Als nächstes erstellen wir die Binärkiste <code>adder</code>, indem wir <code>cargo new</code> im
Verzeichnis <em>add</em> ausführen:</p>
<pre><code class="language-console">$ cargo new adder
    Creating binary (application) `adder` package
      Adding `adder` as member of workspace at `file:///projects/add`
</code></pre>
<p>Wenn du <code>cargo new</code> innerhalb eines Arbeitsbereichs ausführst, wird das neu
erstellte Paket automatisch zum Schlüssel <code>members</code> in der Definition
<code>[workspace]</code> der Datei <code>Cargo.toml</code> hinzugefügt, etwa so:</p>
<pre><code class="language-toml">[workspace]
resolver = "3"
members = ["adder"]
</code></pre>
<p>An dieser Stelle können wir den Arbeitsbereich erstellen, indem wir <code>cargo  build</code> ausführen. Die Dateien in deinem <em>add</em>-Verzeichnis sollten
folgendermaßen aussehen:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>Der Arbeitsbereich verfügt auf der obersten Ebene über ein <em>Zielverzeichnis</em>
(target), in das die kompilierten Artefakte abgelegt werden; das Paket
<code>adder</code> hat kein eigenes <em>Zielverzeichnis</em>. Selbst wenn wir <code>cargo build</code> aus
dem Verzeichnis <em>adder</em> heraus ausführen würden, landen die kompilierten
Artefakte noch immer in <em>add/target</em> und nicht in <em>add/adder/target</em>. Cargo
strukturiert das <em>Zielverzeichnis</em> in einem derartigen Arbeitsverzeichnis, da
die Kisten voneinander abhängig sein sollen. Wenn jede Kiste ihr eigenes
<em>Zielverzeichnis</em> hätte, müssten für jede Kiste die anderen Kisten im
Arbeitsbereich neu kompiliert werden, damit die Artefakte ein eigenes
<em>Zielverzeichnis</em> haben könnten. Durch die gemeinsame Nutzung eines
Verzeichnisses können die Kisten unnötig wiederholte Erstellung vermeiden.</p>
<h3 id="erstellen-des-zweiten-pakets-im-arbeitsbereich"><a class="header" href="#erstellen-des-zweiten-pakets-im-arbeitsbereich">Erstellen des zweiten Pakets im Arbeitsbereich</a></h3>
<p>Als Nächstes erstellen wir ein weiteres, dem Arbeitsbereich zugehöriges Paket
und nennen es <code>add_one</code>. Erzeuge eine neue Bibliothekskiste namens <code>add_one</code>:</p>
<pre><code class="language-console">$ cargo new add_one --lib
    Creating library `add_one` package
      Adding `add_one` as member of workspace at `file:///projects/add`
</code></pre>
<p>Die Datei <em>Cargo.toml</em> auf der obersten Ebene enthält nun den Pfad <em>add_one</em> in
der Liste <code>members</code>:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]
resolver = "3"
members = ["adder", "add_one"]
</code></pre>
<p>Dein Verzeichnis <em>add</em> sollte nun so aussehen:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>Lass uns in der Datei <em>add_one/src/lib.rs</em>, eine Funktion <code>add_one</code> hinzufügen.</p>
<p><span class="filename">Dateiname: add_one/src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p>Nun können wir das <code>adder</code>-Paket von unserem <code>add_one</code>-Paket, das unsere
Bibliothek enthält, abhängig machen. Zuerst müssen wir <em>adder/Cargo.toml</em> einen
Pfad zur Abhängigkeit von <code>add_one</code> hinzufügen.</p>
<p><span class="filename">Dateiname: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
add_one = { path = "../add_one" }
</code></pre>
<p>Cargo geht nicht davon aus, dass Kisten in einem Arbeitsbereich voneinander
abhängen, daher müssen wir die Abhängigkeit explizit angeben.</p>
<p>Als nächstes verwenden wir die Funktion <code>add_one</code> (aus der <code>add_one</code>-Kiste) in
der <code>adder</code>-Kiste. Öffne die Datei <em>adder/src/main.rs</em> und ändere die Funktion
<code>main</code>, um die Funktion <code>add_one</code> aufzurufen, siehe Codeblock 14-7.</p>
<p><span class="filename">Dateiname: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let num = 10;
    println!("Hello, world! {num} plus one is {}!", add_one::add_one(num));
}</code></pre>
<p><span class="caption">Codeblock 14-7: Die <code>add_one</code>-Bibliothekskiste in der
Kiste <code>adder</code> verwenden</span></p>
<p>Erstellen wir den Arbeitsbereich, indem wir <code>cargo build</code> im obersten
Verzeichnis <em>add</em> ausführen!</p>
<pre><code class="language-console">$ cargo build
  Compiling add_one v0.1.0 (file:///projects/add/add_one)
  Compiling adder v0.1.0 (file:///projects/add/adder)
   Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<p>Um die Binärkiste aus dem Verzeichnis <em>add</em> auszuführen, können wir mithilfe
des Arguments <code>-p</code> und des Paketnamens mit <code>cargo run</code> angeben, welches Paket
im Arbeitsbereich ausgeführt werden soll:</p>
<pre><code class="language-console">$ cargo run -p adder
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>Dadurch wird der Programmcode in <em>adder/src/main.rs</em> ausgeführt, der von der
Kiste <code>add_one</code> abhängt.</p>
<h4 id="abhängigkeiten-zu-externen-paketen-in-einem-arbeitsbereich"><a class="header" href="#abhängigkeiten-zu-externen-paketen-in-einem-arbeitsbereich">Abhängigkeiten zu externen Paketen in einem Arbeitsbereich</a></h4>
<p>Beachte, dass der Arbeitsbereich nur eine Datei <em>Cargo.lock</em> auf der obersten
Ebene enthält, anstatt einer in jeder Kiste. Dies stellt sicher, dass alle
Kisten dieselbe Version aller Abhängigkeiten verwenden. Wenn wir das Paket
<code>rand</code> zu den Dateien <em>adder/Cargo.toml</em> und <em>add_one/Cargo.toml</em> hinzufügen,
löst Cargo beide dieser Versionen zu einer auf und fügt diese in der
<em>Cargo.lock</em>-Datei hinzu. Wenn alle Kisten im Arbeitsbereich dieselben
Abhängigkeiten verwenden, sind die Kisten immer miteinander kompatibel. Lass
uns die Kiste <code>rand</code> in der Datei <em>add_one/Cargo.toml</em> zum Abschnitt
<code>[dependencies]</code> hinzufügen, damit wir die Kiste <code>rand</code> in der Kiste <code>add_one</code>
verwenden können:</p>
<p><span class="filename">Dateiname: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>Wir können nun <code>use rand;</code> zur Datei <em>add_one/src/lib.rs</em> hinzufügen, und wenn
du den gesamten Arbeitsbereich durch Ausführen von <code>cargo build</code> im Verzeichnis
<em>add</em> erstellst, wird die Kiste <code>rand</code> eingefügt und kompiliert. Wir erhalten
eine Warnung, weil wir nicht auf <code>rand</code> referenzieren, das wir in den
Gültigkeitsbereich gebracht haben:</p>
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --abschneiden--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `add_one` (lib) generated 1 warning (run `cargo fix --lib -p add_one` to apply 1 suggestion)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<p>Die Datei <em>Cargo.lock</em> der obersten Ebene enthält nun Informationen über die
Abhängigkeit von <code>add_one</code> von <code>rand</code>. Obwohl <code>rand</code> irgendwo im Arbeitsbereich
verwendet wird, können wir es nicht in anderen Kisten im Arbeitsbereich
verwenden, es sei denn, wir fügen <code>rand</code> zu ihren <em>Cargo.toml</em>-Dateien hinzu.
Wenn wir beispielsweise <code>use rand;</code> zur Datei <em>adder/src/main.rs</em> für das Paket
<code>adder</code> hinzufügen, wird folgende Fehlermeldung angezeigt:</p>
<pre><code class="language-console">$ cargo build
  --abschneiden--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>Um dies zu beheben, bearbeiten wir die Datei <em>Cargo.toml</em> für das Paket <code>adder</code>
und geben an, dass <code>rand</code> auch eine Abhängigkeit davon ist. Durch das Erstellen
des Pakets <code>adder</code> wird <code>rand</code> zur Liste der Abhängigkeiten für <code>adder</code> in
<em>Cargo.lock</em> hinzugefügt, es werden jedoch keine zusätzlichen Kopien von <code>rand</code>
heruntergeladen. Cargo stellt sicher, dass jede Kiste in jedem Paket im
Arbeitsbereich, das das <code>rand</code>-Paket verwendet, die gleiche Version verwendet,
solange sie kompatible Versionen von <code>rand</code> angeben, was uns Platz spart und
sicherstellt, dass die Kisten im Arbeitsbereich miteinander kompatibel sind.</p>
<p>Wenn Kisten im Arbeitsbereich inkompatible Versionen der gleichen Abhängigkeit
angeben, löst Cargo jede von ihnen auf, versucht aber trotzdem, so wenige
Versionen wie möglich aufzulösen.</p>
<h4 id="hinzufügen-eines-tests-zu-einem-arbeitsbereich"><a class="header" href="#hinzufügen-eines-tests-zu-einem-arbeitsbereich">Hinzufügen eines Tests zu einem Arbeitsbereich</a></h4>
<p>Füge für eine weitere Verbesserung innerhalb der <code>add_one</code>-Kiste einen Test der
Funktion <code>add_one::add_one</code> hinzu:</p>
<p><span class="filename">Dateiname: add_one/src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Führen wir nun <code>cargo test</code> in der obersten Ebene im Verzeichnis <em>add</em> aus. Die
Ausführung von <code>cargo test</code> in einem Arbeitsbereich, der wie dieser
strukturiert ist, führt die Tests für alle Kisten im Arbeitsbereich aus:</p>
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Der erste Abschnitt der Ausgabe zeigt, dass der Test <code>it_works</code> in der Kiste
<code>add_one</code> bestanden wurde. Der nächste Abschnitt zeigt, dass in der Kiste
<code>adder</code> keine Tests gefunden wurden, und der letzte Abschnitt zeigt, dass in
der Kiste <code>add_one</code> keine Dokumentationstests gefunden wurden.</p>
<p>Wir können auch Tests für eine bestimmte Kiste in einem Arbeitsbereich aus dem
Verzeichnis der obersten Ebene ausführen, indem wir die Option <code>-p</code> verwenden
und den Namen der Kiste angeben, die wir testen möchten:</p>
<pre><code class="language-console">$ cargo test -p add_one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Die Ausgabe zeigt, dass <code>cargo test</code> nur die Tests der Kiste <code>add_one</code> aber
nicht der Kiste <code>adder</code> ausgeführt hat.</p>
<p>Wenn du die Kisten im Arbeitsbereich unter <a href="https://crates.io/">crates.io</a> veröffentlichst,
muss jede Kiste im Arbeitsbereich separat veröffentlicht werden. Der Befehl
<code>cargo publish</code> hat keine Option <code>--all</code> oder <code>-p</code>, daher musst du in das
Verzeichnis jeder Kiste wechseln und <code>cargo publish</code> für jede Kiste im
Arbeitsbereich ausführen, um die Kisten zu veröffentlichen.</p>
<p>Als zusätzliche Übung, füge ähnlich der Kiste <code>add_one</code> diesem Arbeitsbereich
eine Kiste <code>add-two</code> hinzu!</p>
<p>Wenn dein Projekt wächst, solltest du einen Arbeitsbereich verwenden: Es
ermöglicht dir, mit kleineren, leichter zu verstehenden Komponenten zu arbeiten
als mit einem großen Klumpen von Code. Darüber hinaus kann die Verwaltung von
Kisten in einem Arbeitsbereich die Koordination zwischen Kisten erleichtern,
wenn sie häufig zur gleichen Zeit verändert werden.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installieren-von-binärdateien-mit--cargo-install"><a class="header" href="#installieren-von-binärdateien-mit--cargo-install">Installieren von Binärdateien mit  <code>cargo install</code></a></h2>
<p>Mit dem Befehl <code>cargo install</code> kannst du Binärkisten installieren und
verwenden. Dies soll keine Systempakete ersetzen, sondern soll Rust-Entwicklern
eine bequeme Möglichkeit bieten, Tools zu installieren, die andere auf
<a href="https://crates.io/">crates.io</a> veröffentlicht haben. Beachte, dass du nur binäre Pakete
installieren kannst, das heißt in der Kiste muss eine Datei <em>src/main.rs</em> oder
eine andere als binär spezifizierte Datei vorhanden sein, und nicht nur eine
Bibliothek, die alleine nicht ausführbar ist sondern zur Aufnahme in andere
Programme geeignet ist. Für gewöhnlich enthalten Kisten eine <em>README</em>-Datei mit
Informationen darüber ob die Datei ausführbar ist, eine Bibliothek enthält oder
beides.</p>
<p>Alle mit <code>cargo install</code> installierten Binärdateien werden im Verzeichnis <em>bin</em>
des Wurzelverzeichnisses der Installation gespeichert. Wenn du die Installation
mit <em>rustup.rs</em> durchgeführt und keine benutzerdefinierte Konfiguration
hast, lautet dieses Verzeichnis <code>$HOME/.cargo/bin</code>. Stelle sicher, dass sich
dieses Verzeichnis in deinem <code>$PATH</code> befindet, damit du Programme ausführen
kannst, die du mit <code>cargo install</code> installiert hast.</p>
<p>In Kapitel 12 haben wir beispielsweise erwähnt, dass es eine
Rust-Implementierung namens <code>ripgrep</code> des Werkzeugs <code>grep</code> zum Durchsuchen von
Dateien gibt. Um <code>ripgrep</code> zu installieren, führen wir Folgendes aus:</p>
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v13.0.0
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v13.0.0
--abschneiden--
   Compiling ripgrep v13.0.0
    Finished `release` profile [optimized + debuginfo] target(s) in 10.64s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
</code></pre>
<p>Die vorletzte Zeile der Ausgabe zeigt den Speicherort und den Namen der
installierten Binärdatei, der im Fall von <code>ripgrep</code> <code>rg</code> ist. Solange sich das
Installationsverzeichnis in deinem <code>$PATH</code> befindet, kannst du <code>rg --help</code>
ausführen und damit beginnen ein schnelleres, in Rust programmiertes
Werkzeug zum Durchsuchen von Dateien verwenden!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-um-benutzerdefinierte-befehle-erweitern"><a class="header" href="#cargo-um-benutzerdefinierte-befehle-erweitern">Cargo um benutzerdefinierte Befehle erweitern</a></h2>
<p>Cargo ist so konzipiert, dass man es mit neuen Unterbefehlen erweitern kann,
ohne Cargo ändern zu müssen. Wenn in deinem <code>$PATH</code> eine Binärdatei
<code>cargo-something</code> benannt wird, kannst du sie wie einen Unterbefehl von Cargo
ausführen, indem du <code>cargo something</code> ausführst. Benutzerdefinierte Befehle wie
dieser werden auch aufgelistet, wenn du <code>cargo --list</code> ausführst. Die
Möglichkeit, mithilfe von <code>cargo install</code> Erweiterungen zu installieren und
diese dann wie die integrierten Werkzeuge von Cargo auszuführen, ist ein
äußerst praktischer Vorteil des Cargo-Designs!</p>
<h2 id="zusammenfassung-13"><a class="header" href="#zusammenfassung-13">Zusammenfassung</a></h2>
<p>Das veröffentlichen von Programmcode mit Cargo und <a href="https://crates.io/">crates.io</a> ist Teil
dessen, was das Rust-Ökosystem für viele verschiedene Aufgaben nützlich macht.
Die Standardbibliothek von Rust ist klein und stabil, aber Kisten können
einfach geteilt, verwendet und auf einer von der Sprache unterschiedlichen
Zeitlinie verbessert werden. Scheue dich nicht, Programmcode von
<a href="https://crates.io/">crates.io</a>, der für dich nützlich ist, zu veröffentlichen. Es ist
wahrscheinlich, dass er auch für andere nützlich sein wird!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intelligente-zeiger"><a class="header" href="#intelligente-zeiger">Intelligente Zeiger</a></h1>
<p>Ein <em>Zeiger</em> ist im Allgemeinen ein Konzept für eine Variable, die eine
Speicheradresse enthält. Diese Adresse referenziert oder „zeigt“ auf andere
Daten. Die häufigste Art von Zeigern in Rust ist eine Referenz, die wir bereits
in Kapitel 4 kennengelernt haben. Referenzen werden durch das Symbol <code>&amp;</code>
gekennzeichnet und leihen (borrow) den Wert auf den sie zeigen aus. Sie haben
außer dem Referenzieren auf Daten keine besondere Funktionalität und
verursachen keinen Mehraufwand (overhead).</p>
<p><em>Intelligente Zeiger</em> (smart pointers) sind hingegen Datenstrukturen, die wie
ein Zeiger funktionieren, und über zusätzliche Metadaten und Funktionalitäten
verfügen. Das Konzept der intelligenten Zeiger gibt es nicht nur in Rust, es
stammt aus C++ und ist auch in anderen Sprachen vorhanden. Rust hat diverse
intelligente Zeiger, die in der Standardbibliothek definiert sind und
Funktionalitäten haben, die über die durch Referenzen bereitgestellten
Möglichkeiten hinausgehen. Um das allgemeine Konzept zu erkunden, werden wir
uns verschiedene Beispiele mit intelligenten Zeigern ansehen, darunter einen
<em>referenzzählenden</em> (reference counting) intelligenten Zeigertyp. Dieser Zeiger
ermöglicht es, dass Daten mehrere Eigentümer (owner) haben können, indem er die
Anzahl der Eigentümer verfolgt und die Daten erst dann aufräumt, wenn keine
Eigentümer mehr vorhanden sind.</p>
<p>Da Rust das Konzept der Eigentümerschaft (ownership) und Ausleihen
(borrowing) verwendet, besteht ein zusätzlicher Unterschied zwischen Referenzen
und intelligenten Zeigern: Während Referenzen Zeiger sind, die Daten nur
ausleihen, <em>besitzen</em> intelligente Zeiger in vielen Fällen die Eigentümerschaft
der Daten, auf die sie zeigen.</p>
<p>Obwohl wir sie nicht so genannt haben, sind wir in diesem Buch bereits auf
einige intelligente Zeiger gestoßen, z.B. <code>String</code> und <code>Vec&lt;T&gt;</code> in Kapitel 8.
Diese beiden Typen zählen zu den intelligenten Zeigern, da sie etwas
Arbeitsspeicher besitzen und es dir ermöglichen, diesen zu manipulieren. Sie
verfügen auch über Metadaten und zusätzliche Fähigkeiten oder Garantien.
<code>String</code> speichert beispielsweise seine Kapazität als Metadaten und hat die
zusätzliche Fähigkeit, sicherzustellen, dass seine Daten immer gültiges UTF-8
enthalten.</p>
<p>Intelligente Zeiger werden normalerweise mithilfe von Strukturen implementiert.
Im Unterschied zu einer gewöhnlichen Struktur (struct) implementieren
intelligente Zeiger die Merkmale <code>Deref</code> und <code>Drop</code>. Das Merkmal <code>Deref</code>
ermöglicht es einer Instanz eines intelligenten Zeigers, sich wie eine Referenz
zu verhalten, sodass du Programmcode schreiben kannst, der entweder mit
Referenzen oder intelligenten Zeigern funktioniert. Mit dem Merkmal <code>Drop</code>
kannst du den Programmcode anpassen, der ausgeführt wird, wenn eine Instanz des
intelligenten Zeigers den Gültigkeitsbereich (scope) verlässt. In diesem
Kapitel werden wir beide Merkmale besprechen und zeigen, warum sie für
intelligente Zeiger wichtig sind.</p>
<p>Da das Muster des intelligenten Zeigers ein allgemeines Entwurfsmuster ist, das
in Rust häufig verwendet wird, werden in diesem Kapitel nicht alle vorhandenen
intelligenten Zeiger behandelt. Viele Bibliotheken haben ihre eigenen
intelligenten Zeiger, und du kannst sogar deine eigenen schreiben. Wir werden
die am häufigsten verwendeten intelligenten Zeiger der Standardbibliothek
behandeln:</p>
<ul>
<li><code>Box&lt;T&gt;</code> zum Zuweisen von Werten auf dem Heap</li>
<li><code>Rc&lt;T&gt;</code>, ein Typ der Referenzen zählt und dadurch mehrfache Eigentümerschaft
ermöglicht</li>
<li><code>Ref&lt;T&gt;</code> und <code>RefMut&lt;T&gt;</code> mit Zugriff über <code>RefCell&lt;T&gt;</code>, ein Typ, der das
Einhalten der Ausleihregel zur Laufzeit (runtime) statt zur Kompilierzeit
erzwingt.</li>
</ul>
<p>Darüber hinaus wird das <em>innere Veränderbarkeitsmuster</em> (interior mutability
pattern) behandelt, bei dem ein unveränderbarer Typ eine API zum Verändern
eines inneren Werts bereitstellt. Wir werden auch <em>Referenzzyklen</em> besprechen,
wie sie Speicherverlust verursachen können und wie wir das verhindert können.</p>
<p>Lass uns in die Themen eintauchen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mit-boxt-auf-daten-im-haldenspeicher-heap-zeigen"><a class="header" href="#mit-boxt-auf-daten-im-haldenspeicher-heap-zeigen">Mit <code>Box&lt;T&gt;</code> auf Daten im Haldenspeicher (heap) zeigen</a></h2>
<p>Der einfachste intelligente Zeiger ist <em>Box</em>, deren Typ <code>Box&lt;T&gt;</code> lautet. In
Boxen kann man Daten statt auf dem Stapelspeicher (stack) im Haldenspeicher
(heap) speichern. Was auf dem Stapelspeicher verbleibt, ist der Zeiger auf die
Daten im Haldenspeicher. In Kapitel 4 findest du Informationen zum Unterschied
zwischen dem Stapelspeicher und dem Haldenspeicher.</p>
<p>Boxen haben keinen Performanz-Overhead, außer dass die Daten auf
den Haldenspeicher anstatt auf dem Stapelspeicher gespeichert werden, aber
sie haben auch nicht viele zusätzliche Funktionalitäten. Sie werden am
häufigsten in folgenden Situationen verwendet:</p>
<ul>
<li>Wenn man einen Typ hat, dessen Größe zum Zeitpunkt der Kompilierung nicht
bekannt ist, und man einen Wert dieses Typs in einem Kontext verwenden
möchte, für den eine genaue Größe erforderlich ist.</li>
<li>Wenn man über eine große Datenmenge verfügt und die Eigentümerschaft
(ownership) übertragen möchte und sicherstellen will, dass die Daten dabei
nicht kopiert werden.</li>
<li>Wenn man einen Wert besitzen und sich nur darum kümmern möchte, dass es sich
um einen Typ handelt, der ein bestimmtes Merkmal implementiert, anstatt den
Typ zu spezifizieren.</li>
</ul>
<p>Wir werden die erste Situation in <a href="ch15-01-box.html#erm%C3%B6glichen-rekursiver-typen-mit-boxen">„Ermöglichen rekursiver Typen mit
Boxen“</a> zeigen. Im zweiten Fall kann
die Übertragung der Eigentümerschaft einer großen Datenmenge lange dauern, da
die Daten auf dem Stapelspeicher kopiert werden. Um die Performanz in dieser
Situation zu verbessern, können wir die große Datenmenge auf dem Haldenspeicher
in einer Box speichern. Dann wird nur die kleine Menge von Zeigerdaten auf dem
Stapelspeicher kopiert, während die Daten, auf die referenziert wird, im
Haldenspeicher an einer Stelle verbleiben. Der dritte Fall ist als
<em>Merkmalsobjekt</em> (trait object) bekannt, und <a href="ch18-02-trait-objects.html">„Merkmalsobjekte (trait objects)
die Werte unterschiedlicher Typen erlauben“</a> in Kapitel 18
widmet sich diesem Thema. Was du hier lernst, wirst du in diesem Abschnitt
erneut anwenden!</p>
<h3 id="boxt-verwenden-um-daten-im-haldenspeicher-zu-speichern"><a class="header" href="#boxt-verwenden-um-daten-im-haldenspeicher-zu-speichern"><code>Box&lt;T&gt;</code> verwenden um Daten im Haldenspeicher zu speichern</a></h3>
<p>Bevor wir den Haldenspeicher-Anwendungsfall für <code>Box&lt;T&gt;</code> besprechen, werden wir
die Syntax und die Interaktion mit Werten behandeln, die in einer <code>Box&lt;T&gt;</code>
gespeichert sind.</p>
<p>Codeblock 15-1 zeigt, wie man mit einer Box einen <code>i32</code>-Wert auf dem
Haldenspeicher speichert:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}</code></pre></pre>
<p><span class="caption">Codeblock 15-1: Speichern eines <code>i32</code>-Wertes in einer Box
im Haldenspeicher</span></p>
<p>Wir definieren die Variable <code>b</code> so, dass sie den den Wert einer <code>Box</code> hat die
auf den Wert <code>5</code> zeigt, der auf dem Haldenspeicher allokiert ist. Dieses
Programm gibt <code>b = 5</code> aus, in diesem Fall können wir auf die Daten in der Box
zugreifen, ähnlich als würden sich die Daten im Stapelspeicher befinden. Genau
wie bei Werten mit Eigentümerschaft wird auch eine Box freigegeben, wenn sie
den Gültigkeitsbereich verlässt, wie dies bei <code>b</code> am Ende von <code>main</code> der Fall
ist. Die Freigabe erfolgt sowohl für die Box (gespeichert im Stapelspeicher)
als auch für die Daten, auf die sie zeigt (gespeichert im Haldenspeicher).</p>
<p>Es ist nicht besonders hilfreich, einen einzelnen Wert im Haldenspeicher zu
speichern, daher verwendet man Boxen selten alleine. Meistens ist es besser,
Werte wie eine <code>i32</code> auf dem Stapelspeicher zu haben, wo sie standardmäßig
gespeichert werden. Sehen wir uns einen Fall an, in dem Boxen es uns
ermöglichen, Typen zu definieren, die wir nicht hätten, wenn es keine Boxen
gäbe.</p>
<h3 id="ermöglichen-rekursiver-typen-mit-boxen"><a class="header" href="#ermöglichen-rekursiver-typen-mit-boxen">Ermöglichen rekursiver Typen mit Boxen</a></h3>
<p>Ein Wert eines <em>rekursiven Typs</em> kann einen anderen Wert desselben Typs als
Teil von sich selbst haben. Rekursive Typen stellen ein Problem dar, weil Rust
zur Kompilierzeit wissen muss, wie viel Platz ein Typ einnimmt. Allerdings
könnte die Verschachtelung von Werten rekursiver Typen theoretisch unendlich
weitergehen, sodass Rust nicht wissen kann, wie viel Platz der Wert benötigt.
Da Boxen eine bekannte Größe haben, können wir rekursive Typen ermöglichen,
indem wir eine Box in die Definition des rekursiven Typs einfügen.</p>
<p>Als Beispiel für einen rekursiven Typ wollen wir uns die <em>Cons-Liste</em> ansehen.
Dies ist ein Datentyp, den man häufig in funktionalen Programmiersprachen
findet. Der Cons-Listen-Typ, den wir definieren werden, ist bis auf die
Rekursion einfach; daher werden die Konzepte in dem Beispiel, mit dem wir
arbeiten werden, immer dann nützlich sein, wenn du in komplexeren Situationen
mit rekursiven Typen arbeitest.</p>
<h4 id="weitere-informationen-zur-cons-liste"><a class="header" href="#weitere-informationen-zur-cons-liste">Weitere Informationen zur Cons-Liste</a></h4>
<p>Eine <em>Cons-Liste</em> ist eine Datenstruktur, die aus der Programmiersprache Lisp
und ihren Dialekten stammt und aus verschachtelten Paaren besteht. Sie ist die
Lisp-Version einer verketteten Liste. Ihr Name stammt von der Funktion <code>cons</code>
(Kurzform von „construct function“) in Lisp, die aus ihren beiden Argumenten
ein neues Paar konstruiert. Durch den Aufruf von <code>cons</code> für ein Paar, das aus
einem Wert und einem anderen Paar besteht, können wir Cons-Listen konstruieren,
die aus rekursiven Paaren bestehen.</p>
<p>Hier ist zum Beispiel eine Pseudocode-Darstellung einer Cons-Liste, die die
Liste <code>1, 2, 3</code> enthält, wobei jedes Paar in Klammern steht:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Jedes Element in einer Cons-Liste enthält zwei Elemente: Den Wert des aktuellen
Elements und das nächste Element. Das letzte Element in der Liste enthält nur
ein Element namens <code>Nil</code> ohne ein nächstes Element. Eine Cons-Liste wird durch
rekursives Aufrufen der Funktion <code>cons</code> erstellt. Der kanonische Name für den
Basisfall der Rekursion lautet <code>Nil</code>. Beachte, dass dies nicht mit dem Konzept
„null“ oder „nil“ in Kapitel 6 identisch ist, das einen fehlenden oder
ungültigen Wert darstellt.</p>
<p>Die Cons-Liste ist keine häufig verwendete Datenstruktur in Rust. Wenn man in
Rust eine Liste von Elementen hat, ist <code>Vec&lt;T&gt;</code> die bessere Wahl. Andere,
komplexere rekursive Datentypen sind in verschiedenen Situationen nützlich.
Wenn wir jedoch mit der Cons-Liste beginnen, können wir untersuchen, wie Boxen
es uns ermöglichen, ohne grosse Ablenkung einen rekursiven Datentyp zu
definieren.</p>
<p>Codeblock 15-2 enthält eine Aufzählungsdefinition (enum) für eine Cons-Liste.
Beachte, dass dieser Code nicht kompiliert werden kann, da der Typ <code>List</code> keine
bekannte Größe hat, wie wir nachfolgend sehen werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-2: Der erste Versuch eine Aufzählung zu
definieren, um eine Datenstruktur der Cons-Liste von <code>i32</code>-Werten
darzustellen</span></p>
<blockquote>
<p>Hinweis: Für dieses Beispiel implementieren wir eine Cons-Liste, die nur
<code>i32</code>-Werte enthält. Wir hätten sie mit generischen Typen implementieren
können wie wir es in Kapitel 10 besprochen haben, um eine Cons-Liste zu
erstellen, in der Werte eines beliebigen Typs gespeichert werden können.</p>
</blockquote>
<p>Die Verwendung des Typs <code>List</code>, um die Liste <code>1, 2, 3</code> zu speichern, würde wie
in Codeblock 15-3 aussehen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre></pre>
<p><span class="caption">Codeblock 15-3: Verwendung der <code>List</code>-Aufzählung um die
Liste <code>1, 2, 3</code> zu speichern</span></p>
<p>Der erste <code>Cons</code>-Wert enthält <code>1</code> und einen anderen <code>List</code>-Wert. Dieser
<code>List</code>-Wert ist ein weiterer <code>Cons</code>-Wert, der <code>2</code> und einen anderen <code>List</code>-Wert
enthält. Dieser <code>List</code>-Wert ist wiederum ein <code>Cons</code>-Wert, der <code>3</code> enthält und
ein <code>List</code>, das schließlich <code>Nil</code> ist – die nicht-rekursive Variante, die
das Ende der Liste signalisiert.</p>
<p>Wenn wir versuchen den Programmcode in Codeblock 15-3 zu kompilieren,
erhalten wir den Fehler der in Codeblock 15-4 gezeigt wird.</p>
<p><span class="filename">Dateiname: output.txt</span></p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
</code></pre>
<p><span class="caption">Codeblock 15-4: Der Fehler den wir erhalten wenn wir
versuchen eine rekursive Aufzählung zu definieren</span></p>
<p>Der Fehler zeigt, dass dieser Typ „unendlich groß“ ist. Der Grund dafür ist,
dass wir <code>List</code> mit einer rekursiven Variante definiert haben, sie enthält
direkt einen anderen Wert von sich selbst, daher kann Rust nicht herausfinden,
wie viel Speicherplatz zum Speichern eines Listenwerts erforderlich ist. Lass
uns zusammenfassen, warum wir diesen Fehler bekommen. Schauen wir uns zunächst
an, wie Rust ermittelt, wie viel Speicherplatz zum Speichern des Werts eines
nicht-rekursiven Typs benötigt wird.</p>
<h4 id="die-größe-eines-nicht-rekursiven-typs-berechnen"><a class="header" href="#die-größe-eines-nicht-rekursiven-typs-berechnen">Die Größe eines nicht-rekursiven Typs berechnen</a></h4>
<p>Erinnere dich an die in Codeblock 6-2 definierte <code>Message</code>-Aufzählung, als wir
die Definition von Aufzählungen in Kapitel 6 besprochen haben:</p>
<pre><pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Um zu bestimmen, wie viel Speicherplatz für einen <code>Message</code>-Wert benötigt wird,
analysiert Rust alle Varianten, um festzustellen, welche Variante den meisten
Speicherplatz benötigt. Rust erkennt, dass <code>Message::Quit</code> keinen Speicherplatz
benötigt, und <code>Message::Move</code> so viel Speicherplatz braucht um zwei <code>i32</code>-Werte
zu speichern, und so weiter. Da nur eine Variante verwendet wird, ist der
Speicherbedarf, den ein <code>Message</code>-Wert benötigt, gleich dem Speicherplatz, der
zum Speichern der größten Variante benötigt wird.</p>
<p>Übertrage das auf den Fall, bei dem Rust zu bestimmen versucht, wie viel
Speicherplatz ein rekursiver Typ wie die Aufzählung <code>List</code> in Codeblock 15-2
benötigt. Der Compiler betrachtet zunächst die Variante <code>Cons</code>, die einen Typ
<code>i32</code> und einen Wert vom Typ <code>List</code> enthält. Daher benötigt <code>Cons</code>
Speicherplatz, der der Größe eines <code>i32</code> plus der Größe einer <code>List</code>
entspricht. Um herauszufinden, wie viel Speicher der Typ <code>List</code> benötigt,
betrachtet der Compiler die Varianten, beginnend mit der Variante <code>Cons</code>. Die
Variante <code>Cons</code> enthält einen Typ <code>i32</code> und einen Wert vom Typ <code>List</code>. Dieser
Vorgang wird wie in Abbildung 15-1 dargestellt, unendlich fortgesetzt.</p>
<img alt="Eine unendliche Cons-Liste" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 15-1: Ein unendlicher <code>List</code>-Typ der aus
unendlichen <code>Cons</code>-Varianten besteht</span></p>
<h4 id="verwenden-von-boxt-um-einen-rekursiven-typ-mit-einer-bekannten-größe-zu-erhalten"><a class="header" href="#verwenden-von-boxt-um-einen-rekursiven-typ-mit-einer-bekannten-größe-zu-erhalten">Verwenden von <code>Box&lt;T&gt;</code>, um einen rekursiven Typ mit einer bekannten Größe zu erhalten</a></h4>
<p>Da Rust nicht herausfinden kann, wie viel Speicherplatz für rekursiv definierte
Typen reserviert werden muss, gibt der Compiler eine Fehlermeldung mit diesem
hilfreichen Vorschlag aus:</p>
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>In diesem Hinweis bedeutet „indirection“ (Umweg), dass die Datenstruktur den
Wert nicht direkt speichern soll, sondern indirekt, indem stattdessen ein
Zeiger auf den Wert gespeichert wird.</p>
<p>Da eine <code>Box&lt;T&gt;</code> ein Zeiger ist, weiß Rust immer, wie viel Platz eine <code>Box&lt;T&gt;</code>
benötigt: Die Größe eines Zeigers ändert sich nicht basierend auf der
Datenmenge, auf die er zeigt. Dies bedeutet, dass wir anstelle eines anderen
<code>List</code>-Wertes direkt eine <code>Box&lt;T&gt;</code> in die <code>Cons</code>-Variante einfügen können. Die
<code>Box&lt;T&gt;</code> zeigt auf den nächsten <code>List</code>-Wert, der sich auf dem Haldenspeicher
befindet und nicht in der <code>Cons</code>-Variante. Konzeptionell haben wir immer noch
eine Liste, die mit Listen erstellt wurde, die andere Listen enthalten. Diese
Implementierung ähnelt nun eher dem Platzieren der Elemente nebeneinander als
ineinander.</p>
<p>Wir können die Definition der Liste <code>List</code> in Codeblock 15-2 und die Verwendung
von <code>List</code> in Codeblock 15-3 in den Programmcode von Codeblock 15-5 ändern, der
kompilieren wird.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<p><span class="caption">Codeblock 15-5: Definition von <code>List</code>, die <code>Box&lt;T&gt;</code>
benutzt, um eine bekannte Größe zu haben</span></p>
<p>Die <code>Cons</code>-Variante benötigt die Größe eines <code>i32</code> plus Platz zum Speichern der
Zeigerdaten der Box. Die <code>Nil</code>-Variante speichert keine Werte und benötigt
daher weniger Speicher als die <code>Cons</code>-Variante. Wir wissen nun, dass jeder
<code>List</code>-Wert die Größe eines <code>i32</code> plus die Größe der Zeigerdaten einer Box
annimmt. Durch Verwenden einer Box haben wir die unendliche, rekursive Kette
unterbrochen, sodass der Compiler die Größe ermitteln kann, die zum Speichern
eines Listenwerts erforderlich ist. Abbildung 15-2 zeigt, wie die Variante
<code>Cons</code> jetzt aussieht.</p>
<img alt="Eine endliche Cons-Liste" src="img/trpl15-02.svg" class="center" style="width: 20%;" />
<p><span class="caption">Abbildung 15-2: Ein <code>List</code>-Typ, der keine unendliche
Größe hat, da <code>Cons</code> eine <code>Box</code> enthält</span></p>
<p>Boxen kümmern sich nur die Dereferenzierung und Speicherallokation auf dem
Haldenspeicher, haben aber keine weiteren speziellen Funktionalitäten, wie wir
sie bei anderen intelligenten Zeigertypen sehen werden. Sie haben aber auch
keinen Performanz-Overhead, der mit diesen zusätzlichen Funktionalitäten
verbunden ist. Daher können sie in Fällen wie der Cons-Liste nützlich sein, in
denen die Dereferenzierung die einzige Funktionalität ist, die wir benötigen.
Weitere Anwendungsfälle für Boxen werden wir uns auch in Kapitel 18 ansehen.</p>
<p>Der Typ <code>Box&lt;T&gt;</code> ist ein intelligenter Zeiger, da er das Merkmal <code>Deref</code>
implementiert, mit dem <code>Box&lt;T&gt;</code>-Werte wie Referenzen behandelt werden können.
Wenn ein <code>Box&lt;T&gt;</code>-Wert den Gültigkeitsbereich verlässt, werden die Daten am
Haldenspeicher, auf die die Box zeigt, aufgrund der Implementierung des
Merkmals <code>Drop</code> ebenfalls aufgeräumt. Diese beiden Merkmale sind für die
Funktionalität der anderen intelligenten Zeigertypen, die wir im restlichen
Kapitel erläutern, noch wichtiger. Lass uns diese beiden Merkmale genauer
untersuchen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="intelligente-zeiger-wie-normale-referenzen-behandeln-mit-dem-merkmal-trait-deref"><a class="header" href="#intelligente-zeiger-wie-normale-referenzen-behandeln-mit-dem-merkmal-trait-deref">Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) <code>Deref</code></a></h2>
<p>Durch die Implementierung des Merkmals <code>Deref</code> kann man das Verhalten des
<em>Dereferenzierungsoperators</em> (dereference operator) <code>*</code> (nicht zu verwechseln
mit dem Multiplikations- oder Stern-Operator (glob operator)) anpassen. Indem
du <code>Deref</code> so implementierst, dass ein intelligenter Zeiger wie eine reguläre
Referenz behandelt werden kann, kannst du Programmcode schreiben, der mit
Referenzen arbeitet, und diesen Programmcode auch mit intelligenten Zeigern
verwenden.</p>
<p>Schauen wir uns zunächst an, wie der Dereferenzierungsoperator mit regulären
Referenzen arbeitet. Dann werden wir versuchen, einen benutzerdefinierten Typ
zu definieren, der sich wie <code>Box&lt;T&gt;</code> verhält, und herausfinden, warum der
Dereferenzierungsoperator nicht wie eine Referenz für unseren neu definierten
Typ funktioniert. Wir werden untersuchen, wie die Implementierung des Merkmals
<code>Deref</code> es intelligenten Zeigern ermöglicht, auf ähnliche Weise wie Referenzen
zu funktionieren, dann sehen wir uns an wie wir mit Rusts <em>automatischer
Umwandlung</em> (deref coercion) mit Referenzen oder intelligenten Zeigern arbeiten
können.</p>
<blockquote>
<p>Hinweis: Es gibt einen großen Unterschied zwischen dem Typ <code>MyBox&lt;T&gt;</code>, den
wir gerade erstellen, und dem echten Typ <code>Box&lt;T&gt;</code>: Unsere Version speichert
ihre Daten nicht auf dem Haldenspeicher (heap). In diesem Beispiel
konzentrieren wir uns auf <code>Deref</code>, daher ist es weniger wichtig, wo die Daten
tatsächlich gespeichert sind als das zeigerähnliche Verhalten.</p>
</blockquote>
<h3 id="dem-zeiger-zum-wert-folgen"><a class="header" href="#dem-zeiger-zum-wert-folgen">Dem Zeiger zum Wert folgen</a></h3>
<p>Eine reguläre Referenz ist eine Art Zeiger, und eine Möglichkeit, sich einen
Zeiger als Pfeil vorzustellen, der auf einen Wert zeigt, der an einer anderen
Stelle gespeichert ist. In Codeblock 15-6 erstellen wir eine Referenz auf einen
<code>i32</code>-Wert und verwenden dann den Dereferenzierungsoperator, um der Referenz
zum Wert zu folgen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-6: Einen Dereferenzierungsoperator verwenden
um einer Referenz auf einen <code>i32</code>-Wert zu folgen </span></p>
<p>Die Variable <code>x</code> enthält den <code>i32</code>-Wert <code>5</code>. Wir weisen <code>y</code> eine Referenz auf
<code>x</code> zu. Wir können sicherstellen, dass <code>x</code> gleich <code>5</code> ist. Wenn wir jedoch eine
Aussage über den Wert <code>y</code> machen möchten, müssen wir <code>*y</code> verwenden, um der
Referenz auf den Wert zu folgen, auf den sie zeigt (daher <em>Dereferenzierung</em>).
Sobald wir <code>y</code> dereferenzieren, haben wir Zugriff auf den Zahlenwert, auf den
<code>y</code> zeigt, und können ihn mit <code>5</code> vergleichen.</p>
<p>Wenn wir stattdessen versuchen würden, <code>assert_eq!(5, y);</code> zu schreiben, würden
wir diesen Fehler beim Kompilieren erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider dereferencing here
 --&gt; file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/macros/mod.rs:46:35
  |
46|                 if !(*left_val == **right_val) {
  |                                   +

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>Das Vergleichen einer Zahl mit einer Referenz auf eine Zahl ist nicht zulässig,
da es sich um verschiedene Typen handelt. Wir müssen den
Dereferenzierungsoperator verwenden um der Referenz auf den Wert zu folgen, auf
den sie zeigt.</p>
<h3 id="boxt-wie-eine-referenz-verwenden"><a class="header" href="#boxt-wie-eine-referenz-verwenden"><code>Box&lt;T&gt;</code> wie eine Referenz verwenden</a></h3>
<p>Wir können den Programmcode in Codeblock 15-6 neu schreiben, um anstelle einer
Referenz <code>Box&lt;T&gt;</code> zu verwenden. Wie Codeblock 15-7 zeigt, funktioniert der
Dereferenzierungsoperator:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-7: Using the dereference operator on a
<code>Box&lt;i32&gt;</code></span></p>
<p>Der Hauptunterschied zwischen Codeblock 15-7 und 15-6 besteht darin, dass wir
hier <code>y</code> als Instanz einer <code>Box&lt;T&gt;</code> festlegen, das auf einen kopierten Wert von
<code>x</code> zeigt, und nicht als Referenz, die auf den Wert <code>x</code> zeigt. In der letzten
Zusicherung (assertion) können wir den Dereferenzierungsoperator verwenden um
dem Zeiger in <code>Box&lt;T&gt;</code> auf die gleiche Weise zu folgen, wie wir es getan haben,
als <code>y</code> eine Referenz war. Als Nächstes werden wir ergründen, was das Besondere
an <code>Box&lt;T&gt;</code> ist, wodurch der Dereferenzierungsoperator verwendet werden kann,
indem wir unseren eigenen Box-Typ definieren.</p>
<h3 id="einen-eigenen-intelligenten-zeiger-definieren"><a class="header" href="#einen-eigenen-intelligenten-zeiger-definieren">Einen eigenen intelligenten Zeiger definieren</a></h3>
<p>Erstellen wir einen intelligenten Zeiger, der dem von der Standardbibliothek
bereitgestellten Typ <code>Box&lt;T&gt;</code> ähnelt, um zu erfahren, wie sich intelligente
Zeiger standardmäßig anders als Referenzen verhalten. Anschließend sehen wir
uns an, wie man die Möglichkeit zur Verwendung des Dereferenzierungsoperators
hinzufügen kann.</p>
<p>Der Typ <code>Box&lt;T&gt;</code> wird letztendlich als Tupel-Struktur (tuple struct) mit einem
Element definiert. Codeblock 15-8 definiert den Typ <code>MyBox&lt;T&gt;</code> auf die gleiche
Weise. Wir werden auch eine Funktion <code>new</code> definieren, analog zu <code>Box&lt;T&gt;</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-8: Definition des Type <code>MyBox&lt;T&gt;</code></span></p>
<p>Wir definieren eine Struktur mit dem Namen <code>MyBox</code> und deklarieren einen
generischen Parameter <code>T</code>, da unser Typ Werte jedes beliebigen Typs enthalten
können soll. Der Typ <code>MyBox</code> ist eine Tupelstruktur mit einem Element vom Typ
<code>T</code>. Die Funktion <code>MyBox::new</code> verwendet einen Parameter vom Typ <code>T</code> und gibt
eine <code>MyBox</code>-Instanz zurück, die den übergebenen Wert enthält.</p>
<p>Versuchen wir, die Funktion <code>main</code> in Codeblock 15-7 zu Codeblock 15-8
hinzuzufügen und sie so zu ändern, dass der von uns definierte Typ <code>MyBox&lt;T&gt;</code>
anstelle von <code>Box&lt;T&gt;</code> verwendet wird. Der Programmcode in Codeblock 15-9 wird
nicht kompilieren, da Rust nicht weiß, wie er <code>MyBox</code> dereferenzieren kann.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring"> }
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-9: Versuch, <code>MyBox&lt;T&gt;</code> auf die gleiche Weise
wie <code>Box&lt;T&gt;</code> und Referenzen zu benutzen</span></p>
<p>Hier ist der Kompilierfehler den wir erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>Unser Typ <code>MyBox&lt;T&gt;</code> kann nicht dereferenziert werden, da wir diese Fähigkeit
für unseren Typ nicht implementiert haben. Um eine Dereferenzierung mit dem
Operator <code>*</code> zu ermöglichen, implementieren wir das Merkmal <code>Deref</code>.</p>
<h3 id="implementieren-des-merkmals-deref"><a class="header" href="#implementieren-des-merkmals-deref">Implementieren des Merkmals <code>Deref</code></a></h3>
<p>Wie in <a href="ch10-02-traits.html#ein-merkmal-f%C3%BCr-einen-typ-implementieren">„Ein Merkmal für einen Typ implementieren“</a> in Kapitel 10
beschrieben, müssen wir zur Implementierung eines Merkmals Implementierungen
für die erforderlichen Methoden des Merkmals bereitstellen. Das von der
Standardbibliothek bereitgestellte Merkmal <code>Deref</code> erfordert die
Implementierung einer Methode namens <code>deref</code>, die <code>self</code> ausleiht (borrow) und
eine Referenz auf die beinhalteten Daten zurückgibt. Codeblock 15-10 enthält
eine Implementierung von <code>Deref</code>, um die Definition von <code>MyBox</code> zu ergänzen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-10: <code>Deref</code> auf <code>MyBox&lt;T&gt;</code>
implementieren</span></p>
<p>Die Syntax <code>type Target = T;</code> definiert einen assoziierten Typ, den das Merkmal
<code>Deref</code> verwenden soll. Assoziierte Typen sind eine andere Art, einen
generischen Parameter zu deklarieren, aber darüber musst du dir vorerst noch
keine Gedanken machen; in Kapitel 20 werden wir sie ausführlicher behandeln.</p>
<p>Wir füllen den Rumpf der Methode <code>deref</code> mit <code>&amp;self.0</code>, damit <code>deref</code> eine
Referenz auf den Wert zurückgibt, auf den wir mit dem Operator <code>*</code> zugreifen
wollen. Erinnere dich an <a href="ch05-01-defining-structs.html#verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen">„Verwenden von Tupel-Strukturen ohne benannte Felder
um verschiedene Typen zu erzeugen“</a> in Kapitel 5, wo <code>.0</code> auf
den ersten Wert in einer Tupel-Struktur zugreift. Die Funktion <code>main</code> in
Codeblock 15-9, die <code>*</code> für den Wert <code>MyBox&lt;T&gt;</code> aufruft, kompiliert nun und die
Zusicherungen werden erfüllt!</p>
<p>Ohne das Merkmal <code>Deref</code> kann der Compiler nur <code>&amp;</code>-Referenzen dereferenzieren.
Die Methode <code>deref</code> gibt dem Compiler die Möglichkeit, einen Wert eines
beliebigen Typs zu verwenden, der <code>Deref</code> implementiert, und die Methode
<code>deref</code> aufzurufen, um eine <code>&amp;</code>-Referenz zu erhalten, die er dereferenzieren
kann.</p>
<p>Als wir in Codeblock 15-9 <code>*y</code> eingegeben haben, hat Rust hinter den Kulissen
tatsächlich diesen Programmcode ausgeführt:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust ersetzt den Operator <code>*</code> durch einen Aufruf der Methode <code>deref</code> und dann
durch eine einfache Dereferenzierung, sodass wir nicht darüber nachdenken
müssen, ob wir die Methode <code>deref</code> aufrufen müssen oder nicht. Mit dieser
Rust-Funktionalität können wir Code schreiben, der unabhängig davon
funktioniert, ob wir eine reguläre Referenz haben oder einen Typ, der <code>Deref</code>
implementiert.</p>
<p>Der Grund, warum die Methode <code>deref</code> eine Referenz auf einen Wert zurückgibt
und die einfache Dereferenzierung außerhalb der Klammern in <code>*(y.deref())</code>
weiterhin erforderlich ist, hat mit der Eigentümerschaft (ownership) zu tun.
Wenn die Methode <code>deref</code> den Wert direkt anstelle einer Referenz auf den Wert
zurückgibt, wird der Wert aus <code>self</code> herausverschoben. Wenn wir den
Dereferenzierungsoperator verwenden, wollen wir meistens, wie auch hier, nicht
die Eigentümerschaft des inneren Wertes von <code>MyBox&lt;T&gt;</code> übernehmen.</p>
<p>Beachte, dass der <code>*</code>-Operator durch einen Aufruf der Methode <code>deref</code> und dann
einem Aufruf des <code>*</code>-Operators ersetzt wird. Da die Ersetzung des <code>*</code>-Operators
nicht unendlich rekursiv ist, erhalten wir Daten vom Typ <code>i32</code>, die mit der <code>5</code>
in <code>assert_eq!</code> in Codeblock 15-9 übereinstimmen.</p>
<h3 id="implizite-automatische-umwandlung-mit-funktionen-und-methoden"><a class="header" href="#implizite-automatische-umwandlung-mit-funktionen-und-methoden">Implizite automatische Umwandlung mit Funktionen und Methoden</a></h3>
<p>Die <em>automatische Umwandlung</em> (deref coercion) wandelt eine Referenz auf einen
Typ, der das Merkmal <code>Deref</code> implementiert, in eine Referenz auf einen anderen
Typ um. Zum Beispiel kann die automatische Umwandlung <code>&amp;String</code> in <code>&amp;str</code>
konvertieren, da <code>String</code> das Merkmal <code>Deref</code> implementiert, sodass <code>&amp;str</code>
zurückgegeben wird. Die automatische Umwandlung ist eine Bequemlichkeit, die
Rust auf Argumente für Funktionen und Methoden anwendet, und funktioniert nur
bei Typen, die das Merkmal <code>Deref</code> implementieren. Die automatische Umwandlung
erfolgt automatisch, wenn wir eine Referenz auf den Wert eines bestimmten Typs
als Argument an eine Funktion oder Methode übergeben, die nicht dem
Parametertyp in der Funktion oder Methodendefinition übereinstimmt. Eine Folge
von Aufrufen der Methode <code>deref</code> konvertiert den von uns angegebenen Typ in den
Typ, den der Parameter benötigt.</p>
<p>Rust wurde um die automatische Umwandlung erweitert, damit Programmierer, die
Funktions- und Methodenaufrufe schreiben, nicht so viele explizite
Referenzierungen und Dereferenzierungen mit <code>&amp;</code> und <code>*</code> angeben müssen. Mit der
Funktionalität der automatischen Umwandlung können wir auch Programmcode
schreiben, der sowohl für Referenzen als auch für intelligente Zeiger geeignet
ist.</p>
<p>Um die automatische Umwandlung in Aktion zu sehen, verwenden wir den in
Codeblock 15-8 definierten Typ <code>MyBox&lt;T&gt;</code> sowie die Implementierung von
<code>Deref</code>, die wir in Codeblock 15-10 hinzugefügt haben. Codeblock 15-11 zeigt
die Definition einer Funktion mit einen Zeichenketten-Anteilstyp (string slice)
Parameter.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn hello(name: &amp;str) {
    println!("Hallo {name}!");
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-11: Eine Funktion <code>hello</code> mit dem Parameter
<code>name</code> vom Typ <code>&amp;str</code></span></p>
<p>Wir können die Funktion <code>hello</code> mit einem Zeichenketten-Anteilstyp als Argument
aufrufen, wie zum Beispiel <code>hello("Rust");</code>. Die automatischer Umwandlung
ermöglicht es, <code>hello</code> mit einer Referenz auf einen Wert vom Typ
<code>MyBox&lt;String&gt;</code> aufzurufen, wie Codeblock 15-12 zeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hallo {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;m);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-12: <code>hello</code> mit einer Referenz auf einen
<code>MyBox&lt;String&gt;</code>-Wert, der aufgrund automatischer Umwandlung funktioniert</span></p>
<p>Hier rufen wir die Funktion <code>hello</code> mit dem Argument <code>&amp;m</code> auf, das auf einen
<code>MyBox&lt;String&gt;</code>-Wert referenziert. Da wir in Codeblock 15-10 das Merkmal
<code>Deref</code> für <code>MyBox&lt;T&gt;</code> implementiert haben, kann Rust <code>&amp;MyBox&lt;String&gt;</code> durch
Aufrufen von <code>deref</code> in <code>&amp;String</code> verwandeln. Die Standardbibliothek bietet
eine Implementierung von <code>Deref</code> auf <code>String</code>, die einen
Zeichenketten-Anteilstyp zurückgibt. Dies kann man in der API-Dokumentation für
<code>Deref</code> nachlesen. Rust ruft erneut <code>deref</code> auf, um <code>&amp;String</code> in <code>&amp;str</code>
umzuwandeln, was der Definition der Funktion <code>hello</code> entspricht.</p>
<p>Wenn Rust keine automatische Umwandlung implementiert hätte, müssten wir den
Programmcode in Codeblock 15-13 anstelle des Programmcodes in 15-12 schreiben,
um <code>hello</code> mit einem Wert vom Typ <code>&amp;MyBox&lt;String&gt;</code> aufzurufen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hallo {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-13: Programmcode den wir schreiben
müssten wenn Rust keine automatische Umwandlung hätte</span></p>
<p>Das <code>(*m)</code> dereferenziert <code>Mybox&lt;String&gt;</code> zu einem <code>String</code>. Dann nehmen <code>&amp;</code>
und <code>[..]</code> einen Anteilstyp des <code>String</code>, der gleich der gesamten Zeichenkette
ist, um der Signatur von <code>hello</code> zu entsprechen. Der Programmcode ohne
automatische Umwandlung ist mit all den Symbolen schwerer zu lesen, zu
schreiben und zu verstehen. Durch die automatische Umwandlung kann Rust diese
Konvertierung automatisch für uns durchführen.</p>
<p>Wenn das Merkmal <code>Deref</code> für die beteiligten Typen definiert ist, analysiert
Rust die Typen und verwendet <code>Deref::deref</code> so oft wie nötig, um eine Referenz
zu erhalten, die dem Typ des Parameters entspricht. Wie oft <code>Deref::deref</code>
eingefügt werden muss, wird zur Kompilierzeit ermittelt, sodass zur Laufzeit
kein Nachteil durch die Nutzung der automatischen Umwandlung entsteht!</p>
<h3 id="wie-die-automatische-umwandlung-mit-veränderbarkeit-umgeht"><a class="header" href="#wie-die-automatische-umwandlung-mit-veränderbarkeit-umgeht">Wie die automatische Umwandlung mit Veränderbarkeit umgeht</a></h3>
<p>Ähnlich wie du das Merkmal <code>Deref</code> verwendest, um den <code>*</code>-Operator bei
unveränderbaren Referenzen zu überschreiben, kannst du das Merkmal <code>DerefMut</code>
verwenden, um den <code>*</code>-Operator bei veränderbaren Referenzen zu überschreiben.</p>
<p>Rust wendet die automatische Umwandlung bei Typen und Merkmalsimplementierungen
in folgenden drei Fällen an:</p>
<ol>
<li>Von <code>&amp;T</code> zu <code>&amp;U</code>, wenn <code>T: Deref&lt;Target=U&gt;</code></li>
<li>Von <code>&amp;mutT</code> zu <code>&amp;mutU</code>, wenn <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>Von <code>&amp;mutT</code> zu <code>&amp;U</code>, wenn <code>T: Deref&lt;Target=U&gt;</code></li>
</ol>
<p>Die ersten beiden Fälle sind identisch, mit der Ausnahme, dass der zweite die
Veränderbarkeit implementiert. Der erste Fall besagt, dass wenn man einen <code>&amp;T</code>
hat und <code>T</code> <code>Deref</code> für einen Typ <code>U</code> implementiert hat, man transparent <code>&amp;U</code>
erhalten kann. Der zweite Fall besagt, dass die gleiche automatische Umwandlung
bei veränderbaren Referenzen erfolgt.</p>
<p>Der dritte Fall ist schwieriger: Rust wird auch eine veränderbare Referenz in
eine unveränderbare umwandeln. Das Gegenteil ist jedoch <em>nicht</em> möglich:
Unveränderbare Referenzen werden niemals zu veränderbaren gemacht. Wenn man
eine veränderbare Referenz hat, muss diese veränderbare Referenz aufgrund der
Ausleihregeln (borrowing rules) die einzige Referenz auf diese Daten sein
(anderenfalls würde das Programm nicht kompilieren). Das Konvertieren einer
veränderbaren Referenz in eine unveränderbare verstößt niemals gegen die
Ausleihregeln. Das Konvertieren einer unveränderbaren Referenz in eine
veränderbare Referenz, würde erfordern, dass die ursprüngliche unveränderbare
Referenz die einzige unveränderbare Referenz auf diese Daten ist, aber die
Ausleihregeln garantieren dies nicht.
Daher kann Rust nicht davon ausgehen, dass die Konvertierung einer
unveränderbaren Referenz in eine veränderbare Referenz möglich ist.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="programmcode-beim-aufräumen-ausführen-mit-dem-merkmal-trait-drop"><a class="header" href="#programmcode-beim-aufräumen-ausführen-mit-dem-merkmal-trait-drop">Programmcode beim Aufräumen ausführen mit dem Merkmal (trait) <code>Drop</code></a></h2>
<p>Das zweite wichtige Merkmal für intelligente Zeiger ist <code>Drop</code>, mit dem man
anpassen kann, was passiert, wenn ein Wert den Gültigkeitsbereich verlässt. Man
kann eine Implementierung für das Merkmal (trait) <code>Drop</code> für jeden Typ
bereitstellen, und der angegebene Programmcode kann zum Freigeben von
Ressourcen wie Dateien oder Netzwerkverbindungen verwendet werden.</p>
<p>Wir führen <code>Drop</code> im Kontext von intelligenten Zeigern ein, da die
Funktionalität des Merkmals <code>Drop</code> fast immer bei der Implementierung eines
intelligenten Zeigers verwendet wird. Wenn beispielsweise eine <code>Box&lt;T&gt;</code>
aufgeräumt wird, wird der Speicherplatz auf dem Haldenspeicher freigegeben, auf
den die Box zeigt.</p>
<p>In einigen Programmiersprachen muss der Programmierer für manche Datentypen
den Speicher oder die Ressourcen manuell freigeben, wenn die jeweiligen
Instanzen nicht mehr benötigt werden. Beispiele hierfür sind Dateiressourcen,
Sockets und Sperren. Wenn er das vergisst, kann das System überlastet werden
und abstürzen. In Rust kannst du festlegen, dass ein bestimmter Programmcode
ausgeführt wird, sobald ein Wert seinen Gültigkeitsbereich verlässt. Der
Compiler fügt dann diesen Programmcode automatisch ein. Infolgedessen muss man
sich nicht darum kümmern, an allen relevanten Stellen Aufräumcode zu
platzieren, und verschwendet trotzdem keine Ressourcen!</p>
<p>Du schreibst den Programmcode, der ausgeführt wird, wenn ein Wert den
Gültigkeitsbereich verlässt, durch Implementieren des Merkmals <code>Drop</code>. Für das
Merkmal <code>Drop</code> muss man eine Methode <code>drop</code> implementieren, die eine
veränderbare Referenz auf <code>self</code> enthält. Um zu sehen, wann Rust <code>drop</code>
aufruft, implementieren wir <code>drop</code> zunächst mit <code>println!</code>-Anweisungen.</p>
<p>Codeblock 15-14 zeigt eine Struktur (struct) <code>CustomSmartPointer</code>, deren
einzige benutzerdefinierte Funktionalität darin besteht, <code>CustomSmartPointer mit Daten aufräumen</code> auszugegeben, sobald die Instanz den Gültigkeitsbereich
verlässt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("CustomSmartPointer mit Daten aufräumen: `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("meine Sache"),
    };
    let d = CustomSmartPointer {
        data: String::from("andere Sachen"),
    };
    println!("CustomSmartPointers erzeugt.");
}</code></pre></pre>
<p><span class="caption">Codeblock 15-14: Eine Struktur <code>CustomSmartPointer</code>, die
das Merkmal <code>Drop</code> implementiert, wo wir unseren Programmcode für das Aufräumen
platzieren würden</span></p>
<p>Das Merkmal <code>Drop</code> ist im Präludium (prelude) enthalten, daher müssen wir es
nicht in den Gültigkeitsbereich bringen. Wir implementieren das Merkmal <code>Drop</code>
in <code>CustomSmartPointer</code> und stellen eine Implementierung für die Methode <code>drop</code>
bereit, die <code>println!</code> aufruft. Im Hauptteil der Methode <code>drop</code> kannst du jede
Logik platzieren, die du ausführen möchtest, wenn eine Instanz deines Typs den
Gültigkeitsbereich verlässt. Wir geben hier einen Text aus, um visuell zu
zeigen, wann Rust <code>drop</code> aufruft.</p>
<p>In <code>main</code> erstellen wir zwei Instanzen von <code>CustomSmartPointer</code> und geben dann
<code>CustomSmartPointers erzeugt</code> aus. Am Ende von <code>main</code> verlassen unsere
Instanzen von <code>CustomSmartPointer</code> den Gültigkeitsbereich und Rust ruft den
Programmcode auf, den wir in der Methode <code>drop</code> angegeben haben, und gibt
schließlich unsere Nachricht aus. Beachte, dass wir die Methode <code>drop</code> nicht
explizit aufrufen mussten.</p>
<p>Wenn wir das Programm ausführen, erhalten wir folgende Ausgabe:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers erzeugt.
CustomSmartPointer mit Daten aufräumen: `andere Sachen`!
CustomSmartPointer mit Daten aufräumen: `meine Sache`!
</code></pre>
<p>Rust hat für uns automatisch <code>drop</code> und den von uns angegebenen Programmcode
aufgerufen, als unsere Instanzen den Gültigkeitsbereich verlassen haben.
Variablen werden in umgekehrter Reihenfolge ihrer Erstellung aufgeräumt, daher
wurde <code>d</code> vor <code>c</code> aufgeräumt. Der Zweck dieses Beispiels ist, dir eine visuelle
Anleitung zur Funktionsweise der Methode <code>drop</code> zu geben. Normalerweise
schreibst du den Aufräumcode, der für deinen Typ nötig ist, anstatt einen Text
auszugeben.</p>
<p>Leider ist es nicht einfach, die automatische <code>drop</code>-Funktionalität zu
deaktivieren. Für gewöhnlich ist es auch nicht erforderlich; der wesentliche
Punkt des Merkmals <code>Drop</code> ist, dass es automatisch erledigt wird. Gelegentlich
möchte man jedoch möglicherweise einen Wert frühzeitig aufräumen. Ein Beispiel
ist die Verwendung intelligenter Zeiger, die Sperren verwalten: Möglicherweise
möchtest du den Aufruf der Methode <code>drop</code> erzwingen, um die Sperre sofort
freizugegeben, damit ein anderer Programmcode im selben Gültigkeitsbereich die
Sperre erhalten kann. Mit Rust kann man die Methode <code>drop</code> des Merkmals <code>Drop</code>
nicht manuell aufrufen. Stattdessen muss man die von der Standardbibliothek
bereitgestellte Funktion <code>std::mem::drop</code> aufrufen, wenn man das Aufräumen
eines Werts vor dem Ende seines ültigkeitsbereichs erzwingen möchte.</p>
<p>Wenn wir versuchen die Methode <code>drop</code> des Merkmals <code>Drop</code> manuell aufzurufen,
indem wir die Funktion <code>main</code> aus Codeblock 15-14 ändern, wie im Codeblock
15-15, gezeigt, erhalten wir einen Kompilierfehler.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("CustomSmartPointer mit Daten aufräumen: `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("Daten"),
    };
    println!("CustomSmartPointer erzeugt.");
    c.drop();
    println!("CustomSmartPointer vor dem Ende von main aufgeräumt.");
}</code></pre></pre>
<p><span class="caption">Codeblock 15-15: Der Versuch, die Methode <code>drop</code> des
Merkmals <code>Drop</code> manuell aufzurufen, um frühzeitig aufzuräumen</span></p>
<p>Wenn wir versuchen, diesen Programmcode zu kompilieren, erhalten wir folgende
Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
   |
help: consider using `drop` function
   |
16 |     drop(c);
   |     +++++ ~

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` (bin "drop-example") due to 1 previous error
</code></pre>
<p>Diese Fehlermeldung besagt, dass wir <code>drop</code> nicht explizit aufrufen dürfen. Die
Fehlermeldung verwendet den Begriff <em>Destruktor</em> (destructor), der der
allgemeine Programmierbegriff für eine Funktion ist, die eine Instanz aufräumt.
Ein <em>Destruktor</em> ist analog zu einem <em>Konstruktor</em> (constructor), der eine
Instanz erstellt. Die Funktion <code>drop</code> in Rust ist so ein <em>Destruktor</em>.</p>
<p>Rust lässt uns <code>drop</code> nicht explizit aufrufen, da Rust immer noch automatisch
für den Wert am Ende von <code>main</code> <code>drop</code> aufruft. Dies würde einen
<em>Doppel-Freigabe-Fehler</em> (double free error) verursachen, da Rust versuchen
würde, den gleichen Wert zweimal aufzuräumen.</p>
<p>Wir können das automatische Einfügen von <code>drop</code> am Ende des Gültigkeitsbereichs
nicht deaktivieren und wir können die Methode <code>drop</code> nicht explizit aufrufen.
Wenn wir also erzwingen wollen, dass ein Wert frühzeitig aufgeräumt wird,
verwenden wir die Funktion <code>std::mem::drop</code>.</p>
<p>Die Funktion <code>std::mem::drop</code> unterscheidet sich von der Methode <code>drop</code> im
Merkmal <code>Drop</code>. Wir rufen sie auf, indem wir den Wert, dessen vorzeitiges
Aufräumen wir erzwingen möchten, der Funktion als Argument mitgeben. Die
Funktion befindet sich im Präludium, daher können wir <code>main</code> in Codeblock 15-15
ändern, um die Funktion <code>drop</code> wie in Codeblock 15-16 gezeigt aufzurufen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("CustomSmartPointer mit Daten aufräumen: `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("Daten"),
    };
    println!("CustomSmartPointer erzeugt.");
    drop(c);
    println!("CustomSmartPointer vor dem Ende von main aufgeräumt.");
}</code></pre></pre>
<p><span class="caption">Codeblock 15-16: <code>std::mem::drop</code> aufrufen, um einen Wert
explizit aufzuräumen, bevor er den Gültigkeitsbereich verlässt</span></p>
<p>Wenn wir den Programmcode aufrufen, wird folgendes ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer erzeugt.
CustomSmartPointer mit Daten aufräumen: `Daten`!
CustomSmartPointer vor dem Ende von main aufgeräumt.
</code></pre>
<p>Der Text <code>CustomSmartPointer mit Daten aufräumen: `Daten`!</code> wird zwischen
<code>CustomSmartPointer erzeugt</code> und <code>CustomSmartPointer vor dem Ende von main aufgeräumt</code> ausgegeben und zeigt, dass der Methodencode von <code>drop</code> aufgerufen
wird, um <code>c</code> an diesem Punkt aufzuräumen.</p>
<p>Du kannst den Programmcode, der in einer Implementierung des Merkmals <code>Drop</code>
angegeben ist, auf viele Arten verwenden, um das Aufräumen bequem und sicher
zu gestalten. Du kannst ihn beispielsweise dazu verwenden, deine eigene
Speicherverwaltung (memory allocator) zu erstellen! Mit dem Merkmal <code>Drop</code> und
dem Eigentümerschaftssystem von Rust musst du nicht ans Aufräumen denken, da
Rust dies automatisch tut.</p>
<p>Man muss sich auch keine Sorgen über Probleme machen, die sich aus dem
versehentlichen Aufräumen noch verwendeter Werte ergeben: Das
Eigentümerschaftssystem, das sicherstellt, das Referenzen immer gültig sind,
stellt auch sicher, dass <code>drop</code> nur einmal aufgerufen wird, wenn der Wert nicht
mehr verwendet wird.</p>
<p>Nachdem wir nun <code>Box&lt;T&gt;</code> und einige der Merkmale von intelligenten Zeigern
untersucht haben, schauen wir uns einige andere intelligente Zeiger an, die in
der Standardbibliothek definiert sind.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="der-referenzzählende-intelligente-zeiger-rct"><a class="header" href="#der-referenzzählende-intelligente-zeiger-rct">Der referenzzählende intelligente Zeiger <code>Rc&lt;T&gt;</code></a></h2>
<p>In den meisten Fällen ist die Eigentümerschaft klar, man weiß genau, welche
Variable einen bestimmten Wert besitzt. Es gibt jedoch Fälle, in denen ein
einzelner Wert mehrere Eigentümer haben kann. In Graphdatenstrukturen (graph
data structures) können beispielsweise mehrere Kanten auf denselben Knoten
verweisen, und dieser Knoten gehört konzeptionell allen Kanten, die darauf
verweisen. Ein Knoten sollte nur aufgeräumt werden, wenn keine Kanten darauf
zeigen und er daher keine Eigentümer hat.</p>
<p>Du musst die mehrfache Eigentümerschaft explizit aktivieren, indem du den
Rust-Typ <code>Rc&lt;T&gt;</code> verwendest, was eine Kurzform für <em>Referenzzählung</em> (reference
counting) ist. Der Typ <code>Rc&lt;T&gt;</code> zählt die Anzahl der Referenzen auf einen
Wert, um festzustellen, ob der Wert noch verwendet wird oder nicht. Wenn auf
einen Wert keine Referenz vorhanden ist, kann der Wert aufgeräumt werden, ohne
dass Referenzen ungültig werden.</p>
<p>Stell dir <code>Rc&lt;T&gt;</code> als einen Fernseher im Wohnzimmer vor. Wenn eine Person zum
Fernsehen hereinkommt, schaltet sie ein. Andere können in das Zimmer kommen und
fernsehen. Wenn die letzte Person den Raum verlässt, schaltet sie den Fernseher
aus, da er nicht mehr verwendet wird. Wenn jemand den Fernseher ausschaltet,
während andere noch fernsehen möchten, wird es Aufruhr bei den übrigen
Zuschauern geben!</p>
<p>Wir verwenden den Typ <code>Rc&lt;T&gt;</code>, wenn wir Daten auf dem Haldenspeicher (heap)
allokieren möchten, damit mehrere Teile unseres Programms diese lesen können,
und wir können zum Zeitpunkt der Kompilierung nicht bestimmen, welcher Teil
zuletzt fertig sein würde. Wenn wir wüssten, welcher Teil zuletzt fertig sein
würde, könnten wir diesen Teil einfach zum Eigentümer der Daten machen, und die
Eigentumsregeln, die zur Kompilierzeit sichergestellt werden, würden wirksam.</p>
<p>Beachte, dass <code>Rc&lt;T&gt;</code> nur in einsträngigen (single-threaded) Szenarien verwendet
werden kann. Wenn wir in Kapitel 16 auf Nebenläufigkeit (concurrency) eingehen,
werden wir uns mit der Referenzzählung in mehrsträngigen (multi-threaded)
Programmen befassen.</p>
<h3 id="rct-zur-gemeinsamen-nutzung-von-daten-verwenden"><a class="header" href="#rct-zur-gemeinsamen-nutzung-von-daten-verwenden"><code>Rc&lt;T&gt;</code> zur gemeinsamen Nutzung von Daten verwenden</a></h3>
<p>Kehren wir zu unserem Beispiel mit der Cons-Liste in Codeblock 15-5 zurück.
Denke daran, dass wir sie mit <code>Box&lt;T&gt;</code> definiert haben. Dieses Mal erstellen
wir zwei Listen, die beide gemeinsam eine dritte Liste besitzen. Konzeptionell
sieht dies ähnlich aus wie in Abbildung 15-3.</p>
<p><img alt="Zwei Listen die sich die Eigentümerschaft einer dritten Liste teilen"
src="img/trpl15-03.svg" class="center" /></p>
<p><span class="caption">Abbildung 15-3: Zwei Listen <code>b</code> und <code>c</code> teilen sich die
Eigentümerschaft über eine dritte Liste <code>a</code></span></p>
<p>Wir erstellen eine Liste <code>a</code>, die <code>5</code> und <code>10</code> enthält. Dann erstellen wir zwei
weitere Listen: <code>b</code>, die mit <code>3</code> beginnt, und <code>c</code>, die mit <code>4</code> beginnt. Sowohl
<code>b</code> als auch <code>c</code> werden dann mit mit der ersten Liste <code>a</code> fortfahren, die <code>5</code>
und <code>10</code> enthält. Mit anderen Worten, beide Listen teilen sich die erste Liste
mit <code>5</code> und <code>10</code>.</p>
<p>Der Versuch, dieses Szenario mithilfe unserer Definition von <code>List</code> mit <code>Box&lt;T&gt;</code>
zu implementieren, funktioniert nicht, wie in Codeblock 15-17 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre></pre>
<p><span class="caption">Codeblock 15-17: Dies zeigt, dass wir mit <code>Box&lt;T&gt;</code> keine
zwei Listen haben dürfen, die versuchen, die Eigentümerschaft einer dritten
Liste zu teilen</span></p>
<p>Beim Versuch den Programmcode zu kompilieren, erhalten wir folgende Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin "cons-list") due to 1 previous error
</code></pre>
<p>Die <code>Cons</code>-Varianten besitzen die Daten, die sie enthalten. Wenn wir also die
Liste <code>b</code> erstellen, wird <code>a</code> in <code>b</code> verschoben und <code>b</code> besitzt <code>a</code>. Wenn wir
dann beim Erstellen von <code>c</code> versuchen erneut <code>a</code> zu verwenden, ist dies nicht
zulässig, da <code>a</code> verschoben wurde.</p>
<p>Wir könnten die Definition von <code>Cons</code> ändern und stattdessen Referenzen
verwenden, aber dann müssten wir Lebensdauerparameter (lifetime parameters)
angeben. Durch die Angabe von Lebensdauerparametern würden wir angeben, dass
jedes Element in der Liste mindestens so lange wie die gesamte Liste lebt. Dies
ist bei den Elementen und Listen in Codeblock 15-17 der Fall, aber nicht in
jedem Szenario.</p>
<p>Stattdessen ändern wir unsere Definition von <code>List</code> so, dass <code>Rc&lt;T&gt;</code> anstelle
von <code>Box&lt;T&gt;</code> verwendet wird, wie in Codeblock 15-18 gezeigt. Jede
<code>Cons</code>-Variante enthält nun einen Wert und ein <code>Rc&lt;T&gt;</code>, das auf eine <code>List</code>
zeigt. Wenn wir <code>b</code> erstellen, übernehmen wir nicht <code>a</code>, sondern klonen
<code>Rc&lt;List&gt;</code>, das <code>a</code> enthält, und erhöhen die Anzahl der Referenzen von eins auf
zwei und lassen <code>a</code> und <code>b</code> die Eigentümerschaft (ownership) an den Daten
dieser <code>Rc&lt;List&gt;</code> teilen. Wir werden <code>a</code> auch klonen, wenn wir <code>c</code> erstellen,
wodurch die Anzahl der Referenzen von zwei auf drei erhöht wird. Jedes Mal,
wenn wir <code>Rc::clone</code> aufrufen, erhöht sich die Anzahl der Referenzen auf die
Daten in <code>Rc&lt;List&gt;</code>, und die Daten werden erst dann aufgeräumt, wenn keine
Referenzen mehr darauf vorhanden sind.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
<p><span class="caption">Codeblock 15-18: Eine Definition von <code>List</code>, die <code>Rc&lt;T&gt;</code>
verwendet</span></p>
<p>Wir müssen eine <code>use</code>-Anweisung hinzufügen, um <code>Rc&lt;T&gt;</code> in den
Gültigkeitsbereich (scope) zu bringen, da es nicht im Präludium (prelude) ist.
In <code>main</code> erstellen wir die Liste mit <code>5</code> und <code>10</code> und speichern sie in einer
neuen <code>Rc&lt;List&gt;</code>-Instanz in <code>a</code>. Wenn wir dann <code>b</code> und <code>c</code> erstellen, rufen wir
die Funktion <code>Rc::clone</code> auf und übergeben eine Referenz auf <code>Rc&lt;List&gt;</code> in <code>a</code>
als Argument.</p>
<p>Wir hätten <code>a.clone()</code> anstelle von <code>Rc::clone(&amp;a)</code> aufrufen können, aber in
Rust ist es Konvention, in diesem Fall <code>Rc::clone</code> zu verwenden. Die
Implementierung von <code>Rc::clone</code> erstellt keine tiefe Kopie aller Daten, wie es
bei den meisten Implementierungen von <code>clone</code> der Fall ist. Der Aufruf von
<code>Rc::clone</code> erhöht nur den Referenzzähler, was nicht viel Zeit in benötigt.
Tiefe Kopien von Daten können viel Zeit in Anspruch nehmen. Durch die
Verwendung von <code>Rc::clone</code> für die Referenzzählung können wir visuell zwischen
den Arten von Klonen mit tiefer Kopie und Klonen, die den Referenzzähler
erhöhen, unterscheiden. Bei der Suche nach Performanzproblemen im Code müssen
wir nur die Klone mit tiefer Kopie berücksichtigen und können die Aufrufe von
<code>Rc::clone</code> ignorieren.</p>
<h3 id="klonen-von-rct-erhöht-den-referenzzähler"><a class="header" href="#klonen-von-rct-erhöht-den-referenzzähler">Klonen von <code>Rc&lt;T&gt;</code> erhöht den Referenzzähler</a></h3>
<p>Lass uns unser Arbeitsbeispiel in Codeblock 15-18 ändern, damit sich die
Referenzanzahl ändert, wenn wir Referenzen auf <code>Rc&lt;List&gt;</code> in <code>a</code> erstellen
und aufräumen.</p>
<p>In Codeblock 15-19 ändern wir <code>main</code>, damit es einen inneren Gültigkeitsbereich
um die Liste <code>c</code> hat; so können wir sehen, wie sich der Referenzzähler ändert,
wenn <code>c</code> den Gültigkeitsbereich verlässt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("Zähler nach der Erstellung von a = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("Zähler nach der Erstellung von b = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("Zähler nach der Erstellung von c = {}", Rc::strong_count(&amp;a));
    }
    println!("Zahler nachdem c den Gültigkeitsbereich verlassen hat = {}",
             Rc::strong_count(&amp;a));
}</code></pre></pre>
<p><span class="caption">Codeblock 15-19: Den Referenzzähler ausgeben</span></p>
<p>An jeder Programmstelle, an der sich der Referenzzähler ändert, geben wir den
Referenzzählerstand aus, den wir durch Aufrufen der Funktion <code>Rc::strong_count</code>
erhalten. Diese Funktion heißt <code>strong_count</code> und nicht <code>count</code>, da der Typ
<code>Rc&lt;T&gt;</code> auch eine Funktion <code>weak_count</code> hat. Wir werden in <a href="ch15-06-reference-cycles.html#verhindern-von-referenzzyklen-mit-weakt">„Verhindern von
Referenzzyklen mit <code>Weak&lt;T&gt;</code>“</a> sehen, wofür <code>weak_count</code>
verwendet wird.</p>
<p>Dieser Programmcode gibt folgendes aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
Zähler nach der Erstellung von a = 1
Zähler nach der Erstellung von b = 2
Zähler nach der Erstellung von c = 3
Zahler nachdem c den Gültigkeitsbereich verlassen hat = 2
</code></pre>
<p>Wir sehen, dass <code>Rc&lt;List&gt;</code> in <code>a</code> einen anfänglichen Referenzzählerstand
von 1 hat. Jedes Mal wenn wir <code>clone</code> aufrufen, erhöht sich der Zähler um 1.
Wenn <code>c</code> den Gültigkeitsbereich verlässt, verringert sich der Zähler um 1. Wir
müssen keine Funktion aufrufen, um den Referenzzähler wie erforderlich zu
verringern, während wir <code>Rc::clone</code> aufrufen müssen, um den Referenzzähler zu
erhöhen: Die Implementierung des Merkmals (trait) <code>Drop</code> verringert den
Referenzzähler automatisch, wenn ein <code>Rc&lt;T&gt;</code>-Wert den Gültigkeitsbereich
verlässt.</p>
<p>Was wir in diesem Beispiel nicht sehen können, ist, dass wenn <code>b</code> und dann <code>a</code>
am Ende von <code>main</code> den Gültigkeitsbereich verlassen, der Zähler 0 ist und
<code>Rc&lt;List&gt;</code> vollständig aufgeräumt wird. Durch die Verwendung von <code>Rc&lt;T&gt;</code> kann
ein einzelner Wert mehrere Eigentümer haben und der Zähler stellt sicher, dass
der Wert gültig bleibt, solange ein Eigentümer vorhanden ist.</p>
<p>Über unveränderbare (immutable) Referenzen kann man mit <code>Rc&lt;T&gt;</code> Daten zwischen
mehreren Teilen eines Programms zum Lesen austauschen. Wenn man mit <code>Rc&lt;T&gt;</code>
auch mehrere veränderbare (mutable) Referenzen haben könnte, verstößt man
möglicherweise gegen eine der in Kapitel 4 beschriebenen Ausleihregeln
(borrowing rules): Mehrere veränderbar ausgeliehene Referenzen an derselben
Stelle können zu Daten-Wettlaufsituationen (data races) und Inkonsistenzen
führen. Es ist jedoch sehr nützlich, Daten verändern zu können! Im nächsten
Abschnitt werden wir das innere Veränderbarkeitsmuster und den Typ <code>RefCell&lt;T&gt;</code>
erläutern, den man in Verbindung mit <code>Rc&lt;T&gt;</code> verwenden kann, um mit dieser
Unveränderbarkeitsbeschränkung zu arbeiten.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-und-das-innere-veränderbarkeitsmuster"><a class="header" href="#refcellt-und-das-innere-veränderbarkeitsmuster"><code>RefCell&lt;T&gt;</code> und das innere Veränderbarkeitsmuster</a></h2>
<p>Die <em>innere Veränderbarkeit</em> (interior mutability) ist ein Entwurfsmuster in
Rust, mit dem man Daten auch dann verändern kann, wenn unveränderbare
Referenzen auf diese Daten vorhanden sind. Normalerweise ist diese Aktion nach
den Ausleihregeln nicht zulässig. Um Daten zu verändern, verwendet das Muster
„unsicheren Programmcode“ (<code>unsafe</code> code) innerhalb einer Datenstruktur, um
Rusts übliche Regeln, die Veränderbarkeit und Ausleihen betreffen, zu
verändern. Unsicherer Code zeigt dem Compiler an, dass wir die Regeln manuell
überprüfen, anstatt uns darauf zu verlassen, dass der Compiler sie für uns
überprüft; wir werden unsicheren Code in Kapitel 20 genauer besprechen.</p>
<p>Wir können Typen verwenden, die das innere Veränderbarkeitsmuster verwenden,
wenn wir sicherstellen können, dass die Ausleihregeln zur Laufzeit eingehalten
werden, obwohl der Compiler dies nicht garantieren kann. Der betroffene
unsichere Programmcode wird dann in eine sichere API eingepackt und der äußere
Typ ist immer noch unveränderbar.</p>
<p>Lass uns dieses Konzept untersuchen, indem wir uns den Typ <code>RefCell&lt;T&gt;</code>
ansehen, der dem inneren Veränderbarkeitsmuster folgt.</p>
<h3 id="mit-refcellt-ausleihregeln-zur-laufzeit-sicherstellen"><a class="header" href="#mit-refcellt-ausleihregeln-zur-laufzeit-sicherstellen">Mit <code>RefCell&lt;T&gt;</code> Ausleihregeln zur Laufzeit sicherstellen</a></h3>
<p>Im Gegensatz zu <code>Rc&lt;T&gt;</code> repräsentiert der Typ <code>RefCell&lt;T&gt;</code> die ungeteilte
Eigentümerschaft (ownership) für die darin enthaltenen Daten. Was unterscheidet
<code>RefCell&lt;T&gt;</code> von einem Typ wie <code>Box&lt;T&gt;</code>? Erinnere dich an die Ausleihregeln die
wir im Kapitel 4 gelernt haben:</p>
<ul>
<li>Zu jeder Zeit kann man <em>entweder</em> eine veränderbare Referenz oder eine
beliebige Anzahl unveränderbarer Referenzen haben (nicht aber beides).</li>
<li>Referenzen müssen immer gültig sein.</li>
</ul>
<p>Mit Referenzen und <code>Box&lt;T&gt;</code> werden die Invarianten der Ausleihregeln beim
Kompilieren erzwungen. Mit <code>RefCell&lt;T&gt;</code> werden diese Invarianten <em>zur Laufzeit</em>
erzwungen. Wenn man mit Referenzen gegen diese Regeln verstößt, wird beim
Kompilieren ein Fehler angezeigt. Wenn man mit <code>RefCell&lt;T&gt;</code> gegen diese Regeln
verstößt, wird das Programm mit <code>panic</code> abgebrochen.</p>
<p>Die Überprüfung der Ausleihregeln zur Kompilierzeit hat den Vorteil, dass
Fehler früher im Entwicklungsprozess erkannt werden und die Laufzeitperformanz
nicht beeinträchtigt wird, da die gesamte Analyse im Voraus abgeschlossen
wurde. Aus diesen Gründen ist es in den meisten Fällen die beste Wahl, die
Ausleihregeln zur Kompilierzeit zu überprüfen. Aus diesem Grund ist dies die
Standardeinstellung von Rust.</p>
<p>Der Vorteil der Überprüfung der Ausleihregeln zur Laufzeit besteht darin, dass
bestimmte speichersichere Szenarien zulässig sind, während sie bei der
Überprüfung zur Kompilierzeit nicht zulässig gewesen wären. Die statische
Analyse ist wie der Rust-Compiler von Natur aus konservativ. Einige
Eigenschaften des Programmcodes lassen sich durch Analyse des Programmcodes
nicht erkennen: Das bekannteste Beispiel ist das Halteproblem, das über den
Rahmen dieses Buches hinausgeht, aber ein interessantes Thema zum Nachforschen
ist.</p>
<p>Da manche Analysen nicht möglich sind, lehnt der Rust-Compiler möglicherweise
ein korrektes Programm ab, wenn er nicht sicher sein kann, dass der
Programmcode den Eigentumsregeln entspricht. Auf diese Art ist Rust
konservativ. Wenn es ein falsches Programm akzeptiert, können Benutzer den
Garantien von Rust nicht vertrauen. Wenn Rust jedoch ein korrektes Programm
ablehnt, wird der Programmierer belästigt, obwohl nichts Schlimmes passieren
kann. Der Typ <code>RefCell&lt;T&gt;</code> ist nützlich, wenn man sicher ist, dass der
Programmcode den Ausleihregeln entspricht, der Compiler dies jedoch nicht
verstehen und garantieren kann.</p>
<p>Ähnlich wie <code>Rc&lt;T&gt;</code> ist <code>RefCell&lt;T&gt;</code> nur für die Verwendung in einsträngigen
(single-threaded) Szenarien vorgesehen und verursacht einen Kompilierfehler,
wenn man versucht, es in einem mehrsträngigen (multi-threaded) Kontext zu
verwenden. Wir werden in Kapitel 16 darüber sprechen, wie man die Funktionalität
von <code>RefCell&lt;T&gt;</code> in einem mehrsträngigen Programm erhält.</p>
<p>Eine Zusammenfassung der Gründe für die Wahl von <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> oder
<code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> erlaubt mehrere Eigentümer derselben Daten. Mit <code>Box&lt;T&gt;</code> und
<code>RefCell&lt;T&gt;</code> haben Daten nur einen Eigentümer.</li>
<li><code>Box&lt;T&gt;</code> ermöglicht unveränderbares oder veränderbares Ausleihen, das zur
Kompilierzeit überprüft wird. <code>Rc&lt;T&gt;</code> erlaubt nur unveränderbares
Ausleihen, das zur Kompilierzeit geprüft wird und <code>RefCell&lt;T&gt;</code>
erlaubt unveränderbares oder veränderbares Ausleihen, das zur Laufzeit
überprüft wird.</li>
<li>Da <code>RefCell&lt;T&gt;</code> zur Laufzeit überprüfbares veränderbares Ausleihen zulässt,
kann man den Wert innerhalb von <code>RefCell&lt;T&gt;</code> auch dann ändern, wenn
<code>RefCell&lt;T&gt;</code> unveränderbar ist.</li>
</ul>
<p>Das Ändern des Werts innerhalb eines unveränderbaren Werts ist das <em>innere
Veränderbarkeitsmuster</em>. Schauen wir uns eine Situation an, in der innere
Veränderbarkeit nützlich ist, und untersuchen, wie dies möglich ist.</p>
<h3 id="innere-veränderbarkeit-das-veränderbare-ausleihen-eines-unveränderbaren-wertes"><a class="header" href="#innere-veränderbarkeit-das-veränderbare-ausleihen-eines-unveränderbaren-wertes">Innere Veränderbarkeit: Das veränderbare Ausleihen eines unveränderbaren Wertes</a></h3>
<p>Eine Konsequenz der Ausleihregeln ist, dass man einen unveränderbaren Wert
nicht veränderbar ausleihen kann. Dieser Programmcode wird beispielsweise nicht
kompilieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre></pre>
<p>Wenn man versucht, diesen Programmcode zu kompilieren, wird folgende
Fehlermeldung angezeigt:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p>Es gibt jedoch Situationen, in denen es nützlich wäre, wenn ein Wert durch
seine Methoden selbst veränderbar ist, aber für anderen Programmcode
unveränderbar erscheint. Programmcode außerhalb der Methoden des Werts kann
diesen nicht verändern. Die Verwendung von <code>RefCell&lt;T&gt;</code> ist eine Möglichkeit,
die Fähigkeit zur inneren Veränderbarkeit zu erhalten, allerdings umgeht
<code>RefCell&lt;T&gt;</code> die Ausleihregeln nicht vollständig: Der Ausleihenprüfer (borrow
checker) im Compiler ermöglicht diese innere Veränderbarkeit, und die
Ausleihregeln werden stattdessen zur Laufzeit überprüft. Wenn man gegen die
Regeln verstößt, führt das zu <code>panic!</code> anstelle eines Kompilierfehlers.</p>
<p>Lass uns ein praktisches Beispiel durcharbeiten, in dem wir <code>RefCell&lt;T&gt;</code>
verwenden, um einen unveränderbaren Wert zu ändern und um herauszufinden, warum
dies nützlich ist.</p>
<h4 id="ein-anwendungsfall-für-die-innere-veränderbarkeit-mock-objekte-mock-objects"><a class="header" href="#ein-anwendungsfall-für-die-innere-veränderbarkeit-mock-objekte-mock-objects">Ein Anwendungsfall für die innere Veränderbarkeit: Mock-Objekte (Mock Objects)</a></h4>
<p>Manchmal verwendet ein Programmierer beim Testen einen Typ anstelle eines
anderen Typs, um ein bestimmtes Verhalten zu beobachten und festzustellen, ob
es korrekt implementiert ist. Dieser Platzhaltertyp wird <em>Testdoppel</em> (test
double) genannt. Stell dir das so vor wie ein „Stunt-Double“ beim Film, bei dem
eine Person einspringt und einen Schauspieler in einer besonders schwierigen
Szene ersetzt. Testdoppel stehen für andere Typen ein, wenn wir Tests
durchführen. <em>Mock-Objekte</em> sind bestimmte Arten von Testdoppeln, die
aufzeichnen, was während eines Tests passiert, damit man bestätigen kann, dass
die richtigen Aktionen ausgeführt wurden.</p>
<p>Rust verfügt nicht im gleichen Sinne wie andere Programmiersprachen über
Objekte und in die Standardbibliothek integrierte Mock-Objekt-Funktionalität.
Man kann jedoch definitiv eine Struktur erstellen, die denselben Zwecken dient
wie ein Mock-Objekt.</p>
<p>Hier ist das Szenario, das wir testen werden: Wir erstellen eine Bibliothek,
die einen Wert anhand eines Maximalwerts verfolgt und Nachrichten basierend
darauf sendet, wie nahe der Maximalwert am aktuellen Wert liegt. Diese
Bibliothek kann verwendet werden, um das Kontingent eines Benutzers für die
Anzahl der API-Aufrufe zu verfolgen, die er beispielsweise ausführen darf.</p>
<p>Unsere Bibliothek bietet nur die Funktionalität, zu verfolgen, wie nahe ein
Wert am Maximum liegt und wie die Nachrichten zu bestimmten Zeiten sein
sollten. Von Anwendungen, die unsere Bibliothek verwenden, wird erwartet, dass
sie den Mechanismus zum Senden der Nachrichten bereitstellen: Die Anwendung
könnte eine Nachricht in der Anwendung anlegen, eine E-Mail senden, eine
Textnachricht senden oder etwas anderes machen. Die Bibliothek muss dieses
Detail nicht kennen. Alles, was es braucht, ist Code, der ein von uns
bereitgestelltes Merkmal (trait) namens <code>Messenger</code> implementiert. Codeblock
15-20 zeigt den Bibliothekscode.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("Fehler: Du hast dein Kontingent überschritten!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("Dringliche Warnung: Du hast über 90% deines Kontingents verbraucht!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("Warnung: Du hast über 75% deines Kontingents verbraucht!");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-20: Eine Bibliothek um zu verfolgen, wie nahe
ein Wert an einem Maximalwert liegt, und um zu warnen, wenn der Wert über
bestimmten Schwellwerten liegt</span></p>
<p>Ein wichtiger Teil dieses Programmcodes ist, dass das Merkmal <code>Messenger</code> eine
Methode namens <code>send</code> hat, die eine unveränderbare Referenz auf <code>self</code> und den
Text der Nachricht erhält. Dieses Merkmal ist die Schnittstelle, die unser
Mock-Objekt implementieren muss, damit das Mock-Objekt auf die gleiche Weise
wie ein reales Objekt verwendet werden kann. Der andere wichtige Teil ist, dass
wir das Verhalten der Methode <code>set_value</code> von <code>LimitTracker</code> testen wollen. Wir
können ändern, was wir für den Parameter <code>value</code> übergeben, aber <code>set_value</code>
gibt nichts zurück, auf das wir Zusicherungen machen können. Wir wollen in der
Lage sein zu sagen, dass, wenn wir einen <code>LimitTracker</code> mit etwas erstellen,
das das Merkmal <code>Messenger</code> und einen bestimmten Wert für <code>max</code> implementiert,
wenn wir verschiedene Zahlen für <code>value</code> übergeben, der Messenger angewiesen
wird, die entsprechenden Nachrichten zu senden.</p>
<p>Wir benötigen ein Mock-Objekt, das anstelle einer E-Mail oder einer
Textnachricht beim Aufrufen von <code>send</code> nur die Nachrichten verfolgt, die
gesendet werden sollen. Wir können eine neue Instanz des Mock-Objekts estellen,
einen <code>LimitTracker</code> erstellen, der das Mock-Objekt verwendet, die Methode
<code>set_value</code> für <code>LimitTracker</code> aufrufen und dann überprüfen, ob das Mock-Objekt
die erwarteten Nachrichten enthält. Codeblock 15-21 zeigt den Versuch, ein
Mock-Objekt zu implementieren, um genau das zu tun, aber der Ausleihenprüfer
erlaubt dies nicht.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Fehler: Du hast dein Kontingent überschritten!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Dringliche Warnung: Du hast über 90% deines Kontingents verbraucht!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warnung: Du hast über 50% deines Kontingents verbraucht!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-21: Der Versuch einen <code>MockMessenger</code> zu
implementieren, der vom Ausleihenprüfer nicht erlaubt wird</span></p>
<p>Dieser Testcode definiert eine Struktur <code>MockMessenger</code> mit einem Feld
<code>sent_messages</code> mit einem <code>Vec</code> von <code>String</code>-Werten, um Nachrichten zu
verfolgen, die gesendet werden sollen. Wir definieren auch eine zugehörige
Funktion <code>new</code>, um das Erstellen neuer <code>MockMessenger</code>-Werte zu vereinfachen,
die mit einer leeren Liste von Nachrichten beginnen. Wir implementieren dann
das Merkmal <code>Messenger</code> für <code>MockMessenger</code>, damit wir <code>LimitTracker</code> einen
<code>MockMessenger</code> übergeben können. Bei der Definition der Methode <code>send</code> nehmen
wir die übergebene Nachricht als Parameter und speichern sie in der Liste
<code>sent_messages</code> von <code>MockMessenger</code>.</p>
<p>Im Test testen wir, was passiert, wenn dem <code>LimitTracker</code> gesagt wird, er solle
<code>value</code> auf etwas setzen, das mehr als 75 Prozent des <code>max</code>-Wertes beträgt.
Zuerst erstellen wir einen neuen <code>MockMessenger</code>, der mit einer leeren
Nachrichtenliste beginnt. Dann erstellen wir einen neuen <code>LimitTracker</code> und
geben ihm eine Referenz auf den neuen <code>MockMessenger</code> und einen <code>max</code>-Wert von
<code>100</code>. Wir rufen die Methode <code>set_value</code> auf <code>LimitTracker</code> mit dem Wert <code>80</code>
auf, was mehr als 75 Prozent von 100 ist. Dann stellen wir sicher, dass die
Nachrichtenliste, die der <code>MockMessenger</code> verwaltet, nun eine einzige Nachricht
enthalten sollte.</p>
<p>Es gibt jedoch ein Problem mit diesem Test, wie hier gezeigt:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
2  ~     fn send(&amp;mut self, msg: &amp;str);
3  | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>Wir können <code>MockMessenger</code> nicht so ändern, dass es die Nachrichten verfolgt,
da die Methode <code>send</code> eine unveränderbare Referenz auf <code>self</code> benötigt. Wir
können auch nicht den Vorschlag aus dem Fehlertext übernehmen, <code>&amp;mut self</code>
sowohl in der Methode <code>impl</code> als auch in der Merkmalsdefinition zu verwenden.
Wir wollen das Merkmal <code>Messenger</code> nicht nur um des Testens willen ändern.
Stattdessen müssen wir einen Weg finden, damit unser Testcode mit unserem
bestehenden Design korrekt funktioniert.</p>
<p>Dies ist eine Situation, in der innere Veränderbarkeit helfen kann! Wir
speichern die <code>send_messages</code> in einer <code>RefCell&lt;T&gt;</code> und dann kann die Methode
<code>send</code> den Wert <code>sent_messages</code> ändern, um Nachrichten zu speichern, die wir
gesehen haben. Codeblock 15-22 zeigt, wie das aussieht.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Fehler: Du hast dein Kontingent überschritten!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Dringliche Warnung: Du hast über 90% deines Kontingents verbraucht!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warnung: Du hast über 50% deines Kontingents verbraucht!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --abschneiden--

<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span>        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
<p><span class="caption">Codeblock 15-22: <code>RefCell&lt;T&gt;</code> verwenden, um einen inneren
Wert zu verändern, während der äußere Wert als unveränderbar betrachtet
wird</span></p>
<p>Das Feld <code>sent_messages</code> ist jetzt vom Typ <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> anstelle von
<code>Vec&lt;String&gt;</code>. In der Funktion <code>new</code> erstellen wir eine neue
<code>RefCell&lt;Vec&lt;Sting&gt;&gt;</code>-Instanz um den leeren Vektor.</p>
<p>Für die Implementierung der Methode <code>send</code> ist der erste Parameter immer noch
eine unveränderbare Ausleihe von <code>self</code>, die der Merkmalsdefinition entspricht.
Wir rufen <code>borrow_mut</code> auf der <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code>self.sent_messages</code>
auf, um eine veränderbare Referenz auf den Wert in der <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
zu erhalten, der der Vektor ist. Dann können wir <code>push</code> auf der veränderbaren
Referenz zum Vektor aufrufen, um die während des Tests gesendeten Nachrichten
zu verfolgen.</p>
<p>Die letzte Änderung, die wir vornehmen müssen, betrifft die Zusicherung: Um zu
sehen, wie viele Elemente sich im inneren Vektor befinden, rufen wir <code>borrow</code>
auf <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> auf, um eine unveränderbare Referenz auf den Vektor
zu erhalten.</p>
<p>Nachdem du nun gesehen hast, wie du <code>RefCell&lt;T&gt;</code> verwendest, wollen wir uns mit
der Funktionsweise befassen.</p>
<h4 id="mit-refcellt-den-Überblick-über-die-ausleihen-zur-laufzeit-behalten"><a class="header" href="#mit-refcellt-den-Überblick-über-die-ausleihen-zur-laufzeit-behalten">Mit <code>RefCell&lt;T&gt;</code> den Überblick über die Ausleihen zur Laufzeit behalten</a></h4>
<p>Beim Erstellen unveränderbarer und veränderbarer Referenzen verwenden wir die
Syntax <code>&amp;</code> bzw. <code>&amp;mut</code>. Bei <code>RefCell&lt;T&gt;</code> verwenden wir die Methoden <code>borrow</code> und
<code>borrow_mut</code>, die Teil der sicheren API sind, die zu <code>RefCell&lt;T&gt;</code> gehört. Die
Methode <code>borrow</code> gibt den intelligenten Zeigertyp <code>Ref&lt;T&gt;</code> zurück und
<code>borrow_mut</code> den intelligenten Zeigertyp <code>RefMut&lt;T&gt;</code>. Beide Typen
implementieren <code>Deref</code>, sodass wir sie wie reguläre Referenzen behandeln
können.</p>
<p><code>RefCell&lt;T&gt;</code> verfolgt, wie viele intelligente Zeiger <code>Ref&lt;T&gt;</code> und <code>RefMut&lt;T&gt;</code>
derzeit aktiv sind. Jedes Mal, wenn wir <code>borrow</code> aufrufen, erhöht <code>RefCell&lt;T&gt;</code>
die Anzahl der aktiven unveränderbaren Ausleihen. Wenn ein <code>Ref&lt;T&gt;</code>-Wert
außerhalb des Gültigkeitsbereichs (scope) liegt, sinkt die Anzahl der
unveränderbaren Ausleihen um eins. Genau wie bei den Ausleihregeln zur
Kompilierzeit können wir mit <code>RefCell&lt;T&gt;</code> zu jedem Zeitpunkt viele
unveränderbare Ausleihen oder eine veränderbare Ausleihe haben.</p>
<p>Wenn wir versuchen, diese Regeln zu verletzen, erhalten wir keinen
Kompilierfehler wie bei Referenzen, sondern die Implementierung von
<code>RefCell&lt;T&gt;</code> wird zur Laufzeit abstürzen. Codeblock 15-23 zeigt eine
Modifikation der Implementierung von <code>send</code> in Codeblock 15-22. Wir versuchen
absichtlich, zwei veränderbare Ausleihen im selben Gültigkeitsbereich zu
erstellen, um zu veranschaulichen, dass <code>RefCell&lt;T&gt;</code> uns daran hindert, dies
zur Laufzeit zu tun.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust panics edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Fehler: Du hast dein Kontingent überschritten!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Dringliche Warnung: Du hast über 90% deines Kontingents verbraucht!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warnung: Du hast über 50% deines Kontingents verbraucht!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-23: Wir erstellen zwei veränderbare
Referenzen im selben Gültigkeitsbereich, um zu sehen, dass <code>RefCell&lt;T&gt;</code>
abstürzt</span></p>
<p>Wir erstellen eine Variable <code>one_borrow</code> für den intelligenten Zeiger
<code>RefMut&lt;T&gt;</code>, der von <code>borrow_mut</code> zurückgegeben wird. Dann erstellen wir auf
die gleiche Weise eine weitere veränderbare Ausleihe in der Variable
<code>two_borrow</code>. Dadurch werden zwei veränderbare Referenzen im selben
Gültigkeitsbereich erstellt, was nicht zulässig ist. Wenn wir die Tests für
unsere Bibliothek ausführen, wird der Programmcode in Codeblock 15-23
fehlerfrei kompiliert, aber der Test schlägt fehl:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Beachte, dass der Programmcode mit der Meldung <code>already borrowed: BorrowMutError</code> abstürzt. Auf diese Weise behandelt <code>RefCell&lt;T&gt;</code> zur
Laufzeit Verstöße gegen die Ausleihregel.</p>
<p>Wenn du dich dafür entscheidest, Ausleihfehler zur Laufzeit und nicht zur
Kompilierzeit abzufangen, wie wir es hier getan haben, bedeutet das, dass du
Fehler in deinem Code möglicherweise erst später im Entwicklungsprozess
findest: Möglicherweise erst, wenn dein Code in der Produktion eingesetzt
wird. Außerdem würde dieser Programmcode eine kleine Beeinträchtigung der
Laufzeitperformanz verursachen, da die Ausleihen zur Laufzeit und nicht zur
Kompilierzeit nachverfolgt werden. Die Verwendung von <code>RefCell&lt;T&gt;</code> ermöglicht
es jedoch, ein Mock-Objekt zu schreiben, das sich selbst ändern kann, um die
Nachrichten zu verfolgen, die es gesehen hat, während man es in einem Kontext
verwendet, in dem nur unveränderbare Werte zulässig sind. Man kann
<code>RefCell&lt;T&gt;</code> trotz seiner Kompromisse verwenden, um mehr Funktionen zu
erhalten, als reguläre Referenzen bieten.</p>
<h3 id="mehrere-eigentümer-veränderbarer-daten-mit-rct-und-refcellt-erlauben"><a class="header" href="#mehrere-eigentümer-veränderbarer-daten-mit-rct-und-refcellt-erlauben">Mehrere Eigentümer veränderbarer Daten mit <code>Rc&lt;T&gt;</code> und <code>RefCell&lt;T&gt;</code> erlauben</a></h3>
<p>Eine übliche Methode zur Verwendung von <code>RefCell&lt;T&gt;</code> ist die Kombination mit
<code>Rc&lt;T&gt;</code>. Erinnere dich, dass man mit <code>Rc&lt;T&gt;</code> mehrere Eigentümer einiger Daten
haben kann, aber nur unveränderbaren Zugriff auf diese Daten erhält. Wenn
man eine <code>Rc&lt;T&gt;</code> hat, das eine <code>RefCell&lt;T&gt;</code> enthält, kann man einen Wert
erhalten, der mehrere Eigentümer hat <em>und</em> veränderbar ist!</p>
<p>Erinnern wir uns beispielsweise an die Cons-Liste in Codeblock 15-18, in dem
wir <code>Rc&lt;T&gt;</code> verwendet haben, um mehreren Listen die gemeinsame Nutzung einer
anderen Liste zu ermöglichen. Da <code>Rc&lt;T&gt;</code> nur unveränderbare Werte enthält,
können wir keinen der Werte in der Liste ändern, sobald wir sie erstellt haben.
Fügen wir <code>RefCell&lt;T&gt;</code> hinzu, um die Werte in den Listen ändern zu können.
Codeblock 15-24 zeigt, dass wir durch Verwendung einer <code>RefCell&lt;T&gt;</code> in der
Cons-Definition den in allen Listen gespeicherten Wert ändern können:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a nachher = {a:?}");
    println!("b nachher = {b:?}");
    println!("c nachher = {c:?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 15-24: Verwenden von <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> um
<code>List</code> zu erstellen, die wir verändern können</span></p>
<p>Wir erstellen einen Wert, der eine Instanz von <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> ist, und
speichern ihn dann in einer Variable mit dem Namen <code>value</code>, damit wir später
direkt darauf zugreifen können. Dann erstellen wir eine Liste <code>a</code> mit einer
<code>Cons</code>-Variante, die <code>value</code> enthält. Wir müssen <code>value</code> klonen, damit sowohl
<code>a</code> als auch <code>value</code> die Eigentümerschaft am inneren Wert <code>5</code> haben, anstatt
die Eigentümerschaft von <code>value</code> auf <code>a</code> zu übertragen oder <code>a</code> von <code>value</code>
auszuleihen.</p>
<p>Wir wickeln die Liste <code>a</code> in ein <code>Rc&lt;T&gt;</code> ein. Wenn wir also die Listen <code>b</code> und
<code>c</code> erstellen, können beide auf <code>a</code> verweisen, was wir in Codeblock 15-18 getan
haben.</p>
<p>Nachdem wir die Listen <code>a</code>, <code>b</code> und <code>c</code> erstellt haben, wollen wir 10 zum Wert
in <code>value</code> addieren. Dazu rufen wir <code>borrow_mut</code> für <code>value</code> auf, die die
automatische Dereferenzierung verwendet, die wir in <a href="ch05-03-method-syntax.html#wo-ist-der-operator--">„Wo ist der Operator
<code>-&gt;</code>?“</a> besprochen haben, um <code>Rc&lt;T&gt;</code> auf den inneren
<code>RefCell&lt;T&gt;</code>-Wert zu dereferenzieren. Die Methode <code>borrow_mut</code> gibt einen
intelligenten Zeiger <code>RefMut&lt;T&gt;</code> zurück, und wir verwenden den
Dereferenzierungsoperator darauf und ändern den inneren Wert.</p>
<p>Wenn wir <code>a</code>, <code>b</code> und <code>c</code> ausgeben, können wir sehen, dass sie alle den
veränderten Wert <code>15</code> anstelle von <code>5</code> haben:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a nachher = Cons(RefCell { value: 15 }, Nil)
b nachher = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c nachher = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>Diese Technik ist ganz ordentlich! Durch die Verwendung von <code>RefCell&lt;T&gt;</code> haben
wir einen nach außen unveränderbaren <code>List</code>-Wert. Wir können jedoch die
Methoden für <code>RefCell&lt;T&gt;</code> verwenden, die den Zugriff auf die innere
Veränderbarkeit ermöglichen, damit wir unsere Daten bei Bedarf ändern können.
Die Laufzeitprüfungen der Ausleihregeln schützen uns vor
Daten-Wettlaufsituationen (data races), und manchmal lohnt es sich, ein wenig
Geschwindigkeit für diese Flexibilität in unseren Datenstrukturen
einzutauschen. Beachte, dass <code>RefCell&lt;T&gt;</code> nicht bei nebenläufigem Code
funktioniert! <code>Mutex&lt;T&gt;</code> ist die Strang-sichere (thread-safe) Version von
<code>RefCell&lt;T&gt;</code> und wir werden <code>Mutex&lt;T&gt;</code> in Kapitel 16 besprechen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referenzzyklen-können-zu-einem-speicherleck-führen"><a class="header" href="#referenzzyklen-können-zu-einem-speicherleck-führen">Referenzzyklen können zu einem Speicherleck führen</a></h2>
<p>Die Speichersicherheitsgarantien von Rust machen es schwierig, aber nicht
unmöglich, versehentlich Speicher zu allokieren, der niemals aufgeräumt wird
(bekannt als <em>Speicherleck</em> (memory leak)). Das vollständige Verhindern von
Speicherlecks gehört nicht zu den Garantien von Rust, d.h. Speicherlecks sind
in Rust speichersicher. Wir können sehen, dass Rust Speicherlecks mithilfe von
<code>Rc&lt;T&gt;</code> und <code>RefCell&lt;T&gt;</code> zulässt: Es ist möglich, Referenzen zu erstellen, bei
denen Elemente in einem Zyklus aufeinander referenzieren. Dies führt zu
Speicherlecks, da der Referenzzähler jedes Elements im Zyklus niemals 0
erreicht und die Werte niemals aufgeräumt werden.</p>
<h3 id="einen-referenzzyklus-erstellen"><a class="header" href="#einen-referenzzyklus-erstellen">Einen Referenzzyklus erstellen</a></h3>
<p>Schauen wir uns an, wie ein Referenzzyklus passieren und wie er verhindert
werden kann, beginnend mit der Definition der Aufzählung <code>List</code> und einer
Methode <code>tail</code> in Codeblock 15-25.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
<p><span class="caption">Codeblock 15-25: Definition einer Cons-Liste die ein
<code>RefCell&lt;T&gt;</code> hält, damit man ändern kann, worauf eine <code>Cons</code>-Variante
referenziert</span></p>
<p>Wir verwenden eine andere Variante der <code>List</code>-Definition aus Codeblock 15-5.
Das zweite Element in der <code>Cons</code>-Variante ist jetzt <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>. Dies
bedeutet, dass wir anstelle der Möglichkeit, den <code>i32</code>-Wert wie in Codeblock
15-24 zu ändern, den <code>List</code>-Wert einer <code>Cons</code>-Variante ändern, auf den sie
zeigt. Wir fügen eine Methode <code>tail</code> hinzu, damit wir bequem auf das zweite
Element zugreifen können, wenn wir eine <code>Cons</code>-Variante haben.</p>
<p>In Codeblock 15-26 fügen wir eine Funktion <code>main</code> hinzu, die die Definitionen
in Codeblock 15-25 verwendet. Dieser Code erstellt eine Liste <code>a</code> und eine
Liste <code>b</code>, die auf die Liste <code>a</code> zeigt. Anschließend wird die Liste <code>a</code> so
geändert, dass sie auf <code>b</code> zeigt, wodurch ein Referenzzyklus erstellt wird. Wir
fügen <code>println!</code>-Anweisungen ein, um zu zeigen, wie hoch der Referenzzähler an
den jeweiligen Stellen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a anfängliche Rc-Zählung = {}", Rc::strong_count(&amp;a));
    println!("a nächstes Element = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("a Rc-Zählung nach Erstellen von b = {}", Rc::strong_count(&amp;a));
    println!("b anfängliche Rc-Zählung = {}", Rc::strong_count(&amp;b));
    println!("b nächstes Element = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("b Rc-Zählung nach Änderung von a = {}", Rc::strong_count(&amp;b));
    println!("a Rc-Zählung nach Änderung von a = {}", Rc::strong_count(&amp;a));

    // Kommentiere die nächste Zeile aus, um zu sehen, dass wir einen Zyklus haben;
    // sie wird den Stapelspeicher (stack) überlaufen lassen.
    // println!("a nächstes Element = {:?}", a.tail());
}</code></pre></pre>
<p><span class="caption">Codeblock 15-26: Erstellen eines Referenzzyklus aus zwei
Listenwerten, die aufeinander zeigen</span></p>
<p>Wir erstellen eine <code>Rc&lt;List&gt;</code>-Instanz, die einen <code>List</code>-Wert in der Variablen
<code>a</code> mit einer initialen Liste <code>5, Nil</code> enthält. Wir erstellen dann eine
<code>Rc&lt;List&gt;</code>-Instanz, die einen anderen <code>List</code>-Wert in der Variablen <code>b</code> enthält,
die den Wert <code>10</code> enthält und auf die Liste in <code>a</code> zeigt.</p>
<p>Wir modifizieren <code>a</code> so, dass es auf <code>b</code> anstatt auf <code>Nil</code> zeigt, wodurch ein
Zyklus erstellt wird. Wir tun dies, indem wir die Methode <code>tail</code> verwenden, um
eine Referenz auf <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> in <code>a</code> zu erhalten, die wir in die
Variable <code>link</code> einfügen. Dann verwenden wir die Methode <code>borrow_mut</code> für
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, um den Wert von <code>Rc&lt;List&gt;</code>, der einen <code>Nil</code>-Wert enthält,
in <code>Rc&lt;List&gt;</code> in <code>b</code> zu ändern.</p>
<p>Wenn wir diesen Programmcode ausführen und das letzte <code>println!</code>
auskommentieren, erhalten wir folgende Ausgabe:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a anfängliche Rc-Zählung = 1
a nächstes Element = Some(RefCell { value: Nil })
a Rc-Zählung nach erstellen von b = 2
b anfängliche Rc-Zählung = 1
b nächstes Element = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b Rc-Zählung nach Änderung von a = 2
a Rc-Zählung nach Änderung von a = 2     
</code></pre>
<p>Der Referenzzähler der <code>Rc&lt;List&gt;</code>-Instanzen in <code>a</code> und <code>b</code> beträgt 2, nachdem
wir die Liste in <code>a</code> so geändert haben, dass sie auf <code>b</code> zeigt. Am Ende von
<code>main</code> versucht Rust, zuerst <code>b</code> aufzuräumen, wodurch der Zähler der
<code>Rc&lt;List&gt;</code>-Instanz in <code>b</code> um 1 verringert wird. Der Speicher, den <code>Rc&lt;List&gt;</code>
auf dem Haldenspeicher (heap) hat, wird zu diesem Zeitpunkt nicht aufgeräumt,
da seine Referenzanzahl 1 und nicht 0 ist. Dann räumt Rust <code>a</code> auf, was die
Referenzanzahl der <code>Rc&lt;List&gt;</code>-Instanz in <code>a</code> ebenfalls von 2 auf 1 reduziert.
Der Speicher dieser Instanz kann ebenfalls nicht aufgeräumt werden, weil die
andere <code>Rc&lt;List&gt;</code>-Instanz immer noch auf sie referenziert. Der der Liste
zugewiesene Speicher bleibt für immer unaufgeräumt. Das Diagramm in Abbildung
15-4 veranschaulicht diesen Referenzzyklus.</p>
<img alt="Referenzzyklus von Listen" src="img/trpl15-04.svg" class="center" style="width: 40%;" />
<p><span class="caption">Abbildung 15-4: Ein Referenzzyklus der Listen <code>a</code> und
<code>b</code>, die aufeinander zeigen</span></p>
<p>Wenn man das letzte <code>println!</code> auskommentiert und das Programm ausführt,
versucht Rust, diesen Zyklus mit <code>a</code> auszugeben, wobei <code>b</code> auf <code>a</code> zeigt, und
so weiter, bis der Stapelspeicher (stack) überläuft.</p>
<p>Im Vergleich zu einem realen Programm sind die Konsequenzen, die das Anlegen
eines Referenzzyklus in diesem Beispiel hat, nicht sehr schlimm: Gleich nachdem
wir den Referenzzyklus angelegt haben, endet das Programm. Wenn jedoch ein
komplexeres Programm viel Speicher in einem Zyklus allokierte und diesen lange
Zeit behielte, würde das Programm mehr Speicher als erforderlich verbrauchen
und das System möglicherweise überlasten, sodass ihm der verfügbare Speicher
ausgeht.</p>
<p>Das Erstellen von Referenzzyklen ist nicht einfach, aber auch nicht unmöglich.
Wenn man <code>RefCell&lt;T&gt;</code>-Werte hat, die <code>Rc&lt;T&gt;</code>-Werte oder ähnliche verschachtelte
Typkombinationen mit innerer Veränderbarkeit und Referenzzählung enthalten,
muss man sicherstellen, dass man keine Zyklen erstellt. Man kann sich nicht
darauf verlassen, dass Rust sie feststellen kann. Das Erstellen eines
Referenzzyklus wäre ein logischer Fehler in deinem Programm, den du mithilfe
automatisierter Tests, Codeüberprüfungen und anderer Methoden zur
Softwareentwicklung minimieren solltest.</p>
<p>Eine andere Lösung zur Vermeidung von Referenzzyklen besteht darin, deine
Datenstrukturen so zu reorganisieren, dass einige Referenzen die
Eigentümerschaft (ownership) erhalten und andere nicht. Infolgedessen können
Zyklen entstehen, die aus Beziehungen mit und ohne Eigentümerschaft bestehen,
und nur die Beziehungen mit Eigentümerschaft beeinflussen, ob ein
Wert aufgeräumt wird oder nicht. In Codeblock 15-25 möchten wir immer, dass
<code>Cons</code>-Varianten ihre Liste besitzen, sodass eine Neuorganisation der
Datenstruktur nicht möglich ist. Schauen wir uns ein Beispiel an, in dem
Diagramme aus übergeordneten und untergeordneten Knoten verwendet werden, um
festzustellen, wann Beziehungen ohne Eigentümerschaft ein geeigneter Weg sind,
um Referenzzyklen zu verhindern.</p>
<h3 id="verhindern-von-referenzzyklen-mit-weakt"><a class="header" href="#verhindern-von-referenzzyklen-mit-weakt">Verhindern von Referenzzyklen mit <code>Weak&lt;T&gt;</code></a></h3>
<p>Bisher haben wir gezeigt, dass das Aufrufen von <code>Rc::clone</code> den <code>strong_count</code>
einer <code>Rc&lt;T&gt;</code>-Instanz erhöht und eine <code>Rc&lt;T&gt;</code>-Instanz nur dann aufgeräumt wird,
wenn ihr <code>strong_count</code> 0 ist. Man kann auch eine <em>schwache Referenz</em> (weak
reference) auf den Wert innerhalb einer <code>Rc&lt;T&gt;</code>-Instanz erstellen, indem man
<code>Rc::downgrade</code> aufruft und eine Referenz auf den <code>Rc&lt;T&gt;</code> übergibt. Starke
Referenzen sind die Art und Weise, wie man die Eigentümerschaft an einer
<code>Rc&lt;T&gt;</code>-Instanz teilen kann. Schwache Referenzen drücken keine
Eigentumsbeziehung aus, und ihre Anzahl hat keinen Einfluss darauf, wann eine
<code>Rc&lt;T&gt;</code> Instanz aufgeräumt wird. Sie werden keinen Referenzzyklus verursachen,
weil jeder Zyklus, der schwache Referenzen beinhaltet, unterbrochen wird,
sobald die Anzahl der starken Referenzen der beteiligten Werte 0 ist.</p>
<p>Wenn man <code>Rc::downgrade</code> aufruft, erhält man einen intelligenten Zeiger vom Typ
<code>Weak&lt;T&gt;</code>. Anstatt den <code>strong_count</code> in der <code>Rc&lt;T&gt;</code>-Instanz um 1 zu erhöhen,
erhöht der Aufruf von <code>Rc::downgrade</code> den <code>weak_count</code> um 1. Der Typ <code>Rc&lt;T&gt;</code>
verwendet <code>weak_count</code>, um den Überblick zu behalten wie viele
<code>Weak&lt;T&gt;</code>-Referenzen existieren, ähnlich wie bei <code>strong_count</code>. Der
Unterschied besteht darin, dass <code>weak_count</code> nicht 0 sein muss, damit die
<code>Rc&lt;T&gt;</code>-Instanz aufgeräumt wird.</p>
<p>Da der Wert, auf den <code>Weak&lt;T&gt;</code> referenziert, möglicherweise aufgeräumt wurde,
musst du sicherstellen, dass der Wert noch vorhanden ist, um etwas mit dem Wert
zu tun, auf den ein <code>Weak&lt;T&gt;</code> zeigt. Ruft man dazu die Methode <code>upgrade</code> für
eine <code>Weak&lt;T&gt;</code>-Instanz auf, die eine <code>Option&lt;Rc&lt;T&gt;&gt;</code>zurückgibt, erhält man ein
<code>Some</code> als Ergebnis, wenn der Wert <code>Rc&lt;T&gt;</code> noch nicht aufgeräumt wurde, und das
Ergebnis <code>None</code>, wenn der <code>Rc&lt;T&gt;</code>-Wert aufgeräumt wurde. Da <code>upgrade</code> eine
<code>Option&lt;Rc&lt;T&gt;&gt;</code> zurückgibt, stellt Rust sicher, dass der Fall <code>Some</code> und der
Fall <code>None</code> behandelt werden und es keine ungültigen Zeiger gibt.</p>
<p>Anstatt eine Liste zu verwenden, deren Elemente nur das nächste Element kennen,
erstellen wir eine Baumstruktur, deren Elemente die Kind-Elemente <em>und</em> die
Eltern-Elemente kennen.</p>
<h4 id="erstellen-einer-baumdatenstruktur-ein-knoten-mit-kind-knoten"><a class="header" href="#erstellen-einer-baumdatenstruktur-ein-knoten-mit-kind-knoten">Erstellen einer Baumdatenstruktur: Ein Knoten mit Kind-Knoten</a></h4>
<p>Zunächst erstellen wir eine Baumstruktur mit Knoten (nodes), die ihre
Kind-Knoten kennen. Wir erstellen eine Struktur mit dem Namen <code>Node</code>, die ihren
eigenen <code>i32</code>-Wert sowie Referenzen auf die Kind-<code>Node</code>-Werte enthält:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>Wir möchten, dass ein <code>Node</code> seine Kind-Elemente besitzt, und wir möchten diese
Eigentümerschaft mit Variablen teilen, damit wir direkt auf jeden <code>Node</code> in
der Baumstruktur zugreifen können. Zu diesem Zweck definieren wir die
<code>Vec&lt;T&gt;</code>-Elemente als Werte vom Typ <code>Rc&lt;Node&gt;</code>. Wir möchten auch ändern, welche
Knoten Kind-Knoten eines anderen Knotens sind, sodass wir ein <code>RefCell&lt;T&gt;</code> in
<code>children</code> um den <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> haben.</p>
<p>Als Nächstes verwenden wir unsere Strukturdefinition und erstellen eine
<code>Node</code>-Instanz mit dem Namen <code>leaf</code> und dem Wert <code>3</code> und ohne Kind-Elemente,
sowie eine weitere Instanz mit dem Namen <code>branch</code> und dem Wert <code>5</code> und <code>leaf</code>
als Kind-Element, wie in Codeblock 15-27 gezeigt wird.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
<p><span class="caption">Codeblock 15-27: Erstellen eines <code>leaf</code>-Knotens ohne
Kind-Element und eines <code>branch</code>-Knotens mit <code>leaf</code> als Kind-Element</span></p>
<p>Wir klonen <code>Rc&lt;Node&gt;</code> in <code>leaf</code> und speichern ihn in <code>branch</code>, was bedeutet,
dass der <code>Node</code> in <code>leaf</code> jetzt zwei Eigentümer hat: <code>leaf</code> und <code>branch</code>. Wir
können über <code>branch.children</code> von <code>branch</code> zu <code>leaf</code> gelangen, aber es gibt
keine Möglichkeit, von <code>leaf</code> zu <code>branch</code> zu gelangen. Der Grund dafür ist,
dass <code>leaf</code> keine Referenz zu <code>branch</code> hat und daher nicht weiß, dass diese in
Beziehung stehen. Wir möchten, dass <code>leaf</code> weiß, dass <code>branch</code> ein
übergeordnetes Element ist. Das machen wir als Nächstes.</p>
<h4 id="hinzufügen-einer-referenz-vom-kind--zum-eltern-element"><a class="header" href="#hinzufügen-einer-referenz-vom-kind--zum-eltern-element">Hinzufügen einer Referenz vom Kind- zum Eltern-Element</a></h4>
<p>Um dem Kind-Knoten seinen Eltern-Knoten bewusst zu machen, müssen wir unserer
Strukturdefinition <code>Node</code> ein <code>parent</code>-Feld hinzufügen. Das Problem besteht
darin, zu entscheiden, welcher Typ <code>parent</code> sein soll. Wir wissen, dass es
keinen <code>Rc&lt;T&gt;</code> enthalten kann, da dies einen Referenzzyklus erzeugen würde, bei
dem <code>leaf.parent</code> auf <code>branch</code> und <code>branch.children</code> auf <code>leaf</code> zeigt, was dazu
führen würde das die <code>strong_count</code>-Werte niemals 0 sein würden.</p>
<p>Wenn man die Beziehungen auf andere Weise betrachtet, sollte ein Eltern-Knoten
die Eigentümerschaft seiner Kind-Knoten besitzen: Wenn ein Eltern-Knoten
aufgeräumt wird, sollten auch seine Kind-Knoten aufgeräumt werden. Ein
Kind-Knoten sollte jedoch keine Eigentümerschaft seines Eltern-Elementes haben:
Wenn wir einen Kind-Knoten aufräumen, sollte das Eltern-Element weiterhin
existieren. Dies ist ein Fall für schwache Referenzen!</p>
<p>Anstelle von <code>Rc&lt;T&gt;</code> wird <code>parent</code> den Typ <code>Weak&lt;T&gt;</code> verwenden, im Speziellen
einen <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Nun sieht unsere <code>Node</code>-Strukturdefinition
folgendermaßen aus:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>Ein Knoten kann auf seinen Eltern-Knoten referenzieren, besitzt ihn jedoch
nicht. In Codeblock 15-28 aktualisieren wir <code>main</code>, um diese neue Definition
zu verwenden, damit der <code>leaf</code>-Knoten auf seinen Eltern-Knoten <code>branch</code>
referenzieren kann.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}</code></pre></pre>
<p><span class="caption">Codeblock 15-28: Ein <code>leaf</code>-Knoten mit einer schwachen
Referenz auf seinen Eltern-Knoten <code>branch</code></span></p>
<p>Das Erstellen des <code>leaf</code>-Knotens ähnelt Codeblock 15-27 mit Ausnahme des Feldes
<code>parent</code>: <code>leaf</code> beginnt ohne Eltern-Knoten, daher erstellen wir eine neue
leere <code>Weak&lt;Node&gt;</code>-Referenz-Instanz.</p>
<p>Wenn wir zu diesem Zeitpunkt versuchen, mit der Methode <code>upgrade</code> eine Referenz
auf das Eltern-Element von <code>leaf</code> zu bekommen, erhalten wir den Wert <code>None</code>.
Wir sehen dies in der Ausgabe der ersten <code>println!</code>-Anweisung:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>Wenn wir den <code>branch</code>-Knoten erstellen, hat er auch eine neue
<code>Weak&lt;Node&gt;</code>-Referenz im Feld <code>parent</code>, da <code>branch</code> keinen Eltern-Knoten hat.
Wir haben noch immer <code>leaf</code> als Kind-Element von <code>branch</code>. Sobald wir die
<code>Node</code>-Instanz in <code>branch</code> haben, können wir <code>leaf</code> ändern, um ihm eine
<code>Weak&lt;Node&gt;</code>-Referenz auf sein Eltern-Element zu geben. Wir verwenden die
Methode <code>borrow_mut</code> für <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> im <code>parent</code>-Feld von <code>leaf</code> und
verwenden dann die Funktion <code>Rc::downgrade</code>, um eine <code>Weak&lt;Node&gt;</code>-Referenz auf
<code>branch</code> aus dem <code>Rc&lt;Node&gt;</code> in <code>branch</code> zu erzeugen.</p>
<p>Wenn wir das Eltern-Element von <code>leaf</code> erneut ausgeben, erhalten wir diesmal
eine <code>Some</code>-Variante mit <code>branch</code>: Jetzt kann <code>leaf</code> auf das Eltern-Element
zugreifen! Wenn wir <code>leaf</code> ausgeben, vermeiden wir auch den Zyklus, der
schließlich zu einem Stapelspeicherüberlauf führte, wie wir ihn in Codeblock
15-26 hatten. Die <code>Weak&lt;Node&gt;</code>-Referenzen werden als <code>(Weak)</code> ausgegeben:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>Das Fehlen einer unendlichen Ausgabe bedeutet, dass dieser Programmcode keinen
Referenzzyklus erzeugt hat. Wir können dies auch anhand der Werte erkennen, die
wir durch den Aufruf von <code>Rc::strong_count</code> und <code>Rc::weak_count</code> erhalten.</p>
<h4 id="visualisieren-von-Änderungen-an-strong_count-und-weak_count"><a class="header" href="#visualisieren-von-Änderungen-an-strong_count-und-weak_count">Visualisieren von Änderungen an <code>strong_count</code> und <code>weak_count</code></a></h4>
<p>Schauen wir uns an, wie sich die Werte für <code>strong_count</code> und <code>weak_count</code> der
<code>Rc&lt;Node&gt;</code>-Instanzen ändern, indem ein neuer innerer Gültigkeitsbereich (scope)
erstellt und die Erstellung von <code>branch</code> in diesen Bereich verschoben wird. Auf
diese Weise können wir sehen, was passiert, wenn <code>branch</code> erstellt und dann
aufgeräumt wird, wenn es den Gültigkeitsbereich verlässt. Die Änderungen
sind in Codeblock 15-29 aufgeführt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
<p><span class="caption">Codeblock 15-29: Erstellen von <code>branch</code> in einem inneren
Gültigkeitsbereich und Prüfen der starken und schwachen Referenzzähler</span></p>
<p>Nachdem <code>leaf</code> erstellt wurde, hat <code>Rc&lt;Node&gt;</code> einen <code>strong_count</code> von 1 und
einen <code>weak_count</code> von 0. Im inneren Gültigkeitsbereich erstellen wir <code>branch</code>
und ordnen ihm <code>leaf</code> zu. Zum Zeitpunkt des Ausgebens der Zähler, hat der
<code>Rc&lt;Node&gt;</code> in <code>branch</code> einen <code>strong_count</code> von 1 und einen <code>weak_count</code> von 1
(da <code>leaf.parent</code> mit einen <code>Weak&lt;Node&gt;</code> auf <code>branch</code> zeigt). Wenn wir den
Zähler in <code>leaf</code> ausgeben, werden wir sehen, dass er einen <code>strong_count</code> von 2
hat, da <code>branch</code> jetzt einen Klon des <code>Rc&lt;Node&gt;</code> von <code>leaf</code> in
<code>branch.children</code> gespeichert hat, aber immer noch einen <code>weak_count</code>von 0 hat.</p>
<p>Wenn der innere Gültigkeitsbereich endet, verlässt <code>branch</code> den
Gültigkeitsbereich und der <code>strong_count</code> von <code>Rc&lt;Node&gt;</code> sinkt auf 0, sodass
sein <code>Node</code> aufgeräumt wird. Der <code>weak_count</code> von 1 aus <code>leaf_parent</code> hat keinen
Einfluss darauf, ob <code>Node</code> aufgeräumt wird oder nicht, sodass wir kein
Speicherleck bekommen!</p>
<p>Wenn wir nach dem Ende des Gültigkeitsbereichs versuchen, auf das
Eltern-Element von <code>leaf</code> zuzugreifen, erhalten wir erneut <code>None</code>. Am Ende des
Programms hat der <code>Rc&lt;Node&gt;</code> in <code>branch</code> einen <code>strong_count</code> von 1 und einen
<code>weak_count</code> von 0, da die Variable <code>branch</code> jetzt wieder die einzige Referenz
auf <code>Rc&lt;Node&gt;</code> ist.</p>
<p>Die gesamte Logik, die die Zähler und das Aufräumen des Wertes verwaltet, ist
in <code>Rc&lt;T&gt;</code> und <code>Weak&lt;T&gt;</code> und deren Implementierung des Merkmals (trait) <code>Drop</code>
integriert. Wenn man angibt, dass die Beziehung von einem Kind- zu seinem
Eltern-Element eine <code>Weak&lt;T&gt;</code>-Referenz in der Definition von <code>Node</code> sein soll,
können Eltern-Knoten auf Kind-Knoten referenzieren und umgekehrt, ohne einen
Referenzzyklus oder Speicherlecks zu erzeugen.</p>
<h2 id="zusammenfassung-14"><a class="header" href="#zusammenfassung-14">Zusammenfassung</a></h2>
<p>In diesem Kapitel wurde beschrieben, wie man mithilfe intelligenter Zeiger
andere Garantien und Kompromisse eingehen kann, als es standardmäßig mit gewöhnlichen
Referenzen in Rust möglich ist. Der Typ <code>Box&lt;T&gt;</code> hat eine bekannte Größe und
zeigt auf Daten die auf dem Haldenspeicher allokiert sind. Der Typ <code>Rc&lt;T&gt;</code>
verfolgt die Anzahl der Referenzen von Daten auf dem Haldenspeicher, sodass
Daten mehrere Eigentümer haben können. Der Typ <code>RefCell&lt;T&gt;</code> mit
seiner inneren Veränderbarkeit stellt uns einen Typ zur Verfügung, den wir
verwenden können, wenn wir einen unveränderbaren Typ benötigen, aber einen
inneren Wert dieses Typs ändern müssen. Außerdem werden die Ausleihregeln zur
Laufzeit anstatt zur Kompilierzeit durchgesetzt.</p>
<p>Ebenfalls diskutiert wurden die Merkmale <code>Deref</code> und <code>Drop</code>, die einen Großteil
der Funktionalität von intelligenten Zeigern ermöglichen. Wir haben
Referenzzyklen untersucht, die zu Speicherlecks führen können, und wie diese
mithilfe von <code>Weak&lt;T&gt;</code> verhindert werden können.</p>
<p>Wenn dieses Kapitel dein Interesse geweckt hat und du deinen eigenen
intelligenten Zeiger implementieren möchtest, lies <a href="https://doc.rust-lang.org/nomicon/index.html">„The
Rustonomicon“</a>, um weitere nützliche Informationen zu erhalten.</p>
<p>Als Nächstes werden wir über Nebenläufigkeit (concurrency) in Rust sprechen.
Wir werden sogar einige neue intelligente Zeiger kennenlernen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="furchtlose-nebenläufigkeit"><a class="header" href="#furchtlose-nebenläufigkeit">Furchtlose Nebenläufigkeit</a></h1>
<p>Der sichere und effiziente Umgang mit nebenläufiger Programmierung ist ein
weiteres wichtiges Ziel von Rust. Die <em>nebenläufige Programmierung</em> (concurrent
programming), bei der verschiedene Teile eines Programms unabhängig voneinander
ausgeführt werden, und die <em>parallele Programmierung</em> (parallel programming),
bei der verschiedene Teile eines Programms gleichzeitig ausgeführt werden,
werden immer wichtiger, da immer mehr Computer die Vorteile mehrerer
Prozessoren nutzen. In der Vergangenheit war die Programmierung in diesen
Bereichen schwierig und fehleranfällig: Rust hofft, das ändern zu können.</p>
<p>Ursprünglich dachte das Rust-Team, dass das Gewährleisten von
Speichersicherheit (memory safety) und das Verhindern von
Nebenläufigkeitsproblemen (concurrency problems) zwei separate
Herausforderungen seien, die mit unterschiedlichen Methoden gelöst werden
müssten. Im Laufe der Zeit entdeckte das Team, dass Eigentümerschaft
(ownership) und Typsysteme ein leistungsstarkes Instrumentarium zur Bewältigung
von Speichersicherheits- <em>und</em> Nebenläufigkeitsproblemen sind! Durch das Nutzen
der Eigentümerschaft und Typprüfung werden viele Nebenläufigkeitsfehler zu
Kompilierzeitfehlern in Rust anstatt Laufzeitfehlern. Anstatt dass du viel Zeit
damit verbringen musst, die genauen Umstände zu reproduzieren, unter denen ein
Laufzeit-Nebenläufigkeitsfehler auftritt, wird der fehlerhafte Code nicht
kompilieren und einen Fehler anzeigen, der das Problem erklärt. Dadurch kannst
du deinen Code reparieren, während du daran arbeitest, und nicht möglicherweise
erst, nachdem er in Produktion ausgeliefert wurde. Wir haben diesem Aspekt von
Rust den Spitznamen <em>furchtlose Nebenläufigkeit</em> (fearless concurrency)
gegeben. Die furchtlose Nebenläufigkeit ermöglicht es dir, Code zu schreiben,
der frei von subtilen Fehlern und leicht zu refaktorieren ist, ohne neue
Fehler zu erzeugen.</p>
<blockquote>
<p>Anmerkung: Der Einfachheit halber werden wir viele der Probleme als
<em>nebenläufig</em> bezeichnen, anstatt präziser zu sein, indem wir <em>nebenläufig
und/oder gleichzeitig</em> sagen. Wenn es in diesem Buch um Nebenläufigkeit
und/oder Gleichzeitigkeit ginge, wären wir präziser. Bitte ersetze dieses
Kapitel gedanklich durch <em>nebenläufig und/oder gleichzeitig</em>, wenn wir
<em>nebenläufig</em> verwenden.</p>
</blockquote>
<p>Viele Sprachen sind dogmatisch, was die Lösungen betrifft, die sie zur
Behandlung von Nebenläufigkeitsproblemen anbieten. Beispielsweise verfügt
Erlang über elegante Funktionen für die nachrichtenübermittelnde
Nebenläufigkeit (message-passing concurrency), hat aber nur obskure
Möglichkeiten, einen gemeinsamen Status mit mehreren Strängen (threads) zu
teilen. Die Unterstützung nur einer Teilmenge möglicher Lösungen ist eine
vernünftige Strategie für Hochsprachen, da eine Hochsprache Vorteile
verspricht, wenn sie eine gewisse Kontrolle aufgibt, um Abstraktionen zu
erhalten. Es wird jedoch erwartet, dass Sprachen auf niedrigeren Ebenen in
jeder Situation die Lösung mit der besten Performanz bieten und weniger
Abstraktionen der Hardware haben. Daher bietet Rust eine Vielzahl von
Werkzeugen zur Modellierung von Problemen in der Art und Weise, die für deine
Situation und deine Anforderungen geeignet ist.</p>
<p>Hier sind die Themen, die wir in diesem Kapitel behandeln werden:</p>
<ul>
<li>Wie man Stränge (threads) erstellt, um mehrere Code-Abschnitte gleichzeitig
auszuführen.</li>
<li><em>Nachrichtenübermittelnde</em> Nebenläufigkeit, bei der Kanäle Nachrichten
zwischen Strängen senden.</li>
<li>Nebenläufigkeit mit <em>gemeinsamem Zustand</em> (shared-state), bei der mehrere
Stränge Zugriff auf bestimmte Daten haben.</li>
<li>Die Merkmale (traits) <code>Sync</code> und <code>Send</code>, die Rusts Nebenläufigkeitsgarantien
sowohl auf benutzerdefinierte Typen als auch auf von der Standardbibliothek
bereitgestellte Typen erweitern.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mit-strängen-threads-programmcode-gleichzeitig-ausführen"><a class="header" href="#mit-strängen-threads-programmcode-gleichzeitig-ausführen">Mit Strängen (threads) Programmcode gleichzeitig ausführen</a></h2>
<p>In den meisten aktuellen Betriebssystemen wird der Code eines ausgeführten
Programms in einem <em>Prozess</em> ausgeführt und das Betriebssystem verwaltet
mehrere Prozesse gleichzeitig. Innerhalb eines Programms kannst du auch
unabhängige Teile haben, die gleichzeitig laufen. Die Funktionalitäten, die
diese unabhängigen Teile ausführen, werden <em>Stränge</em> (threads) genannt. Ein
Webserver könnte beispielsweise mehrere Stränge haben, damit er auf mehrere
Anfragen gleichzeitig reagieren kann.</p>
<p>Das Aufteilen der Berechnung in deinem Programm in mehrere Stränge, um mehrere
Aufgaben gleichzeitig auszuführen, kann die Performanz erhöhen, aber es erhöht
auch die Komplexität. Da Stränge gleichzeitig laufen können, gibt es keine
inhärente Garantie für die Reihenfolge, in der Teile deines Codes in
verschiedenen Strängen ausgeführt werden. Dies kann zu Problemen führen wie:</p>
<ul>
<li>Wettlaufsituationen (race conditions), bei denen Stränge auf Daten oder
Ressourcen in einer inkonsistenten Reihenfolge zugreifen.</li>
<li>Deadlocks, bei denen zwei Stränge auf den jeweils anderen warten, sodass
beide Stränge nicht fortgesetzt werden können.</li>
<li>Fehler, die nur in bestimmten Situationen auftreten und schwer zu
reproduzieren und zu beheben sind.</li>
</ul>
<p>Rust versucht, die negativen Auswirkungen bei der Verwendung von Strängen zu
mildern, aber die Programmierung in einem mehrsträngigen Kontext erfordert
immer noch sorgfältige Überlegungen und benötigt eine andere Code-Struktur als
bei Programmen, die in einem einzigen Strang laufen.</p>
<p>Programmiersprachen implementieren Stränge auf verschiedene Weise, und viele
Betriebssysteme bieten eine API, die die Sprache aufrufen kann, um neue Stränge
zu erstellen. Die Rust-Standardbibliothek verwendet ein <em>1:1</em>-Modell der
Strang-Implementierung, bei dem ein Programm einen Betriebssystem-Strang für
einen Sprach-Strang verwendet. Es gibt Kisten, die andere Strang-Modelle
implementieren, die andere Kompromisse als das 1:1-Modell eingehen. (Das
async-System von Rust, das wir uns im nächsten Kapitel ansehen werden, bietet
ebenfalls einen anderen Ansatz der Nebenläufigkeit.)</p>
<h3 id="erstellen-eines-neuen-strangs-mit-spawn"><a class="header" href="#erstellen-eines-neuen-strangs-mit-spawn">Erstellen eines neuen Strangs mit <code>spawn</code></a></h3>
<p>Um einen neuen Strang zu erstellen, rufen wir die Funktion <code>thread::spawn</code> auf
und übergeben ihr einen Funktionsabschluss (closure) (wir haben in Kapitel 13
über Funktionsabschlüsse gesprochen), der den Code enthält, den wir im neuen
Strang ausführen wollen. Das Beispiel in Codeblock 16-1 gibt einen Text im
Hauptstrang und anderen Text im neuen Strang aus:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("Hallo Zahl {i} aus dem erzeugten Strang!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("Hallo Zahl {i} aus dem Hauptstrang!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 16-1: Erstellen eines neuen Strangs, um einen
Text auszugeben, während der Hauptstrang einen anderen Text ausgibt</span></p>
<p>Beachte, dass bei der Beendigung des Hauptstrangs eines Rust-Programms alle
erzeugten Stränge beendet werden, unabhängig davon, ob sie zu Ende gelaufen
sind oder nicht. Die Ausgabe dieses Programms kann jedes Mal ein wenig anders
sein, aber sie wird in etwa wie folgt aussehen:</p>
<pre><code class="language-text">Hallo Zahl 1 aus dem Hauptstrang!
Hallo Zahl 1 aus dem erzeugten Strang!
Hallo Zahl 2 aus dem Hauptstrang!
Hallo Zahl 2 aus dem erzeugten Strang!
Hallo Zahl 3 aus dem Hauptstrang!
Hallo Zahl 3 aus dem erzeugten Strang!
Hallo Zahl 4 aus dem Hauptstrang!
Hallo Zahl 4 aus dem erzeugten Strang!
Hallo Zahl 5 aus dem erzeugten Strang!
</code></pre>
<p>Aufrufe von <code>thread::sleep</code> zwingen einen Strang, seine Ausführung für eine
kurze Zeit anzuhalten, sodass ein anderer Strang laufen kann. Die Stränge
werden sich wahrscheinlich abwechseln, aber das ist nicht garantiert: Es hängt
davon ab, wie dein Betriebssystem die Stränge organisiert (schedule). In diesem
Lauf hat der Hauptstrang zuerst etwas ausgegeben, obwohl sich die
Ausgabeanweisung des erzeugten Strangs weiter oben im Code befindet. Und obwohl
wir dem erzeugten Strang gesagt haben, er solle solange etwas ausgeben, bis <code>i</code>
den Wert <code>9</code> hat, kam er nur bis <code>5</code>, als sich der Hauptstrang beendet hat.</p>
<p>Wenn du diesen Code ausführst und nur Ausgaben aus dem Hauptstrang siehst oder
keine Überschneidungen feststellst, versuche, die Zahlen in den Bereichen zu
erhöhen, um dem Betriebssystem mehr Gelegenheit zu geben, zwischen den Strängen
zu wechseln.</p>
<h3 id="warten-auf-das-ende-aller-stränge-mit-join"><a class="header" href="#warten-auf-das-ende-aller-stränge-mit-join">Warten auf das Ende aller Stränge mit <code>join</code></a></h3>
<p>Der Code in Codeblock 16-1 beendet nicht nur den erzeugten Strang meist
vorzeitig, weil der Hauptstrangs endet, sondern weil es keine Garantie für die
Reihenfolge gibt, in der Stränge laufen. Wir können auch nicht garantieren,
dass der erzeugte Strang überhaupt zum Laufen kommt!</p>
<p>Wir können das Problem, dass der erzeugte Strang nicht läuft oder vorzeitig
beendet wird, beheben, indem wir den Rückgabewert von <code>thread::spawn</code> in einer
Variable speichern. Der Rückgabetyp von <code>thread::spawn</code> ist <code>JoinHandle&lt;T&gt;</code>.
Ein <code>JoinHandle&lt;T&gt;</code> ist ein aneigenbarer (owned) Wert, der, wenn wir die
Methode <code>join</code> darauf aufrufen, darauf wartet, bis sich sein Strang beendet.
Codeblock 16-2 zeigt, wie der <code>JoinHandle&lt;T&gt;</code> des Strangs, den wir in Codeblock
16-1 erstellt haben, verwendet und wie <code>join</code> aufgerufen wird, um
sicherzustellen, dass der erzeugte Strang beendet wird, bevor <code>main</code> endet:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("Hallo Zahl {i} aus dem erzeugten Strang!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("Hallo Zahl {i} aus dem Hauptstrang!");
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 16-2: Speichern des <code>JoinHandle&lt;T&gt;</code> von
<code>thread::spawn</code>, um zu garantieren, dass der Strang bis zum Ende ausgeführt
wird</span></p>
<p>Aufrufen von <code>join</code> auf <code>JoinHandle</code> blockiert den gerade laufenden Strang, bis
der durch <code>JoinHandle</code> repräsentierte Strang beendet ist. <em>Blockieren</em> eines
Strangs bedeutet, dass der Strang daran gehindert wird, Arbeit auszuführen oder
sich zu beenden. Da wir den Aufruf von <code>join</code> nach der <code>for</code>-Schleife im
Hauptstrang gesetzt haben, sollte das Ausführen von Codeblock 16-2 eine Ausgabe
wie folgt erzeugen:</p>
<pre><code class="language-text">Hallo Zahl 1 aus dem Hauptstrang!
Hallo Zahl 2 aus dem Hauptstrang!
Hallo Zahl 1 aus dem erzeugten Strang!
Hallo Zahl 3 aus dem Hauptstrang!
Hallo Zahl 2 aus dem erzeugten Strang!
Hallo Zahl 4 aus dem Hauptstrang!
Hallo Zahl 3 aus dem erzeugten Strang!
Hallo Zahl 4 aus dem erzeugten Strang!
Hallo Zahl 5 aus dem erzeugten Strang!
Hallo Zahl 6 aus dem erzeugten Strang!
Hallo Zahl 7 aus dem erzeugten Strang!
Hallo Zahl 8 aus dem erzeugten Strang!
Hallo Zahl 9 aus dem erzeugten Strang!
</code></pre>
<p>Die beiden Stränge setzen abwechselnd fort, aber der Hauptstrang wartet wegen
des Aufrufs von <code>handle.join()</code> und endet nicht, bis der erzeugte Strang
beendet ist.</p>
<p>Aber lass uns sehen, was passiert, wenn wir stattdessen <code>handle.join()</code> vor die
<code>for</code>-Schleife in <code>main</code> schieben, etwa so:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("Hallo Zahl {i} aus dem erzeugten Strang!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("Hallo Zahl {i} aus dem Hauptstrang!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<p>Der Hauptstrang wartet auf das Ende des erzeugten Strangs und führt dann seine
<code>for</code>-Schleife aus, sodass die Ausgabe nicht mehr überlappend ist, wie hier
gezeigt:</p>
<pre><code class="language-text">Hallo Zahl 1 aus dem erzeugten Strang!
Hallo Zahl 2 aus dem erzeugten Strang!
Hallo Zahl 3 aus dem erzeugten Strang!
Hallo Zahl 4 aus dem erzeugten Strang!
Hallo Zahl 5 aus dem erzeugten Strang!
Hallo Zahl 6 aus dem erzeugten Strang!
Hallo Zahl 7 aus dem erzeugten Strang!
Hallo Zahl 8 aus dem erzeugten Strang!
Hallo Zahl 9 aus dem erzeugten Strang!
Hallo Zahl 1 aus dem Hauptstrang!
Hallo Zahl 2 aus dem Hauptstrang!
Hallo Zahl 3 aus dem Hauptstrang!
Hallo Zahl 4 aus dem Hauptstrang!
</code></pre>
<p>Kleine Details, z.B. wo <code>join</code> aufgerufen wird, können beeinflussen, ob deine
Stränge zur gleichen Zeit laufen oder nicht.</p>
<h3 id="verwenden-von-move-funktionsabschlüssen-mit-strängen"><a class="header" href="#verwenden-von-move-funktionsabschlüssen-mit-strängen">Verwenden von <code>move</code>-Funktionsabschlüssen mit Strängen</a></h3>
<p>Wir werden oft das Schlüsselwort <code>move</code> mit Funktionsabschlüssen verwenden, die
an <code>thread::spawn</code> übergeben werden, weil der Funktionsabschluss dann die
Eigentümerschaft an den Werten, die sie benutzt, von der Umgebung übernimmt und
damit die Eigentümerschaft an diesen Werten von einem Strang auf einen anderen
überträgt. In <a href="ch13-01-closures.html#erfassen-von-referenzen-oder-verschieben-der-eigent%C3%BCmerschaft">„Erfassen von Referenzen oder Verschieben der
Eigentümerschaft“</a> in Kapitel 13 haben wir <code>move</code> im Zusammenhang mit
Funktionsabschlüssen besprochen. Jetzt werden wir uns mehr auf die Interaktion
zwischen <code>move</code> und <code>thread::spawn</code> konzentrieren.</p>
<p>Beachte in Codeblock 16-1, dass der Funktionsabschluss, den wir an
<code>thread::spawn</code> übergeben, keine Argumente erfordert: Wir verwenden keine Daten
aus dem Hauptstrang im Code des erzeugten Strangs. Um Daten aus dem Hauptstrang
im erzeugten Strang zu verwenden, muss der Funktionsabschluss des erzeugten
Strangs die benötigten Werte erfassen. Codeblock 16-3 zeigt einen Versuch,
einen Vektor im Hauptstrang zu erstellen und ihn im erzeugten Strang zu
verwenden. Dies wird jedoch noch nicht funktionieren, wie du gleich sehen
wirst.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Hier ist ein Vektor: {v:?}");
    });

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 16-3: Versuch, einen im Hauptstrang erzeugten
Vektor in einem anderen Strang zu verwenden</span></p>
<p>Der Funktionsabschluss verwendet <code>v</code>, sodass er <code>v</code> erfasst und zum Teil der
Umgebung des Funktionsabschlusses macht. Da <code>thread::spawn</code> diesen
Funktionsabschluss in einem neuen Strang ausführt, sollten wir in der Lage
sein, auf <code>v</code> innerhalb dieses neuen Strangs zuzugreifen. Aber wenn wir dieses
Beispiel kompilieren, erhalten wir den folgenden Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Hier ist ein Vektor: {v:?}");
  |                                         - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Hier ist ein Vektor: {v:?}");
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `playground` (bin "playground") due to 1 previous error
</code></pre>
<p>Rust <em>folgert</em>, wie <code>v</code> zu erfassen ist, und weil <code>println!</code> nur eine Referenz
auf <code>v</code> benötigt, versucht der Funktionsabschluss, <code>v</code> auszuleihen. Es gibt
jedoch ein Problem: Rust kann nicht sagen, wie lange der erzeugte Strang laufen
wird, sodass es nicht weiß, ob die Referenz auf <code>v</code> immer gültig sein wird.</p>
<p>Codeblock 16-4 zeigt ein Szenario, das eine Referenz auf <code>v</code> hat, die eher
nicht gültig ist:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Hier ist ein Vektor: {v:?}");
    });

    drop(v); // Oh nein!

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 16-4: Ein Strang mit einem Funktionsabschluss,
der versucht, eine Referenz auf <code>v</code> vom Hauptstrang zu erfassen, der <code>v</code>
aufräumt</span></p>
<p>Wenn Rust uns erlauben würde, diesen Code auszuführen, bestünde die
Möglichkeit, dass der erzeugte Strang sofort in den Hintergrund gestellt wird,
ohne überhaupt zu laufen. Der erzeugte Strang hat eine Referenz auf <code>v</code> im
Inneren, aber der Hauptstrang räumt <code>v</code> sofort auf, indem er die Funktion
<code>drop</code> benutzt, die wir in Kapitel 15 besprochen haben. Wenn der erzeugte
Strang dann mit der Ausführung beginnt, ist <code>v</code> nicht mehr gültig, sodass eine
Referenz darauf ebenfalls ungültig ist. Oh nein!</p>
<p>Um den Kompilierfehler in Codeblock 16-3 zu beheben, können wir die Hinweise
der Fehlermeldung verwenden:</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>Indem wir vor dem Funktionsabschluss das Schlüsselwort <code>move</code> hinzufügen,
zwingen wir den Funktionsabschluss dazu, die Eigentümerschaft der Werte zu
übernehmen, die er benutzt, anstatt zuzulassen, dass Rust daraus ableitet, dass
er sich die Werte ausleihen sollte. Die in Codeblock 16-5 gezeigte Änderung an
Codeblock 16-3 wird wie von uns beabsichtigt kompilieren und ausgeführt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Hier ist ein Vektor: {v:?}");
    });

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 16-5: Durch Verwenden des Schlüsselwortes
<code>move</code> zwigen wir den Funktionsabschluss, die Eigentümerschaft der von ihm
verwendeten Werte zu übernehmen</span></p>
<p>Wir könnten versuchen, den Code in Codeblock 16-4 auf diesselbe Weise zu
reparieren, wo der Hauptstrang <code>drop</code> aufruft, während wir einen
<code>move</code>-Funktionsabschluss verwenden. Diese Lösung wird jedoch nicht
funktionieren, weil das, was Codeblock 16-4 versucht, aus einem anderen Grund
nicht erlaubt ist. Wenn wir dem Funktionsabschluss <code>move</code> hinzufügen, würden
wir <code>v</code> in die Umgebung des Funktionsabschlusses verschieben, und wir könnten
im Hauptstrang nicht mehr <code>drop</code> darauf aufrufen. Wir würden stattdessen diesen
Kompilierfehler erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  | 
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("Hier ist ein Vektor: {v:?}");
   |                                         - variable moved due to use in closure
...
10 |     drop(v); // Oh nein!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Die Eigentumsregeln von Rust haben uns wieder einmal gerettet! Wir haben einen
Fehler im Code in Codeblock 16-3 erhalten, weil Rust konservativ war und nur
<code>v</code> für den Strang auslieh, was bedeutete, dass der Hauptstrang theoretisch die
Referenz des erzeugte Strangs ungültig machen konnte. Indem wir Rust anweisen,
die Eigentümerschaft von <code>v</code> in den erzeugte Strang zu verlagern, garantieren
wir Rust, dass der Hauptstrang <code>v</code> nicht mehr benutzen wird. Wenn wir Codeblock
16-4 auf die gleiche Weise ändern, verletzen wir die Eigentumsregeln, wenn wir
versuchen, <code>v</code> im Hauptstrang zu benutzen. Das Schlüsselwort <code>move</code> setzt Rusts
konservative Standardausleihe außer Kraft; es lässt uns nicht gegen die
Eigentumsregeln verstoßen.</p>
<p>Nachdem wir uns nun damit beschäftigt haben, was Stränge sind und welche
Methoden die Strang-API bietet, wollen wir uns nun einige Situationen ansehen,
in denen wir Stränge verwenden können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nachrichtenaustausch-zwischen-strängen-threads"><a class="header" href="#nachrichtenaustausch-zwischen-strängen-threads">Nachrichtenaustausch zwischen Strängen (threads)</a></h2>
<p>Ein immer beliebter werdender Ansatz zur Gewährleistung einer sicheren
Nebenläufigkeit (safe concurrency) ist der <em>Nachrichtenaustausch</em> (message
passing), bei dem Stränge oder Akteure kommunizieren, indem sie sich
gegenseitig Nachrichten mit Daten senden. Hier ist die Idee in einem Slogan aus
der <a href="https://golang.org/doc/effective_go.html#concurrency">Go-Sprachdokumentation</a>: „Kommuniziere nicht, indem du
Arbeitsspeicher teilst; teile stattdessen Arbeitsspeicher durch Kommunikation.“</p>
<p>Um Nebenläufigkeit beim Senden von Nachrichten zu erreichen, bietet die
Standardbibliothek von Rust eine Implementierung für Kanäle. Ein <em>Kanal</em>
(channel) ist ein allgemeines Programmierkonzept, mit dem Daten von einem
Strang zu einem anderen gesendet werden.</p>
<p>Du kannst dir einen Kanal in der Programmierung wie einen gerichteten
Wasserkanal vorstellen, z.B. einen Bach oder einen Fluss. Wenn du etwas wie
eine Gummiente in einen Fluss setzt, wird sie stromabwärts bis zum Ende des
Wasserwegs reisen.</p>
<p>Ein Kanal hat zwei Hälften: Einen Sender und einen Empfänger. Die Senderhälfte
ist die stromaufwärts gelegene Stelle, an der du die Gummiente in den Fluss
setzt, und die Empfängerhälfte ist die Stelle, an der die Gummiente
stromabwärts ankommt. Ein Teil deines Codes ruft Methoden auf dem Sender mit
den Daten auf, die du senden möchtest, und ein anderer Teil überprüft die
Empfangsseite auf ankommende Nachrichten. Ein Kanal gilt als <em>geschlossen</em>
(closed), wenn entweder die Sender- oder die Empfängerhälfte aufgeräumt
(dropped) wird.</p>
<p>Hier erarbeiten wir uns ein Programm, das einen Strang hat, um Werte zu
generieren und sie über einen Kanal zu senden, und einen anderen Strang, der
die Werte empfängt und ausgibt. Wir werden einfache Werte zwischen den Strängen
über einen Kanal senden, um die Funktionalität zu veranschaulichen. Sobald du
mit der Technik vertraut bist, kannst du Kanäle für alle Stränge verwenden, die
miteinander kommunizieren müssen, z.B. für ein Chatsystem oder ein System, in
dem viele Stränge Teile einer Berechnung durchführen und die Teile an einen
Strang senden, der die Ergebnisse zusammenfasst.</p>
<p>Erstens werden wir in Codeblock 16-6 einen Kanal erstellen, aber nichts damit
machen. Beachte, dass sich dieser Code noch nicht kompilieren lässt, weil Rust
nicht sagen kann, welchen Typ von Werten wir über den Kanal senden wollen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre></pre>
<p><span class="caption">Codeblock 16-6: Erstellen eines Kanals und Zuweisen der
beiden Hälften zu <code>tx</code> und <code>rx</code></span></p>
<p>Wir erstellen einen neuen Kanal mit der Funktion <code>mpsc::channel</code>; <code>mpsc</code> steht
für <em>mehrfacher Produzent, einzelner Konsument</em> (multiple producer, single
consumer). Kurz gesagt, die Art und Weise, wie die Standardbibliothek von Rust
Kanäle implementiert, bedeutet, dass ein Kanal mehrere <em>sendende</em> Enden haben
kann, die Werte produzieren, aber nur ein <em>empfangendes</em> Ende, das diese Werte
konsumiert. Stell dir vor, mehrere Bäche würden zu einem großen Fluss
zusammenfließen: Alles, was in einem der Bäche hinuntergeschickt wird, landet
am Ende in einem Fluss. Wir fangen zunächst mit einem einzigen Produzenten an,
aber wir fügen mehrere Produzenten hinzu, wenn dieses Beispiel funktioniert.</p>
<p>Die Funktion <code>mpsc::channel</code> gibt ein Tupel zurück, dessen erstes Element die
sendende Seite und dessen zweites Element die empfangende Seite ist. Die
Abkürzungen <code>tx</code> und <code>rx</code> werden traditionell in vielen Feldern für <em>Sender</em>
(transmitter) bzw. <em>Empfänger</em> (receiver) verwendet, daher benennen wir unsere
Variablen als solche, um jedes Ende anzugeben. Wir verwenden eine
<code>let</code>-Anweisung mit einem Muster, das die Tupel destrukturiert; wir werden die
Verwendung von Mustern in <code>let</code>-Anweisungen und die Destrukturierung in Kapitel
19 besprechen. Für den Moment solltest du wissen, dass die Verwendung einer
<code>let</code>-Anweisung auf diese Weise ein bequemer Ansatz ist, um die Teile des
Tupels zu extrahieren, die von <code>mpsc::channel</code> zurückgegeben werden.</p>
<p>Verschieben wir das sendende Ende in einen erzeugten Strang und lassen es eine
Zeichenkette senden, sodass der erzeugte Strang mit dem Hauptstrang
kommuniziert, wie in Codeblock 16-7 gezeigt. Das ist so, als würde man eine
Gummiente flussaufwärts in den Fluss setzen oder eine Chat-Nachricht von einem
Strang zum anderen senden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hallo");
        tx.send(val).unwrap();
    });
}</code></pre></pre>
<p><span class="caption">Codeblock 16-7: Verschieben von <code>tx</code> in einen erzeugten
Strang und Senden von „hallo“</span></p>
<p>Wieder verwenden wir <code>thread::spawn</code>, um einen neuen Strang zu erstellen, und
dann <code>move</code>, um <code>tx</code> in den Funktionsabschluss zu verschieben, sodass der
erzeugte Strang <code>tx</code> besitzt. Der erzeugte Strang muss den Sender besitzen, um
in der Lage zu sein, Nachrichten durch den Kanal zu senden.</p>
<p>Der Sender hat eine Methode <code>send</code>, die den Wert entgegennimmt, den wir senden
wollen. Die Methode <code>send</code> gibt ein <code>Result&lt;T, E&gt;</code> zurück; wenn also die
empfangende Seite bereits aufgeräumt wurde und es keinen Ort gibt, an den ein
Wert gesendet werden kann, wird die Sendeoperation einen Fehler zurückgeben. In
diesem Beispiel rufen wir <code>unwrap</code> auf, um im Falle eines Fehlers abzubrechen.
Aber in einer echten Anwendung würden wir es ordentlich handhaben: Kehre zu
Kapitel 9 zurück, um Strategien für eine korrekte Fehlerbehandlung anzusehen.</p>
<p>In Codeblock 16-8 erhalten wir den Wert vom Empfänger im Hauptstrang. Das ist
so, als würde man die Gummiente am Ende des Flusses aus dem Wasser holen oder
eine Chat-Nachricht erhalten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hallo");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Erhalten: {received}");
}</code></pre></pre>
<p><span class="caption">Codeblock 16-8: Empfangen des Wertes „hallo“ im
Hauptstrang und Ausgeben des Wertes</span></p>
<p>Das Empfänger hat zwei nützliche Methoden: <code>recv</code> und <code>try_recv</code>. Wir benutzen
<code>recv</code>, kurz für <em>empfangen</em> (receive), was die Ausführung des Hauptstrangs
blockiert und wartet, bis ein Wert in den Kanal geschickt wird. Sobald ein Wert
gesendet wurde, wird er von <code>recv</code> in einem <code>Result&lt;T, E&gt;</code> zurückgegeben. Wenn
der Sender geschlossen ist, gibt <code>recv</code> einen Fehler zurück, um zu
signalisieren, dass keine weiteren Werte mehr kommen werden.</p>
<p>Die Methode <code>try_recv</code> blockiert nicht, sondern gibt stattdessen sofort ein
<code>Result&lt;T, E&gt;</code> zurück: Einen <code>Ok</code>-Wert, der eine Nachricht enthält, wenn eine
verfügbar ist, und einen <code>Err</code>-Wert, wenn gerade keine Nachricht vorhanden ist.
Die Verwendung von <code>try_recv</code> ist nützlich, wenn dieser Strang während des
Wartens auf Nachrichten andere Arbeiten zu erledigen hat: Wir könnten eine
Schleife schreiben, die <code>try_recv</code> ab und zu aufruft, eine Nachricht
verarbeitet, wenn eine verfügbar ist, und ansonsten für eine Weile andere
Arbeiten erledigt, bis sie erneut überprüft wird.</p>
<p>Wir haben in diesem Beispiel der Einfachheit halber <code>recv</code> verwendet; wir haben
keine andere Arbeit für den Hauptstrang zu erledigen, außer auf Nachrichten zu
warten, daher ist es angebracht, den Hauptstrang zu blockieren.</p>
<p>Wenn wir den Code in Codeblock 16-8 ausführen, sehen wir den durch den
Hauptstrang ausgegebenen Wert:</p>
<pre><code class="language-text">Erhalten: hallo
</code></pre>
<p>Perfekt!</p>
<h3 id="kanäle-und-eigentümerschaftsübertragung"><a class="header" href="#kanäle-und-eigentümerschaftsübertragung">Kanäle und Eigentümerschaftsübertragung</a></h3>
<p>Die Eigentumsregeln spielen beim Nachrichtenversand eine entscheidende Rolle,
da sie dir helfen, sicheren, nebenläufigen Code zu schreiben. Die Vermeidung
von Fehlern bei der nebenläufigen Programmierung ist der Vorteil, den du durch
Berücksichtigen der Eigentümerschaft in deinen Rust-Programmen erhältst. Lass
uns ein Experiment machen, um zu zeigen, wie Kanäle und Eigentümerschaft
zusammenwirken, um Probleme zu vermeiden: Wir versuchen, einen Wert <code>val</code> im
erzeugten Strang zu verwenden, <em>nachdem</em> wir ihn in den Kanal geschickt haben.
Versuche, den Code in Codeblock 16-9 zu kompilieren, um zu sehen, warum dieser
Code nicht erlaubt ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hallo");
        tx.send(val).unwrap();
        println!("val ist {val}");
    });

    let received = rx.recv().unwrap();
    println!("Erhalten: {received}");
}</code></pre></pre>
<p><span class="caption">Codeblock 16-9: Versuch, <code>val</code> zu benutzen, nachdem wir
es in den Kanal geschickt haben</span></p>
<p>Hier versuchen wir, <code>val</code> auszugeben, nachdem wir es per <code>tx.send</code> in den Kanal
geschickt haben. Dies zuzulassen wäre eine schlechte Idee: Sobald der Wert an
einen anderen Strang gesendet wurde, könnte dieser Strang ihn ändern oder
aufräumen, bevor wir versuchen, den Wert erneut zu verwenden. Möglicherweise
können die Änderungen des anderen Strangs aufgrund inkonsistenter oder nicht
vorhandener Daten zu Fehlern oder unerwarteten Ergebnissen führen. Rust gibt
uns jedoch einen Fehler, wenn wir versuchen, den Code in Codeblock 16-9 zu
kompilieren:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {val}");
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
</code></pre>
<p>Unser Nebenläufigkeitsfehler hat einen Kompilierzeitfehler verursacht. Die
Funktion <code>send</code> übernimmt die Eigentümerschaft an ihrem Parameter und wenn der
Wert verschoben wird, übernimmt der Empfänger die Eigentümerschaft an ihm.
Dadurch wird verhindert, dass wir den Wert nach dem Senden versehentlich wieder
verwenden; das Eigentumssystem prüft, ob alles in Ordnung ist.</p>
<h3 id="mehrere-werte-senden-und-den-empfänger-warten-sehen"><a class="header" href="#mehrere-werte-senden-und-den-empfänger-warten-sehen">Mehrere Werte senden und den Empfänger warten sehen</a></h3>
<p>Der Code in Codeblock 16-8 wurde kompiliert und ausgeführt, aber er zeigte uns
nicht eindeutig, dass zwei getrennte Stränge über den Kanal miteinander
sprachen. In Codeblock 16-10 haben wir einige Änderungen vorgenommen, die
beweisen, dass der Code in Codeblock 16-8 nebenläufig ausgeführt wird: Der
erzeugte Strang sendet nun mehrere Nachrichten und macht dazwischen eine Pause
von einer Sekunde.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hallo"),
            String::from("aus"),
            String::from("dem"),
            String::from("Strang"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Erhalten: {received}");
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 16-10: Senden mehrerer Nachrichten mit Pausen
dazwischen</span></p>
<p>Diesmal verwendet der erzeugte Strang einen Vektor von Zeichenketten, die wir
an den Hauptstrang senden wollen. Wir iterieren über diese Zeichenketten,
senden jede einzeln und pausieren dazwischen, indem wir die Funktion
<code>thread::sleep</code> mit einem <code>Duration</code>-Wert von einer Sekunde aufrufen.</p>
<p>Im Hauptstrang rufen wir die Funktion <code>recv</code> nicht mehr explizit auf:
Stattdessen behandeln wir <code>rx</code> als Iterator. Jeden empfangenen Wert geben wir
aus. Wenn der Kanal geschlossen wird, wird die Iteration beendet.</p>
<p>Wenn du den Code in Codeblock 16-10 ausführst, solltest du die folgende Ausgabe
mit einer Ein-Sekunden-Pause zwischen jeder Zeile sehen:</p>
<pre><code class="language-text">Erhalten: hallo
Erhalten: aus
Erhalten: dem
Erhalten: Strang
</code></pre>
<p>Da wir keinen Code haben, der die <code>for</code>-Schleife im Hauptstrang pausiert oder
verzögert, können wir sagen, dass der Hauptstrang darauf wartet, Werte vom
erzeugten Strang zu erhalten.</p>
<h3 id="erstellen-mehrerer-produzenten-durch-klonen-des-senders"><a class="header" href="#erstellen-mehrerer-produzenten-durch-klonen-des-senders">Erstellen mehrerer Produzenten durch Klonen des Senders</a></h3>
<p>Vorhin haben wir erwähnt, dass <code>mpsc</code> ein Akronym für <em>mehrfacher Produzent,
einzelner Konsument</em> ist. Lass uns <code>mpsc</code> verwenden und den Code in Codeblock
16-10 erweitern, um mehrere Stränge zu erzeugen, die alle Werte an den gleichen
Empfänger senden. Wir können dies tun, indem wir den Sender klonen, wie in
Codeblock 16-11 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --abschneiden--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hallo"),
            String::from("aus"),
            String::from("dem"),
            String::from("Strang"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("mehr"),
            String::from("Nachrichten"),
            String::from("für"),
            String::from("dich"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Erhalten: {received}");
    }

    // --abschneiden--
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 16-11: Senden mehrerer Nachrichten von mehreren
Produzenten</span></p>
<p>Bevor wir den ersten Strang erzeugen, rufen wir dieses Mal <code>clone</code> auf dem
Sender auf. Dadurch erhalten wir einen weiteren Sender, das wir an den ersten
erzeugten Strang weitergeben können. Wir übergeben den ursprüngliche Sender an
einen zweiten erzeugten Strang. Dadurch erhalten wir zwei Stränge, die jeweils
unterschiedliche Nachrichten an den Empfänger senden.</p>
<p>Wenn du den Code ausführst, sollte deine Ausgabe in etwa so aussehen:</p>
<pre><code class="language-text">Erhalten: hallo
Erhalten: mehr
Erhalten: aus
Erhalten: Nachrichten
Erhalten: für
Erhalten: dem
Erhalten: Strang
Erhalten: dich
</code></pre>
<p>Möglicherweise siehst du die Werte in einer anderen Reihenfolge, dies hängt von
deinem System ab. Das macht die Nebenläufigkeit sowohl interessant als auch
schwierig. Wenn du mit <code>thread::sleep</code> experimentierst und ihm verschiedene
Werte in den verschiedenen Strängen gibst, wird jeder Durchlauf
nicht-deterministischer sein und jedes Mal eine andere Ausgabe erzeugen.</p>
<p>Nachdem wir uns nun angesehen haben, wie Kanäle funktionieren, wollen wir uns
eine andere Methode der Nebenläufigkeit ansehen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nebenläufigkeit-mit-gemeinsamem-zustand"><a class="header" href="#nebenläufigkeit-mit-gemeinsamem-zustand">Nebenläufigkeit mit gemeinsamem Zustand</a></h2>
<p>Die Nachrichtenübermittlung ist eine gute Methode zur Behandlung von
Nebenläufigkeit, aber sie ist nicht die einzige. Eine andere Methode wäre, dass
mehrere Stränge auf dieselben gemeinsamen Daten zugreifen. Betrachte folgenden
Teil des Slogans aus der Go-Sprachdokumentation noch einmal: „Kommuniziere
nicht, indem du Arbeitsspeicher teilst.“</p>
<p>Wie würde Kommunikation durch gemeinsame Nutzung von Arbeitsspeicher aussehen?
Und warum sollten Liebhaber der Nachrichtenübermittlung davor warnen,
gemeinsamen Arbeitsspeicher zu verwenden?</p>
<p>In gewisser Weise ähneln Kanäle in jeder Programmiersprache dem Alleineigentum,
denn sobald du einen Wert in einen Kanal übertragen hast, solltest du diesen
Wert nicht mehr verwenden. Nebenläufigkeit mit gemeinsam genutztem
Arbeitsspeicher ist wie Mehrfacheigentum: Mehrere Stränge können gleichzeitig
auf denselben Speicherplatz zugreifen. Wie du in Kapitel 15 gesehen hast, wo
intelligente Zeiger Mehrfacheigentum ermöglichten, kann Mehrfacheigentum zu
zusätzlicher Komplexität führen, da die verschiedenen Eigentümer verwaltet
werden müssen. Das Typsystem und die Eigentumsregeln von Rust sind eine große
Hilfe, um diese Verwaltung korrekt zu gestalten. Betrachten wir als Beispiel
den Mutex, eines der gebräuchlicheren Nebenläufigkeitsprimitive für gemeinsam
genutzten Speicher.</p>
<h3 id="verwenden-von-mutex-um-datenzugriff-von-jeweils-einem-strang-zu-ermöglichen"><a class="header" href="#verwenden-von-mutex-um-datenzugriff-von-jeweils-einem-strang-zu-ermöglichen">Verwenden von Mutex, um Datenzugriff von jeweils einem Strang zu ermöglichen</a></h3>
<p><em>Mutex</em> ist eine Abkürzung für <em>mutual exclusion</em> (engl. wechselseitiger
Ausschluss), da ein Mutex zu einem bestimmten Zeitpunkt nur einem Strang
(thread) den Zugriff auf Daten erlaubt. Um auf die Daten in einem Mutex
zuzugreifen, muss ein Strang zunächst signalisieren, dass er Zugriff wünscht,
indem er darum bittet, die <em>Sperre</em> (lock) des Mutex zu erwerben. Die Sperre
ist eine Datenstruktur, die Teil des Mutex ist, die verfolgt, wer derzeit
exklusiven Zugriff auf die Daten hat. Daher wird der Mutex als <em>Schutz</em> der
Daten beschrieben, die er über das Sperrsystem hält.</p>
<p>Mutexe haben den Ruf, dass sie schwierig anzuwenden sind, weil man sich zwei
Regeln merken muss:</p>
<ol>
<li>Du musst versuchen, die Sperre zu erwerben, bevor du die Daten verwendest.</li>
<li>Wenn du mit den Daten, die der Mutex schützt, fertig bist, musst du die Daten
entsperren, damit andere Stränge die Sperre übernehmen können.</li>
</ol>
<p>Als reale Metapher für einen Mutex stelle dir eine Podiumsdiskussion auf einer
Konferenz mit nur einem Mikrofon vor. Bevor ein Podiumsteilnehmer das Wort
ergreifen kann, muss er fragen oder signalisieren, dass er das Mikrofon
benutzen möchte. Wenn er das Mikrofon erhält, kann er so lange sprechen, wie er
möchte, und das Mikrofon dann dem nächsten Diskussionsteilnehmer übergeben, der
um das Wort bittet. Wenn ein Diskussionsteilnehmer vergisst, das Mikrofon
abzugeben, wenn er damit fertig ist, kann kein anderer mehr sprechen. Wenn die
Verwaltung des gemeinsam genutzten Mikrofons schief geht, funktioniert das
Podium nicht wie geplant!</p>
<p>Das Management von Mutexen kann unglaublich schwierig sein, weshalb so viele
Menschen von Kanälen begeistert sind. Dank des Typsystems und der
Eigentumsregeln von Rust kann man jedoch beim Sperren und Entsperren nichts
falsch machen.</p>
<h4 id="die-api-von-mutext"><a class="header" href="#die-api-von-mutext">Die API von <code>Mutex&lt;T&gt;</code></a></h4>
<p>Als Beispiel für die Verwendung eines Mutex beginnen wir mit der Verwendung
eines Mutex in einem einsträngigen (single-threaded) Kontext, wie in Codeblock
16-12 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 16-12: Untersuchen der API von <code>Mutex&lt;T&gt;</code> in
einem einsträngigen Kontext zur Vereinfachung</span></p>
<p>Wie bei vielen Typen erzeugen wir einen <code>Mutex&lt;T&gt;</code> mit der zugehörigen Funktion
<code>new</code>. Um auf die Daten innerhalb des Mutex zuzugreifen, verwenden wir die
Methode <code>lock</code>, um die Sperre zu erhalten. Dieser Aufruf blockiert den
aktuellen Strang, sodass er keine Arbeit verrichten kann, bis wir an der Reihe
sind und die Sperre bekommen.</p>
<p>Der Aufruf von <code>lock</code> würde fehlschlagen, wenn ein anderer Strang, der die
Sperre hält, abstürzte. In diesem Fall wäre niemand jemals in der Lage, die
Sperre zu erhalten, also haben wir uns entschieden, <code>unwrap</code> zu benutzen und
diesen Strang abstürzen zu lassen, wenn wir uns in dieser Situation befinden.</p>
<p>Nachdem wir die Sperre bekommen haben, können wir den Rückgabewert, in diesem
Fall <code>num</code> genannt, als veränderbare Referenz auf die darin enthaltenen Daten
verwenden. Das Typsystem stellt sicher, dass wir eine Sperre erwerben, bevor
wir den Wert in <code>m</code> verwenden. Der Typ von <code>m</code> ist <code>Mutex&lt;i32&gt;</code>, nicht <code>i32</code>,
also <em>müssen</em> wir <code>lock</code> aufrufen, um den <code>i32</code>-Wert verwenden zu können. Wir
können das nicht vergessen, das Typsystem würde uns sonst keinen Zugriff auf
das innere <code>i32</code> erlauben.</p>
<p>Wie du vielleicht vermutest, ist <code>Mutex&lt;T&gt;</code> ein intelligenter Zeiger (smart
pointer). Genauer gesagt gibt der Aufruf von <code>lock</code> einen intelligenten Zeiger
namens <code>MutexGuard</code> zurück, der in ein <code>LockResult</code> verpackt ist, das wir mit
dem Aufruf von <code>unwrap</code> behandelt haben. Der intelligente Zeiger <code>MutexGuard</code>
implementiert <code>Deref</code>, um auf unsere inneren Daten zu zeigen; der intelligente
Zeiger hat auch eine <code>Drop</code>-Implementierung, die die Sperre automatisch
aufhebt, wenn ein <code>MutexGuard</code> den Gültigkeitsbereich verlässt, was am Ende des
inneren Gültigkeitsbereichs geschieht. Dadurch laufen wir nicht Gefahr, zu
vergessen, die Sperre freizugeben und die Verwendung des Mutex durch andere
Stränge zu blockieren, da die Freigabe der Sperre automatisch erfolgt.</p>
<p>Nachdem wir die Sperre aufgehoben haben, können wir den Mutex-Wert ausgeben und
sehen, dass wir den inneren <code>i32</code> in 6 ändern konnten.</p>
<h4 id="gemeinsames-nutzen-eines-mutext-von-mehreren-strängen"><a class="header" href="#gemeinsames-nutzen-eines-mutext-von-mehreren-strängen">Gemeinsames Nutzen eines <code>Mutex&lt;T&gt;</code> von mehreren Strängen</a></h4>
<p>Versuchen wir nun, einen Wert zwischen mehreren Strängen mit <code>Mutex&lt;T&gt;</code> zu
teilen. Wir starten 10 Stränge und lassen sie jeweils einen Zählerwert um 1
erhöhen, sodass der Zähler von 0 auf 10 geht. Das Beispiel in Codeblock 16-13
wird einen Kompilierfehler haben und wir werden diesen Fehler verwenden, um
mehr über die Verwendung von <code>Mutex&lt;T&gt;</code> zu erfahren und darüber, wie Rust uns
hilft, ihn korrekt zu verwenden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Ergebnis: {}", *counter.lock().unwrap());
}</code></pre></pre>
<p><span class="caption">Codeblock 16-13: Zehn Stränge inkrementieren jeweils
einen Zähler, der durch einen <code>Mutex&lt;T&gt;</code> geschützt ist</span></p>
<p>Wir erstellen eine Variable <code>counter</code>, um ein <code>i32</code> innerhalb eines <code>Mutex&lt;T&gt;</code>
zu halten, wie wir es in Codeblock 16-12 getan haben. Als Nächstes erstellen
wir 10 Stränge, indem wir über einen Zahlenbereich iterieren. Wir verwenden
<code>thread::spawn</code> und geben allen Strängen den gleichen Funktionsabschluss
(closure), der den Zähler in den Strang verschiebt, eine Sperre auf dem
<code>Mutex&lt;T&gt;</code> durch Aufrufen der Methode <code>lock</code> erwirbt und dann 1 zum Wert im
Mutex addiert. Wenn ein Strang die Ausführung seines Funktionsabschlusses
beendet hat, verlässt <code>num</code> den Gültigkeitsbereich und gibt die Sperre frei,
sodass ein anderer Strang sie erwerben kann.</p>
<p>Im Hauptstrang sammeln wir alle <code>JoinHandle</code>. Dann rufen wir analog zu
Codeblock 16-2 <code>join</code> auf jedem Strang auf, um sicherzustellen, dass alle
Stränge beendet sind. An diesem Punkt erhält der Hauptstrang die Sperre und
gibt das Ergebnis dieses Programms aus.</p>
<p>Wir haben angedeutet, dass sich dieses Beispiel nicht kompilieren lässt. Jetzt
wollen wir herausfinden, warum!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
8  |     for _ in 0..10 {
   |     -------------- inside of this loop
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>Die Fehlermeldung besagt, dass der Wert <code>counter</code> in der vorherigen Iteration
der Schleife verschoben wurde. Rust sagt uns, dass wir die Eigentümerschaft von
<code>counter</code> nicht in mehrere Stränge verschieben können. Lass uns den
Kompilierfehler mit einer Mehrfacheigentums-Methode beheben, die wir in Kapitel
15 besprochen haben.</p>
<h4 id="mehrfacheigentum-mit-mehreren-strängen"><a class="header" href="#mehrfacheigentum-mit-mehreren-strängen">Mehrfacheigentum mit mehreren Strängen</a></h4>
<p>In Kapitel 15 gaben wir einen Wert an mehrere Eigentümer, indem wir den
intelligenten Zeiger <code>Rc&lt;T&gt;</code> verwendet haben, um einen Referenzzählwert zu
erstellen. Lass uns hier das Gleiche tun und sehen, was passiert. Wir packen
den <code>Mutex&lt;T&gt;</code> in <code>Rc&lt;T&gt;</code> in Codeblock 16-14 ein und klonen <code>Rc&lt;T&gt;</code>, bevor wir
die Eigentümerschaft an den Strang übertragen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Ergebnis: {}", *counter.lock().unwrap());
}</code></pre></pre>
<p><span class="caption">Codeblock 16-14: Versuch, <code>Rc&lt;T&gt;</code> zu verwenden, um
mehreren Strängen zu erlauben, den <code>Mutex&lt;T&gt;</code> zu besitzen</span></p>
<p>Wir kompilieren erneut und bekommen verschiedene Fehler! Der Compiler lehrt uns
eine Menge.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:36
    |
11  |           let handle = thread::spawn(move || {
    |                        ------------- ^------
    |                        |             |
    |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
    | |                      |
    | |                      required by a bound introduced by this call
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
    |
    = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`
note: required because it's used within this closure
   --&gt; src/main.rs:11:36
    |
11  |         let handle = thread::spawn(move || {
    |                                    ^^^^^^^
note: required by a bound in `spawn`
   --&gt; file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/std/src/thread/mod.rs:731:8
    |
728 | pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    |        ----- required by a bound in this function
...
731 |     F: Send + 'static,
    |        ^^^^ required by this bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>Toll, diese Fehlermeldung ist sehr wortreich! Hier ist der wichtige Teil, auf
den wir uns konzentrieren müssen: <code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between  threads safely</code> Der Compiler teilt uns auch den Grund dafür mit: Das Merkmal
(trait) <code>Send</code> ist für <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> nicht implementiert. Wir werden im
nächsten Abschnitt über das Merkmal <code>Send</code> sprechen: Es ist eines der Merkmale,
das sicherstellt, dass die Typen, die wir mit Strängen verwenden, für die
Verwendung in nebenläufigen Situationen gedacht sind.</p>
<p>Leider ist es nicht sicher, <code>Rc&lt;T&gt;</code> über verschiedene Stränge hinweg gemeinsam
zu nutzen. Wenn <code>Rc&lt;T&gt;</code> den Referenzzähler verwaltet, inkrementiert es den
Zähler bei jedem Aufruf von <code>clone</code> und dekrementiert den Zähler bei jedem
Klon, der aufgeräumt wird. Es werden jedoch keine Nebenläufigkeitsprimitive
verwendet, um sicherzustellen, dass Änderungen am Zähler nicht durch einen
anderen Strang unterbrochen werden können. Dies könnte zu falschen Zählungen
führen – subtile Fehler, die wiederum zu Speicherlecks (memory leaks)
oder zum Aufräumen eines Wertes führen könnten, obwohl wir ihn noch nutzen
wollen. Was wir brauchen, ist ein Typ genau wie <code>Rc&lt;T&gt;</code>, aber einer, der
Änderungen am Referenzzähler auf Strang-sichere (thread-safe) Weise vornimmt.</p>
<h4 id="atomare-referenzzählung-mit-arct"><a class="header" href="#atomare-referenzzählung-mit-arct">Atomare Referenzzählung mit <code>Arc&lt;T&gt;</code></a></h4>
<p>Glücklicherweise ist <code>Arc&lt;T&gt;</code> ein Typ wie <code>Rc&lt;T&gt;</code>, der in nebenläufigen
Situationen sicher zu verwenden ist. Das <em>a</em> steht für <em>atomar</em>, d.h. es
handelt sich um einen <em>atomar-referenzzählenden</em> (atomically reference
counted) Typ. Atomare Typen (atomics) sind eine zusätzliche Art von
Nebenläufigkeitsprimitiven, die wir hier nicht im Detail behandeln werden:
Weitere Einzelheiten findest du in der Standardbibliotheksdokumentation für
<a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a>. An dieser Stelle musst du nur wissen, dass
atomare Typen wie primitive Typen funktionieren, aber sicher über Stränge
hinweg gemeinsam genutzt werden können.</p>
<p>Du wirst dich dann vielleicht fragen, warum nicht alle primitiven Typen atomar
sind und warum Standardbibliothekstypen nicht so implementiert sind, dass sie
standardmäßig <code>Arc&lt;T&gt;</code> verwenden. Der Grund dafür ist, dass Strang-Sicherheit
mit Performanzeinbußen verbunden ist, die du nur dann zahlen willst, wenn du
sie wirklich brauchst. Wenn du nur Operationen an Werten innerhalb eines
einzelnen Strangs durchführst, kann dein Code schneller laufen, wenn er nicht
die Garantien erzwingen muss, die atomare Typen bieten.</p>
<p>Kehren wir zu unserem Beispiel zurück: <code>Arc&lt;T&gt;</code> und <code>Rc&lt;T&gt;</code> haben die gleiche
API, also reparieren wir unser Programm, indem wir die <code>use</code>-Zeile, den Aufruf
von <code>new</code> und den Aufruf von <code>clone</code> ändern. Der Code in Codeblock 16-15 wird
schließlich kompilieren und laufen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Ergebnis: {}", *counter.lock().unwrap());
}</code></pre></pre>
<p><span class="caption">Codeblock 16-15: Verwenden von <code>Arc&lt;T&gt;</code>, um den <code>Mutex&lt;T&gt;</code>
einzupacken, um die Eigentümerschaft mit mehreren Strängen teilen zu
können</span></p>
<p>Dieser Code gibt folgendes aus:</p>
<pre><code class="language-text">Ergebnis: 10
</code></pre>
<p>Wir haben es geschafft! Wir zählten von 0 bis 10, was nicht sehr beeindruckend
erscheinen mag, aber wir haben viel über <code>Mutex&lt;T&gt;</code> und Strangsicherheit
gelernt. Du kannst die Struktur dieses Programms auch dazu nutzen,
kompliziertere Operationen durchzuführen als nur einen Zähler zu
inkrementieren. Mit dieser Strategie kannst du eine Berechnung in unabhängige
Teile aufteilen, diese Teile auf Stränge verteilen und dann <code>Mutex&lt;T&gt;</code>
verwenden, damit jeder Strang das Endergebnis mit seinem Teil aktualisiert.</p>
<p>Beachte, dass es für einfache numerische Operationen einfachere Typen als
<code>Mutex&lt;T&gt;</code> gibt, die durch das <a href="https://doc.rust-lang.org/std/sync/atomic/index.html">Modul <code>std::sync::atomic</code> der
Standardbibliothek</a> bereitgestellt werden. Diese Typen bieten sicheren,
nebenläufigen und atomaren Zugriff auf primitive Typen. Wir haben uns
entschieden, <code>Mutex&lt;T&gt;</code> mit einem primitiven Typ für dieses Beispiel zu
verwenden, damit wir uns darauf konzentrieren können, wie <code>Mutex&lt;T&gt;</code>
funktioniert.</p>
<h3 id="Ähnlichkeiten-zwischen-refcelltrct-und-mutextarct"><a class="header" href="#Ähnlichkeiten-zwischen-refcelltrct-und-mutextarct">Ähnlichkeiten zwischen <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> und <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>Du hast vielleicht bemerkt, dass <code>counter</code> unveränderbar (immutable) ist, aber
wir könnten eine veränderbare (mutable) Referenz auf den Wert in seinem
Inneren erhalten; das bedeutet, dass <code>Mutex&lt;T&gt;</code> innere Veränderbarkeit
(interior mutability) bietet, wie es die <code>Cell</code>-Familie tut. Auf gleiche Weise,
wie wir <code>RefCell&lt;T&gt;</code> in Kapitel 15 benutzt haben, um Inhalte innerhalb eines
<code>Rc&lt;T&gt;</code> verändern zu können, benutzen wir <code>Mutex&lt;T&gt;</code>, um Inhalte innerhalb
eines <code>Arc&lt;T&gt;</code> zu verändern.</p>
<p>Ein weiteres zu beachtendes Detail ist, dass Rust dich nicht vor allen Arten
von Logikfehlern schützen kann, wenn du <code>Mutex&lt;T&gt;</code> verwendest. Erinnere dich an
Kapitel 15, dass die Verwendung von <code>Rc&lt;T&gt;</code> mit dem Risiko verbunden ist,
Referenzzyklen zu erzeugen, bei denen sich zwei <code>Rc&lt;T&gt;</code>-Werte gegenseitig
referenzieren und dadurch Speicherlecks verursachen. In ähnlicher Weise ist
<code>Mutex&lt;T&gt;</code> mit dem Risiko verbunden, <em>Deadlocks</em> zu schaffen. Diese treten auf,
wenn eine Operation zwei Ressourcen sperren muss und zwei Stränge jeweils eine
der Sperren erworben haben, was dazu führt, dass sie ewig aufeinander warten.
Wenn du an Deadlocks interessiert bist, versuche ein Programm in Rust zu
schreiben, das einen Deadlock hat; dann recherchiere Strategien zur Vermeidung
von Deadlocks mit Mutexe in einer beliebigen Sprache und versuche, sie in Rust
zu implementieren. Die Standardbibliotheks-API-Dokumentation für <code>Mutex&lt;T&gt;</code> und
<code>MutexGuard</code> bietet nützliche Informationen.</p>
<p>Wir runden dieses Kapitel ab, indem wir über die Merkmale <code>Send</code> und <code>Sync</code>
sprechen und wie wir sie mit benutzerdefinierten Typen verwenden können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="erweiterbare-nebenläufigkeit-mit-den-merkmalen-traits-send-und-sync"><a class="header" href="#erweiterbare-nebenläufigkeit-mit-den-merkmalen-traits-send-und-sync">Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) <code>Send</code> und <code>Sync</code></a></h2>
<p>Interessanterweise war fast jede Nebenläufigkeitsfunktionalität, über die wir
bisher in diesem Kapitel gesprochen haben, Teil der Standardbibliothek, nicht
der Sprache. Deine Möglichkeiten für den Umgang mit Nebenläufigkeit sind nicht
auf die Sprache oder die Standardbibliothek beschränkt; du kannst deine eigenen
Nebenläufigkeitsfunktionalitäten schreiben oder die von anderen geschriebenen
verwenden.</p>
<p>Zu den wichtigsten Nebenläufigkeitskonzepten, die in die Sprache und nicht in
die Standardbibliothek eingebettet sind, gehören jedoch die Merkmale <code>Send</code> und
<code>Sync</code> in <code>std::marker</code>.</p>
<h3 id="erlauben-der-eigentümerschaftübertragung-zwischen-strängen-mit-send"><a class="header" href="#erlauben-der-eigentümerschaftübertragung-zwischen-strängen-mit-send">Erlauben der Eigentümerschaftübertragung zwischen Strängen mit <code>Send</code></a></h3>
<p>Das Markierungsmerkmal (marker trait) <code>Send</code> zeigt an, dass die
Eigentümerschaft an Werten des Typs, der <code>Send</code> implementiert, zwischen
Strängen (threads) übertragen werden kann. Fast jeder Rust-Typ implementiert
<code>Send</code>, aber es gibt einige Ausnahmen, einschließlich <code>Rc&lt;T&gt;</code>: Dieser kann
nicht <code>Send</code> sein, denn wenn du einen <code>Rc&lt;T&gt;</code>-Wert geklont hast und versucht
hast, die Eigentümerschaft am Klon auf einen anderen Strang zu übertragen,
könnten beide Stränge gleichzeitig den Referenzzähler aktualisieren. Aus diesem
Grund ist <code>Rc&lt;T&gt;</code> für die Verwendung in einsträngigen Situationen
implementiert, in denen du nicht die Strang-sichere Performanzeinbuße zahlen
willst.</p>
<p>Daher stellen das Typsystem und die Merkmalsabgrenzungen (trait bounds) von
Rust sicher, dass du niemals versehentlich einen <code>Rc&lt;T&gt;</code>-Wert unsicher zwischen
Strängen senden kannst. Als wir dies in Codeblock 16-14 versuchten, erhielten
wir folgenden Fehler: Das Merkmal <code>Send</code> ist für <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> nicht
implementiert. Als wir zu <code>Arc&lt;T&gt;</code> wechselten, das <code>Send</code> implementiert, ließ
sich der Code kompilieren.</p>
<p>Jeder Typ, der vollständig aus <code>Send</code>-Typen besteht, wird automatisch auch als
<code>Send</code> markiert. Fast alle primitiven Typen implementieren <code>Send</code>, abgesehen
von Roh-Zeigern, die wir in Kapitel 20 besprechen werden.</p>
<h3 id="erlauben-des-zugriffs-von-mehreren-strängen-mit-sync"><a class="header" href="#erlauben-des-zugriffs-von-mehreren-strängen-mit-sync">Erlauben des Zugriffs von mehreren Strängen mit <code>Sync</code></a></h3>
<p>Das Markierungsmerkmal <code>Sync</code> zeigt an, dass es sicher ist, den Typ, der <code>Sync</code>
implementiert, von mehreren Strängen zu referenzieren. Mit anderen Worten,
jeder Typ <code>T</code> implementiert <code>Sync</code>, wenn <code>&amp;T</code> (eine unveränderbare Referenz auf
<code>T</code>) <code>Send</code> implementiert, was bedeutet, dass die Referenz sicher an einen
anderen Strang gesendet werden kann. Ähnlich wie bei <code>Send</code> implementieren
primitive Typen <code>Sync</code>, und Typen, die vollständig aus Typen bestehen, die
<code>Sync</code> implementieren, implementieren ebenfalls <code>Sync</code>.</p>
<p>Der intelligente Zeiger <code>Rc&lt;T&gt;</code> implementiert ebenfalls nicht <code>Sync</code>, aus
denselben Gründen, warum er nicht <code>Send</code> implementiert. Der Typ <code>RefCell&lt;T&gt;</code>
(über den wir in Kapitel 15 gesprochen haben) und die Familie der verwandten
<code>Cell&lt;T&gt;</code>-Typen implementieren nicht <code>Sync</code>. Die Implementierung der
Ausleihenprüfung (borrow checking), die <code>RefCell&lt;T&gt;</code> zur Laufzeit durchführt,
ist nicht Strang-sicher. Der intelligente Zeiger <code>Mutex&lt;T&gt;</code> implementiert
<code>Sync</code> und kann verwendet werden, um den Zugriff mit mehreren Strängen zu
teilen, wie du in <a href="ch16-03-shared-state.html#gemeinsames-nutzen-eines-mutext-von-mehreren-str%C3%A4ngen">„Gemeinsames Nutzen eines <code>Mutex&lt;T&gt;</code> von mehreren
Strängen“</a> gesehen hast.</p>
<h3 id="manuelles-implementieren-von-send-und-sync-ist-unsicher"><a class="header" href="#manuelles-implementieren-von-send-und-sync-ist-unsicher">Manuelles Implementieren von <code>Send</code> und <code>Sync</code> ist unsicher</a></h3>
<p>Da Typen, die sich ausschließlich aus Typen zusammensetzen, die die Merkmale
<code>Send</code> und <code>Sync</code> implementieren, automatisch auch <code>Send</code> und <code>Sync</code>
implementieren, müssen wir diese Merkmale nicht manuell implementieren. Als
Markierungsmerkmale haben sie noch nicht einmal irgendwelche Methoden, um sie
zu implementieren. Sie sind nur nützlich, um Invarianten in Bezug auf die
Nebenläufigkeit zu erzwingen.</p>
<p>Das manuelle Implementieren dieser Merkmale beinhaltet das Schreiben von
unsicherem Rust-Code. Wir werden über das Verwenden von unsicherem Rust-Code in
Kapitel 20 sprechen; für den Moment ist die wichtige Information, dass das
Erstellen neuer nebenläufiger Typen, die nicht aus <code>Send</code>- und <code>Sync</code>-Teilen
bestehen, sorgfältige Überlegungen erfordert, um die Sicherheitsgarantien
aufrechtzuerhalten. <a href="https://doc.rust-lang.org/nomicon/index.html">„Das Rustonomicon“</a> enthält weitere
Informationen über diese Garantien und wie man sie aufrechterhalten kann.</p>
<h2 id="zusammenfassung-15"><a class="header" href="#zusammenfassung-15">Zusammenfassung</a></h2>
<p>Dies ist nicht das letzte Mal, dass du in diesem Buch der Nebenläufigkeit
begegnest: Das nächste Kapitel befasst sich mit asynchroner Programmierung, und
das Projekt in Kapitel 21 wird die Konzepte in diesem Kapitel in einer
realistischeren Situation anwenden als die hier besprochenen kleineren
Beispiele.</p>
<p>Wie bereits erwähnt, ist nur sehr wenig davon, wie Rust mit Nebenläufigkeit
umgeht, Teil der Sprache; viele Nebenläufigkeitslösungen sind in Kisten
(crates) implementiert. Diese entwickeln sich schneller als die
Standardbibliothek. Stelle also sicher, dass du online nach den aktuellen,
hochmodernen Kisten suchst, die in mehrsträngigen Situationen verwendet werden
können.</p>
<p>Die Rust-Standardbibliothek bietet Kanäle (channels) für die
Nachrichtenübermittlung und intelligente Zeigertypen wie <code>Mutex&lt;T&gt;</code> und
<code>Arc&lt;T&gt;</code>, die sicher in nebenläufigen Kontexten verwendet werden können. Das
Typsystem und der Ausleihenprüfer stellen sicher, dass der Code, der diese
Lösungen verwendet, nicht mit Daten-Wettlaufsituationen (data races) oder
ungültigen Referenzen endet. Sobald du deinen Code zum Kompilieren gebracht
hast, kannst du sicher sein, dass er problemlos mit mehreren Strängen läuft,
ohne die schwer aufspürbaren Fehler, die in anderen Sprachen üblich sind.
Nebenläufige Programmierung ist kein Konzept mehr, vor dem man sich fürchten
muss: Gehe hinaus und mache deine Programme nebenläufig – furchtlos!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grundlagen-der-asynchronen-programmierung-async-await-futures-und-ströme"><a class="header" href="#grundlagen-der-asynchronen-programmierung-async-await-futures-und-ströme">Grundlagen der asynchronen Programmierung: Async, Await, Futures und Ströme</a></h1>
<p>Viele Operationen, die wir einen Computer ausführen lassen, können eine Weile
dauern, bis sie erledigt sind. Es wäre schön, wenn wir etwas anderes tun
könnten, während wir darauf warten, bis diese lang dauernden Prozesse
abgeschlossen sind. Moderne Computer bieten zwei Techniken, um mehr als einen
Vorgang gleichzeitig zu bearbeiten: Parallelität und Nebenläufigkeit. Sobald
wir jedoch anfangen, Programme zu schreiben, die parallele oder nebenläufige
Operationen beinhalten, stoßen wir schnell auf neue Herausforderungen, die mit
der <em>asynchronen Programmierung</em> verbunden sind, bei der Operationen nicht
unbedingt in der Reihenfolge beendet werden, in der sie begonnen wurden. Dieses
Kapitel baut auf der Verwendung von Strängen (threads) für Parallelität und
Nebenläufigkeit in Kapitel 16 auf, indem es einen alternativen Ansatz zur
asynchronen Programmierung vorstellt: Rusts Futures, Ströme (streams), die
unterstützende Syntax <code>async</code> und <code>await</code>, und die Werkzeuge für die Verwaltung
und Koordinierung zwischen asynchronen Operationen.</p>
<p>Schauen wir uns ein Beispiel an. Nehmen wir an, du exportierst ein Video, das
du von einer Familienfeier erstellt hast – ein Vorgang, der zwischen
Minuten und Stunden dauern kann. Der Videoexport wird so viel CPU- und
GPU-Leistung wie möglich beanspruchen. Wenn du nur einen CPU-Kern hast und dein
Betriebssystem den Export nicht anhält, bevor er abgeschlossen ist, d.h. wenn
es den Export <em>synchron</em> ausführt, kannst du während dieser Zeit nichts anderes
auf deinem Computer tun. Das wäre eine ziemlich frustrierende Erfahrung. Zum
Glück kann das Betriebssystem deines Computers den Export oft genug unsichtbar
unterbrechen, damit du gleichzeitig andere Arbeiten erledigen kannst.</p>
<p>Nehmen wir an, du lädst ein Video herunter, das von einer anderen Person
geteilt wurde, was ebenfalls eine Weile dauern kann, aber nicht so viel
CPU-Zeit in Anspruch nimmt. In diesem Fall muss die CPU warten, bis die Daten
aus dem Netzwerk eintreffen. Du kannst zwar mit dem Lesen der Daten beginnen,
sobald sie ankommen, aber es kann einige Zeit dauern, bis alle Daten
eingetroffen sind. Selbst wenn alle Daten angekommen sind, kann es bei einem
recht großen Video mindestens ein oder zwei Sekunden dauern, bis alles geladen
ist. Das hört sich vielleicht nicht nach viel an, aber für einen modernen
Prozessor, der jede Sekunde Milliarden von Operationen ausführen kann, ist das
eine sehr lange Zeit. Auch hier wird das Betriebssystem dein Programm
unsichtbar unterbrechen, damit die CPU andere Arbeiten ausführen kann, während
sie auf den Abschluss des Netzwerkvorgangs wartet.</p>
<p>Der Videoexport ist ein Beispiel für einen <em>CPU-gebundenen</em> (CPU-bound) oder
<em>rechengebunden</em> (compute-bound) Vorgang. Er ist durch die potenzielle
Datenverarbeitungsgeschwindigkeit der CPU oder GPU des Computers begrenzt und
dadurch, wie viel von dieser Geschwindigkeit er für den Vorgang nutzen kann.
Der Videodownload ist ein Beispiel für einen <em>E/A-gebunden</em> (IO-bound) Vorgang,
da er durch die Geschwindigkeit der <em>Eingabe und Ausgabe</em> des Computers
begrenzt ist; er kann nur so schnell sein, wie die Daten über das Netzwerk
gesendet werden können.</p>
<p>In beiden Beispielen stellen die unsichtbaren Unterbrechungen durch das
Betriebssystem eine Form der Nebenläufigkeit dar. Diese Nebenläufigkeit findet
allerdings nur auf der Ebene des gesamten Programms statt: Das Betriebssystem
unterbricht ein Programm, damit andere Programme ihre Arbeit erledigen können.
Da wir unsere Programme in vielen Fällen auf einer viel detaillierteren Ebene
verstehen als das Betriebssystem, können wir Möglichkeiten zur Nebenläufigkeit
sehen, die das Betriebssystem nicht erkennen kann.</p>
<p>Wenn wir beispielsweise ein Werkzeug zur Verwaltung von Dateidownloads
entwickeln, sollten wir unser Programm so schreiben können, dass das Starten
eines Downloads die Benutzeroberfläche nicht blockiert, und die Benutzer
sollten in der Lage sein, mehrere Downloads zur gleichen Zeit zu starten. Viele
Betriebssystem-APIs für die Interaktion mit dem Netzwerk sind jedoch
<em>blockierend</em>, d.h. sie blockieren den Programmfortschritt, bis die Daten, die
sie verarbeiten, vollständig verfügbar sind.</p>
<blockquote>
<p>Hinweis: So funktionieren die <em>meisten</em> Funktionsaufrufe, wenn du darüber
nachdenkst. Wir denken beim Begriff <em>blockierend</em> jedoch normalerweise an
Funktionsaufrufe, die mit Dateien, dem Netzwerk oder anderen Ressourcen auf
dem Computer interagieren, weil dies Stellen sind, an denen ein individuelles
Programm davon profitieren würde, wenn die Operation <em>nicht</em> blockierend
wäre.</p>
</blockquote>
<p>Wir könnten das Blockieren unseres Hauptstrangs (main thread) vermeiden, indem
wir für das Herunterladen jeder Datei einen eigenen Strang (thread) starten.
Der Overhead dieser Stränge würde jedoch irgendwann zu einem Problem werden. Es
wäre besser, wenn der Aufruf gar nicht erst blockiert würde. Es wäre auch
besser, wenn wir in demselben direkten Stil schreiben könnten, den wir in
blockierendem Code verwenden, ähnlich wie hier:</p>
<pre><code class="language-rust ignore does_not_compile">let data = fetch_data_from(url).await;
println!("{data}");</code></pre>
<p>Genau das bietet uns die <em>async</em> (kurz für <em>asynchronous</em>) Abstraktion von
Rust. In diesem Kapitel wirst du alles über async lernen, indem wir die
folgenden Themen behandeln:</p>
<ul>
<li>Wie man die Syntax <code>async</code> und <code>await</code> von Rust verwendet</li>
<li>Wie man das asynchrone Modell verwendet, um einige der gleichen
Herausforderungen zu lösen, die wir uns in Kapitel 16 angeschaut haben</li>
<li>Wie Mehrsträngigkeit (multithreading) und async komplementäre Lösungen
bieten, die man in vielen Fällen kombinieren kann</li>
</ul>
<p>Bevor wir uns jedoch ansehen, wie async in der Praxis funktioniert, müssen wir
einen kleinen Abstecher zu den Unterschieden zwischen Parallelität und
Nebenläufigkeit machen.</p>
<h3 id="parallelität-und-nebenläufigkeit"><a class="header" href="#parallelität-und-nebenläufigkeit">Parallelität und Nebenläufigkeit</a></h3>
<p>Bislang haben wir Parallelität und Nebenläufigkeit als weitgehend
gleichbedeutend behandelt. Jetzt müssen wir genauer zwischen ihnen
unterscheiden, denn die Unterschiede werden sich bei der Arbeit zeigen.</p>
<p>Es gibt verschiedene Möglichkeiten, wie ein Team die Arbeit an einem
Softwareprojekt aufteilen kann. Du könntest einem einzelnen Mitglied mehrere
Aufgaben zuweisen oder jedem Teammitglied genau eine Aufgabe oder eine Mischung
aus beiden Ansätzen verwenden.</p>
<p>Wenn eine Person an mehreren, verschiedenen Aufgaben arbeitet, bevor eine von
ihnen abgeschlossen ist, handelt es sich um <em>Nebenläufigkeit</em>. Vielleicht hast
du zwei verschiedene Projekte auf deinem Computer ausgecheckt, und wenn dir bei
einem Projekt langweilig wird oder du nicht weiterkommst, wechselst du zum
anderen. Da du nur eine Person bist, kannst du nicht an beiden Aufgaben
gleichzeitig arbeiten, aber du kannst an mehreren Aufgaben arbeiten, indem du
zwischen ihnen abwechselst (siehe Abbildung 17-1).</p>
<img alt="Nebenläufiger Arbeitsablauf" src="img/trpl17-01.svg" class="center" />
<p><span class="caption">Abbildung 17-1: Ein nebenläufiger Arbeitsablauf, der
zwischen Aufgabe A und Aufgabe B wechselt.</span></p>
<p>Wenn das Team eine Gruppe von Aufgaben aufteilt, indem jedes Mitglied eine
Aufgabe übernimmt und sie alleine bearbeitet, ist das <em>Parallelismus</em>. Jede
Person im Team kann genau zur gleichen Zeit Fortschritte machen (siehe
Abbildung 17-2).</p>
<img alt="Paralleler Arbeitsablauf" src="img/trpl17-02.svg" class="center" />
<p><span class="caption">Abbildung 17-2: Ein paralleler Arbeitsablauf, bei dem die
Arbeit an Aufgabe A und Aufgabe B unabhängig voneinander erfolgt.</span></p>
<p>Bei diesen beiden Arbeitsabläufen musst du dich möglicherweise zwischen
verschiedenen Aufgaben abstimmen. Vielleicht <em>dachtest</em> du, die einer Person
zugewiesene Aufgabe sei völlig unabhängig von der Arbeit der anderen, aber in
Wirklichkeit muss eine andere Person im Team ihre Aufgabe zuerst erledigen. Ein
Teil der Arbeit könnte parallel erledigt werden, aber ein Teil der Arbeit war
eigentlich <em>sequentiell</em>: Sie konnte nur nacheinander stattfinden, eine Aufgabe
nach der anderen, wie in Abbildung 17-3.</p>
<img alt="Nebenläufiger Arbeitsablauf" src="img/trpl17-03.svg" class="center" />
<p><span class="caption">Abbildung 17-3: Ein teilweise paralleler Arbeitsablauf,
bei dem die Arbeit an Aufgabe A und Aufgabe B unabhängig voneinander erfolgt,
bis Aufgabe A3 durch die Ergebnisse von Aufgabe B3 blockiert wird.</span></p>
<p>Ebenso könntest du feststellen, dass eine deiner eigenen Aufgaben von einer
anderen deiner Aufgaben abhängt. Jetzt ist deine nebenläufige Arbeit auch
sequentiell geworden.</p>
<p>Parallelität und Nebenläufigkeit können sich auch gegenseitig überschneiden.
Wenn du erfährst, dass ein Kollege nicht weiterkommt, bis du eine deiner
Aufgaben beendet hast, wirst du dich wahrscheinlich ganz auf diese Aufgabe
konzentrieren, um deinen Kollegen nicht weiter zu blockieren. Du und dein
Kollege können nicht mehr parallel arbeiten, und du könntest auch nicht mehr
nebenläufig an deinen eigenen Aufgaben arbeiten.</p>
<p>Die gleiche grundlegende Dynamik kommt bei Software und Hardware zum Tragen.
Auf einem Rechner mit einem einzigen CPU-Kern kann die CPU nur eine Operation
zur gleichen Zeit ausführen, aber sie kann dennoch nebenläufig arbeiten.
Mithilfe von Werkzeugen wie Strängen, Prozessen und async kann der Computer
eine Aktivität unterbrechen und zu einer anderen wechseln, bis er schließlich
wieder zur ersten Aktivität zurückkehrt. Auf einem Computer mit mehreren
CPU-Kernen kann er auch parallel arbeiten. Ein Kern kann eine Aufgabe
erledigen, während ein anderer Kern eine komplett unabhängige, andere Aufgabe
erledigt, und das sogar zur gleichen Zeit.</p>
<p>Wenn wir mit async in Rust arbeiten, haben wir es immer mit Nebenläufigkeit zu
tun. Abhängig von der Hardware, dem Betriebssystem und der verwendeten
asynchronen Laufzeitumgebung, die wir verwenden, kann die Nebenläufigkeit unter
der Haube auch Parallelität nutzen.</p>
<p>Jetzt wollen wir uns ansehen, wie die asynchrone Programmierung in Rust
tatsächlich funktioniert!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="futures-und-die-asynchrone-syntax"><a class="header" href="#futures-und-die-asynchrone-syntax">Futures und die asynchrone Syntax</a></h2>
<p>Die Schlüsselelemente der asynchronen Programmierung in Rust sind <em>Futures</em> und
die Rust-Schlüsselwörter <code>async</code> und <code>await</code>.</p>
<p>Ein <em>Future</em> ist ein Wert, der vielleicht noch nicht verfügbar ist, aber
irgendwann in der Zukunft verfügbar sein wird. (Das gleiche Konzept taucht in
vielen Programmiersprachen auf, manchmal unter anderen Namen wie „task“ oder
„promise“.) Rust hat ein Merkmal <code>Future</code> als Baustein, sodass verschiedene
asynchrone Operationen mit verschiedenen Datenstrukturen, aber mit einer
gemeinsamen Schnittstelle implementiert werden können. In Rust sind Futures
Typen, die das Merkmal <code>Future</code> implementieren. Jedes Future hält seine eigenen
Informationen über den Fortschritt, der gemacht wurde und was „fertig“
bedeutet.</p>
<p>Das Schlüsselwort <code>async</code> kann auf Blöcke und Funktionen angewendet werden, um
anzugeben, dass sie unterbrochen und fortgesetzt werden können. Innerhalb eines
asynchronen Blocks oder einer asynchronen Funktion kannst du mit dem
Schlüsselwort <code>await</code> auf ein Future warten (d.h. warten bis es fertig ist).
Jede Stelle, an der du innerhalb eines asynchronen Blocks oder einer
asynchronen Funktion auf ein Future wartest, ist eine Stelle, an der der
asynchrone Block oder die asynchrone Funktion unterbrochen und fortgesetzt
werden kann. Der Vorgang, bei dem bei einem Future geprüft wird, ob sein Wert
bereits verfügbar ist, wird <em>polling</em> (engl. Abfragen) genannt.</p>
<p>Andere Sprachen wie C# und JavaScript verwenden ebenfalls die Schlüsselwörter
<code>async</code> und <code>await</code> für die asynchrone Programmierung. Wenn du mit diesen
Sprachen vertraut bist, wirst du vielleicht einige signifikante Unterschiede
zur Arbeitsweise von Rust bemerken, einschließlich der Art und Weise, wie es
die Syntax handhabt. Und das aus gutem Grund, wie wir sehen werden!</p>
<p>Wenn wir asynchrones Rust schreiben, verwenden wir meistens die Schlüsselwörter
<code>async</code> und <code>await</code>. Rust kompiliert sie in äquivalenten Code unter Verwendung
des Merkmals <code>Future</code>, genauso wie es <code>for</code>-Schleifen in äquivalenten Code
unter Verwendung des Merkmals <code>Iterator</code> kompiliert. Da Rust das Merkmal
<code>Future</code> bereitstellt, kannst du es bei Bedarf auch für deine eigenen
Datentypen implementieren. Viele der Funktionen, die wir in diesem Kapitel
sehen werden, geben Typen mit ihren eigenen Implementierungen von <code>Future</code>
zurück. Wir werden am Ende des Kapitels noch einmal auf die Definition des
Merkmals zurückkommen und mehr darüber erfahren, wie es funktioniert. Aber das
sind vorerst genug Details, die wir brauchen.</p>
<p>Das mag sich alles ein wenig abstrakt anfühlen, lass uns daher unser erstes
asynchrones Programm schreiben: Einen kleinen Web Scraper. Wir geben zwei URLs
über die Befehlszeile ein, rufen beide gleichzeitig ab und geben das Ergebnis
desjenigen zurück, der zuerst fertig wird. Dieses Beispiel wird eine neue
Syntax verwenden, aber keine Sorge – wir erklären dir alles, was du zum
jeweiligen Zeitpunkt wissen musst.</p>
<h2 id="unser-erstes-asynchrones-programm"><a class="header" href="#unser-erstes-asynchrones-programm">Unser erstes asynchrones Programm</a></h2>
<p>Um dieses Kapitel auf das Erlernen von async zu beschränken, anstatt mit Teilen
des Ökosystems zu jonglieren, haben wir die Kiste <code>trpl</code> erstellt (<code>trpl</code> ist
die Abkürzung für „The Rust Programming Language“). Sie re-exportiert alle
Typen, Merkmale und Funktionen, die du benötigst, hauptsächlich aus den Kisten
<a href="https://crates.io/crates/futures"><code>futures</code></a> und <a href="https://tokio.rs"><code>tokio</code></a>. Die Kiste <code>futures</code> ist ein
offizielles Zuhause für Rust-Experimente mit asynchronem Code und ist
eigentlich der Ort, an dem das Merkmal <code>Future</code> ursprünglich entworfen wurde.
Tokio ist heute die am häufigsten verwendete asynchrone Laufzeitumgebung in
Rust, insbesondere für Webanwendungen. Es gibt noch andere großartige
Laufzeitumgebungen, die für deine Zwecke evtl. besser geeignet sind. Wir
verwenden unter der Haube die Kiste <code>tokio</code> für <code>trpl</code>, weil es gut getestet
und weit verbreitet ist.</p>
<p>In einigen Fällen nennt <code>trpl</code> die ursprünglichen APIs um oder umschließt sie,
damit wir uns auf die für dieses Kapitel relevanten Details konzentrieren
können. Wenn du verstehen willst, was die Kiste tut, empfehlen wir dir, sich
den <a href="https://github.com/rust-lang/book/tree/main/packages/trpl">trpl-Quellcode</a> anzusehen. Du wirst sehen können, aus
welcher Kiste jeder Re-Export stammt, und wir haben ausführliche Kommentare
angegeben, die erklären, was die Kiste tut.</p>
<p>Erstelle ein neues Binärprojekt mit dem Namen <code>hello-async</code> und füge die Kiste
<code>trpl</code> als Abhängigkeit hinzu:</p>
<pre><code class="language-console">$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
</code></pre>
<p>Jetzt können wir die verschiedenen von <code>trpl</code> bereitgestellten Teile verwenden,
um unser erstes asynchrones Programm zu schreiben. Wir werden ein kleines
Kommandozeilen-Werkzeug erstellen, das zwei Webseiten abruft, das
jeweilige <code>&lt;title&gt;</code>-Element ausliest und den Titel derjenigen Seite ausgibt,
die den Vorgang zuerst beendet hat.</p>
<h3 id="definieren-der-funktion-page_title"><a class="header" href="#definieren-der-funktion-page_title">Definieren der Funktion <code>page_title</code></a></h3>
<p>Beginnen wir mit dem Schreiben einer Funktion, die eine Seiten-URL als
Parameter entgegennimmt, eine Anfrage an diese stellt und den Text des
Titelelements zurückgibt (siehe Codeblock 17-1).</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: Wir fügen dies als nächstes hinzu!
</span><span class="boring">}
</span><span class="boring">
</span>use trpl::Html;

async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title_element| title_element.inner_html())
}</code></pre></pre>
<p><span class="caption">Codeblock 17-1: Definieren einer asynchronen Funktion zum
Abrufen des Titelelements aus einer HTML-Seite</span></p>
<p>Zuerst definieren wir eine Funktion <code>page_title</code> und versehen sie mit dem
Schlüsselwort <code>async</code>. Dann verwenden wir die Funktion <code>trpl::get</code>, um die
übergebene URL abzurufen, und geben das Schlüsselwort <code>await</code> an, um auf die
Antwort zu warten. Um den Text aus der Antwort zu erhalten, rufen wir die
Methode <code>text</code> auf und warten erneut mit dem Schlüsselwort <code>await</code>. Diese
beiden Schritte sind asynchron. Bei der Funktion <code>get</code> müssen wir darauf
warten, dass der Server den ersten Teil seiner Antwort sendet, der den
HTTP-Header, Cookies und so weiter enthält. Dieser Teil der Antwort kann
getrennt vom Hauptteil der Anfrage übermittelt werden. Vor allem, wenn der
Textteil sehr umfangreich ist, kann es einige Zeit dauern, bis er vollständig
angekommen ist. Da wir auf das Eintreffen der <em>gesamten</em> Antwort warten müssen,
wird die Methode <code>text</code> ebenfalls als asynchron deklariert.</p>
<p>Wir müssen beide Futures explizit abwarten, weil Futures in Rust <em>faul</em> (lazy)
sind: Sie tun nichts, bis man sie mit dem Schlüsselwort <code>await</code> dazu
auffordert. (Tatsächlich zeigt Rust eine Compiler-Warnung an, wenn du keine
Futures verwendest.) Das dürfte dich an unsere Diskussion über Iteratoren in
<a href="ch13-02-iterators.html">„Eine Reihe von Elementen verarbeiten mit Iteratoren“</a> in
Kapitel 13 erinnern. Iteratoren tun nichts, es sei denn, du rufst ihre Methode
<code>next</code> auf – entweder direkt oder mit Hilfe von <code>for</code>-Schleifen
oder Methoden wie <code>map</code>, die <code>next</code> unter der Haube verwenden. Ebenso machen
Futures nichts, es sei denn, man bittet sie ausdrücklich darum. Diese Faulheit
erlaubt es Rust, die Ausführung von asynchronem Code zu vermeiden, bis er
tatsächlich benötigt wird.</p>
<blockquote>
<p>Anmerkung: Dies unterscheidet sich von dem Verhalten, das wir im vorherigen
Kapitel gesehen haben, als wir <code>thread::spawn</code> in <a href="ch16-01-threads.html#erstellen-eines-neuen-strangs-mit-spawn">„Erstellen eines neuen
Strangs mit spawn“</a> verwendet haben und der Funktionsabschluss,
den wir an einen anderen Strang übergeben haben, sofort zu laufen begann. Es
unterscheidet sich auch davon, wie viele andere Sprachen die asynchrone
Programmierung umsetzen! Aber es ist wichtig für Rust, dass es seine
Leistungsgarantien gewährleisten kann, genau wie bei Iteratoren.</p>
</blockquote>
<p>Sobald wir <code>response_text</code> haben, können wir ihn mit <code>Html::parse</code> in eine
Instanz des Typs <code>Html</code> einlesen. Anstelle einer rohen Zeichenkette haben wir
nun einen Datentyp, den wir verwenden können, um mit HTML als eine
reichhaltigere Datenstruktur zu arbeiten. Insbesondere können wir die Methode
<code>select_first</code> verwenden, um die erste Instanz eines bestimmten CSS-Selektors
zu finden. Durch Übergeben der Zeichenkette <code>"title"</code> erhalten wir das erste
<code>&lt;title&gt;</code>-Element im Dokument, wenn es eines gibt. Da möglicherweise kein
passendes Element vorhanden ist, gibt <code>select_first</code> eine <code>Option&lt;ElementRef&gt;</code>
zurück. Schließlich verwenden wir die Methode <code>Option::map</code>, die uns mit dem
Element in der <code>Option</code> arbeiten lässt, wenn es vorhanden ist, und nichts tut,
wenn es nicht vorhanden ist. (Wir könnten hier auch einen <code>match</code>-Ausdruck
verwenden, aber <code>map</code> ist idiomatischer.) Im Rumpf der Funktion, die wir an
<code>map</code> übergeben, rufen wir <code>inner_html</code> auf <code>title_element</code> auf, um dessen
Inhalt als <code>String</code> zu erhalten. Wenn alles erledigt ist, haben wir eine
<code>Option&lt;String&gt;</code>.</p>
<p>Beachte, dass das Rust-Schlüsselwort <code>await</code> <em>hinter</em> dem Ausdruck steht, auf
den du wartest, nicht vor ihm. Das heißt, es ist ein <em>Postfix</em>-Schlüsselwort.
Dies mag sich von dem unterscheiden, was du vielleicht gewohnt bist, wenn du
async in anderen Sprachen verwendet hast. Rust hat sich dafür entschieden, weil
es die Arbeit mit Methodenketten viel angenehmer macht. Als Ergebnis können wir
den Rumpf von <code>page_url_for</code> ändern, um die Funktionsaufrufe <code>trpl::get</code> und
<code>text</code> mit <code>await</code> dazwischen zu verketten, wie in Codeblock 17-2 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: Wir fügen dies als nächstes hinzu!
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span>    let response_text = trpl::get(url).await.text().await;
<span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-2: Verketten mit dem Schlüsselwort
<code>await</code></span></p>
<p>Damit haben wir erfolgreich unsere erste asynchrone Funktion geschrieben! Bevor
wir etwas Code in <code>main</code> schreiben, um sie aufzurufen, wollen wir uns ansehen,
was wir geschrieben haben und was es bedeutet.</p>
<p>Wenn Rust einen mit dem Schlüsselwort <code>async</code> markierten Block sieht,
kompiliert es ihn in einen eindeutigen, anonymen Datentyp, der das Merkmal
<code>Future</code> implementiert. Wenn Rust eine mit dem Schlüsselwort <code>async</code>
markierte Funktion sieht, kompiliert es sie zu einer nicht-asynchronen
Funktion, deren Rumpf ein asynchroner Block ist. Der Rückgabetyp einer
asynchronen Funktion ist der Typ des anonymen Datentyps, den der Compiler für
diesen asynchronen Block erstellt.</p>
<p>Die Angabe von <code>async fn</code> ist also gleichbedeutend mit dem Schreiben einer
Funktion, die ein <em>Future</em> des Rückgabetyps zurückgibt. Für den Compiler ist
eine Funktionsdefinition wie <code>async fn page_title</code> in Codeblock 17-1
äquivalent zu einer nicht-asynchronen Funktion, die wie folgt definiert ist:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl;
</span>use std::future::Future;
use trpl::Html;

fn page_title(url: &amp;str) -&gt; impl Future&lt;Output = Option&lt;String&gt;&gt; {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&amp;text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Gehen wir die einzelnen Teile der umgewandelten Version durch:</p>
<ul>
<li>Sie verwendet die Syntax <code>impl Trait</code>, die wir bereits in <a href="ch10-02-traits.html#merkmale-als-parameter">„Merkmale als
Parameter“</a> in Kapitel 10 besprochen haben.</li>
<li>Das zurückgegebene Merkmal ist ein <code>Future</code> mit dem assoziierten Typ von
<code>Output</code>. Beachte, dass der <code>Output</code>-Typ <code>Option&lt;String&gt;</code> ist, was dem
ursprünglichen Rückgabetyp der <code>async fn</code>-Version von <code>page_title</code>
entspricht.</li>
<li>Der gesamte im Rumpf der ursprünglichen Funktion wird in einen <code>async move</code>-Block eingepackt. Denke daran, dass Blöcke Ausdrücke sind. Dieser ganze
Block ist der Ausdruck, der von der Funktion zurückgegeben wird.</li>
<li>Dieser asynchrone Block erzeugt einen Wert vom Typ <code>Option&lt;String&gt;</code>, wie eben
beschrieben. Dieser Wert entspricht dem Typ <code>Output</code> im Rückgabetyp. Dies ist
genau wie bei anderen Blöcken, die du gesehen hast.</li>
<li>Der neue Funktionsrumpf ist ein <code>async move</code>-Block, da er den Parameter <code>url</code>
verwendet. (Wir werden mehr über <code>async</code> versus <code>async move</code> später in diesem
Kapitel sprechen.)</li>
</ul>
<p>Jetzt können wir <code>page_title</code> in <code>main</code> aufrufen.</p>
<h2 id="bestimmen-des-titels-einer-einzelnen-seite"><a class="header" href="#bestimmen-des-titels-einer-einzelnen-seite">Bestimmen des Titels einer einzelnen Seite</a></h2>
<p>Für den Anfang werden wir nur den Titel einer einzelnen Seite abrufen. In
Codeblock 17-3 folgen wir dem gleichen Muster, das wir zum Einlesen von
Kommandozeilenargumenten in <a href="ch12-01-accepting-command-line-arguments.html">„Kommandozeilenargumente
entgegennehmen“</a> in Kapitel 12 verwendet haben. Dann übergeben wir
die erste URL an <code>page_title</code> und warten das Ergebnis ab. Da der vom Future
erzeugte Wert ein <code>Option&lt;String&gt;</code> ist, verwenden wir einen <code>match</code>-Ausdruck,
um verschiedene Meldungen auszugeben, je nachdem ob die Seite einen <code>&lt;title&gt;</code>
hatte oder nicht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>async fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    let url = &amp;args[1];
    match page_title(url).await {
        Some(title) =&gt; println!("Der Titel von {url} ist {title}"),
        None =&gt; println!("{url} hat keinen Titel"),
    }
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-3: Aufruf der Funktion <code>page_title</code> aus
<code>main</code> mit einem vom Benutzer angegebenen Argument</span></p>
<p>Leider lässt sich dieser Code nicht kompilieren. Der einzige Ort, an dem wir
das Schlüsselwort <code>await</code> verwenden können, ist in asynchronen Funktionen oder
Blöcken, und Rust lässt uns die spezielle Funktion <code>main</code> nicht als <code>async</code>
markieren.</p>
<pre><code class="language-text">error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p>Der Grund, warum <code>main</code> nicht mit <code>async</code> markiert werden kann, ist, dass
asynchroner Code eine <em>Laufzeitumgebung</em> benötigt: eine Rust-Kiste, die die
Details der Ausführung von asynchronem Code verwaltet. Die Funktion <code>main</code>
eines Programms kann eine Laufzeitumgebung <em>initialisieren</em>, aber sie ist
nicht <em>selbst</em> eine Laufzeitumgebung. (Warum das so ist, werden wir später
sehen.) Jedes Rust-Programm, das asynchronen Code ausführt, hat mindestens eine
Stelle, an der es eine Laufzeitumgebung einrichtet und die Futures ausführt.</p>
<p>Die meisten Sprachen, die asynchrone Programmierung unterstützen, enthalten
eine Laufzeitumgebung, Rust hat das nicht. Stattdessen gibt es viele
verschiedene asynchrone Laufzeitumgebungen, von denen jede für den jeweiligen
Anwendungsfall unterschiedliche Kompromisse eingeht. Ein Webserver mit hohem
Durchsatz, vielen CPU-Kernen und einer großen Menge an RAM hat zum Beispiel
ganz andere Anforderungen als einen Mikrocontroller mit einem einzigen Kern,
einer kleinen Menge an RAM und keiner Möglichkeit, Haldenspeicher-Allokationen
(heap allocations) durchzuführen. Die Kisten, die diese Laufzeitumgebungen
bereitstellen, bieten oft auch asynchrone Versionen gängiger Funktionen wie
Datei- oder Netzwerkkommunikation.</p>
<p>Hier und im Rest dieses Kapitels werden wir die Funktion <code>run</code> aus der Kiste
<code>trpl</code> verwenden, die ein Future als Argument annimmt und es bis zum Ende
ausführt. Hinter den Kulissen wird durch den Aufruf von <code>run</code> eine
Laufzeitumgebung eingerichtet, die das übergebene Future ausführt. Sobald das
Future abgeschlossen ist, gibt <code>run</code> den Wert zurück, den das Future erzeugt
hat.</p>
<p>Wir könnten das von <code>page_title</code> zurückgegebene Future direkt an <code>run</code>
übergeben. Sobald es abgeschlossen ist, könnten wir die resultierende
<code>Option&lt;String&gt;</code> abgleichen, so wie wir es in Codeblock 17-3 versucht haben.
Für die meisten Beispiele in diesem Kapitel (und den meisten asynchronen Code
in der realen Welt!) werden wir jedoch mehr als nur einen asynchronen
Funktionsaufruf durchführen, also übergeben wir stattdessen einen <code>async</code>-Block
und warten explizit auf das Ergebnis des Aufrufs von <code>page_title</code>, wie in
Codeblock 17-4.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let url = &amp;args[1];
        match page_title(url).await {
            Some(title) =&gt; println!("Der Titel von {url} ist {title}"),
            None =&gt; println!("{url} hat keinen Titel"),
        }
    })
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-4: Warten auf einen asynchronen Block mit
<code>trpl::run</code></span></p>
<p>Wenn wir diesen Code ausführen, erhalten wir das Verhalten, das wir anfangs
erwartet haben:</p>
<pre><code class="language-console">$ cargo run -- https://www.rust-lang.org
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
Der Titel von https://www.rust-lang.org ist
            Rust Programming Language
</code></pre>
<p>Puh – wir haben endlich funktionierenden asynchronen Code! Bevor wir aber
den Code hinzufügen, um zwei Webseiten gegeneinander antreten zu lassen, wollen
wir uns noch einmal kurz der Funktionsweise von Futures zuwenden.</p>
<p>Jede Codestelle mit dem Schlüsselwort <code>await</code> stellt einen Punkt dar, an dem
die Kontrolle an die Laufzeitumgebung abgegeben wird. Damit das funktioniert,
muss Rust den Zustand des asynchronen Blocks verwalten, sodass die
Laufzeitumgebung eine andere Arbeit starten und dann zurückkommen kann, wenn
er bereit ist, diese Arbeit wieder fortzusetzen. Dies ist eine unsichtbare
Zustandsmaschine, so als ob du eine Aufzählung auf diese Weise geschrieben
hättest, um den aktuellen Zustand an jedem <code>await</code>-Punkt zu speichern:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl;
</span><span class="boring">
</span>enum PageTitleFuture&lt;'a&gt; {
    Initial { url: &amp;'a str },
    GetAwaitPoint { url: &amp;'a str },
    TextAwaitPoint { response: trpl::Response },
}
<span class="boring">}</span></code></pre></pre>
<p>Den Code für den Übergang zwischen den einzelnen Zuständen von Hand zu
schreiben, wäre allerdings mühsam und fehleranfällig, vor allem, wenn dem Code
später mehr Funktionalität und mehr Zustände hinzugefügt werden. Stattdessen
erstellt und verwaltet der Rust-Compiler die Zustandsmaschinen-Datenstrukturen
für asynchronen Code automatisch. Falls du dich wunderst: Ja, die normalen
Regeln für Ausleihen und die Eigentümerschaft von Datenstrukturen gelten auch
hier. Erfreulicherweise übernimmt der Compiler auch die Überprüfung dieser
Regeln für uns und gibt hilfreiche Fehlermeldungen aus. Ein paar davon werden
wir später im Kapitel durcharbeiten.</p>
<p>Letztendlich muss etwas diese Zustandsmaschine ausführen, und dieses Etwas ist
eine Laufzeitumgebung. (Aus diesem Grund wird auf <em>Executors</em> verwiesen, wenn
man sich mit Laufzeitumgebungen befasst: Ein Executor ist der Teil einer
Laufzeitumgebung, der für die Ausführung des asynchronen Codes verantwortlich
ist.)</p>
<p>Jetzt kannst du sehen, warum uns der Compiler in Codeblock 17-3 davon
abgehalten hat, <code>main</code> selbst zu einer asynchronen Funktion zu machen. Wäre
<code>main</code> eine asynchrone Funktion, müsste etwas anderes den Zustandsautomaten für
das Future verwalten, das <code>main</code> zurückgibt, aber <code>main</code> ist der Startpunkt des
Programms! Stattdessen haben wir die Funktion <code>trpl::run</code> in <code>main</code> aufgerufen,
um eine Laufzeitumgebung einzurichten und das vom <code>async</code>-Block zurückgegebene
Future auszuführen, bis es fertig ist.</p>
<blockquote>
<p>Hinweis: Einige Laufzeitumgebungen stellen Makros zur Verfügung, mit denen du
eine asynchrone Funktion <code>main</code> schreiben <em>kannst</em>. Diese Makros wandeln
<code>async fn main() { ... }</code> in eine normale <code>fn main</code> um, die dasselbe tut, was
wir in Codeblock 17-4 von Hand gemacht haben: Eine Funktion aufrufen, die ein
Future zu Ende ausführt, so wie <code>trpl::run</code> es macht.</p>
</blockquote>
<p>Fügen wir die Teile zusammen und sehen wir uns an, wie wir nebenläufigen Code
schreiben können.</p>
<h3 id="unsere-zwei-urls-gegeneinander-antreten-lassen"><a class="header" href="#unsere-zwei-urls-gegeneinander-antreten-lassen">Unsere zwei URLs gegeneinander antreten lassen</a></h3>
<p>In Codeblock 17-5 rufen wir <code>page_title</code> mit zwei verschiedenen URLs auf, die
von der Befehlszeile übergeben werden, und lassen sie um die Wette laufen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl;
</span><span class="boring">
</span>use trpl::{Either, Html};

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let title_fut_1 = page_title(&amp;args[1]);
        let title_fut_2 = page_title(&amp;args[2]);

        let (url, maybe_title) =
            match trpl::race(title_fut_1, title_fut_2).await {
                Either::Left(left) =&gt; left,
                Either::Right(right) =&gt; right,
            };

        println!("{url} wurde zuerst zurückgegeben");
        match maybe_title {
            Some(title) =&gt; println!("Der Titel ist: '{title}'"),
            None =&gt; println!("Der Titel konnte nicht eingelesen werden."),
        }
    })
}

async fn page_title(url: &amp;str) -&gt; (&amp;str, Option&lt;String&gt;) {
    let text = trpl::get(url).await.text().await;
    let title = Html::parse(&amp;text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}</code></pre>
<p><span class="caption">Codeblock 17-5</span></p>
<p>Wir beginnen mit dem Aufruf von <code>page_title</code> für jede der vom Benutzer
angegebenen URLs. Wir speichern die erhaltenen Futures als <code>title_fut_1</code> und
<code>title_fut_2</code>. Denke daran, dass diese noch nichts tun, denn Futures sind faul
und wir haben noch nicht auf sie gewartet. Dann übergeben wir die Futures an
<code>trpl::race</code>, das einen Wert zurückgibt, der anzeigt, welches der übergebenen
Futures zuerst fertig wurde.</p>
<blockquote>
<p>Anmerkung: Unter der Haube ist <code>race</code> auf der allgemeineren Funktion <code>select</code>
aufgebaut, der du bei realem Rust-Codes häufiger begegnen wirst. Die Funktion
<code>select</code> kann eine Menge Dinge tun, die die Funktion <code>trpl::race</code> nicht kann,
aber sie bringt auch zusätzliche Komplexität mit sich, die wir für den Moment
überspringen können.</p>
</blockquote>
<p>Jedes Future kann legitimerweise „gewinnen“, also macht es keinen Sinn, ein
<code>Result</code> zurückzugeben. Stattdessen gibt <code>race</code> einen Typ zurück, den wir noch
nicht gesehen haben: <code>trpl::Either</code>. Der Typ <code>Either</code> ist einem <code>Result</code>
insofern ähnlich, als dass er zwei Fälle hat. Im Gegensatz zu <code>Result</code>
unterscheidet <code>Either</code> jedoch nicht zwischen Erfolg und Misserfolg.
Stattdessen werden <code>Left</code> und <code>Right</code> verwendet, um „das eine oder das andere“
anzuzeigen.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre></pre>
<p>Die Funktion <code>race</code> gibt <code>Left</code> mit der Ausgabe des ersten Futures zurück, wenn
das erste Argument zuerst fertig ist, und <code>Right</code> mit der Ausgabe des zweiten
Futures, wenn dieses zuerst fertig ist. Dies entspricht der Reihenfolge, in der
die Argumente beim Aufruf der Funktion angegeben wurden: Das erste Argument
steht links vom zweiten Argument.</p>
<p>Wir aktualisieren auch <code>page_title</code>, um die gleiche URL zurückzugeben, die wir
übergeben haben. Auf diese Weise können wir eine aussagekräftige Meldung
ausgeben, wenn die Seite, die zuerst zurückkommt, keinen <code>&lt;title&gt;</code> hat, den wir
auslesen können. Mit diesen Informationen aktualisieren wir die Ausgabe von
<code>println!</code>, um anzugeben, welche URL als erste beendet wurde und was der
<code>&lt;title&gt;</code> der Webseite hinter dieser URL war, sofern vorhanden.</p>
<p>Du hast jetzt einen kleinen funktionierenden Web Scraper erstellt! Wähle ein
paar URLs aus und führe das Befehlszeilenwerkzeug aus. Du wirst möglicherweise
feststellen, dass einige Webseiten stets schneller sind als andere, während in
anderen Fällen die schnellere Webseite von Ausführung zu Ausführung
unterschiedlich ist. Noch wichtiger ist, dass du die Grundlagen der Arbeit mit
Futures gelernt hast, sodass wir uns jetzt noch mehr mit den Dingen befassen
können, die wir mit asynchroner Programmierung tun können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anwenden-von-nebenläufigkeit-mit-async"><a class="header" href="#anwenden-von-nebenläufigkeit-mit-async">Anwenden von Nebenläufigkeit mit async</a></h2>
<p>In diesem Abschnitt werden wir async auf einige Nebenläufigkeitsprobleme
anwenden, die wir in Kapitel 16 mit Strängen (threads) angegangen sind. Da wir
dort bereits über viele Schlüsselideen gesprochen haben, werden wir uns in
diesem Abschnitt auf die Unterschiede zwischen Strängen und Futures
konzentrieren.</p>
<p>In vielen Fällen sind die APIs für den Umgang mit Nebenläufigkeit mittels async
sehr ähnlich zu denen mit Strängen. In anderen Fällen sind sie am Ende ganz
anders. Selbst wenn die APIs von Strängen und async <em>ähnlich</em> aussehen, haben
sie oft ein anderes Verhalten und fast immer unterschiedliche
Leistungsmerkmale.</p>
<h3 id="erstellen-einer-neuen-aufgabe-mit-spawn_task"><a class="header" href="#erstellen-einer-neuen-aufgabe-mit-spawn_task">Erstellen einer neuen Aufgabe mit <code>spawn_task</code></a></h3>
<p>Die erste Operation, die wir in <a href="ch16-01-threads.html#erstellen-eines-neuen-strangs-mit-spawn">„Erstellen eines neuen Strangs mit
<code>spawn</code>“</a> in Angriff genommen haben, war das Hochzählen in zwei
separaten Strängen. Lass uns das Gleiche mit async machen. Die Kiste <code>trpl</code>
enthält eine Funktion <code>spawn_task</code>, die der API <code>thread::spawn</code> sehr ähnlich
ist, und eine Funktion <code>sleep</code>, die eine async-Version der API <code>thread::sleep</code>
ist. Wir können diese zusammen verwenden, um das Zählbeispiel zu
implementieren, siehe Codeblock 17-6.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span>use std::time::Duration;

fn main() {
    trpl::run(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("Hallo Nummer {i} von der ersten Aufgabe!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("Hallo Nummer {i} von der zweiten Aufgabe!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre></pre>
<p><span class="caption">Codeblock 17-6: Erstellen einer neuen Aufgabe, die etwas
ausgibt, während die Hauptaufgabe etwas anderes ausgibt</span></p>
<p>Als Ausgangspunkt rufen wir in unserer Funktion <code>main</code> <code>trpl::run</code> auf, sodass
unsere Top-Level-Funktion asynchron sein kann.</p>
<blockquote>
<p>Hinweis: Im weiteren Verlauf dieses Kapitels wird jedes Beispiel genau den
gleichen Rahmen-Code mit <code>trpl::run</code> in <code>main</code> enthalten, also werden wir ihn
oft auslassen, genau wie wir es mit <code>main</code> tun. Vergiss nicht, ihn in
deinem Code einzubauen!</p>
</blockquote>
<p>Dann schreiben wir zwei Schleifen innerhalb dieses Blocks, jede mit einem
<code>trpl::sleep</code>-Aufruf, der eine halbe Sekunde (500 Millisekunden) wartet, bevor
die nächste Nachricht gesendet wird. Wir platzieren die eine Schleife in den
Rumpf des <code>trpl::spawn_task</code>-Aufrufs und die andere in eine <code>for</code>-Schleife auf
oberster Ebene. Wir fügen auch ein <code>await</code> nach den <code>sleep</code>-Aufrufen ein.</p>
<p>Dieser Code funktioniert ähnlich wie die Strang-basierte Implementierung
– einschließlich der Tatsache, dass die Meldungen in deinem Terminal in
einer anderen Reihenfolge erscheinen, wenn du es ausführst:</p>
<pre><code class="language-text">Hallo Nummer 1 von der zweiten Aufgabe!
Hallo Nummer 1 von der ersten Aufgabe!
Hallo Nummer 2 von der ersten Aufgabe!
Hallo Nummer 2 von der zweiten Aufgabe!
Hallo Nummer 3 von der ersten Aufgabe!
Hallo Nummer 3 von der zweiten Aufgabe!
Hallo Nummer 4 von der ersten Aufgabe!
Hallo Nummer 4 von der zweiten Aufgabe!
Hallo Nummer 5 von der ersten Aufgabe!
</code></pre>
<p>Diese Version beendet sich, sobald die <code>for</code>-Schleife im Rumpf des asynchronen
Blocks beendet ist, da die von <code>spawn_task</code> erzeugte Aufgabe beendet wird, wenn
die Funktion <code>main</code> endet. Wenn du die Aufgabe bis zum Ende ausführen willst,
musst du <code>JoinHandle</code> verwenden, um auf das Ende der ersten Aufgabe zu warten.
Bei Strängen haben wir die Methode <code>join</code> verwendet, um zu „blockieren“, bis
der Strang fertig ist. In Codeblock 17-7 können wir <code>await</code> verwenden, um
dasselbe zu tun, weil <code>JoinHandle</code> selbst ein Future ist. Sein <code>Output</code>-Typ ist
<code>Result</code>, also entpacken wir es ebenfalls, nachdem wir darauf gewartet haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("Hallo Nummer {i} von der ersten Aufgabe!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("Hallo Nummer {i} von der zweiten Aufgabe!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-7: Verwenden von <code>await</code> mit einem
<code>JoinHandle</code>, um eine Aufgabe bis zum Ende auszuführen</span></p>
<p>Diese aktualisierte Version läuft, bis <em>beide</em> Schleifen beendet sind.</p>
<pre><code class="language-text">Hallo Nummer 1 von der zweiten Aufgabe!
Hallo Nummer 1 von der ersten Aufgabe!
Hallo Nummer 2 von der ersten Aufgabe!
Hallo Nummer 2 von der zweiten Aufgabe!
Hallo Nummer 3 von der ersten Aufgabe!
Hallo Nummer 3 von der zweiten Aufgabe!
Hallo Nummer 4 von der ersten Aufgabe!
Hallo Nummer 4 von der zweiten Aufgabe!
Hallo Nummer 5 von der ersten Aufgabe!
Hallo Nummer 6 von der ersten Aufgabe!
Hallo Nummer 7 von der ersten Aufgabe!
Hallo Nummer 8 von der ersten Aufgabe!
Hallo Nummer 9 von der ersten Aufgabe!
</code></pre>
<p>Bisher sieht es so aus, als ob async und Stränge zu den gleichen Ergebnissen
führen, nur mit einer anderen Syntax: Verwenden von <code>await</code> anstelle des
Aufrufs von <code>join</code> auf <code>JoinHandle</code> und Abwarten der <code>sleep</code>-Aufrufe.</p>
<p>Der größere Unterschied ist, dass wir dafür keinen weiteren
Betriebssystem-Strang starten müssen. Tatsächlich brauchen wir hier nicht
einmal eine Aufgabe zu starten. Da asynchrone Blöcke zu anonymen Futures
kompiliert werden, können wir beide Schleifen in einen asynchronen Block packen
und von der Laufzeitumgebung mittels der Funktion <code>trpl::join</code> bis zum Ende
ausführen lassen.</p>
<p>Im Abschnitt <a href="ch16-01-threads.html#warten-auf-das-ende-aller-str%C3%A4nge-mit-join">„Warten auf das Ende aller Stränge mit <code>join</code>“</a>
haben wir gezeigt, wie man die Methode <code>join</code> auf den Typ <code>JoinHandle</code>
anwendet, der beim Aufruf von <code>std::thread::spawn</code> zurückgegeben wird. Die
Funktion <code>trpl::join</code> ist ähnlich, aber für Futures. Wenn du ihr zwei Futures
gibst, erzeugt sie ein neues Future, dessen Ausgabe ein Tupel mit der Ausgabe
der beiden übergebenen Futures ist, sobald <em>beide</em> abgeschlossen sind. In
Codeblock 17-8 verwenden wir also <code>trpl::join</code>, um darauf zu warten, dass
sowohl <code>fut1</code> als auch <code>fut2</code> fertig sind. Wir warten <em>nicht</em> auf <code>fut1</code> und
<code>fut2</code>, sondern auf das neue Future, das von <code>trpl::join</code> erzeugt wurde. Wir
ignorieren die Ausgabe, da es sich nur um ein Tupel mit zwei Einheitswerten
handelt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("Hallo Nummer {i} von der ersten Aufgabe!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("Hallo Nummer {i} von der zweiten Aufgabe!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-8: Verwenden von <code>trpl::join</code>, um auf zwei
anonyme Futures zu warten</span></p>
<p>Wenn wir dies ausführen, sehen wir, dass beide Futures bis zum Ende laufen:</p>
<pre><code class="language-text">Hallo Nummer 1 von der ersten Aufgabe!
Hallo Nummer 1 von der zweiten Aufgabe!
Hallo Nummer 2 von der ersten Aufgabe!
Hallo Nummer 2 von der zweiten Aufgabe!
Hallo Nummer 3 von der ersten Aufgabe!
Hallo Nummer 3 von der zweiten Aufgabe!
Hallo Nummer 4 von der ersten Aufgabe!
Hallo Nummer 4 von der zweiten Aufgabe!
Hallo Nummer 5 von der ersten Aufgabe!
Hallo Nummer 6 von der ersten Aufgabe!
Hallo Nummer 7 von der ersten Aufgabe!
Hallo Nummer 8 von der ersten Aufgabe!
Hallo Nummer 9 von der ersten Aufgabe!
</code></pre>
<p>Nun siehst du jedes Mal genau dieselbe Reihenfolge, was sich sehr von dem
unterscheidet, was wir bei Strängen gesehen haben. Das liegt daran, dass die
Funktion <code>trpl::join</code> <em>fair</em> ist, d.h. sie prüft jedes Future gleich oft,
wechselt zwischen ihnen ab und lässt nie eines vorauslaufen, wenn das andere
bereit ist. Bei Strängen entscheidet das Betriebssystem, welcher Strang geprüft
wird und wie lange er laufen darf. Bei asynchronem Rust entscheidet die
Laufzeitumgebung, welche Aufgabe geprüft werden soll. (In der Praxis sind die
Details komplizierter, weil eine asynchrone Laufzeitumgebung unter der Haube
Betriebssystem-Stränge für die Verwaltung der Nebenläufigkeit verwenden könnte,
sodass das Einhalten der Fairness mehr Aufwand für eine Laufzeitumgebung sein
kann – aber es ist immer noch möglich!) Laufzeitumgebungen müssen nicht
für jede beliebige Operation Fairness garantieren, und sie stellen oft mehrere
APIs bereit, mit denen du wählen kannst, ob du Fairness wünschst oder nicht.</p>
<p>Probiere einige dieser Varianten des Wartens auf das Future aus und sieh, was
sie bewirken:</p>
<ul>
<li>Entferne den asynchronen Block um eine oder beide Schleifen.</li>
<li>Warte auf jeden asynchronen Block sofort nach seiner Definition.</li>
<li>Packe nur die erste Schleife in einen asynchronen Block und warte auf das
resultierende Future nach dem Rumpf der zweiten Schleife.</li>
</ul>
<p>Eine zusätzliche Herausforderung ist es, herauszufinden, wie die Ausgabe in
jedem Fall aussehen wird, <em>bevor</em> du den Code ausführst!</p>
<h3 id="hochzählen-in-zwei-aufgaben-mit-nachrichtenübermittlung"><a class="header" href="#hochzählen-in-zwei-aufgaben-mit-nachrichtenübermittlung">Hochzählen in zwei Aufgaben mit Nachrichtenübermittlung</a></h3>
<p>Auch die gemeinsame Nutzung von Daten zwischen Futures wird uns vertraut sein:
Wir werden wieder die Nachrichtenübermittlung verwenden, diesmal jedoch mit
asynchronen Versionen der Typen und Funktionen. Wir werden einen etwas anderen
Weg einschlagen als in <a href="ch16-02-message-passing.html">„Nachrichtenaustausch zwischen Strängen
(threads)“</a>, um einige der wichtigsten Unterschiede
zwischen Strang-basierter und Future-basierter Nebenläufigkeit zu
veranschaulichen. In Codeblock 17-9 beginnen wir mit einem einzigen asynchronen
Block – <em>ohne</em> eine separate Aufgabe zu erstellen, da wir einen separaten
Strang erstellt haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("Erhalten: {received}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-9: Erstellen eines asynchronen Kanals und
Zuweisen der beiden Enden an <code>tx</code> und <code>rx</code></span></p>
<p>Hier verwenden wir <code>trpl::channel</code>, eine asynchrone Version des Kanals wie mit
Strängen in Kapitel 16. Die asynchrone Version der API unterscheidet sich nur
geringfügig von der Strang-basierten Version: Sie verwendet einen veränderbaren
statt eines unveränderbaren Empfängers <code>rx</code>, und ihre Methode <code>recv</code> erzeugt
ein Future, auf das wir warten müssen, anstatt den Wert direkt zu erzeugen.
Jetzt können wir Nachrichten vom Sender zum Empfänger senden. Beachte, dass wir
keinen separaten Strang oder gar eine Aufgabe erzeugen müssen; wir müssen
lediglich auf den Aufruf von <code>rx.recv</code> warten.</p>
<p>Die synchrone Methode <code>Receiver::recv</code> in <code>std::mpsc::channel</code> blockiert, bis
sie eine Nachricht erhält. Die Methode <code>trpl::Receiver::recv</code> tut dies nicht,
da sie asynchron ist. Anstatt zu blockieren, übergibt sie die Kontrolle zurück
an die Laufzeitumgebung, bis entweder eine Nachricht empfangen wird oder die
Sendeseite des Kanals geschlossen wurde. Im Gegensatz dazu warten wir nicht auf
den <code>send</code>-Aufruf, weil er nicht blockiert. Das ist auch nicht nötig, denn der
Kanal, in den wir die Nachricht senden, ist unlimitiert.</p>
<blockquote>
<p>Anmerkung: Da der gesamte asynchrone Code in einem asynchronen Block in einem
<code>trpl::run</code>-Aufruf läuft, kann alles innerhalb dieses Blocks ein Blockieren
vermeiden. Allerdings wird der Code <em>außerhalb</em> des Blocks blockieren, wenn
die Funktion <code>run</code> zurückkehrt. Das ist der ganze Sinn der Funktion
<code>trpl::run</code>: Sie lässt dich <em>wählen</em>, wo du bei einer Menge von asynchronem
Code blockieren willst, und somit wo du zwischen synchronem und asynchronem
Code wechseln willst. In den meisten asynchronen Laufzeitumgebungen wird
<code>run</code> aus genau diesem Grund <code>block_on</code> genannt.</p>
</blockquote>
<p>Beachte bei diesem Beispiel zwei Dinge. Erstens: Die Nachricht wird sofort
ankommen! Zweitens: Obwohl wir hier ein Future verwenden, gibt es noch keine
Nebenläufigkeit. Alles im Codeblock geschieht der Reihe nach, so wie es auch
geschehen würde, wenn keine Futures beteiligt wären.</p>
<p>Der erste Teil besteht darin, eine Reihe von Nachrichten zu senden und
dazwischen zu schlafen, wie in Codeblock 17-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("Hallo"),
            String::from("aus"),
            String::from("dem"),
            String::from("Future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("Erhalten: '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-10: Senden und Empfangen mehrerer
Nachrichten über den asynchronen Kanal und Schlafen mit einem <code>await</code> zwischen
jeder Nachricht</span></p>
<p>Wir müssen die Nachrichten nicht nur senden, sondern auch empfangen. In diesem
Fall könnten wir das manuell tun, indem wir einfach <code>rx.recv().await</code> viermal
ausführen, weil wir wissen, wie viele Nachrichten ankommen werden. In der
realen Welt werden wir jedoch im Allgemeinen auf eine <em>unbekannte</em> Anzahl von
Nachrichten warten, wir müssen also so lange warten, bis wir feststellen, dass
es keine weiteren Nachrichten mehr gibt.</p>
<p>In Codeblock 16-10 haben wir eine <code>for</code>-Schleife verwendet, um alle Elemente zu
verarbeiten, die von einem synchronen Kanal empfangen wurden. In Rust gibt es
jedoch noch keine Möglichkeit, eine <code>for</code>-Schleife über eine <em>asynchrone</em> Reihe
von Elementen zu schreiben. Stattdessen müssen wir eine neue Schleifenart
verwenden, die wir bisher noch nicht gesehen haben: die <code>while let</code>-Schleife
mit Bedingungen. Dies ist die Schleifenvariante des <code>if let</code>-Konstrukts, das
wir in <a href="ch06-03-if-let.html">„Prägnanter Kontrollfluss mit <code>if let</code> und <code>let else</code>“</a> gesehen
haben. Die Schleife wird so lange ausgeführt, wie das angegebene Muster zum
Wert passt.</p>
<p>Der Aufruf <code>rx.recv</code> erzeugt ein Future, auf das wir warten. Die
Laufzeitumgebung pausiert das Future, bis es bereit ist. Sobald eine Nachricht
eintrifft, wird das Future zu <code>Some(message)</code> aufgelöst, so oft wie eine
Nachricht eintrifft. Wenn der Kanal geschlossen wird, unabhängig davon, ob
<em>irgendwelche</em> Nachrichten eingetroffen sind, wird das Future stattdessen zu
<code>None</code> aufgelöst, um anzuzeigen, dass es keine weiteren Werte gibt und wir
daher mit dem Polling aufhören können, d.h. aufhören zu warten.</p>
<p>Die <code>while let</code>-Schleife fasst all dies zusammen. Wenn das Ergebnis des Aufrufs
von <code>rx.recv().await</code> den Wert <code>Some(message)</code> hat, erhalten wir Zugriff auf
die Nachricht und können sie im Schleifenrumpf verwenden, genauso wie wir es
mit <code>if let</code> könnten. Wenn das Ergebnis <code>None</code> ist, endet die Schleife. Jedes
Mal, wenn die Schleife durchlaufen wird, trifft sie erneut auf den await-Punkt,
sodass die Laufzeitumgebung die Schleife erneut unterbricht, bis eine weitere
Nachricht eintrifft.</p>
<p>Der Code sendet und empfängt nun erfolgreich alle Nachrichten. Leider gibt es
immer noch ein paar Probleme. Zum einen kommen die Nachrichten nicht in
Abständen von einer halben Sekunde an. Sie kommen alle auf einmal an, und zwar
zwei Sekunden (2.000 Millisekunden) nach dem Start des Programms. Zum anderen
beendet sich dieses Programm nie! Stattdessen wartet es ewig auf neue
Nachrichten. Du musst es mit <kbd>Strg</kbd>+<kbd>c</kbd> beenden.</p>
<p>Beginnen wir damit, herauszufinden, warum die Nachrichten alle auf einmal nach
der vollen Verzögerung eintreffen, anstatt mit Verzögerungen zwischen den
einzelnen Nachrichten. Innerhalb eines bestimmten asynchronen Blocks ist die
Reihenfolge, in der die Schlüsselwörter <code>await</code> im Code erscheinen, auch die
Reihenfolge, in der sie bei der Ausführung des Programms auftreten.</p>
<p>In Codeblock 17-10 gibt es nur einen asynchronen Block, sodass alles darin
linear abläuft. Es gibt immer noch keine Nebenläufigkeit. Alle Aufrufe von
<code>tx.send</code> finden statt, unterbrochen von allen <code>trpl::sleep</code>-Aufrufen und
ihren zugehörigen Wartepunkten. Erst dann durchläuft die <code>while let</code>-Schleife
einen der <code>await</code> Punkte nach dem Aufruf von <code>recv</code>.</p>
<p>Um die gewünschte Verzögerung zwischen dem Empfang jeder Nachricht zu
erreichen, müssen wir die Operationen <code>tx</code> und <code>rx</code> in eigene asynchrone Blöcke
packen, wie in Codeblock 17-11 gezeigt. Dann kann die Laufzeitumgebung jede
dieser Operationen separat mit <code>trpl::join</code> ausführen, genau wie im
Zählbeispiel. Auch hier warten wir auf das Ergebnis des Aufrufs von
<code>trpl::join</code>, nicht auf die einzelnen Futures. Würden wir auf die einzelnen
Futures nacheinander warten, hätten wir wieder einen sequenziellen Ablauf
– genau das, was wir <em>nicht</em> wollen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("Hallo"),
                String::from("aus"),
                String::from("dem"),
                String::from("Future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("Erhalten: '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-11: Aufteilen von <code>send</code> und <code>recv</code> in
separate <code>async</code>-Blöcke und Warten auf die Futures dieser Blöcke</span></p>
<p>Mit dem aktualisierten Code in Codeblock 17-11 werden die Nachrichten in
Abständen von 500 Millisekunden ausgegeben und nicht mehr alle auf einmal nach
zwei Sekunden.</p>
<p>Das Programm beendet sich aber trotzdem nicht, weil die <code>while let</code>-Schleife
mit <code>trpl::join</code> interagiert:</p>
<ul>
<li>Das von <code>trpl::join</code> zurückgegebene Future ist erst erledigt, wenn <em>beide</em>
übergebene Futures erledigt sind.</li>
<li>Das Future <code>tx</code> ist erledigt, sobald es die Pause nach dem Senden der letzten
Nachricht in <code>vals</code> beendet hat.</li>
<li>Das Future <code>rx</code> ist erst nach dem Ende der <code>while let</code>-Schleife erledigt.</li>
<li>Die <code>while let</code>-Schleife endet erst, wenn das Ergebnis von <code>rx.recv</code> <code>None</code>
ist.</li>
<li>Das Ergebnis von <code>rx.recv</code> ist nur dann <code>None</code>, wenn das andere Ende des
Kanals geschlossen wurde.</li>
<li>Der Kanal wird nur geschlossen, wenn wir <code>rx.close</code> aufrufen oder wenn die
Senderseite <code>tx</code> aufgeräumt (dropped) wird.</li>
<li>Wir rufen nirgendwo <code>rx.close</code> auf, und <code>tx</code> wird nicht aufgeräumt, bis der
äußerste asynchrone Block, der an <code>trpl::run</code> übergeben wurde, endet.</li>
<li>Der Block kann nicht enden, weil er auf <code>trpl::join</code> wartet, was uns wieder
an den Anfang dieser Liste bringt.</li>
</ul>
<p>Wir könnten <code>rx</code> manuell schließen, indem wir irgendwo <code>rx.close</code> aufrufen,
aber das macht nicht viel Sinn. Das Beenden nach der Verarbeitung einer
bestimmten Anzahl von Nachrichten würde das Programm herunterfahren, aber wir
könnten Nachrichten verpassen. Wir brauchen einen anderen Weg, um
sicherzustellen, dass <code>tx</code> <em>vor</em> dem Ende der Funktion aufgeräumt wird.</p>
<p>Im Moment leiht sich der async-Block, in dem wir die Nachrichten senden, nur
<code>tx</code> aus, weil das Senden einer Nachricht keine Eigentümerschaft erfordert.
Wenn wir <code>tx</code> aber in den async-Block verschieben könnten, würde es aufgeräumt
werden, sobald der Block endet. In <a href="ch13-01-closures.html#erfassen-von-referenzen-oder-verschieben-der-eigent%C3%BCmerschaft">„Erfassen von Referenzen oder Verschieben
der Eigentümerschaft“</a> in Kapitel 13 haben wir gelernt, wie
man das Schlüsselwort <code>move</code> mit Funktionsabschlüssen verwendet, und in
<a href="ch16-01-threads.html#verwenden-von-move-funktionsabschl%C3%BCssen-mit-str%C3%A4ngen">„Verwenden von <code>move</code>-Funktionsabschlüssen mit Strängen“</a> in
Kapitel 16 haben wir gesehen, dass wir oft Daten in Funktionsabschlüsse
verschieben müssen, wenn wir mit Strängen arbeiten. Für asynchrone Blöcke gilt
dieselbe grundlegende Dynamik, sodass das Schlüsselwort <code>move</code> mit asynchronen
Blöcken genauso funktioniert wie mit Funktionsabschlüssen.</p>
<p>In Codeblock 17-12 ändern wir den Block zum Senden von Nachrichten von <code>async</code>
zu <code>async move</code>. Wenn wir <em>diese</em> Version des Codes ausführen, beendet sie sich
ordnungsgemäß, nachdem die letzte Nachricht gesendet und empfangen wurde.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            let vals = vec![
                String::from("Hallo"),
                String::from("aus"),
                String::from("dem"),
                String::from("Future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                eprintln!("Erhalten: '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-12: Eine Überarbeitung des Codes aus
Codeblock 17-11, die den Code korrekt beendet, wenn er fertig ist</span></p>
<p>Dieser asynchrone Kanal ist auch ein Kanal für mehrere Erzeuger, sodass wir
<code>clone</code> auf <code>tx</code> aufrufen können, wenn wir Nachrichten von mehreren Futures
senden wollen, wie in Codeblock 17-13 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("Hallo"),
                String::from("aus"),
                String::from("dem"),
                String::from("Future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("Erhalten: '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("Weitere"),
                String::from("Nachrichten"),
                String::from("für"),
                String::from("dich"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-13: Verwenden mehrerer Produzenten mit
asynchronen Blöcken</span></p>
<p>Zuerst klonen wir <code>tx</code> und erstellen <code>tx1</code> außerhalb des ersten asynchronen
Blocks. Wir verschieben <code>tx1</code> in diesen Block, genau wie wir es zuvor mit <code>tx</code>
gemacht haben. Dann verschieben wir das ursprüngliche <code>tx</code> in einen <em>neuen</em>
asynchronen Block, wo wir mehr Nachrichten mit einer etwas größeren Verzögerung
senden. Wir setzen diesen neuen asynchronen Block nach dem asynchronen Block
für den Empfang von Nachrichten, aber er könnte genauso gut vor ihm stehen. Der
Schlüssel ist die Reihenfolge, in der auf die Futures gewartet wird, nicht die
Reihenfolge, in der sie erstellt werden.</p>
<p>Die beiden asynchronen Blöcke zum Senden von Nachrichten müssen <code>async move</code>-Blöcke sein, sodass sowohl <code>tx</code> als auch <code>tx1</code> aufgeräumt werden, wenn
diese Blöcke zu Ende sind. Sonst landen wir wieder in der gleichen
Endlosschleife, mit der wir angefangen haben. Schließlich wechseln wir von
<code>trpl::join</code> zu <code>trpl::join3</code>, um das zusätzliche Future zu behandeln.</p>
<p>Jetzt sehen wir alle Nachrichten der beiden sendenden Futures. Da die sendenden
Futures leicht unterschiedliche Verzögerungen nach dem Senden verwenden, werden
die Nachrichten auch in diesen unterschiedlichen Intervallen empfangen.</p>
<pre><code class="language-text">Erhalten: 'Hallo'
Erhalten: 'Weitere'
Erhalten: 'aus'
Erhalten: 'dem'
Erhalten: 'Nachrichten'
Erhalten: 'Future'
Erhalten: 'für'
Erhalten: 'dich'
</code></pre>
<p>Das ist ein guter Anfang, aber es schränkt uns auf eine Handvoll Futures ein:
Zwei mit <code>join</code> und drei mit <code>join3</code>. Schauen wir uns an, wie wir mit mehr
Futures arbeiten können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="arbeiten-mit-einer-beliebigen-anzahl-von-futures"><a class="header" href="#arbeiten-mit-einer-beliebigen-anzahl-von-futures">Arbeiten mit einer beliebigen Anzahl von Futures</a></h2>
<p>Als wir im vorigen Abschnitt von zwei auf drei Futures umgestellt haben,
mussten wir auch von <code>join</code> auf <code>join3</code> umstellen. Es wäre lästig, jedes Mal
eine andere Funktion aufrufen zu müssen, wenn wir die Anzahl der Futures, auf
die wir warten wollen, ändern. Glücklicherweise gibt es eine Makroform von
<code>join</code>, an die wir eine beliebige Anzahl von Argumenten übergeben können. Es
kümmert sich auch um das Warten auf die Futures. Wir könnten also den Code aus
Codeblock 17-13 umschreiben, um <code>join!</code> anstelle von <code>join3</code> zu verwenden, wie
in Codeblock 17-14.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Hallo"),
</span><span class="boring">                String::from("aus"),
</span><span class="boring">                String::from("dem"),
</span><span class="boring">                String::from("Future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("Erhalten: '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Weitere"),
</span><span class="boring">                String::from("Nachrichten"),
</span><span class="boring">                String::from("für"),
</span><span class="boring">                String::from("dich"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        trpl::join!(tx1_fut, tx_fut, rx_fut);
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-14: Verwenden von <code>join!</code> zum Warten auf
mehrere Futures</span></p>
<p>Das ist definitiv eine Verbesserung gegenüber dem Wechsel zwischen <code>join</code> und
<code>join3</code> und <code>join4</code> und so weiter! Allerdings funktioniert auch diese Makroform
nur, wenn wir die Anzahl der Futures im Voraus kennen. In der realen Rust-Welt
ist es jedoch ein gängiges Muster, Futures in eine Kollektion (collection) zu
geben und dann darauf zu warten, dass einige oder alle Futures fertig werden.</p>
<p>Um alle Futures in einer Kollektion zu prüfen, müssen wir über <em>alle</em> Futures
iterieren und sie verbinden. Die Funktion <code>trpl::join_all</code> akzeptiert jeden
Typ, der das Merkmal <code>Iterator</code> implementiert, das wir in <a href="ch13-02-iterators.html#das-merkmal-trait-iterator-und-die-methode-next">„Das Merkmal (trait)
<code>Iterator</code> und die Methode <code>next</code>“</a> in Kapitel 13 kennengelernt
haben, also scheint sie genau das Richtige zu sein. Lass uns versuchen, unsere
Futures in einen Vektor zu packen und <code>join!</code> durch <code>join_all</code> zu ersetzen, wie
in Codeblock 17-15 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Hallo"),
</span><span class="boring">                String::from("aus"),
</span><span class="boring">                String::from("dem"),
</span><span class="boring">                String::from("Future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("Erhalten: '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Weitere"),
</span><span class="boring">                String::from("Nachrichten"),
</span><span class="boring">                String::from("für"),
</span><span class="boring">                String::from("dich"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures = vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-15: Speichern anonymer Futures in einem
Vektor und Aufrufen von <code>join_all</code></span></p>
<p>Leider lässt sich dieser Code nicht kompilieren. Stattdessen erhalten wir
diesen Fehler:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src/main.rs:45:37
   |
10 |         let tx1_fut = async move {
   |                       ---------- the expected `async` block
...
24 |         let rx_fut = async {
   |                      ----- the found `async` block
...
45 |         let futures = vec![tx1_fut, rx_fut, tx_fut];
   |                                     ^^^^^^ expected `async` block, found a different `async` block
   |
   = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
              found `async` block `{async block@src/main.rs:24:22: 24:27}`
   = note: no two async blocks, even if identical, have the same type
   = help: consider pinning your async block and casting it to a trait object
</code></pre>
<p>Das mag überraschend sein. Schließlich gibt keiner der asynchronen Blöcke etwas
zurück, sodass jeder Block ein <code>Future&lt;Output = ()&gt;</code> erzeugt. Denke jedoch
daran, dass <code>Future</code> ein Merkmal ist und dass der Compiler für jeden
asynchronen Block eine eigene Aufzählung erstellt. Man kann nicht zwei
verschiedene handgeschriebene Strukturen in einen <code>Vec</code> packen. Dieselbe Regel
gilt für die verschiedenen vom Compiler erzeugten Strukturen.</p>
<p>Damit dies funktioniert, müssen wir <em>Merkmalsobjekte</em> (trait objects)
verwenden, wie wir es in <a href="ch12-03-improving-error-handling-and-modularity.html#r%C3%BCckgabe-von-fehlern-aus-der-funktion-run">„Rückgabe von Fehlern aus der Funktion <code>run</code>“</a>
in Kapitel 12 getan haben. (Wir werden Merkmalsobjekte im Detail in Kapitel 18
behandeln.) Die Verwendung von Merkmalsobjekten ermöglicht es uns, alle
anonymen Futures, die von diesen Typen erzeugt werden, als denselben Typ zu
behandeln, da alle von ihnen das Merkmal <code>Future</code> implementieren.</p>
<blockquote>
<p>Anmerkung: In <a href="ch08-01-vectors.html#verwenden-einer-aufz%C3%A4hlung-zum-speichern-mehrerer-typen">„Verwenden einer Aufzählung zum Speichern mehrerer
Typen“</a> in Kapitel 8 haben wir eine andere Möglichkeit besprochen,
mehrere Typen in einem <code>Vec</code> aufzunehmen: Verwenden eines Enums, um jeden
Typ, der im Vektor vorkommen kann, zu repräsentieren. Das können wir hier
allerdings nicht tun. Zum einen haben wir keine Möglichkeit, die
verschiedenen Typen zu benennen, da sie anonym sind. Zum anderen war der
Grund, warum wir uns überhaupt für einen Vektor und <code>join_all</code> entschieden
haben, dass wir mit einer dynamischen Kollektion von Futures arbeiten
wollten, wobei wir nur darauf achten, dass sie denselben Ausgabetyp haben.</p>
</blockquote>
<p>Wir beginnen, indem wir jedes Future in <code>vec!</code> in eine <code>Box::new</code> packen, wie
in Codeblock 17-16 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Hallo"),
</span><span class="boring">                String::from("aus"),
</span><span class="boring">                String::from("dem"),
</span><span class="boring">                String::from("Future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("Erhalten: '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Weitere"),
</span><span class="boring">                String::from("Nachrichten"),
</span><span class="boring">                String::from("für"),
</span><span class="boring">                String::from("dich"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-16: Verwenden von <code>Box::new</code>, um die Typen
der Futures in einen <code>Vec</code> zu bringen</span></p>
<p>Leider lässt sich dieser Code immer noch nicht kompilieren. Tatsächlich
erhalten wir den gleichen grundlegenden Fehler wie zuvor, aber wir bekommen
einen für den zweiten und dritten Aufruf von <code>Box::new</code>, sowie neue Fehler, die
sich auf das Merkmal <code>Unpin</code> beziehen. Wir werden gleich auf die <code>Unpin</code>-Fehler
zurückkommen. Lass uns zunächst die Typ-Fehler bei den Aufrufen von <code>Box::new</code>
beheben, indem wir den Typ der Variable <code>futures</code> explizit annotieren, siehe
Codeblock 17-17.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Hallo"),
</span><span class="boring">                String::from("aus"),
</span><span class="boring">                String::from("dem"),
</span><span class="boring">                String::from("Future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("Erhalten: '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Weitere"),
</span><span class="boring">                String::from("Nachrichten"),
</span><span class="boring">                String::from("für"),
</span><span class="boring">                String::from("dich"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

<span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-17: Beheben der restlichen Typfehler durch
Verwenden einer expliziten Typdeklaration</span></p>
<p>Diese Typdeklaration ist ein wenig kompliziert, also gehen wir sie Stück für
Stück durch:</p>
<ol>
<li>Der innerste Typ ist das Future selbst. Wir geben explizit an, dass das
Ergebnis des Future der Einheitstyp <code>()</code> ist, indem wir <code>Future&lt;Output = ()&gt;</code> schreiben.</li>
<li>Dann annotieren wir das Merkmal mit <code>dyn</code>, um es als dynamisch zu
kennzeichnen.</li>
<li>Die gesamte Merkmals-Referenz wird in eine <code>Box</code> gepackt.</li>
<li>Schließlich geben wir explizit an, dass <code>futures</code> ein <code>Vec</code> ist, der diese
Elemente enthält.</li>
</ol>
<p>Das hat bereits einen großen Unterschied gemacht. Wenn wir nun den Compiler
laufen lassen, bekommen wir nur noch die <code>Unpin</code>-Fehler. Obwohl es drei davon
gibt, ist ihr Inhalt sehr ähnlich.</p>
<pre><code class="language-text">error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
   --&gt; src/main.rs:49:24
    |
49  |         trpl::join_all(futures).await;
    |         -------------- ^^^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
    |         |
    |         required by a bound introduced by this call
    |
    = note: consider using the `pin!` macro
            consider using `Box::pin` if you need to access the pinned value outside of the current scope
    = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `join_all`
   --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:105:14
    |
102 | pub fn join_all&lt;I&gt;(iter: I) -&gt; JoinAll&lt;I::Item&gt;
    |        -------- required by a bound in this function
...
105 |     I::Item: Future,
    |              ^^^^^^ required by this bound in `join_all`

error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
  --&gt; src/main.rs:49:9
   |
49 |         trpl::join_all(futures).await;
   |         ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
  --&gt; src/main.rs:49:33
   |
49 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `async_await` (bin "async_await") due to 3 previous errors
</code></pre>
<p>Das ist <em>viel</em> zu verdauen, also lass uns das auseinandernehmen. Der erste Teil
der Meldung sagt uns, dass der erste asynchrone Block (<code>src/main.rs:8:23:  20:10</code>) das Merkmal <code>Unpin</code> nicht implementiert, und schlägt vor, <code>pin!</code> oder
<code>Box::pin</code> zu verwenden, um das Problem zu lösen. Später in diesem Kapitel
werden wir uns mit weiteren Details zu <code>Pin</code> und <code>Unpin</code> beschäftigen. Für den
Moment können wir jedoch einfach dem Rat des Compilers folgen, um uns aus der
Patsche zu helfen! In Codeblock 17-18 beginnen wir damit, <code>Pin</code> von <code>std::pin</code>
zu importieren. Danach aktualisieren wir die Typ-Annotation für <code>futures</code>,
indem jede <code>Box</code> mit einem <code>Pin</code> umschlossen wird. Schließlich rufen wir
<code>Box::pin</code> bei den Futures auf.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::{pin, Pin},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = pin!(async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Hallo"),
</span><span class="boring">                String::from("aus"),
</span><span class="boring">                String::from("dem"),
</span><span class="boring">                String::from("Future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let rx_fut = pin!(async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("Erhalten: '{value}'");
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let tx_fut = pin!(async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Weitere"),
</span><span class="boring">                String::from("Nachrichten"),
</span><span class="boring">                String::from("für"),
</span><span class="boring">                String::from("dich"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span>        let futures: Vec&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;&gt; =
            vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];

<span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-18: Verwenden von <code>Pin</code> und <code>Box::pin</code>, um
den Typ <code>Vec</code> zu korrigieren</span></p>
<p>Wenn wir dies kompilieren und ausführen, erhalten wir endlich die erhoffte Ausgabe:</p>
<pre><code class="language-text">Erhalten: 'Hallo'
Erhalten: 'Weitere'
Erhalten: 'aus'
Erhalten: 'Nachrichten'
Erhalten: 'dem'
Erhalten: 'für'
Erhalten: 'Future'
Erhalten: 'dich'
</code></pre>
<p>Puh!</p>
<p>Wir können hier noch ein bisschen weiterforschen. Zum einen bringt die
Verwendung von <code>Pin&lt;Box&lt;T&gt;&gt;</code> ein wenig zusätzlichen Overhead mit sich, da wir
die Futures mit <code>Box</code> auf den Haldenspeicher (heap) legen – und das tun
wir nur, um die Typen in eine Kollektion zu bringen. Wir <em>brauchen</em> die
Haldenspeicher-Allokation eigentlich nicht: Diese Futures sind lokal in dieser
speziellen Funktion. Wie zuvor erwähnt, ist <code>Pin</code> selbst ein Wrapper-Typ,
sodass wir den Vorteil haben, einen einzigen Typ in <code>Vec</code> zu haben – der
ursprüngliche Grund, warum wir uns für <code>Box</code> entschieden haben – ohne
eine Haldenspeicher-Allokation durchzuführen. Wir können <code>Pin</code> direkt mit jedem
Future verwenden, indem wir das Makro <code>std::pin::pin</code> benutzen.</p>
<p>Wir müssen jedoch immer noch explizit den Typ der <code>Pin</code>-Referenz angeben, da
Rust sonst nicht weiß, wie es diese als dynamische Merkmals-Objekte
interpretieren soll. Wir fügen daher <code>pin</code> zu unserer Importliste von
<code>std::pin</code> hinzu. Dann können wir <code>pin!</code> für jedes Future aufrufen und
definieren <code>futures</code> als <code>Vec</code>, der veränderbare Referenzen mit <code>pin</code> auf den
dynamischen Future-Typ enthält, wie in Codeblock 17-19 zu sehen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::{pin, Pin},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span>        let tx1_fut = pin!(async move {
            // --abschneiden--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Hallo"),
</span><span class="boring">                String::from("aus"),
</span><span class="boring">                String::from("dem"),
</span><span class="boring">                String::from("Future"),
</span><span class="boring">             ];
</span><span class="boring">
</span><span class="boring">             for val in vals {
</span><span class="boring">                 tx1.send(val).unwrap();
</span><span class="boring">                 trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">             }
</span>        });

        let rx_fut = pin!(async {
            // --abschneiden--
<span class="boring">             while let Some(value) = rx.recv().await {
</span><span class="boring">                 println!("Erhalten: '{value}'");
</span><span class="boring">             }
</span>        });

        let tx_fut = pin!(async move {
            // --abschneiden--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Weitere"),
</span><span class="boring">                String::from("Nachrichten"),
</span><span class="boring">                String::from("für"),
</span><span class="boring">                String::from("dich"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let futures: Vec&lt;Pin&lt;&amp;mut dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![tx1_fut, rx_fut, tx_fut];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-19: Direktes Verwenden von <code>Pin</code> mit dem
Makro <code>pin!</code> zum Vermeiden unnötiger Haldenspeicher-Allokation</span></p>
<p>Wir sind so weit gekommen, indem wir die Tatsache ignoriert haben, dass wir
verschiedene <code>Output</code>-Typen haben könnten. In Codeblock 17-20 zum Beispiel
implementiert das anonyme Future für <code>a</code> den Typ <code>Future&lt;Output = u32&gt;</code>, das
anonyme Future für <code>b</code> implementiert <code>Future&lt;Output = &amp;str&gt;</code>, und das anonyme
Future für <code>c</code> implementiert <code>Future&lt;Output = bool&gt;</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async { 1u32 };
        let b = async { "Hallo!" };
        let c = async { true };

        let (a_result, b_result, c_result) = trpl::join!(a, b, c);
        println!("{a_result}, {b_result}, {c_result}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-20: Drei Futures mit unterschiedlichen
Typen</span></p>
<p>Wir können <code>trpl::join!</code> verwenden, um auf sie zu warten, weil es uns erlaubt,
mehrere Future-Typen zu übergeben und ein Tupel dieser Typen zu erzeugen. Wir
können <em>nicht</em> <code>trpl::join_all</code> verwenden, weil es voraussetzt, dass die
übergebenen Futures alle denselben Typ haben. Erinnere dich, dieser Fehler war
es, der uns zu diesem Abenteuer mit <code>Pin</code> gebracht hat!</p>
<p>Dies ist eine grundlegende Abwägung: Wir können entweder eine dynamische Anzahl
von Futures mit <code>join_all</code> behandeln, solange sie alle denselben Typ haben,
oder wir können eine bestimmte Anzahl von Futures mit den Funktionen <code>join</code>
oder dem Makro <code>join!</code> behandeln, auch wenn sie unterschiedliche Typen haben.
Das ist das Gleiche wie mit jedem anderen Typ in Rust. Futures sind nichts
Besonderes, auch wenn wir eine nette Syntax für die Arbeit mit ihnen haben, und
das ist eine gute Sache.</p>
<h3 id="future-wettlauf"><a class="header" href="#future-wettlauf">Future-Wettlauf</a></h3>
<p>Wenn wir auf Futures mit <code>join</code> warten, müssen <em>alle</em> von ihnen beendet sein,
bevor wir weitermachen. Manchmal müssen jedoch nur <em>einige</em> Futures fertig
sein, bevor wir weitermachen – ähnlich wie bei einem Wettlauf zwischen
zwei Futures.</p>
<p>In Codeblock 17-21 verwenden wir wieder <code>trpl::race</code>, um zwei Futures <code>slow</code>
und <code>fast</code> gegeneinander antreten zu lassen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            println!("'slow' gestartet.");
            trpl::sleep(Duration::from_millis(100)).await;
            println!("'slow' beendet.");
        };

        let fast = async {
            println!("'fast' gestartet.");
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'fast' beendet.");
        };

        trpl::race(slow, fast).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-21: Verwenden von <code>race</code>, um das Ergebnis
des zuerst beendeten Future zu erhalten</span></p>
<p>Jedes Future gibt eine Nachricht aus, wenn es startet, pausiert für eine
gewisse Zeit, indem es <code>sleep</code> aufruft und wartet, und gibt dann eine weitere
Nachricht aus, wenn es fertig ist. Dann übergeben wir <code>slow</code> und <code>fast</code> an
<code>trpl::race</code> und warten, bis eines von ihnen fertig ist. (Das Ergebnis ist
nicht allzu überraschend: <code>fast</code> gewinnt!) Anders als bei der Verwendung von
<code>race</code> in <a href="ch17-01-futures-and-syntax.html#unser-erstes-asynchrones-programm">„Unser erstes asynchrones Programm“</a> ignorieren wir
hier einfach die <code>Either</code>-Instanz, die es zurückgibt, da das gesamte
interessante Verhalten im Rumpf der asynchronen Blöcke stattfindet.</p>
<p>Beachte, dass sich die Reihenfolge der „gestarteten“ Meldungen ändert, wenn du
die Reihenfolge der Argumente in <code>race</code> umdrehst, obwohl das Future <code>fast</code>
immer zuerst fertig wird. Das liegt daran, dass die Implementierung dieser
speziellen Funktion <code>race</code> nicht fair ist. Sie führt die als Argumente
übergebenen Futures immer in der Reihenfolge aus, in der sie übergeben werden.
Andere Implementierungen sind <em>fair</em> und wählen zufällig, welches Future zuerst
abgefragt wird. Unabhängig davon, ob die Implementierung von <code>race</code> fair ist,
wird <em>eines</em> der Futures bis zum ersten <code>await</code> in seinem Rumpf laufen, bevor
eine andere Aufgabe beginnen kann.</p>
<p>Erinnere dich an <a href="ch17-01-futures-and-syntax.html#unser-erstes-asynchrones-programm">„Unser erstes asynchrones Programm“</a>, bei dem
Rust der Laufzeitumgebung an jedem await-Punkt die Möglichkeit gibt, die
Aufgabe anzuhalten und zu einer anderen zu wechseln, wenn das zu erwartende
Future nicht fertig ist. Der umgekehrte Fall gilt ebenfalls: Rust hält
asynchrone Blöcke <em>nur</em> an einem await-Punkt an und übergibt die Kontrolle der
Laufzeitumgebung. Alles zwischen den await-Punkten ist synchron.</p>
<p>Das heißt, wenn du eine Menge Arbeit in einem asynchronen Block ohne einen
await-Punkt erledigst, blockiert dieses Future alle anderen Futures an ihrem
Fortschritt. Dies wird manchmal auch als „ein Future lässt ein anderes Future
verhungern“ bezeichnet. In manchen Fällen mag das keine große Sache sein. Wenn
du jedoch eine teure Initialisierung oder eine langwierige Arbeit durchführst
oder wenn du ein Future hast, das eine bestimmte Aufgabe auf unbestimmte Zeit
ausführt, musst du darüber nachdenken, wann und wo du die Kontrolle an die
Laufzeitumgebung abgibst.</p>
<p>Aber <em>wie</em> würdest du in diesen Fällen die Kontrolle an die Laufzeitumgebung
abgeben?</p>
<h3 id="abgeben-yielding-der-kontrolle-an-die-laufzeitumgebung"><a class="header" href="#abgeben-yielding-der-kontrolle-an-die-laufzeitumgebung">Abgeben (yielding) der Kontrolle an die Laufzeitumgebung</a></h3>
<p>Simulieren wir einen langlaufenden Ablauf. Codeblock 17-22 führt eine Funktion
<code>slow</code> ein.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        // Wir werden hier `slow` aufrufen
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ist für {ms} ms gelaufen");
}</code></pre></pre>
<p><span class="caption">Codeblock 17-22: Verwenden von <code>thread::sleep</code> zum
Simulieren langsamer Abläufe</span></p>
<p>Dieser Code verwendet <code>std::thread::sleep</code> anstelle von <code>trpl::sleep</code>, sodass
der Aufruf von <code>slow</code> den aktuellen Strang für eine bestimmte Anzahl von
Millisekunden blockiert. Wir können <code>slow</code> benutzen, um reale Abläufe zu
simulieren, die sowohl langwierig als auch blockierend sind.</p>
<p>In Codeblock 17-23 verwenden wir <code>slow</code>, um diese Art von CPU-gebundener Arbeit
in einem Paar von Futures zu emulieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' gestartet.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a' beendet.");
        };

        let b = async {
            println!("'b' gestartet.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' beendet.");
        };

        trpl::race(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ist für {ms} ms gelaufen");
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-23: Verwenden von <code>thread::sleep</code> zum
Simulieren langsamer Abläufe</span></p>
<p>Zunächst gibt jedes Future die Kontrolle erst nach einer Reihe von langsamen
Abläufen an die Laufzeitumgebung zurück. Wenn du diesen Code ausführst,
erhältst du diese Ausgabe:</p>
<pre><code class="language-text">'a' gestartet.
'a' ist für 30 ms gelaufen
'a' ist für 10 ms gelaufen
'a' ist für 20 ms gelaufen
'b' gestartet.
'b' ist für 75 ms gelaufen
'b' ist für 10 ms gelaufen
'b' ist für 15 ms gelaufen
'b' ist für 350 ms gelaufen
'a' beendet.
</code></pre>
<p>Wie in unserem früheren Beispiel wird <code>race</code> immer noch beendet, sobald <code>a</code>
fertig ist. Es gibt jedoch keine Abwechslung zwischen den beiden Futures. Das
Future <code>a</code> erledigt seine gesamte Arbeit, bis auf den Aufruf von <code>trpl::sleep</code>
gewartet wird, dann erledigt das Future <code>b</code> seine gesamte Arbeit, bis auch dort
auf den Aufruf von <code>trpl::sleep</code> gewartet wird, und schließlich wird das Future
<code>a</code> beendet. Damit beide Futures während ihrer langsamen Vorgänge Fortschritte
machen können, brauchen wir await-Punkte, damit wir die Kontrolle an die
Laufzeitumgebung abgeben können. Das heißt, wir brauchen etwas, auf das wir
warten können!</p>
<p>Wir können diese Art der Übergabe bereits in Codeblock 17-23 sehen: Wenn wir
<code>trpl::sleep</code> am Ende des Futures <code>a</code> entfernen, würde es fertig werden, ohne
dass das Future <code>b</code> <em>überhaupt</em> läuft. Versuchen wir, die Funktion <code>sleep</code> als
Ausgangspunkt zu verwenden, um Operationen am Fortschritt zu hindern, wie in
Codeblock 17-24 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a' gestartet.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a' beendet.");
        };

        let b = async {
            println!("'b' gestartet.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 35);
            trpl::sleep(one_ms).await;
            println!("'b' beendet.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ist für {ms} ms gelaufen");
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-24: Verwenden von <code>sleep</code>, um Vorgänge zu
unterbrechen</span></p>
<p>In Codeblock 17-24 fügen wir Aufrufe von <code>trpl::sleep</code> mit await-Punkten
zwischen den Aufrufen von <code>slow</code> ein. Nun wechseln die beiden Futures ihre
Arbeit ab:</p>
<pre><code class="language-text">'a' gestartet.
'a' ist für 30 ms gelaufen
'b' gestartet.
'b' ist für 75 ms gelaufen
'a' ist für 10 ms gelaufen
'b' ist für 10 ms gelaufen
'a' ist für 20 ms gelaufen
'b' ist für 15 ms gelaufen
'a' beendet.
</code></pre>
<p>Das Future <code>a</code> läuft noch eine Weile, bevor es die Kontrolle an <code>b</code> abgibt,
weil es <code>slow</code> aufruft, bevor es <code>trpl::sleep</code> aufruft. Aber danach wechseln
sich die Futures jedes Mal ab, wenn eines von ihnen einen await-Punkt erreicht.
In diesem Fall haben wir das nach jedem Aufruf von <code>slow</code> gemacht, aber wir
könnten die Arbeit so aufteilen, wie es für uns am sinnvollsten ist.</p>
<p>Wir wollen hier aber nicht wirklich <em>schlafen</em>: Wir wollen so schnell wie
möglich vorankommen. Wir müssen nur die Kontrolle an die Laufzeitumgebung
abgeben. Das können wir direkt tun, indem wir die Funktion <code>yield_now</code>
verwenden. In Codeblock 17-25 ersetzen wir all diese Aufrufe von <code>sleep</code> durch
<code>yield_now</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' gestartet.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' beendet.");
        };

        let b = async {
            println!("'b' gestartet.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 35);
            trpl::yield_now().await;
            println!("'b' beendet.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring"># fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ist für {ms} ms gelaufen");
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-25: Verwenden von <code>yield_now</code>, um Vorgänge
anzuhalten</span></p>
<p>Dieser Code ist sowohl klarer als auch wesentlich schneller als <code>sleep</code>, weil
Zeitgeber wie <code>sleep</code> oft Grenzen haben, wie granular sie sein können. Die
Version von <code>sleep</code>, die wir benutzen, wird zum Beispiel immer mindestens eine
Millisekunde lang schlafen, selbst wenn wir ihr eine <code>Duration</code> von einer
Nanosekunde übergeben. Nochmals, moderne Computer sind <em>schnell</em>: Sie können
eine Menge in einer Millisekunde tun!</p>
<p>Du kannst dich selbst davon überzeugen, indem du einen kleinen Benchmark wie in
Codeblock 17-26 erstellst. (Dies ist kein besonders strenger Weg, um
Leistungstests durchzuführen, aber es reicht aus, um den Unterschied hier zu
zeigen.)</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ns = Duration::from_nanos(1);
        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::sleep(one_ns).await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'sleep'-Version beendet nach {} Sekunden.",
            time.as_secs_f32()
        );

        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::yield_now().await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'yield'-Version beendet nach {} Sekunden.",
            time.as_secs_f32()
        );
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-26: Vergleich der Performanz von <code>sleep</code> und
<code>yield_now</code></span></p>
<p>Hier überspringen wir die Statusausgabe, übergeben eine <code>Duration</code> von einer
Nanosekunde an <code>trpl::sleep</code> und lassen jedes Future für sich laufen, ohne
zwischen den Futures zu wechseln. Dann lassen wir 1.000 Iterationen laufen und
sehen, wie lange das Future mit <code>trpl::sleep</code> im Vergleich zum Future mit
<code>trpl::yield_now</code> braucht.</p>
<p>Die Version mit <code>yield_now</code> ist <em>viel</em> schneller!</p>
<p>Das bedeutet, dass async sogar für rechengebundene Aufgaben nützlich sein kann,
je nachdem, was dein Programm sonst noch tut, weil es ein nützliches Werkzeug
für die Strukturierung der Beziehungen zwischen verschiedenen Teilen des
Programms ist. Es handelt sich um eine Form von <em>kooperativem Multitasking</em>,
bei dem jedes Future die Möglichkeit hat zu bestimmen, wann es die Kontrolle
mittels await-Punkte abgibt. Jedes Future hat daher auch die Verantwortung, ein
zu langes Blockieren zu vermeiden. In einigen Rust-basierten, eingebetteten
Betriebssystemen ist dies die <em>einzige</em> Art von Multitasking!</p>
<p>In der Praxis wirst du natürlich nicht nach jeder einzelnen Zeile
einen await-Punkt einfügen. Obwohl die Abgabe der Kontrolle auf diese Weise
relativ kostengünstig ist, ist sie nicht kostenlos! In vielen Fällen kann der
Versuch, eine rechengebundene Aufgabe zu unterbrechen, sie erheblich langsamer
machen, sodass es manchmal für die <em>gesamte</em> Performanz besser ist, eine
Operation kurzzeitig zu blockieren. Du solltest immer messen, um die
tatsächlichen Leistungsengpässe deines Codes zu finden. Die zugrundeliegende
Dynamik solltest du immer im Hinterkopf haben, wenn du feststellst, dass viele
Vorgänge seriell ausgeführt werden, von denen du erwartet hast, dass sie
nebenläufig ausgeführt werden!</p>
<h3 id="eigene-async-abstraktionen-erstellen"><a class="header" href="#eigene-async-abstraktionen-erstellen">Eigene Async-Abstraktionen erstellen</a></h3>
<p>Wir können Futures auch kombinieren, um neue Muster zu schaffen. Zum Beispiel
können wir eine Funktion <code>timeout</code> mit bereits vorhandenen asynchronen
Bausteinen erstellen. Wenn wir fertig sind, ist das Ergebnis ein weiterer
Baustein, mit dem wir weitere asynchrone Abstraktionen erstellen können.</p>
<p>Codeblock 17-27 zeigt die erwartete Arbeitsweise von <code>timeout</code> bei einem
langsamen Future.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            trpl::sleep(Duration::from_millis(100)).await;
            "Bin fertig!"
        };

        match timeout(slow, Duration::from_millis(10)).await {
            Ok(message) =&gt; println!("Erfolgreich mit '{message}'"),
            Err(duration) =&gt; {
                println!("Fehlgeschlagen nach {} Sekunden", duration.as_secs())
            }
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-27: Verwendeng unseres imaginären <code>timeout</code>,
um eine langsame Operation mit einem Zeitlimit durchzuführen</span></p>
<p>Lass es uns implementieren! Denken wir zunächst über die API für <code>timeout</code>
nach:</p>
<ul>
<li>Sie muss selbst eine asynchrone Funktion sein, damit wir auf sie warten
können.</li>
<li>Ihr erster Parameter sollte ein ausführbares Future sein. Wir können sie
generisch machen, damit sie mit jedem Future funktioniert.</li>
<li>Der zweite Parameter ist die maximale Wartezeit. Wenn wir eine <code>Duration</code>
verwenden, wird es einfach sein, ihn an <code>trpl::sleep</code> weiterzureichen.</li>
<li>Es sollte ein <code>Result</code> zurückgeben. Wenn das Future erfolgreich beendet wird,
ist das <code>Result</code> ein <code>Ok</code> mit dem vom Future erzeugten Wert. Wenn das
Zeitlimit zuerst erreicht wird, wird <code>Result</code> ein <code>Err</code> mit der Wartedauer
sein.</li>
</ul>
<p>Codeblock 17-28 zeigt diese Deklaration.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "Bin fertig"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_millis(10)).await {
</span><span class="boring">            Ok(message) =&gt; println!("Erfolgreich mit '{message}'"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!("Fehlgeschlagen nach {} Sekunden", duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    // Hier kommt die Implementierung hin
}</code></pre>
<p><span class="caption">Codeblock 17-28: Definieren der Signatur von
<code>timeout</code></span></p>
<p>Damit sind unsere Ziele für die Typen erfüllt. Denken wir nun über das
<em>Verhalten</em> nach, das wir brauchen: Wir wollen die Dauer des übergebenen Future
überwachen. Wir können mit <code>trpl::sleep</code> einen Timer aus der Dauer machen und
<code>trpl::race</code> verwenden, um mit diesem Timer das übergebene Future zu
überwachen.</p>
<p>Wir wissen auch, dass <code>race</code> nicht fair ist und die Argumente in der
Reihenfolge abfragt, in der sie übergeben werden. Daher übergeben wir
<code>future_to_try</code> zuerst an <code>race</code>, sodass es eine Chance bekommt, auch dann
fertig zu werden, wenn <code>max_time</code> eine sehr kurze Dauer hat. Wenn
<code>future_to_try</code> zuerst fertig wird, wird <code>race</code> den Wert <code>Left</code> mit der
Ausgabe von <code>future</code> zurückgeben. Wenn <code>timer</code> zuerst fertig wird, gibt
<code>race</code> den Wert <code>Right</code> mit der Ausgabe des Timers von <code>()</code> zurück.</p>
<p>In Codeblock 17-29 werten wir das Ergebnis des Wartens auf <code>trpl::race</code> aus.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span>use trpl::Either;

// --abschneiden--

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Bin fertig"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) =&gt; println!("Erfolgreich mit '{message}'"),
            Err(duration) =&gt; {
                println!("Fehlgeschlagen nach {} Sekunden", duration.as_secs())
            }
        }
    });
}

async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    match trpl::race(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) =&gt; Ok(output),
        Either::Right(_) =&gt; Err(max_time),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-29: Definieren von <code>timeout</code> mit <code>race</code> und
<code>sleep</code></span></p>
<p>Wenn <code>Future_to_try</code> erfolgreich war und wir <code>Left(output)</code> erhalten, geben wir
<code>Ok(output)</code> zurück. Wenn stattdessen der Sleep-Timer abgelaufen ist und wir
<code>Right(())</code> erhalten, ignorieren wir der Wert <code>()</code> mit <code>_</code> und geben
stattdessen <code>Err(max_time)</code> zurück.</p>
<p>Damit haben wir ein funktionierendes <code>timeout</code>, das aus zwei anderen
asynchronen Helfern besteht. Wenn wir unseren Code ausführen, wird er als
Fehlermeldung nach dem Timeout ausgeben:</p>
<pre><code class="language-text">Fehlgeschlagen nach 2 Sekunden
</code></pre>
<p>Da Futures aus anderen Futures zusammengesetzt werden können, lassen sich mit
kleineren asynchronen Bausteinen wirklich leistungsfähige Werkzeuge erstellen.
So kannst du beispielsweise mit demselben Ansatz Zeitüberschreitungen mit
Wiederholungen kombinieren und diese wiederum für Operationen wie
Netzwerkaufrufe verwenden – eines der Beispiele vom Anfang des Kapitels!</p>
<p>In der Praxis wirst du normalerweise direkt mit <code>async</code> und <code>await</code> arbeiten
und in zweiter Linie mit Funktionen und Makros wie <code>join</code>, <code>join_all</code>, <code>race</code>
und so weiter. Du wirst nur ab und zu zu <code>pin</code> greifen müssen, um Futures mit
diesen APIs zu benutzen.</p>
<p>Wir haben nun eine Reihe von Möglichkeiten gesehen, mit mehreren Futures
gleichzeitig zu arbeiten. Als Nächstes werden wir uns mit Hilfe von <em>Strömen</em>
(streams) ansehen, wie wir mit mehreren Futures in einer zeitlichen Reihenfolge
arbeiten können. Vorher solltest du aber noch ein paar Dinge beachten:</p>
<ul>
<li>
<p>Wir haben einen <code>Vec</code> mit <code>join_all</code> verwendet, um zu warten, bis alle
Futures in einer Gruppe beendet sind. Wie könnte man stattdessen einen
<code>Vec</code> verwenden, um eine Gruppe von Futures nacheinander zu verarbeiten?
Was sind die Nachteile dieser Vorgehensweise?</p>
</li>
<li>
<p>Wirf einen Blick auf den Typ <code>futures::stream::FuturesUnordered</code> aus der
Kiste <code>futures</code>. Inwiefern unterscheidet sich die Verwendung dieses Typs von
der Verwendung eines <code>Vec</code>? (Mach dir keine Sorgen über die Tatsache, dass es
aus dem <code>stream</code>-Teil der Kiste stammt; es funktioniert problemlos mit jeder
Kollektion von Futures.)</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ströme-streams-sequenz-von-futures"><a class="header" href="#ströme-streams-sequenz-von-futures">Ströme (streams): Sequenz von Futures</a></h2>
<p>Bislang haben wir uns in diesem Kapitel hauptsächlich mit einzelnen Futures
beschäftigt. Die einzige große Ausnahme war der von uns verwendete asynchrone
Kanal. Erinnere dich daran, wie wir den Empfänger unseres asynchronen Kanals
weiter oben in diesem Kapitel in <a href="ch17-02-concurrency-with-async.html#hochz%C3%A4hlen-in-zwei-aufgaben-mit-nachrichten%C3%BCbermittlung">„Hochzählen in zwei Aufgaben mit
Nachrichtenübermittlung“</a> verwendet haben. Die asynchrone
Methode <code>recv</code> erzeugt eine Sequenz von Elementen. Dies ist ein Beispiel eines
viel allgemeineren Musters, bekannt als <em>Strom</em> (stream).</p>
<p>Wir haben eine Sequenz von Elementen in Kapitel 13 gesehen, als das Merkmal
<code>Iterator</code> im Abschnitt <a href="ch13-02-iterators.html#das-merkmal-trait-iterator-und-die-methode-next">„Das Merkmal (trait) <code>Iterator</code> und die Methode
<code>next</code>“</a> betrachtet haben. Es gibt jedoch zwei Unterschiede zwischen
Iteratoren und dem asynchronen Kanalempfänger. Der erste ist die Zeit:
Iteratoren sind synchron, während der Kanalempfänger asynchron ist. Der zweite
ist die API. Wenn wir direkt mit einem <code>Iterator</code> arbeiten, rufen wir seine
synchrone Methode <code>next</code> auf. Mit dem Strom <code>trpl::Receiver</code> rufen wir
stattdessen die asynchrone Methode <code>recv</code> auf. Ansonsten sind sich diese APIs
sehr ähnlich, und diese Ähnlichkeit ist kein Zufall. Ein Strom ist wie eine
asynchrone Form der Iteration. Während <code>trpl::Receiver</code> jedoch speziell auf den
Empfang von Nachrichten wartet, ist die allgemeine Strom-API viel breiter
angelegt: Sie liefert das nächste Element auf die gleiche Weise wie <code>Iterator</code>,
aber asynchron.</p>
<p>Die Ähnlichkeit zwischen Iteratoren und Strömen in Rust bedeutet, dass wir aus
jedem Iterator einen Strom erzeugen können. Wie bei einem Iterator können wir
mit einem Strom arbeiten, indem wir seine Methode <code>next</code> aufrufen und dann auf
die Ausgabe warten, wie in Codeblock 17-30.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("Der Wert war: {value}");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-30: Erstellen eines Stroms aus einem
Iterator und Ausgeben seiner Werte</span></p>
<p>Wir beginnen mit einem Array von Zahlen, das wir in einen Iterator umwandeln
und dann <code>map</code> aufrufen, um alle Werte zu verdoppeln. Dann wandeln wir den
Iterator mit der Funktion <code>trpl::stream_from_iter</code> in einen Strom um.
Schließlich durchlaufen wir mit der <code>while let</code>-Schleife die Elemente im
Strom.</p>
<p>Wenn wir versuchen, den Code auszuführen, lässt er sich leider nicht
kompilieren. Stattdessen meldet der Compiler, dass keine Methode <code>next</code>
verfügbar ist.</p>
<pre><code class="language-console">error[E0599]: no method named `next` found for struct `Iter` in the current scope
  --&gt; src/main.rs:10:40
   |
10 |         while let Some(value) = stream.next().await {
   |                                        ^^^^
   |
   = note: the full type name has been written to 'file:///projects/async_await/target/debug/deps/async_await-9de943556a6001b8.long-type-1281356139287206597.txt'
   = note: consider using `--verbose` to print the full type name to the console
   = help: items from traits can only be used if the trait is in scope
help: the following traits which provide `next` are implemented but not in scope; perhaps you want to import one of them
   |
1  + use crate::trpl::StreamExt;
   |
1  + use futures_util::stream::stream::StreamExt;
   |
1  + use std::iter::Iterator;
   |
1  + use std::str::pattern::Searcher;
   |
help: there is a method `try_next` with a similar name
   |
10 |         while let Some(value) = stream.try_next().await {
   |                                        ~~~~~~~~
</code></pre>
<p>Wie diese Ausgabe erklärt, liegt der Grund für den Compilerfehler darin, dass
wir das richtige Merkmal im Gültigkeitsbereich benötigen, um die Methode <code>next</code>
verwenden zu können. In Anbetracht der bisherigen Diskussion könnte man
erwarten, dass es sich um das Merkmal <code>Stream</code> handelt, aber ist das Merkmal
<code>StreamExt</code>. <code>Ext</code> steht hier für „extension“ (engl. Erweiterung): Dies ist
eine gängige Vorgehensweise in der Rust-Gemeinschaft, um ein Merkmal mit einem
anderen zu erweitern.</p>
<p>Wir werden die Merkmale <code>Stream</code> und <code>StreamExt</code> am Ende des Kapitels etwas
genauer erklären, aber für den Moment musst du nur wissen, dass das Merkmal
<code>Stream</code> eine Low-Level-Schnittstelle definiert, die effektiv die Merkmale
<code>Iterator</code> und <code>Future</code> kombiniert. <code>StreamExt</code> stellt eine Reihe von APIs auf
höherer Ebene zur Verfügung, darunter die Methode <code>next</code> sowie andere
Hilfsmethoden, die denen des Merkmals <code>Iterator</code> ähneln. <code>Stream</code> und
<code>StreamExt</code> sind noch nicht Teil der Standardbibliothek von Rust, aber die
meisten Ökosystemkisten verwenden dieselbe Definition.</p>
<p>Die Behebung des Compilerfehlers besteht darin, eine <code>use</code>-Anweisung für
<code>trpl::StreamExt</code> hinzuzufügen, wie in Codeblock 17-31.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("Der Wert war: {value}");
        }
    });
}</code></pre></pre>
<p><span class="caption">Codeblock 17-31: Erfolgreiche Verwendung eines Iterators
als Grundlage für einen Strom</span></p>
<p>Mit all diesen Teilen zusammen funktioniert der Code so, wie wir es wollen!
Außerdem können wir jetzt, da wir <code>StreamExt</code> im Gültigkeitsbereich haben, alle
seine Hilfsmethoden verwenden, genau wie bei Iteratoren. In Codeblock 17-32
verwenden wir zum Beispiel die Methode <code>filter</code>, um alles außer Vielfache von
drei und fünf herauszufiltern.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = 1..101;
        let iter = values.map(|n| n * 2);
        let stream = trpl::stream_from_iter(iter);

        let mut filtered =
            stream.filter(|value| value % 3 == 0 || value % 5 == 0);

        while let Some(value) = filtered.next().await {
            println!("Der Wert war: {value}");
        }
    });
}</code></pre></pre>
<p><span class="caption">Codeblock 17-32: Filtern eines Stroms mit der Methode
<code>StreamExt::filter</code></span></p>
<p>Das ist natürlich nicht sehr interessant, da wir das auch mit normalen
Iteratoren und ganz ohne asynchronen Code machen könnten. Schauen wir uns an,
was für Ströme einzigartig sind.</p>
<h3 id="komposition-von-strömen"><a class="header" href="#komposition-von-strömen">Komposition von Strömen</a></h3>
<p>Viele Konzepte werden auf natürliche Weise als Datenströme dargestellt:
Elemente, die in einer Warteschlange verfügbar werden, Datenpakete, die
inkrementell aus dem Dateisystem eingelesen werden, wenn der gesamte Datensatz
zu groß für den Speicher des Computers ist, oder Daten, die im Laufe der Zeit
über das Netz ankommen. Da es sich bei Strömen um Futures handelt, können wir
sie auch mit jeder anderen Art von Futures verwenden und sie auf interessante
Weise kombinieren. So können wir beispielsweise Ereignisse stapeln, um zu viele
Netzwerkaufrufe zu vermeiden, Zeitüberschreitungen für Sequenzen lang laufender
Vorgänge festlegen oder Ereignisse der Benutzeroberfläche drosseln, um unnötige
Arbeit zu vermeiden.</p>
<p>Beginnen wir damit, einen kleinen Nachrichtenstrom zu erstellen, als Ersatz für
einen Datenstrom, den wir von einer WebSocket oder einem anderen
Echtzeit-Kommunikationsprotokoll sehen könnten, wie in Codeblock 17-33 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span>use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages = get_messages();

        while let Some(message) = messages.next().await {
            println!("{message}");
        }
    });
}

fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
    for message in messages {
        tx.send(format!("Nachricht: '{message}'")).unwrap();
    }

    ReceiverStream::new(rx)
}</code></pre></pre>
<p><span class="caption">Codeblock 17-33: Verwenden des Empfängers <code>rx</code> als
<code>ReceiverStream</code></span></p>
<p>Zunächst erstellen wir eine Funktion namens <code>get_messages</code>, die <code>impl  Stream&lt;Item = String&gt;</code> zurückgibt. Für die Implementierung erstellen wir einen
asynchronen Kanal, iterieren über die ersten 10 Buchstaben des englischen
Alphabets und senden sie über den Kanal.</p>
<p>Wir verwenden auch einen neuen Typ: <code>ReceiverStream</code>, der den Empfänger <code>rx</code>
aus dem <code>trpl::channel</code> in einen <code>Stream</code> mit einer Methode <code>next</code> umwandelt.
Zurück in <code>main</code> benutzen wir eine <code>while let</code>-Schleife, um alle Nachrichten
aus dem Strom auszugeben.</p>
<p>Wenn wir diesen Code ausführen, erhalten wir genau die Ergebnisse, die wir
erwarten würden:</p>
<pre><code class="language-text">Nachricht: 'a'
Nachricht: 'b'
Nachricht: 'c'
Nachricht: 'd'
Nachricht: 'e'
Nachricht: 'f'
Nachricht: 'g'
Nachricht: 'h'
Nachricht: 'i'
Nachricht: 'j'
</code></pre>
<p>Wir könnten dies erneut mit der regulären <code>Receiver</code>-API oder sogar mit der
regulären <code>Iterator</code>-API tun. Fügen wir also etwas hinzu, das Ströme erfordert:
Eine Zeitüberschreitung, die für jedes Element im Strom gilt, und eine
Verzögerung für die Elemente, die wir ausgeben, siehe Codeblock 17-34.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span>use std::{pin::pin, time::Duration};
use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages =
            pin!(get_messages().timeout(Duration::from_millis(200)));

        while let Some(result) = messages.next().await {
            match result {
                Ok(message) =&gt; println!("{message}"),
                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
            }
        }
    })
}
<span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">    for message in messages {
</span><span class="boring">        tx.send(format!("Nachricht: '{message}'")).unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-34: Verwenden der Methode
<code>StreamExt::timeout</code>, um ein Zeitlimit für die Elemente in einem Strom
festzulegen</span></p>
<p>Fügen wir zunächst mit der Methode <code>timeout</code>, die aus dem Merkmal <code>StreamExt</code>
stammt, eine Zeitüberschreitung zum Strom hinzu. Dann aktualisieren wir den
Rumpf der <code>while let</code>-Schleife, weil der Strom jetzt ein <code>Result</code> zurückgibt.
Die Variante <code>Ok</code> zeigt an, dass eine Nachricht rechtzeitig angekommen ist; die
Variante <code>Err</code> zeigt an, dass die Zeit abgelaufen ist, bevor irgendeine
Nachricht angekommen ist. Wir gleichen dieses Ergebnis mit <code>match</code> ab und geben
entweder die Nachricht oder eine Meldung über die Zeitüberschreitung aus.
Schließlich ist zu beachten, dass wir die Nachrichten anpinnen, nachdem wir die
Zeitüberschreitung auf sie angewendet haben, da die Timeout-Hilfsmethode einen
Strom erzeugt, der angeheftet werden muss, um abgefragt zu werden.</p>
<p>Da es jedoch keine Verzögerungen zwischen den Nachrichten gibt, ändert diese
Zeitüberschreitung das Verhalten des Programms nicht. Fügen wir den
Nachrichten, die wir senden, eine variable Verzögerung hinzu, wie in Codeblock
17-35 zu sehen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            tx.send(format!("Nachricht: '{message}'")).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<p><span class="caption">Codeblock 17-35: Senden von Nachrichten durch <code>tx</code> mit
einer asynchronen Verzögerung, ohne <code>get_messages</code> zu einer asynchronen
Funktion zu machen</span></p>
<p>In <code>get_messages</code> verwenden wir die Iterator-Methode <code>enumerate</code> mit dem Array
<code>messages</code>, sodass wir den Index jedes Elements, das wir senden, zusammen mit
dem Element selbst erhalten können. Dann wenden wir eine Verzögerung von 100
Millisekunden auf Elemente mit geradem Index und eine Verzögerung von 300
Millisekunden auf Elemente mit ungeradem Index an, um die verschiedenen
Verzögerungen zu simulieren, die wir in der realen Welt bei einem Strom von
Nachrichten sehen könnten. Da unser Timeout 200 Millisekunden beträgt, sollte
dies die Hälfte der Nachrichten betreffen.</p>
<p>Um zwischen den Nachrichten in der Funktion <code>get_messages</code> zu schlafen ohne zu
blockieren, müssen wir async verwenden. Allerdings können wir <code>get_messages</code>
selbst nicht zu einer asynchronen Funktion machen, denn dann würden wir ein
<code>Future&lt;Output = Stream&lt;Item = String&gt;&gt;</code> statt eines <code>Stream&lt;Item = String&gt;&gt;</code>
zurückgeben. Der Aufrufer müsste selbst auf <code>get_messages</code> warten, um Zugriff
auf den Strom zu erhalten. Aber denke daran: Alles in einem bestimmten Future
geschieht linear; Nebenläufigkeit geschieht <em>zwischen</em> den Futures. Das Warten
auf <code>get_messages</code> würde erfordern, dass es alle Nachrichten sendet,
einschließlich einer Pause zwischen dem Senden jeder Nachricht, bevor es den
Empfängerstrom zurückgibt. Infolgedessen wäre die Zeitüberschreitung nutzlos.
Es gäbe keine Verzögerungen im Strom selbst: Die Verzögerungen würden alle
auftreten, bevor der Strom überhaupt verfügbar wäre.</p>
<p>Stattdessen belassen wir <code>get_messages</code> als reguläre Funktion, die einen Strom
zurückgibt, und erzeugen eine Aufgabe, die die asynchronen Aufrufe von <code>sleep</code>
durchführt.</p>
<blockquote>
<p>Anmerkung: Der Aufruf von <code>spawn_task</code> auf diese Weise funktioniert, weil wir
unsere Laufzeitumgebung bereits eingerichtet haben; andernfalls würde das
Programm abstürzen. Andere Implementierungen wählen andere Kompromisse: Sie
könnten eine neue Laufzeitumgebung erzeugen und so den Programmabbruch
vermeiden, müssten dafür aber zusätzlichen Overhead in Kauf nehmen, oder sie
bieten einfach keine eigenständige Möglichkeit, Aufgaben ohne Bezug auf eine
Laufzeitumgebung zu erzeugen. Stelle sicher, dass du weißt, welchen
Kompromiss deine Laufzeitumgebung gewählt hat, und schreibe deinen Code
entsprechend!</p>
</blockquote>
<p>Jetzt hat unser Code ein viel interessanteres Ergebnis. Zwischen jedem zweiten
Paar von Meldungen wird der Fehler <code>Problem: Elapsed(())</code> gemeldet.</p>
<pre><code class="language-text">Nachricht: 'a'
Problem: Elapsed(())
Nachricht: 'b'
Nachricht: 'c'
Problem: Elapsed(())
Nachricht: 'd'
Nachricht: 'e'
Problem: Elapsed(())
Nachricht: 'f'
Nachricht: 'g'
Problem: Elapsed(())
Nachricht: 'h'
Nachricht: 'i'
Problem: Elapsed(())
Nachricht: 'j'
</code></pre>
<p>Die Zeitüberschreitung verhindert nicht, dass die Nachrichten am Ende ankommen.
Wir erhalten immer noch alle ursprünglichen Nachrichten. Das liegt daran, dass
unser Kanal <em>unbegrenzt</em> ist: Er kann so viele Nachrichten aufnehmen, wie in
den Arbeitsspeicher passen. Wenn die Nachricht nicht vor der Zeitüberschreitung
eintrifft, wird unser Strom-Handler dies berücksichtigen, aber wenn er den
Strom erneut abruft, ist die Nachricht vielleicht schon angekommen.</p>
<p>Du kannst bei Bedarf ein anderes Verhalten erreichen, indem du andere Arten von
Kanälen oder allgemeiner andere Arten von Strömen verwendest. Lass uns eine
dieser Möglichkeiten in der Praxis ansehen, indem wir einen Strom von
Zeitintervallen mit diesem Strom von Nachrichten kombinieren.</p>
<h3 id="zusammenführen-von-strömen"><a class="header" href="#zusammenführen-von-strömen">Zusammenführen von Strömen</a></h3>
<p>Erstellen wir zunächst einen weiteren Strom, der jede Millisekunde ein Element
ausgibt, wenn wir ihn direkt laufen lassen. Der Einfachheit halber können wir
die Funktion <code>sleep</code> verwenden, um eine Nachricht verzögert zu senden, und sie
mit dem gleichen Ansatz kombinieren, den wir in <code>get_messages</code> verwendet haben,
indem wir einen Stroms aus einem Kanal erstellen. Der Unterschied ist, dass wir
dieses Mal die Anzahl der abgelaufenen Intervalle zurücksenden werden, also
wird der Rückgabetyp <code>impl Stream&lt;Item = u32&gt;</code> sein, und wir können die Funktion
<code>get_intervals</code> aufrufen (siehe Codeblock 17-36).</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Nachricht: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;
            tx.send(count).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<p><span class="caption">Codeblock 17-36: Erstellen eines Stroms mit einem Zähler,
der einmal pro Millisekunde eine Nachricht generiert</span></p>
<p>Beginnen wir mit der Definition von <code>count</code> in der Aufgabe. (Wir könnten sie
auch außerhalb der Aufgabe definieren, aber es ist klarer, den
Gültigkeitsbereich einer bestimmten Variablen zu begrenzen.) Dann erstellen wir
eine Endlosschleife. Jede Iteration der Schleife schläft asynchron eine
Millisekunde lang, erhöht die Anzahl und sendet sie dann über den Kanal. Da
dies alles in der von <code>spawn_task</code> erzeugten Aufgabe verpackt ist, wird alles
zusammen mit der Laufzeitumgebung aufgeräumt, einschließlich der
Endlosschleife.</p>
<p>Eine derartige Endlosschleife, die erst endet, wenn die gesamte
Laufzeitumgebung beendet wird, ist in asynchronem Rust recht häufig: Viele
Programme müssen unbegrenzt weiterlaufen. Mit asynchronem Code blockiert dies
nichts anderes, solange es in jeder Schleifeniteration mindestens einen
await-Punkt gibt.</p>
<p>Zurück im asynchronen Block unserer Hauptfunktion können wir nun versuchen, die
Ströme <code>messages</code> und <code>intervals</code> zusammenzuführen, wie in Codeblock 17-37
gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals();
        let merged = messages.merge(intervals);
<span class="boring">
</span><span class="boring">        while let Some(result) = merged.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Nachricht: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-37: Versuch, die Ströme <code>messages</code> and
<code>intervals</code> zusammenzuführen</span></p>
<p>Wir beginnen mit dem Aufruf von <code>get_intervals</code>. Dann führen wir die Ströme
<code>messages</code> und <code>intervals</code> mit der Methode <code>merge</code> zusammen, die mehrere Ströme
zu einem Strom kombiniert, der Elemente aus jedem der Quellströme produziert,
sobald die Elemente verfügbar sind, ohne eine bestimmte Reihenfolge
festzulegen. Schließlich laufen wir in einer Schleife über diesen kombinierten
Strom anstatt über <code>messages</code>.</p>
<p>Zu diesem Zeitpunkt müssen weder <code>messages</code> noch <code>intervals</code> angeheftet oder
veränderbar sein, da beide zu einem einzigen Strom <code>merged</code> zusammengeführt
werden. Allerdings lässt sich dieser Aufruf von <code>merge</code> nicht kompilieren!
(Genauso wenig wie der <code>next</code>-Aufruf in der <code>while let</code>-Schleife, aber darauf
kommen wir zurück.) Das liegt daran, dass die beiden Ströme unterschiedliche
Typen haben. Der Strom <code>messages</code> hat den Typ <code>Timeout&lt;impl Stream&lt;Item =  String&gt;&gt;</code>, wobei <code>Timeout</code> der Typ ist, den <code>Stream</code> für einen
<code>timeout</code>-Aufruf implementiert. Der Strom <code>intervals</code> hat den Typ <code>impl Stream&lt;Item = u32&gt;</code>. Um diese beiden Ströme zusammenzuführen, müssen wir
einen von ihnen umwandeln, damit er mit dem anderen übereinstimmt. Wir
überarbeiten den Strom <code>intervals</code>, da <code>messages</code> bereits das gewünschte
Grundformat hat und Timeout-Fehler behandeln muss (siehe Codeblock 17-38).</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("Intervall: {count}"))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Nachricht: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-38: Angleichen des Typs des Stroms
<code>intervals</code> an den Typ des Stroms <code>messages</code></span></p>
<p>Erstens können wir die Hilfsmethode <code>map</code> verwenden, um <code>intervals</code> in eine
Zeichenkette umzuwandeln. Zweitens müssen wir das <code>Timeout</code> aus <code>messages</code>
abgleichen. Da wir aber eigentlich keine Zeitüberschreitung für <code>intervals</code>
<em>wollen</em>, können wir einfach eine Zeitüberschreitung erstellen, die länger ist
als die anderen Zeitspannen, die wir verwenden. Hier erstellen wir eine
10-Sekunden-Zeitüberschreitung mit <code>Duration::from_secs(10)</code>. Schließlich
müssen wir <code>Stream</code> veränderbar machen, damit die Aufrufe von <code>next</code> in der
<code>while let</code>-Schleife durch den Strom iterieren können, und ihn so pinnen, dass
es sicher ist, dies zu tun. Damit sind wir <em>fast</em> da, wo wir hinwollen. Alle
Typen passen. Wenn du das Programm ausführst, gibt es allerdings zwei Probleme.
Erstens wird es sich nie beenden! Du musst es mit <kbd>Strg</kbd>+<kbd>c</kbd>
abbrechen. Zweitens werden die Meldungen des englischen Alphabets inmitten all
der Intervallzähler-Meldungen begraben sein:</p>
<pre><code class="language-text">--abschneiden--
Intervall: 38
Intervall: 39
Intervall: 40
Nachricht: 'a'
Intervall: 41
Intervall: 42
Intervall: 43
--abschneiden--
</code></pre>
<p>Codeblock 17-39 zeigt eine Möglichkeit, diese beiden letzten Probleme zu lösen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("Intervall: {count}"))
            .throttle(Duration::from_millis(100))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals).take(20);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Nachricht: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-39: Verwenden von <code>throttle</code> und <code>take</code> zur
Verwaltung des zusammengeführten Stroms</span></p>
<p>Zuerst verwenden wir die Methode <code>throttle</code> für den Strom <code>intervals</code>, sodass
er den Strom <code>messages</code> nicht begräbt. Die <em>Drosselung</em> ist eine Möglichkeit,
die Rate zu begrenzen, mit der eine Funktion aufgerufen wird – oder in
diesem Fall, wie oft der Strom abgefragt wird. Einmal alle 100 Millisekunden
sollte genügen, denn das entspricht in etwa der Häufigkeit, mit der unsere
Nachrichten eintreffen.</p>
<p>Um die Anzahl der Elemente zu begrenzen, die wir aus einem Strom akzeptieren,
wenden wir die Methode <code>take</code> auf den <em>zusammengeführten</em> Strom an, da wir die
gesamte Ausgabe begrenzen wollen, nicht nur den einen oder anderen Strom.</p>
<p>Wenn wir das Programm jetzt ausführen, hält es nach dem Abrufen von 20
Elementen aus dem Strom an, und die Intervalle begraben die Nachrichten nicht.
Wir erhalten auch nicht <code>Intervall: 100</code> oder <code>Intervall: 200</code> usw., sondern
stattdessen <code>Intervall: 1</code>, <code>Intervall: 2</code> usw. – obwohl wir einen
Quellstrom haben, der jede Millisekunde ein Ereignis erzeugen <em>kann</em>. Das liegt
daran, dass der Aufruf <code>throttle</code> einen neuen Strom erzeugt, der den
ursprünglichen Strom umhüllt, sodass der ursprüngliche Strom nur mit der
Drosselrate abgefragt wird und nicht mit seiner eigenen „nativen“ Rate. Wir
haben keine Vielzahl von unbehandelten Intervallnachrichten, die wir ignorieren
wollen. Stattdessen erzeugen wir diese Intervallnachrichten gar nicht erst!
Hier haben wir wieder die inhärente „Faulheit“ von Rusts Futures, die uns
erlaubt, die Leistungsmerkmale zu wählen.</p>
<pre><code class="language-text">Intervall: 1
Nachricht: 'a'
Intervall: 2
Intervall: 3
Problem: Elapsed(())
Intervall: 4
Nachricht: 'b'
Intervall: 5
Nachricht: 'c'
Intervall: 6
Intervall: 7
Problem: Elapsed(())
Intervall: 8
Nachricht: 'd'
Intervall: 9
Nachricht: 'e'
Intervall: 10
Intervall: 11
Problem: Elapsed(())
Intervall: 12
</code></pre>
<p>Es gibt noch eine letzte Sache, die wir behandeln müssen: Fehler! Bei diesen
beiden kanalbasierten Strömen könnten die Sendeaufrufe fehlschlagen, wenn die
andere Seite des Kanals geschlossen wird – und das ist nur eine Frage der
Art und Weise, wie die Laufzeitumgebung die Futures ausführt, die den Strom
bilden. Bis jetzt haben wir dies möglicherweise ignoriert, indem wir <code>unwrap</code>
aufgerufen haben, aber in einer anständigen Anwendung sollten wir den Fehler
explizit behandeln, zumindest indem wir die Schleife beenden, damit wir nicht
versuchen, weitere Nachrichten zu senden! Codeblock 17-40 zeigt eine einfache
Fehlerstrategie: Den Fehler ausgeben und dann die Schleife verlassen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("Intervall #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];

        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            if let Err(send_error) = tx.send(format!("Nachricht: '{message}'")) {
                eprintln!("Kann die Nachricht '{message}' nicht senden: {send_error}");
                break;
            }
        }
    });

    ReceiverStream::new(rx)
}

fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Konnte das Intervall {count} nicht senden: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<p><span class="caption">Codeblock 17-40: Behandeln von Fehlern und Beenden der
Schleifen</span></p>
<p>Wie üblich, gibt es verschiedene Weisen, einen Fehler beim Senden von
Nachrichten zu behandeln, – stelle einfach sicher, dass du eine Strategie
hast.</p>
<p>Nachdem wir nun eine Menge asynchronen Code in der Praxis gesehen haben, wollen
wir einen Schritt zurückgehen und uns ein paar Details, wie <code>Future</code>, <code>Stream</code>
und andere Schlüsselmerkmale, die Rust verwendet, ansehen, die die asynchrone
Programmierung ermöglichen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ein-genauerer-blick-auf-die-merkmale-für-async"><a class="header" href="#ein-genauerer-blick-auf-die-merkmale-für-async">Ein genauerer Blick auf die Merkmale für Async</a></h2>
<p>Im Laufe des Kapitels haben wir die Merkmale <code>Future</code>, <code>Pin</code>, <code>Unpin</code>, <code>Stream</code>
und <code>StreamExt</code> auf verschiedene Weise verwendet. Bis jetzt haben wir es jedoch
vermieden, zu sehr ins Detail zu gehen, wie sie funktionieren oder wie sie
zusammenpassen. Wenn wir Rust für den Alltag schreiben, ist das meist
ausreichend. Manchmal stößt man jedoch auf Situationen, in denen du
weitergehende Details verstehen musst. In diesem Abschnitt werden wir nur so
weit ins Detail gehen, wie es für diese Szenarien nötig ist, und überlassen die
<em>wirklich</em> tiefen Einblicke der weiteren Dokumentation.</p>
<h3 id="das-merkmal-future"><a class="header" href="#das-merkmal-future">Das Merkmal <code>Future</code></a></h3>
<p>Lass uns zunächst einen genaueren Blick darauf werfen, wie das Merkmal <code>Future</code>
funktioniert. Rust definiert es wie folgt:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Diese Merkmals-Definition enthält eine Reihe neuer Typen und auch eine Syntax,
die wir bisher noch nicht gesehen haben. Gehen wir also die Definition Stück
für Stück durch.</p>
<p>Erstens gibt der zugehörige Typ <code>Output</code> von <code>Future</code> an, was das Future
zurückgibt. Dies ist analog zum Typ <code>Item</code> des Merkmals <code>Iterator</code>. Zweitens
hat <code>Future</code> auch die Methode <code>poll</code>, die eine spezielle <code>Pin</code>-Referenz für
ihren <code>self</code>-Parameter und eine veränderbare Referenz auf einen <code>Context</code>-Typ
entgegennimmt und <code>Poll&lt;Self::Output&gt;</code> zurückgibt. Wir werden gleich ein wenig
mehr über <code>Pin</code> und <code>Context</code> sprechen. Für den Moment wollen wir uns auf das
konzentrieren, was die Methode zurückgibt: Den Typ <code>Poll</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}</span></code></pre></pre>
<p>Dieser Typ <code>Poll</code> ist <code>Option</code> recht ähnlich: Er hat eine Variante <code>Ready(T)</code>,
die einen Wert hat, und eine Variante <code>Pending</code> ohne Wert. <code>Poll</code> bedeutet
jedoch etwas ganz anderes als <code>Option</code>! Die Variante <code>Pending</code> zeigt an, dass
das Future noch Arbeit zu erledigen hat, sodass der Aufrufer später noch einmal
nachsehen muss. Die Variante <code>Ready</code> zeigt an, dass das <code>Future</code> seine Arbeit
beendet hat und der Wert <code>T</code> verfügbar ist.</p>
<blockquote>
<p>Hinweis: Bei den meisten Futures sollte der Aufrufer die Methode <code>poll</code> nicht
erneut aufrufen, nachdem das Future <code>Ready</code> zurückgegeben hat. Viele Futures
werden das Programm zum Absturz bringen, wenn sie erneut abgefragt werden,
obwohl sie bereit sind! Futures, bei denen eine erneute Abfrage sicher ist,
werden dies in ihrer Dokumentation explizit erwähnen. Dies ist ähnlich zum
Verhalten von <code>Iterator::next</code>!</p>
</blockquote>
<p>Rust kompiliert Code mit <code>await</code> unter der Haube zu Code, der <code>poll</code> aufruft.
Wenn du dir Codeblock 17-4 ansiehst, wo wir den Seitentitel für eine einzelne
URL ausgegeben haben, sobald sie aufgelöst wurde, kompiliert Rust das in etwa
(wenn auch nicht genau) wie folgt:</p>
<pre><code class="language-rust ignore">match page_title(url).poll() {
    Ready(page_title) =&gt; match page_title {
        Some(title) =&gt; println!("Der Titel für {url} war {title}"),
        None =&gt; println!("{url} hatte keinen Titel"),
    }
    Pending =&gt; {
        // Aber was kommt hierhin?
    }
}</code></pre>
<p>Was sollen wir tun, wenn das Future noch <code>Pending</code> ist? Wir brauchen eine
Möglichkeit, es nochmal zu versuchen und nochmal und nochmal, bis das Future
endlich fertig ist. Mit anderen Worten, wir benötigen eine Schleife:</p>
<pre><code class="language-rust ignore">let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) =&gt; match page_title {
            Some(title) =&gt; println!("Der Titel für {url} war {title}"),
            None =&gt; println!("{url} hatte keinen Titel"),
        }
        Pending =&gt; {
            // weitermachen
        }
    }
}</code></pre>
<p>Wenn Rust diesen Code kompilieren würde, würde jedes <code>await</code> blockieren –
genau das Gegenteil von dem, was wir erreichen wollten! Stattdessen sorgt Rust
dafür, dass die Schleife die Kontrolle an etwas abgeben kann, das die Arbeit an
diesem Future unterbrechen und an anderen Futures arbeiten kann, um diese
später wieder zu prüfen. Wie wir bereits gesehen haben, ist dieses „Etwas“ eine
asynchrone Laufzeitumgebung, und diese Planungs- und Koordinierungsarbeit ist
eine der Hauptaufgaben einer Laufzeitumgebung.</p>
<p>Weiter oben in diesem Kapitel haben wir das Warten auf <code>rx.recv</code> beschrieben.
Der Aufruf <code>recv</code> gibt ein Future zurück und zum Warten darauf wird es es
abgefragt. Wir haben angemerkt, dass eine Laufzeitumgebung das Future pausieren
wird, bis es entweder mit <code>Some(message)</code> oder <code>None</code> bereit ist, wenn der
Kanal geschlossen wird. Mit unserem tieferen Verständnis des Merkmals <code>Future</code>
und insbesondere von <code>Future::poll</code> können wir sehen, wie das funktioniert. Die
Laufzeitumgebung weiß, dass das Future nicht bereit ist, wenn es
<code>Poll::Pending</code> zurückgibt. Umgekehrt weiß die Laufzeitumgebung, dass das
Future <em>bereit</em> ist und bevorzugt es, wenn <code>poll</code> den Wert
<code>Poll::Ready(Some(message))</code> oder <code>Poll::Ready(None)</code> zurückgibt.</p>
<p>Die genauen Details, wie eine Laufzeitumgebung das macht, gehen über den Rahmen
dieses Buches hinaus, aber der Schlüssel ist, die grundlegende Mechanik von
Futures zu verstehen: Eine Laufzeitumgebung fragt jedes Future ab, für das sie
verantwortlich ist, und versetzt das Future zurück in den Schlaf, wenn es noch
nicht bereit ist.</p>
<h3 id="die-merkmale-pin-and-unpin"><a class="header" href="#die-merkmale-pin-and-unpin">Die Merkmale <code>Pin</code> and <code>Unpin</code></a></h3>
<p>Als wir in Codeblock 17-16 die Idee des Anheftens einführten, stießen wir auf
eine sehr unangenehme Fehlermeldung. Hier ist noch einmal der relevante Teil
davon:</p>
<pre><code class="language-text">error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
</code></pre>
<p>Diese Fehlermeldung sagt uns nicht nur, dass wir die Werte anheften müssen,
sondern auch, warum das Anheften erforderlich ist. Die Funktion
<code>trpl::join_all</code> gibt eine Struktur namens <code>JoinAll</code> zurück. Diese Struktur
ist generisch über einen Typ <code>F</code>, der auf die Implementierung des Merkmals
<code>Future</code> beschränkt ist. Direktes Warten auf ein Future mit <code>await</code> heftet das
Future implizit an. Deshalb müssen wir <code>pin!</code> nicht überall verwenden, wo wir
auf Futures warten wollen.</p>
<p>Allerdings warten wir hier nicht direkt auf ein Future. Stattdessen
konstruieren wir ein neues Future <code>JoinAll</code>, indem wir eine Kollektion von
Futures an die Funktion <code>join_all</code> übergeben. Die Signatur für <code>join_all</code>
erfordert, dass der Typ der Elemente in der Kollektion das Merkmal <code>Future</code>
implementiert. <code>Box&lt;T&gt;</code> implementiert <code>Future</code> nur, wenn das <code>T</code>, das es
umhüllt, ein Future ist, das das Merkmal <code>Unpin</code> implementiert.</p>
<p>Das ist eine Menge, die man verarbeiten muss! Um es wirklich zu verstehen,
müssen wir ein wenig tiefer in die Funktionsweise des Merkmals <code>Future</code>
eintauchen, insbesondere in Bezug auf das <em>Anheften</em> (pinning).</p>
<p>Schau dir noch einmal die Definition des Merkmals <code>Future</code> an:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // Erforderliche Methode
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Der Parameter <code>cx</code> und sein Typ <code>Context</code> sind der Schlüssel dazu, wie eine
Laufzeitumgebung tatsächlich weiß, wann sie ein bestimmtes Future prüfen muss,
während es immer noch faul ist. Die Details, wie das funktioniert, liegen
jedoch außerhalb des Rahmens dieses Kapitels: Du musst dich im Allgemeinen nur
darum kümmern, wenn du eine eigene <code>Future</code>-Implementierung schreibst. Wir
werden uns stattdessen auf den Typ von <code>self</code> konzentrieren, da dies das erste
Mal ist, dass wir eine Methode sehen, bei der <code>self</code> eine Typ-Annotation hat.
Eine Typ-Annotation für <code>self</code> funktioniert wie Typ-Annotationen für andere
Funktionsparameter, jedoch mit zwei wesentlichen Unterschieden:</p>
<ul>
<li>
<p>Sie teilt Rust mit, welchen Typ <code>self</code> haben muss, damit die Methode
aufgerufen werden kann.</p>
</li>
<li>
<p>Sie kann nicht einfach irgendein Typ sein. Sie ist beschränkt auf den Typ,
auf dem die Methode implementiert ist, eine Referenz oder ein intelligenter
Zeiger auf diesen Typ oder ein <code>Pin</code>, das eine Referenz auf diesen Typ
umhüllt.</p>
</li>
</ul>
<p>Wir werden mehr über diese Syntax in <a href="ch18-00-oop.html">Kapitel 18</a> erfahren. Für den
Moment reicht es zu wissen, dass wir, wenn wir ein Future abfragen wollen, um
zu prüfen, ob es <code>Pending</code> oder <code>Ready(Output)</code> ist, eine mit <code>Pin</code> umhüllte
veränderbare Referenz auf den Typ benötigen.</p>
<p><code>Pin</code> ist ein Wrapper für zeigerartige Typen wie <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code> und <code>Rc</code>.
(Technisch gesehen arbeitet <code>Pin</code> mit Typen, die die Merkmale <code>Deref</code> oder
<code>DerefMut</code> implementieren, aber das ist effektiv gleichbedeutend damit, nur mit
Zeigern zu arbeiten.) <code>Pin</code> ist selbst kein Zeiger und hat kein eigenes
Verhalten wie <code>Rc</code> und <code>Arc</code> mit Referenzzählern; es ist lediglich ein
Werkzeug, das der Compiler verwenden kann, um Einschränkungen bei der
Verwendung von Zeigern zu erzwingen.</p>
<p>Wenn du dich daran erinnerst, dass <code>await</code> in Form von Aufrufen von <code>poll</code>
implementiert ist, erklärt das die Fehlermeldung, die wir oben gesehen haben,
aber die bezog sich auf <code>Unpin</code>, nicht auf <code>Pin</code>. Wie genau verhält sich also
<code>Pin</code> zu <code>Unpin</code>, und warum muss <code>self</code> bei einem <code>Future</code> in einem <code>Pin</code>-Typ
sein, um <code>poll</code> aufzurufen?</p>
<p>Erinnere dich an den Anfang dieses Kapitels: Eine Reihe von await-Punkten in
einem Future wird zu einem Zustandsautomaten kompiliert, und der Compiler
stellt sicher, dass dieser Zustandsautomat alle normalen Sicherheitsregeln von
Rust befolgt, einschließlich Ausleihen (borrowing) und Eigentümerschaft
(ownership). Damit das funktioniert, prüft Rust, welche Daten zwischen einem
await-Punkt und entweder dem nächsten await-Punkt oder dem Ende des
asynchronen Blocks benötigt werden. Anschließend wird eine entsprechende
Variante in der kompilierten Zustandsmaschine erstellt. Jede Variante erhält
den erforderlichen Zugriff auf die Daten, die in diesem Abschnitt des
Quellcodes verwendet werden, entweder durch Übernahme der Eigentümerschaft an
diesen Daten oder durch Erhalt einer veränderbaren oder unveränderbaren
Referenz darauf.</p>
<p>So weit, so gut: Wenn wir bei der Eigentümerschaft oder den Referenzen in einem
bestimmten asynchronen Block etwas falsch machen, wird uns der Ausleihenprüfer
(borrow checker) dies mitteilen. Wenn wir das Future, das diesem Block
entspricht, verschieben wollen – etwa in einen <code>Vec</code>, um es an <code>join_all</code>
zu übergeben – wird es schwieriger.</p>
<p>Wenn wir ein Future verschieben – sei es durch Verschieben in eine
Datenstruktur, um es als Iterator mit <code>join_all</code> zu verwenden oder durch
Rückgabe aus einer Funktion – bedeutet das eigentlich, dass wir die
Zustandsmaschine verschieben, die Rust für uns erstellt. Und im Gegensatz zu
den meisten anderen Typen in Rust können die Futures, die Rust für async-Blöcke
erzeugt, mit Referenzen auf sich selbst in den Feldern einer beliebigen
Variante enden, wie in der vereinfachten Darstellung in Abbildung 17-4 gezeigt.</p>
<img alt="Nebenläufiger Arbeitsablauf" src="img/trpl17-04.svg" />
<p><span class="caption">Abbildung 17-4: Ein selbstreferenzierender
Datentyp</span></p>
<p>Standardmäßig kann ein Objekt, das eine Referenz auf sich selbst hat, nicht
sicher verschoben werden, da Referenzen immer auf die tatsächliche
Speicheradresse des Objekts zeigen (siehe Abbildung 17-5). Wenn du die
Datenstruktur selbst verschiebst, verweisen diese internen Referenzen weiterhin
auf den alten Speicherplatz. Dieser Speicherplatz ist nun jedoch ungültig. Zum
einen wird ihr Wert nicht mehr aktualisiert, wenn du Änderungen an der
Datenstruktur vornimmst. Zum anderen – und das ist noch wichtiger –
kann der Computer diesen Speicherplatz nun für andere Zwecke verwenden! Es
könnte sein, dass du später völlig unzusammenhängende Daten liest.</p>
<img alt="Nebenläufiger Arbeitsablauf" src="img/trpl17-05.svg" />
<p><span class="caption">Abbildung 17-5: Das unsichere Ergebnis beim Verschieben
eines selbstreferenzierenden Datentyps</span></p>
<p>Theoretisch könnte der Rust-Compiler versuchen, jede Referenz auf ein Objekt zu
aktualisieren, wenn es verschoben wird. Das würde potenziell eine Menge
zusätzlicher Performance-Overhead bedeuten, vor allem wenn man bedenkt, dass es
ein ganzes Netz von Referenzen geben kann, die aktualisiert werden müssen. Wenn
wir stattdessen sicherstellen können, dass die betreffende Datenstruktur <em>nicht
im Speicher verschoben wird</em>, müssen wir keine Referenzen aktualisieren. Das
ist genau das, was der Rust-Ausleihenprüfer verlangt: In sicherem Code kann man
kein ein Element, auf das aktive Referenzen bestehen, verschieben.</p>
<p><code>Pin</code> baut darauf auf, um uns genau die Garantie zu geben, die wir brauchen.
Wenn wir einen Wert <em>anheften</em>, indem wir einen Zeiger auf diesen Wert in <code>Pin</code>
einpacken, kann er nicht mehr verschoben werden. Wenn du also
<code>Pin&lt;Box&lt;SomeType&gt;&gt;</code> hast, heftest du eigentlich den Wert <code>SomeType</code> an,
<em>nicht</em> den Zeiger <code>Box</code>. Abbildung 17-6 veranschaulicht dies:</p>
<img alt="Nebenläufiger Arbeitsablauf" src="img/trpl17-06.svg" />
<p><span class="caption">Abbildung 17-6: Anheften einer <code>Box</code>, die auf einen
selbstreferenzierenden Future-Typ zeigt</span></p>
<p>In der Tat kann der Zeiger in <code>Box</code> immer noch verschoben werden. Denke daran:
Wir wollen sicherstellen, dass die Daten, auf die letztlich referenziert wird,
an ihrem Platz bleiben. Wenn ein Zeiger verschoben wird, aber die Daten, auf
die er zeigt, an der gleichen Stelle sind, wie in Abbildung 17-7, gibt es kein
potenzielles Problem. (Schau dir als unabhängige Übung die Dokumentationen der
Typen sowie des Moduls <code>std::pin</code> an und versuche herauszufinden, wie du das
mit einem <code>Pin</code> machst, der eine <code>Box</code> umhüllt.) Der Schlüssel ist, dass der
selbstreferenzierende Typ selbst nicht verschoben werden kann, weil er immer
noch angeheftet ist.</p>
<img alt="Nebenläufiger Arbeitsablauf" src="img/trpl17-07.svg" />
<p><span class="caption">Abbildung 17-7: Verschieben einer <code>Box</code>, die auf einen
selbstreferenzierenden Futuretyp zeigt.</span></p>
<p>Die meisten Typen können jedoch gefahrlos verschoben werden, selbst wenn sie
sich hinter einem <code>Pin</code>-Wrapper befinden. Wir müssen nur über das Anheften
nachdenken, wenn Elemente interne Referenzen haben. Primitive Werte wie Zahlen
und Boolesche Werte sind sicher, weil sie keine internen Referenzen haben.
Genauso wenig wie die meisten Typen, mit denen man normalerweise in Rust
arbeitet. Du kannst zum Beispiel unbesorgt einen <code>Vec</code> verschieben. Nach dem,
was wir bisher gesehen haben, müsste man bei einem <code>Pin&lt;Vec&lt;String&gt;&gt;</code> alles
über die sicheren, aber restriktiven APIs von <code>Pin</code> machen, obwohl ein
<code>Vec&lt;String&gt;</code> immer sicher verschoben werden kann, wenn es keine anderen
Referenzen auf ihn gibt. Wir brauchen eine Möglichkeit, dem Compiler
mitzuteilen, dass es in solchen Fällen in Ordnung ist, Elemente zu verschieben
– und hier kommt <code>Unpin</code> ins Spiel.</p>
<p><code>Unpin</code> ist ein Markierungsmerkmal (marker trait), ähnlich wie die Merkmale
<code>Send</code> und <code>Sync</code>, die wir in Kapitel 16 gesehen haben, und es hat keine eigene
Funktionalität. Markierungsmerkmale existieren nur, um dem Compiler
mitzuteilen, dass es sicher ist, den Typ zu verwenden, der ein bestimmtes
Merkmal in einem bestimmten Kontext implementiert. <code>Unpin</code> teilt dem Compiler
mit, dass ein gegebener Typ <em>keine</em> besonderen Garantien aufrechterhalten muss,
um den fraglichen Wert zu verschieben.</p>
<p>Genau wie bei <code>Send</code> und <code>Sync</code> implementiert der Compiler <code>Unpin</code> automatisch
für alle Typen, bei denen er beweisen kann, dass sie sicher sind. Ein
Sonderfall analog zu <code>Send</code> und <code>Sync</code> ist, dass <code>Unpin</code> für einen Typ <em>nicht</em>
implementiert ist. Die Notation hierfür ist <code>impl !Unpin for SomeType</code>, wobei
<code>SomeType</code> der Name eines Typs ist, der diese Garantien aufrechterhalten
<em>muss</em>, um sicher zu sein, wenn ein Zeiger auf diesen Typ in einem <code>Pin</code>
verwendet wird.</p>
<p>Mit anderen Worten, es gibt zwei Dinge über die Beziehung zwischen <code>Pin</code> und
<code>Unpin</code> zu beachten. Erstens ist <code>Unpin</code> der „normale“ Fall und <code>!Unpin</code> der
Spezialfall. Zweitens, ob ein Typ <code>Unpin</code> oder <code>!Unpin</code> implementiert, spielt
<em>nur</em> eine Rolle, wenn man einen angepinnten Zeiger auf diesen Typ wie
<code>Pin&lt;&amp;mut SomeType&gt;</code> verwendet.</p>
<p>Um dies zu verdeutlichen, denke an einen <code>String</code>: Er hat eine Länge und die
Unicode-Zeichen, aus denen er besteht. Wir können einen <code>String</code> in einen <code>Pin</code>
einpacken, wie in Abbildung 17-8. Allerdings implementiert <code>String</code> automatisch
<code>Unpin</code>, wie die meisten anderen Typen in Rust.</p>
<img alt="Concurrent work flow" src="img/trpl17-08.svg" />
<p><span class="caption">Abbildung 17-8: Anheften eines <code>String</code>; die gestrichelte Linie
deutet an, dass die Zeichenkette das Merkmal <code>Unpin</code> implementiert und daher
nicht angeheftet ist.</span></p>
<p>Infolgedessen können wir Dinge tun, die illegal wären, wenn <code>String</code>
stattdessen <code>!Unpin</code> implementiert hätte, wie zum Beispiel das Ersetzen einer
Zeichenkette durch eine andere an der exakt gleichen Stelle im Speicher, wie in
Abbildung 17-9. Dies verletzt nicht den <code>Pin</code>-Vertrag, weil <code>String</code> keine
internen Referenzen hat, die es unsicher machen, es zu verschieben! Das ist
genau der Grund, warum es <code>Unpin</code> und nicht <code>!Unpin</code> implementiert.</p>
<img alt="Concurrent work flow" src="img/trpl17-09.svg" />
<p><span class="caption">Abbildung 17-9: Ersetzen eines <code>String</code> durch einen
völlig anderen <code>String</code> im Speicher.</span></p>
<p>Jetzt wissen wir genug, um die Fehler zu verstehen, die für den Aufruf
<code>join_all</code> in Codeblock 17-17 gemeldet wurden. Ursprünglich haben wir versucht,
die von asynchronen Blöcken erzeugten Futures in einen <code>Vec&lt;Box&lt;dyn  Future&lt;Output = ()&gt;&gt;&gt;</code> zu verschieben, aber wie wir gesehen haben, können
diese Futures interne Referenzen haben, sodass sie <code>Unpin</code> nicht
implementieren. Sie müssen angepinnt werden und dann können wir den Typ <code>Pin</code>
an den <code>Vec</code> übergeben, in der Gewissheit, dass die zugrunde liegenden Daten in
den Futures <em>nicht</em> verschoben werden.</p>
<p><code>Pin</code> und <code>Unpin</code> sind vor allem wichtig für die Erstellung von
Low-Level-Bibliotheken und wenn du eine Laufzeitumgebung erstellst, weniger
bei alltäglichem Rust-Code. Wenn du diese Merkmale in Fehlermeldungen
siehst, hast du jetzt eine bessere Vorstellung davon, wie du deinen Code
korrigieren kannst!</p>
<blockquote>
<p>Anmerkung: Diese Kombination von <code>Pin</code> und <code>Unpin</code> macht es möglich, eine
ganze Klasse von komplexen Typen sicher in Rust zu implementieren, die sich
sonst als schwierig erweisen würden, weil sie selbstreferenzierend sind.
Typen, die <code>Pin</code> benötigen, tauchen heute am häufigsten in asynchronem Rust
auf, aber hin und wieder sieht man sie auch in anderen Kontexten.</p>
<p>Die Besonderheiten der Funktionsweise von <code>Pin</code> und <code>Unpin</code> und die Regeln,
die sie einhalten müssen, werden ausführlich in der API-Dokumentation für
<code>std::pin</code> behandelt. Wenn du mehr darüber lernen willst, ist das ein guter
Ausgangspunkt.</p>
<p>Wenn du noch detaillierter verstehen willst, wie die Dinge unter der Haube
funktionieren, schaue dir die Kapitel <a href="https://rust-lang.github.io/async-book/02_execution/01_chapter.html">„Under the Hood: Executing Futures and
Tasks“</a> und <a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">„Pinning“</a> im Buch <em>Asynchronous
Programming in Rust</em> an:</p>
</blockquote>
<h3 id="das-merkmal-stream"><a class="header" href="#das-merkmal-stream">Das Merkmal <code>Stream</code></a></h3>
<p>Nachdem du nun ein tieferes Verständnis für die Merkmale <code>Future</code>, <code>Pin</code> und
<code>Unpin</code> hast, können wir uns dem Merkmal <code>Stream</code> zuwenden. Wie du bereits in
diesem Kapitel gelernt hast, sind Ströme ähnlich wie asynchrone Iteratoren. Im
Gegensatz zu <code>Iterator</code> und <code>Future</code> hat <code>Stream</code> derzeit keine Definition in
der Standardbibliothek, aber es <em>gibt</em> eine sehr verbreitete Definition in der
Kiste <code>Futures</code>, die im gesamten Ökosystem verwendet wird.</p>
<p>Schauen wir uns die Definitionen der Merkmale <code>Iterator</code> und <code>Future</code> an, bevor
wir uns ansehen, wie ein Merkmal <code>Stream</code> aussehen könnte. Von <code>Iterator</code> haben
wir die Idee einer Sequenz: Seine Methode <code>next</code> liefert eine
<code>Option&lt;Self::Item&gt;</code>. Von <code>Future</code> haben wir die Idee der zeitlichen
Bereitschaft: Seine Methode <code>poll</code> liefert ein <code>Poll&lt;Self::Output&gt;</code>. Um eine
Sequenz von Elementen darzustellen, die im Laufe der Zeit bereit sein werden,
definieren wir ein Merkmal <code>Stream</code>, das diese Funktionalitäten zusammenführt:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Das Merkmal <code>Stream</code> definiert einen zugehörigen Typ namens <code>Item</code> für den Typ
der vom Strom erzeugten Elemente. Dies ist ähnlich wie bei <code>Iterator</code>, wo es
beliebig viele Elemente geben kann, anders als bei <code>Future</code>, wo es immer nur
einen einzigen <code>Output</code> gibt, selbst wenn es der Einheitstyp <code>()</code> ist.</p>
<p><code>Stream</code> definiert auch eine Methode zum Abrufen dieser Elemente. Wir nennen
sie <code>poll_next</code>, um zu verdeutlichen, dass sie auf die gleiche Weise wie
<code>Future::poll</code> abfragt und eine Sequenz von Elementen auf die gleiche Weise wie
<code>Iterator::next</code> erzeugt. Sein Rückgabetyp kombiniert <code>Poll</code> mit <code>Option</code>. Der
äußere Typ ist <code>Poll</code>, weil er auf Bereitschaft geprüft werden muss, genau wie
ein Future. Der innere Typ ist <code>Option</code>, weil er signalisieren muss, ob es
weitere Nachrichten gibt, genau wie ein Iterator.</p>
<p>Etwas, das dieser Definition sehr ähnlich ist, wird wahrscheinlich Teil der
Standardbibliothek von Rust werden. In der Zwischenzeit ist es Teil des
Werkzeugkoffers der meisten Laufzeitumgebungen, sodass du dich darauf verlassen
kannst, und alles, was wir als nächstes behandeln, allgemein gilt!</p>
<p>Im Beispiel, das wir im Abschnitt über Ströme gesehen haben, haben wir
allerdings nicht <code>poll_next</code> <em>oder</em> <code>Stream</code> benutzt, sondern <code>next</code> und
<code>StreamExt</code>. Wir <em>könnten</em> direkt mit der <code>poll_next</code>-API arbeiten, indem wir
unsere eigenen <code>Stream</code>-Zustandsautomaten schreiben, genauso wie wir mit
Futures direkt über deren Methode <code>poll</code> arbeiten <em>können</em>. Die Verwendung von
<code>await</code> ist jedoch viel schöner, und das Merkmal <code>StreamExt</code> stellt die Methode
<code>next</code> bereit, sodass wir folgendes tun können:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">use std::task::{Context, Poll};
</span><span class="boring">
</span><span class="boring">trait Stream {
</span><span class="boring">    type Item;
</span><span class="boring">    fn poll_next(
</span><span class="boring">        self: Pin&lt;&amp;mut Self&gt;,
</span><span class="boring">        cx: &amp;mut Context&lt;'_&gt;,
</span><span class="boring">    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait StreamExt: Stream {
    async fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    where
        Self: Unpin;

    // andere Methoden ...
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Anmerkung: Die tatsächliche Definition von <code>StreamExt</code> sieht etwas anders
aus, da sie Versionen von Rust unterstützt, die noch keine Verwendung von
asynchronen Funktionen in Merkmalen kennen. Infolgedessen sieht sie so aus:</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Next&lt;'_, Self&gt; where Self: Unpin;</code></pre>
<p>Der Typ <code>Next</code> ist ein <code>struct</code>, das <code>Future</code> implementiert, und erlaubt uns,
die Lebensdauer der Referenz auf <code>self</code> mit <code>Next&lt;'_, Self&gt;</code> zu benennen,
sodass <code>await</code> mit dieser Methode arbeiten kann!</p>
</blockquote>
<p>Das Merkmal <code>StreamExt</code> ist auch die Heimat aller interessanten Methoden, die
für die Verwendung mit Strömen zur Verfügung stehen. <code>StreamExt</code> wird
automatisch für jeden Typ implementiert, der <code>Stream</code> implementiert, aber diese
Merkmale werden separat definiert, um der Rust-Gemeinschaft die Möglichkeit zu
geben, Komfort-APIs zu entwickeln, ohne die grundlegenden Merkmale zu
beeinflussen.</p>
<p>In der Version von <code>StreamExt</code>, die in der Kiste <code>trpl</code> verwendet wird,
definiert das Merkmal nicht nur die Methode <code>next</code>, sondern liefert auch eine
Implementierung von <code>next</code>, die die Details des Aufrufs von <code>Stream::poll_next</code>
korrekt behandelt. Das bedeutet, dass du selbst beim Schreiben deines eigenen
Streaming-Datentyps <em>nur</em> <code>Stream</code> implementieren musst, und dann kann jeder,
der deinen Datentyp verwendet, <code>StreamExt</code> und seine Methoden automatisch mit
ihm verwenden.</p>
<p>Das ist alles, was wir für die tieferen Details zu diesen Merkmalen behandeln
werden. Zum Abschluss wollen wir uns ansehen, wie Futures (einschließlich
Ströme), Aufgaben und Stränge zusammenpassen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="alles-zusammenfügen-futures-aufgaben-und-stränge"><a class="header" href="#alles-zusammenfügen-futures-aufgaben-und-stränge">Alles zusammenfügen: Futures, Aufgaben und Stränge</a></h2>
<p>Wie wir in <a href="ch16-00-concurrency.html">Kapitel 16</a> gesehen haben, bieten Stränge (threads) einen
Ansatz für Nebenläufigkeit (concurrency). In diesem Kapitel haben wir einen
anderen Ansatz für Nebenläufigkeit gesehen: Verwenden von asynchronem Code mit
Futures und Strömen (streams). Wenn du dich fragst, wann du eine Methode der
anderen vorziehen solltest, lautet die Antwort: Es kommt darauf an! Und in
vielen Fällen ist die Wahl nicht Stränge <em>oder</em> asynchroner Code, sondern eher
Stränge <em>und</em> asynchroner Code.</p>
<p>Viele Betriebssysteme bieten schon seit Jahrzehnten Strang-basierte
Nebenläufigkeitsmodelle an, und viele Programmiersprachen unterstützen diese
Modelle daher. Diese Modelle sind jedoch nicht frei von Kompromissen. Auf
vielen Betriebssystemen wird für jeden Strang ein beträchtlicher Teil an
Arbeitsspeicher verbraucht und es entsteht ein gewisser Overhead beim Starten
und Beenden. Stränge sind auch nur dann eine Option, wenn dein Betriebssystem
und deine Hardware sie unterstützen. Im Gegensatz zu herkömmlichen Desktop- und
Mobilcomputern haben einige eingebettete Systeme überhaupt kein Betriebssystem,
sodass sie auch keine Stränge haben.</p>
<p>Das asynchrone Modell bietet eine andere – und letztlich ergänzende
– Reihe von Kompromissen. Im asynchronen Modell benötigen nebenläufige
Vorgänge keine eigenen Stränge. Stattdessen können sie in Aufgaben laufen, so
wie wir <code>trpl::spawn_task</code> verwendet haben, um die Arbeit von einer synchronen
Funktion im Abschnitt „Ströme“ zu starten. Eine Aufgabe ähnelt einem Strang,
wird aber nicht vom Betriebssystem, sondern von einem Code auf Bibliotheksebene
verwaltet: der Laufzeitumgebung.</p>
<p>Im vorigen Abschnitt haben wir gesehen, dass wir einen Strom erstellen können,
indem wir einen asynchronen Kanal verwenden und eine asynchrone Aufgabe
erzeugen, die wir von synchronem Code aus aufrufen können. Wir können genau das
Gleiche mit einem Strang machen! In Codeblock 17-40 haben wir
<code>trpl::spawn_task</code> und <code>trpl::sleep</code> verwendet. In Codeblock 17-41 ersetzen wir
diese durch die APIs <code>thread::spawn</code> und <code>thread::sleep</code> aus der
Standardbibliothek.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("Interval #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            if let Err(send_error) = tx.send(format!("Nachricht: '{message}'")) {
</span><span class="boring">                eprintln!("Kann die Nachricht '{message}' nicht senden: {send_error}");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    // Dies ist *nicht* `trpl::spawn` sondern `std::thread::spawn`!
    thread::spawn(move || {
        let mut count = 0;
        loop {
            // Ebenso ist dies *nicht* `trpl::sleep` sondern `std::thread::sleep`!
            thread::sleep(Duration::from_millis(1));
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Konnte das Intervall {count} nicht senden: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<p><span class="caption">Codeblock 17-41: Verwenden der <code>std::thread</code>-APIs
anstelle der asynchronen <code>trpl</code>-APIs für die Funktion <code>get_intervals</code></span></p>
<p>Wenn du diesen Code ausführst, ist die Ausgabe identisch zu der von Codeblock
17-40. Und beachte, wie wenig sich hier aus der Sicht des aufrufenden Codes
ändert! Und obwohl eine unserer Funktionen eine asynchrone Aufgabe in der
Laufzeitumgebung und die andere einen Betriebssystem-Strang startet, hat es
keinen Effekt auf die resultierenden Ströme.</p>
<p>Trotz deren Ähnlichkeiten verhalten sich diese beiden Ansätze sehr
unterschiedlich, obwohl wir es in diesem sehr einfachen Beispiel schwer haben,
dies zu messen. Wir könnten Millionen von asynchronen Aufgaben auf jedem
modernen Computer ausführen. Wenn wir das mit Strängen versuchen würden, würde
uns buchstäblich der Speicher ausgehen!</p>
<p>Es gibt jedoch einen Grund, warum sich diese APIs so ähnlich sind. Stränge
dienen als Grenze für Gruppen von synchronen Operationen; Nebenläufigkeit ist
<em>zwischen</em> Strängen möglich. Aufgaben fungieren als Grenze für Gruppen von
<em>asynchronen</em> Vorgängen; Nebenläufigkeit ist sowohl <em>zwischen</em> als auch
<em>innerhalb</em> von Aufgaben möglich, da eine Aufgabe in ihrem Rumpf zwischen
Futures wechseln kann. Schließlich sind Futures die granularste Einheit der
Nebenläufigkeit in Rust, und jedes Future kann einen Baum von anderen Futures
darstellen. Die Laufzeitumgebung – genauer gesagt ihr Executor –
verwaltet Aufgaben, und Aufgaben verwalten Futures. In dieser Hinsicht ähneln
Aufgaben leichtgewichtigen, von der Laufzeitumgebung verwalteten Strängen mit
zusätzlichen Fähigkeiten, die sich daraus ergeben, dass sie von der
Laufzeitumgebung und nicht vom Betriebssystem verwaltet werden.</p>
<p>Das bedeutet nicht, dass asynchrone Aufgaben immer besser sind als Stränge
(oder umgekehrt). Nebenläufigkeit mit Strängen ist in gewisser Weise ein
einfacheres Programmiermodell als Nebenläufigkeit mit <code>async</code>. Das kann eine
Stärke und eine Schwäche sein. Stränge sind eine Art „Feuern und Vergessen“;
sie haben kein natives Äquivalent zu einem Future, also laufen sie einfach bis
zum Ende, ohne Unterbrechung, außer durch das Betriebssystem selbst. Das heißt,
sie haben keine eingebaute Unterstützung für <em>Nebenläufigkeit innerhalb der
Aufgabe</em>, wie es Futures haben. Stränge in Rust haben auch keine Mechanismen um
die abzubrechen – ein Thema, das wir in diesem Kapitel nicht eingehend
behandelt haben, das aber implizit in der Tatsache enthalten ist, dass immer
dann, wenn wir ein Future beenden, sein Zustand korrekt aufgeräumt wird.</p>
<p>Diese Einschränkungen machen es auch schwieriger, Stränge zu kombinieren, als
Futures. Es ist zum Beispiel viel schwieriger, Stränge zu verwenden, um Helfer
wie <code>timeout</code> und <code>throttle</code> zu erstellen, die wir weiter oben in diesem
Kapitel erstellt haben. Die Tatsache, dass Futures reichhaltigere
Datenstrukturen sind, bedeutet, dass sie natürlicher zusammengesetzt werden
können, wie wir gesehen haben.</p>
<p>Aufgaben geben uns dann <em>zusätzliche</em> Kontrolle über Futures, da man wählen
kann, wo und wie man die Futures gruppiert. Und es stellt sich heraus, dass
Stränge und Aufgaben oft sehr gut zusammenarbeiten, weil Aufgaben (zumindest in
einigen Laufzeitumgebungen) zwischen Strängen verschoben werden können. Unter
der Haube ist die Laufzeitumgebung, die wir verwenden – einschließlich
der Funktionen <code>spawn_blocking</code> und <code>spawn_task</code> – standardmäßig
mehrstängig (multithreaded)! Viele Laufzeitumgebungen verwenden einen Ansatz
namens <em>Work Stealing</em>, um Aufgaben transparent zwischen Strängen zu
verschieben, je nachdem, wie die Stränge gerade ausgelastet sind, um die
Gesamtleistung des Systems zu verbessern. Dieser Ansatz erfordert eigentlich
Stränge <em>und</em> Aufgaben, und damit Futures.</p>
<p>Wenn du überlegst, welche Methode du wann anwenden solltest, beachte diese
Faustregeln:</p>
<ul>
<li>Wenn die Arbeit <em>sehr parallelisierbar</em> ist, z.B. bei der Verarbeitung einer
Menge von Daten, bei der jeder Teil separat verarbeitet werden kann, sind
Stränge die bessere Wahl.</li>
<li>Wenn es sich um <em>sehr nebenläufige</em> Arbeit handelt, wie die Bearbeitung von
Nachrichten aus einer Reihe von verschiedenen Quellen, die in
unterschiedlichen Intervallen oder mit unterschiedlicher Geschwindigkeit
eintreffen können, ist asynchroner Code die bessere Wahl.</li>
</ul>
<p>Und wenn du Parallelität und Nebenläufigkeit benötigst, musst du dich nicht
zwischen Strängen und asynchronem Code entscheiden. Du kannst beide zusammen
verwenden, wobei jede der beiden die Aufgabe übernimmt, für die sie am besten
geeignet ist. Codeblock 17-42 zeigt zum Beispiel ein gängiges Beispiel für
dieses Zusammenspiel in echtem Rust-Code.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span>use std::{thread, time::Duration};

fn main() {
    let (tx, mut rx) = trpl::channel();

    thread::spawn(move || {
        for i in 1..11 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    trpl::run(async {
        while let Some(message) = rx.recv().await {
            println!("{message}");
        }
    });
}</code></pre></pre>
<p><span class="caption">Codeblock 17-42: Senden von Nachrichten mit blockierendem
Code in einem Strang und Warten auf die Nachrichten in einem asynchronen
Block</span></p>
<p>Wir beginnen mit der Erstellung eines asynchronen Kanals. Dann legen wir einen
Strang an, der für die Senderseite des Kanals zuständig ist. Innerhalb des
Strangs senden wir die Zahlen 1 bis 10 und schlafen dazwischen jeweils eine
Sekunde lang. Schließlich führen wir ein Future aus, das mit einem asynchronen
Block erstellt wurde, der an <code>trpl::run</code> übergeben wurde, so wie wir es im
ganzen Kapitel getan haben. In diesem Future warten wir auf diese Nachrichten,
genau wie in den anderen Beispielen mit Nachrichten-Weitergabe, die wir gesehen
haben.</p>
<p>Um zu den Szenarien zurückzukehren, mit denen wir das Kapitel eröffnet haben,
könnte man sich vorstellen, dass eine Reihe von Videokodierungsaufgaben über
einen dedizierten Strang ausgeführt wird, da die Videokodierung rechenintensiv
ist. Die Benutzeroberfläche kann aber über einen asynchronen Kanal informiert
werden, wenn diese Vorgänge ausgeführt werden. Es gibt unzählige Beispiele für
diese Art von Kombinationen in der Praxis.</p>
<h2 id="zusammenfassung-16"><a class="header" href="#zusammenfassung-16">Zusammenfassung</a></h2>
<p>Dies ist nicht das letzte Mal, dass du in diesem Buch etwas über
Nebenläufigkeit lesen wirst. Das Projekt in <a href="ch21-00-final-project-a-web-server.html">Kapitel 21</a> wird die
Konzepte dieses Kapitels in einer realistischeren Situation anwenden als die
hier besprochenen einfacheren Beispiele und einen direkteren Vergleich
anstellen, wie es aussieht, wenn man diese Art von Problemen mit Strängen und
mit Aufgaben und Futures löst.</p>
<p>Welchen Ansatz du auch immer wählst, Rust gibt dir die Werkzeuge an die Hand,
die du benötigst, um sicheren, schnellen und nebenläufigen Code zu schreiben
– sei es für einen durchsatzstarken Webserver oder ein eingebettetes
Betriebssystem.</p>
<p>Als nächstes werden wir über idiomatische Wege sprechen, Probleme zu
modellieren und Lösungen zu strukturieren, wenn deine Rust-Programme größer
werden. Außerdem werden wir erörtern, wie die Idiome von Rust mit denen
verwandt sind, die du vielleicht aus der objektorientierten Programmierung
kennst.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objektorientierte-sprachelemente"><a class="header" href="#objektorientierte-sprachelemente">Objektorientierte Sprachelemente</a></h1>
<p>Die objektorientierte Programmierung (OOP) ist eine Methode zur Modellierung
von Programmen. Objekte als programmatisches Konzept wurden in den 1960er
Jahren in der Programmiersprache Simula eingeführt. Diese Objekte beeinflussten
die Programmierarchitektur von Alan Kay, in der Objekte sich gegenseitig
Nachrichten übermitteln. Er prägte 1967 den Begriff <em>objektorientierte
Programmierung</em>, um diese Architektur zu beschreiben. Viele konkurrierende
Definitionen beschreiben, was OOP ist; einige Definitionen würden Rust als
objektorientiert klassifizieren, andere hingegen nicht. In diesem Kapitel
untersuchen wir bestimmte Charakteristiken, die gemeinhin als objektorientiert
gelten, und wie sich diese Charakteristiken in idiomatisches Rust übersetzen
lassen. Anschließend zeigen wir dir, wie du ein objektorientiertes
Entwurfsmuster in Rust implementieren kannst, und erörtern die Kompromisse, die
sich daraus gegenüber der Implementierung einer Lösung ergeben, die stattdessen
einige der Stärken von Rust nutzt.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="charakteristiken-objektorientierter-sprachen"><a class="header" href="#charakteristiken-objektorientierter-sprachen">Charakteristiken objektorientierter Sprachen</a></h2>
<p>Es gibt in der Programmierergemeinschaft keinen Konsens darüber, welche
Funktionalitäten eine Sprache haben muss, um als objektorientiert zu gelten.
Rust wird von vielen Programmierparadigmen beeinflusst, einschließlich OOP; zum
Beispiel haben wir in Kapitel 13 Funktionalitäten untersucht, die aus der
funktionalen Programmierung stammen. Die OOP-Sprachen haben bestimmte
gemeinsame Charakteristiken, nämlich Objekte, Kapselung (encapsulation) und
Vererbung (inheritance). Schauen wir uns an, was jedes dieser Charakteristiken
bedeutet und ob Rust es unterstützt.</p>
<h3 id="objekte-enthalten-daten-und-verhalten"><a class="header" href="#objekte-enthalten-daten-und-verhalten">Objekte enthalten Daten und Verhalten</a></h3>
<p>Das Buch <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> von
Erich Gamma, Richard Helm, Ralph Johnson und John Vlissides (Addison-Wesley,
1994), umgangssprachlich als <em>The Gang of Four</em>-Buch bezeichnet, ist ein
Katalog von objektorientierten Entwurfsmustern. Es definiert OOP auf folgende
Weise:</p>
<blockquote>
<p>Objektorientierte Programme setzen sich aus Objekten zusammen. Ein <strong>Objekt</strong>
verpackt sowohl Daten als auch Prozeduren, die auf diesen Daten operieren.
Die Prozeduren werden normalerweise <strong>Methoden</strong> oder <strong>Operationen</strong>
genannt.</p>
</blockquote>
<p>Mit dieser Definition ist Rust objektorientiert: Strukturen (structs) und
Aufzählungen (enums) haben Daten, und <code>impl</code>-Blöcke stellen Methoden auf
Strukturen und Aufzählungen zur Verfügung. Auch wenn Strukturen und
Aufzählungen mit Methoden keine <em>aufgerufenen</em> Objekte sind, bieten sie
dieselbe Funktionalität gemäß der Definition von Objekten der Gang of Four.</p>
<h3 id="kapselung-die-implementierungsdetails-verbirgt"><a class="header" href="#kapselung-die-implementierungsdetails-verbirgt">Kapselung, die Implementierungsdetails verbirgt</a></h3>
<p>Ein weiterer Aspekt, der gemeinhin mit OOP in Verbindung gebracht wird, ist die
Idee der <em>Kapselung</em> (encapsulation), was bedeutet, dass die
Implementierungsdetails eines Objekts nicht zugänglich sind für Code, der
dieses Objekt verwendet. Daher ist die einzige Möglichkeit, mit einem Objekt zu
interagieren, seine öffentliche API; Code, der das Objekt verwendet, sollte
nicht in der Lage sein, in die Interna des Objekts vorzudringen und Daten oder
Verhalten direkt zu ändern. Dies ermöglicht es dem Programmierer, die Interna
eines Objekts zu ändern und umzugestalten, ohne Code ändern zu müssen, der das
Objekt verwendet.</p>
<p>Wie man die Kapselung steuert, haben wir in Kapitel 7 besprochen: Wir können
das Schlüsselwort <code>pub</code> benutzen, um zu entscheiden, welche Module, Typen,
Funktionen und Methoden in unserem Code öffentlich sein sollen, alles andere
ist standardmäßig privat. Zum Beispiel können wir eine Struktur
<code>AveragedCollection</code> definieren, die ein Feld hat, das einen Vektor mit
<code>i32</code>-Werten enthält. Die Struktur kann auch ein Feld haben, das den Mittelwert
der Werte im Vektor enthält, was bedeutet, dass der Mittelwert nicht auf
Anfrage berechnet werden muss, wenn jemand ihn braucht. Mit anderen Worten:
<code>AveragedCollection</code> wird den errechneten Durchschnitt für uns
zwischenspeichern. Codeblock 18-1 zeigt die Definition der Struktur
<code>AveragedCollection</code>:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-1: Eine Struktur <code>AveragedCollection</code>, die
eine Liste von ganzen Zahlen und deren Durchschnitt verwaltet</span></p>
<p>Die Struktur wird als <code>pub</code> markiert, damit anderer Code sie verwenden kann,
aber die Felder innerhalb der Struktur bleiben privat. Dies ist in diesem Fall
wichtig, weil wir sicherstellen wollen, dass immer dann, wenn ein Wert
hinzugefügt oder aus der Liste entfernt wird, auch der Durchschnitt
aktualisiert wird. Wir tun dies, indem wir die Methoden <code>add</code>, <code>remove</code> und
<code>average</code> auf der Struktur implementieren, wie in Codeblock 18-2 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-2: Implementierungen der öffentlichen
Methoden <code>add</code>, <code>remove</code> und <code>average</code> auf  <code>AveragedCollection</code></span></p>
<p>Die öffentlichen Methoden <code>add</code>, <code>remove</code> und <code>average</code> sind die einzigen
Möglichkeiten, auf Daten in einer <code>AveragedCollection</code>-Instanz zuzugreifen oder
sie zu ändern. Wenn ein Eintrag mit der Methode <code>add</code> zu <code>list</code> hinzugefügt
oder mit der Methode <code>remove</code> entfernt wird, rufen die Implementierungen der
einzelnen Methoden die private Methode <code>update_average</code> auf, die auch das
Aktualisieren des Feldes <code>average</code> übernimmt.</p>
<p>Wir lassen die Felder <code>list</code> und <code>average</code> privat, sodass es keine Möglichkeit
für externen Code gibt, Elemente direkt zum Feld <code>list</code> hinzuzufügen oder zu
entfernen; andernfalls könnte das Feld <code>average</code> inkonsistent werden, wenn sich
<code>list</code> ändert. Die Methode <code>average</code> gibt den Wert im Feld <code>average</code> zurück,
sodass externer Code den Wert <code>average</code> lesen, aber nicht verändern kann.</p>
<p>Da wir die Implementierungsdetails der Struktur <code>AveragedCollection</code> gekapselt
haben, können wir Aspekte wie die Datenstruktur in Zukunft leicht ändern. Zum
Beispiel könnten wir ein <code>HashSet&lt;i32&gt;</code> anstelle eines <code>Vec&lt;i32&gt;</code> für das Feld
<code>list</code> verwenden. Solange die Signaturen der öffentlichen Methoden <code>add</code>,
<code>remove</code> und <code>average</code> gleich bleiben, würde Code, der <code>AveragedCollection</code>
verwendet, nicht geändert werden müssen damit er kompiliert. Wenn wir
stattdessen <code>list</code> öffentlich machen würden, wäre dies nicht unbedingt der
Fall: <code>HashSet&lt;i32&gt;</code> und <code>Vec&lt;i32&gt;</code> haben unterschiedliche Methoden zum
Hinzufügen und Entfernen von Elementen, sodass externer Code wahrscheinlich
geändert werden müsste, wenn er <code>list</code> direkt modifizieren würde.</p>
<p>Wenn die Kapselung ein erforderlicher Aspekt ist, damit eine Sprache als
objektorientiert betrachtet werden kann, dann erfüllt Rust diese Anforderung.
Die Möglichkeit, <code>pub</code> für verschiedene Teile des Codes zu verwenden oder auch
nicht, ermöglicht die Kapselung von Implementierungsdetails.</p>
<h3 id="vererbung-als-typsystem-und-für-gemeinsamen-code"><a class="header" href="#vererbung-als-typsystem-und-für-gemeinsamen-code">Vererbung als Typsystem und für gemeinsamen Code</a></h3>
<p><em>Vererbung</em> ist ein Mechanismus, mit dem ein Objekt Elemente von der Definition
eines anderen Objekts erben kann und so die Daten und das Verhalten des
übergeordneten Objekts erhält, ohne dass du diese erneut definieren musst.</p>
<p>Wenn eine Programmiersprache Vererbung haben muss, um objektorientiert zu sein,
dann ist Rust keine solche Sprache. Es gibt keine Möglichkeit, eine Struktur zu
definieren, die die Felder und Methodenimplementierungen der Elternstruktur
erbt, ohne ein Makro zu benutzen.</p>
<p>Wenn du jedoch daran gewöhnt bist, Vererbung in deinem
Programmierwerkzeugkasten zu haben, kannst du in Rust andere Lösungen
verwenden, je nachdem, warum du überhaupt zu Vererbung gegriffen hast.</p>
<p>Du würdest dich aus zwei Hauptgründen für die Vererbung entscheiden. Einer ist
die Wiederverwendung von Code: Du kannst ein bestimmtes Verhalten für einen Typ
implementieren und die Vererbung ermöglicht es dir, diese Implementierung für
einen anderen Typ wiederzuverwenden. Du kannst das auf begrenzte Weise in
Rust-Code unter Verwendung von Standard-Merkmalsmethoden-Implementierungen tun,
was du in Codeblock 10-14 gesehen hast, als wir eine Standard-Implementierung
der Methode <code>summarize</code> für das Merkmal (trait) <code>Summary</code> hinzugefügt haben.
Jeder Typ, der das Merkmal <code>Summary</code> implementiert, hätte die Methode
<code>summarize</code> ohne weiteren Code darauf zur Verfügung. Dies ist vergleichbar mit
einer Elternklasse, die eine Implementierung einer Methode hat, und einer
erbenden Kindklasse, die ebenfalls die Implementierung der Methode hat. Wir
können auch die Standard-Implementierung der Methode <code>summarize</code> überschreiben,
wenn wir das Markmal <code>Summary</code> implementieren, die einer Kindklasse ähnelt, die
die Implementierung einer von einer Elternklasse geerbten Methode überschreibt.</p>
<p>Der andere Grund, Vererbung zu verwenden, bezieht sich auf das Typsystem: Ein
untergeordneter Typ soll an den gleichen Stellen wie der übergeordnete Typ
verwendet werden können. Dies wird auch <em>Polymorphismus</em> (polymorphism)
genannt, d.h. du kannst mehrere Objekte zur Laufzeit gegeneinander austauschen,
wenn sie bestimmte Eigenschaften gemeinsam haben.</p>
<blockquote>
<h3 id="polymorphismus"><a class="header" href="#polymorphismus">Polymorphismus</a></h3>
<p>Für viele Menschen ist Polymorphismus gleichbedeutend mit Vererbung. Aber es
ist eigentlich ein allgemeinerer Begriff, der sich auf Code bezieht, der mit
Daten unterschiedlichen Typs arbeiten kann. Für die Vererbung sind diese
Typen im Allgemeinen Unterklassen.</p>
<p>Rust verwendet stattdessen generische Datentypen (generics), um über
verschiedene mögliche Typen und Merkmalsabgrenzungen (trait bounds) zu
abstrahieren, um Beschränkungen für das aufzuerlegen, was diese Typen bieten
müssen. Dies wird manchmal als <em>begrenzter parametrischer Polymorphismus</em>
(bounded parametric polymorphism) bezeichnet.</p>
</blockquote>
<p>Die Vererbung als Programmierdesignlösung ist in letzter Zeit bei vielen
Programmiersprachen in Ungnade gefallen, da sie oft das Risiko birgt, mehr Code
als nötig zu teilen. Unterklassen sollten nicht immer alle Charakteristiken
ihrer Elternklasse teilen, bei Vererbung tun sie es aber. Dies kann den
Programmentwurf weniger flexibel machen. Es wird auch die Möglichkeit
eingeführt, Methoden auf Unterklassen aufzurufen, die keinen Sinn machen oder
die Fehler verursachen, weil die Methoden nicht auf die Unterklasse zutreffen.
Darüber hinaus lassen einige Sprachen nur Einfachvererbung zu (d.h. eine
Unterklasse kann nur von einer Klasse erben), was die Flexibilität des
Programmdesigns weiter einschränkt.</p>
<p>Aus diesen Gründen verfolgt Rust den anderen Ansatz mittels Verwendung von
Merkmalsobjekten (trait objects) anstelle der Vererbung. Schauen wir uns an,
wie Merkmalsobjekte Polymorphismus in Rust ermöglichen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="merkmalsobjekte-trait-objects-die-werte-unterschiedlicher-typen-erlauben"><a class="header" href="#merkmalsobjekte-trait-objects-die-werte-unterschiedlicher-typen-erlauben">Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen erlauben</a></h2>
<p>In Kapitel 8 haben wir erwähnt, dass eine Einschränkung von Vektoren darin
besteht, dass sie nur Elemente eines einzigen Typs speichern können. Wir haben
in Codeblock 8-9 eine Abhilfe geschaffen, indem wir die Aufzählung (enum)
<code>SpreadsheetCell</code> definiert haben, die Varianten zur Aufnahme von Ganzzahlen,
Fließkommazahlen und Text enthielt. Das bedeutete, dass wir in jeder Zelle
verschiedene Datentypen speichern konnten und trotzdem einen Vektor hatten, der
eine Reihe von Zellen darstellte. Dies ist eine perfekte Lösung, wenn unsere
austauschbaren Elemente ein fester Satz von Typen sind, die wir kennen, wenn
unser Code kompiliert wird.</p>
<p>Manchmal möchten wir jedoch, dass unsere Bibliotheksbenutzer in der Lage sind,
die möglichen Typen, die in einer bestimmten Situation erlaubt sind, zu
erweitern. Um zu zeigen, wie wir dies erreichen können, werden wir ein Beispiel
für ein GUI-Werkzeug (Graphical User Interface) erstellen, das über eine Liste
von Elementen iteriert, wobei auf jedem Element eine Methode <code>draw</code> aufgerufen
wird, um es auf den Bildschirm zu zeichnen – eine übliche Technik bei
GUI-Werkzeugen. Wir werden eine Bibliothekskiste (library crate) namens <code>gui</code>
erstellen, die die Struktur einer GUI-Bibliothek enthält. Diese Kiste (crate)
könnte einige Typen enthalten, die Leute benutzen können, z.B. <code>Button</code> und
<code>TextField</code>. Darüber hinaus werden <code>gui</code>-Benutzer ihre eigenen Typen erstellen
wollen, die gezeichnet werden können: Zum Beispiel könnte ein Programmierer ein
<code>Image</code> und ein anderer eine <code>SelectBox</code> hinzufügen.</p>
<p>Wir werden für dieses Beispiel keine vollwertige GUI-Bibliothek implementieren,
aber wir werden zeigen, wie die Teile zusammenpassen würden. Zum Zeitpunkt des
Schreibens der Bibliothek können wir nicht alle Typen kennen und definieren,
die andere Programmierer vielleicht erstellen möchten. Aber wir wissen, dass
<code>gui</code> den Überblick über viele Werte unterschiedlicher Typen behalten muss, und
es muss für jeden dieser unterschiedlich typisierten Werte eine Methode <code>draw</code>
aufrufen. Es muss nicht genau wissen, was passieren wird, wenn wir die Methode
<code>draw</code> aufrufen, sondern nur, dass der Typ diese Methode für uns zum Aufruf
bereithält.</p>
<p>Um dies in einer Sprache mit Vererbung zu tun, könnten wir eine Klasse namens
<code>Component</code> definieren, die eine Methode namens <code>draw</code> enthält. Die anderen
Klassen, z.B. <code>Button</code>, <code>Image</code> und <code>SelectBox</code>, würden von <code>Component</code> erben
und somit die Methode <code>draw</code> erben. Sie könnten jeweils die Methode <code>draw</code>
überschreiben, um ihr eigenes Verhalten zu definieren, aber das
Programmiergerüst (framework) könnte alle Typen so behandeln, als wären sie
<code>Component</code>-Instanzen, und <code>draw</code> aufrufen. Aber da Rust keine Vererbung hat,
brauchen wir einen anderen Weg, die <code>gui</code>-Bibliothek zu strukturieren, damit
die Benutzer sie um neue Typen erweitern können.</p>
<h3 id="definieren-eines-merkmals-trait-für-allgemeines-verhalten"><a class="header" href="#definieren-eines-merkmals-trait-für-allgemeines-verhalten">Definieren eines Merkmals (trait) für allgemeines Verhalten</a></h3>
<p>Um das Verhalten zu implementieren, das wir in <code>gui</code> haben wollen, werden wir
ein Merkmal namens <code>Draw</code> definieren, das eine Methode namens <code>draw</code> haben
wird. Dann können wir einen Vektor definieren, der ein Merkmalsobjekt annimmt.
Ein <em>Merkmalsobjekt</em> (trait object) verweist sowohl auf eine Instanz eines
Typs, der das von uns spezifizierte Merkmal implementiert, und eine Tabelle, in
der Merkmalsmethoden dieses Typs zur Laufzeit nachgeschlagen werden können. Wir
erstellen ein Merkmalsobjekt, indem wir eine Art Zeiger angeben, z.B. eine
Referenz <code>&amp;</code> oder einen intelligenten Zeiger <code>Box&lt;T&gt;</code>, dann das Schlüsselwort
<code>dyn</code> und dann das relevante Merkmal. (Wir werden über den Grund, warum
Merkmalsobjekte einen Zeiger verwenden müssen, in <a href="ch20-03-advanced-types.html#dynamisch-gro%C3%9Fe-typen-und-das-merkmal-sized">„Dynamisch große Typen und
das Merkmal <code>Sized</code>“</a> in Kapitel 20 sprechen.) Wir können
Merkmalsobjekte an Stelle eines generischen oder konkreten Typs verwenden. Wo
immer wir ein Merkmalsobjekt verwenden, stellt Rusts Typsystem zur
Kompilierzeit sicher, dass jeder in diesem Kontext verwendete Wert das Merkmal
des Merkmalsobjekts implementiert. Folglich müssen wir zur Kompilierzeit nicht
alle möglichen Typen kennen.</p>
<p>Wir haben erwähnt, dass wir in Rust davon absehen, Strukturen (structs) und
Aufzählungen „Objekte“ zu nennen, um sie von den Objekten anderer Sprachen zu
unterscheiden. In einer Struktur oder Aufzählung sind die Daten in den
Struktur-Feldern vom Verhalten in <code>impl</code>-Blöcken getrennt, während in anderen
Sprachen die Daten und das Verhalten, die in einem Konzept zusammengefasst
sind, oft als ein Objekt bezeichnet werden. Merkmalsobjekte <em>sind</em> jedoch eher
wie Objekte in anderen Sprachen in dem Sinne, dass sie Daten und Verhalten
kombinieren. Aber Merkmalsobjekte unterscheiden sich von traditionellen
Objekten dadurch, dass wir einem Merkmalsobjekt keine Daten hinzufügen können.
Merkmalsobjekte sind nicht so allgemein einsetzbar wie Objekte in anderen
Sprachen: Ihr spezifischer Zweck besteht darin, Abstraktion über allgemeines
Verhalten zu ermöglichen.</p>
<p>In Codeblock 18-3 wird gezeigt, wie ein Merkmal <code>Draw</code> mit einer Methode <code>draw</code>
definiert werden kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
    fn draw(&amp;self);
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-3: Definition des Merkmals <code>Draw</code></span></p>
<p>Diese Syntax sollte uns aus unseren Diskussionen über die Definition von
Merkmalen in Kapitel 10 bekannt vorkommen. Als nächstes kommt eine neue Syntax:
Codeblock 18-4 definiert eine Struktur namens <code>Screen</code>, die einen Vektor namens
<code>components</code> enthält. Dieser Vektor ist vom Typ <code>Box&lt;dyn Draw&gt;</code>, der ein
Merkmalsobjekt ist; er ist ein Stellvertreter für jeden Typ innerhalb einer
<code>Box</code>, der das Merkmal <code>Draw</code> implementiert.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-4: Definition der Struktur <code>Screen</code> mit
einem Feld <code>components</code>, das einen Vektor von Merkmalsobjekten enthält, die das
Merkmal <code>Draw</code> implementieren</span></p>
<p>Auf der Struktur <code>Screen</code> definieren wir eine Methode namens <code>run</code>, die die
Methode <code>draw</code> auf jeder ihrer <code>components</code> aufruft, wie in Codeblock 18-5
gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-5: Eine Methode <code>run</code> auf <code>Screen</code>, die die
Methode <code>draw</code> jeder Komponente aufruft</span></p>
<p>Dies funktioniert anders als die Definition einer Struktur, die einen
generischen Typparameter mit Merkmalsabgrenzungen (trait bounds) verwendet. Ein
generischer Typparameter kann jeweils nur durch einen konkreten Typ ersetzt
werden, während Merkmalsobjekte die Möglichkeit bieten, zur Laufzeit mehrere
konkrete Typen für das Merkmalsobjekt einzusetzen. Beispielsweise hätten wir
die Struktur <code>Screen</code> mit einem generischen Typ und einer Merkmalsabgrenzung
wie in Codeblock 18-6 definieren können:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-6: Eine alternative Implementierung der
Struktur <code>Screen</code> und ihrer Methode <code>run</code> unter Verwendung generischer Typen
und Merkmalsabgrenzungen</span></p>
<p>Dies schränkt uns auf eine <code>Screen</code>-Instanz ein, die eine Liste von Komponenten
hat, die alle vom Typ <code>Button</code> oder alle vom Typ <code>TextField</code> sind. Wenn du
immer nur homogene Kollektionen haben wirst, ist das Verwenden von generischen
Typen und Merkmalsabgrenzungen vorzuziehen, da die Definitionen zur
Kompilierszeit monomorphisiert werden, um die konkreten Typen zu verwenden.</p>
<p>Andererseits kann bei der Methode mit Merkmalsobjekten eine <code>Screen</code>-Instanz
einen <code>Vec&lt;T&gt;</code> enthalten, der sowohl eine <code>Box&lt;Button&gt;</code> als auch eine
<code>Box&lt;TextField&gt;</code> enthält. Schauen wir uns an, wie dies funktioniert, und dann
werden wir über die Auswirkungen auf die Laufzeitperformanz sprechen.</p>
<h3 id="implementieren-des-merkmals"><a class="header" href="#implementieren-des-merkmals">Implementieren des Merkmals</a></h3>
<p>Nun fügen wir einige Typen hinzu, die das Merkmal <code>Draw</code> implementieren. Wir
werden den Typ <code>Button</code> zur Verfügung stellen. Auch hier liegt die eigentliche
Implementierung einer GUI-Bibliothek jenseits des Rahmens dieses Buches, sodass
die Methode <code>draw</code> keine nützliche Implementierung in ihrem Rumpf haben wird.
Um sich vorzustellen, wie die Implementierung aussehen könnte, könnte eine
Struktur <code>Button</code> Felder für <code>width</code>, <code>height</code> und <code>label</code> haben, wie in
Codeblock 18-7 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // Code zum tatsächlichen Zeichnen einer Schaltfläche
    }
}</code></pre>
<p><span class="caption">Codeblock 18-7: Eine Struktur <code>Button</code>, die das Merkmal
<code>Draw</code> implementiert</span></p>
<p>Die Felder <code>width</code>, <code>height</code> und <code>label</code> in <code>Button</code> unterscheiden sich von den
Feldern anderer Komponenten; beispielsweise könnte ein Typ <code>TextField</code> diese
Felder und zusätzlich ein <code>placeholder</code> haben. Jeder der Typen, die wir auf dem
Bildschirm zeichnen wollen, wird das Merkmal <code>Draw</code> implementieren, aber
unterschiedlichen Code in der Methode <code>draw</code> verwenden, um zu definieren, wie
dieser bestimmte Typ gezeichnet werden soll, wie es hier bei <code>Button</code> der Fall
ist (ohne wie erwähnt den eigentlichen GUI-Code). Der Typ <code>Button</code> könnte zum
Beispiel einen zusätzlichen <code>impl</code>-Block haben, der Methoden enthält, die sich
darauf beziehen, was passiert, wenn ein Benutzer auf die Schaltfläche klickt.
Diese Art von Methoden trifft nicht auf Typen wie <code>TextField</code> zu.</p>
<p>Wenn sich jemand, der unsere Bibliothek benutzt, dazu entschließt, eine
Struktur <code>SelectBox</code> zu implementieren, die die Felder <code>width</code>, <code>height</code> und
<code>options</code> enthält, würde er ebenfalls das Merkmal <code>Draw</code> für den Typ
<code>SelectBox</code> implementieren, wie in Codeblock 18-8 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // Code zum tatsächlichen Zeichnen eines Auswahlfeldes
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p><span class="caption">Codeblock 18-8: Eine andere Kiste, die <code>gui</code> verwendet
und das Merkmal <code>Draw</code> auf einer Struktur <code>SelectBox</code> implementiert</span></p>
<p>Der Benutzer unserer Bibliothek kann nun seine Funktion <code>main</code> schreiben, um
eine <code>Screen</code>-Instanz zu erzeugen. Der <code>Screen</code>-Instanz kann er eine
<code>SelectBox</code> und einen <code>Button</code> hinzufügen, indem er sie in eine <code>Box&lt;T&gt;</code> legt,
um ein Merkmalsobjekt zu werden. Er kann dann die Methode <code>run</code> auf der
<code>Screen</code>-Instanz aufrufen, die dann <code>draw</code> auf jeder der Komponenten aufruft.
Der Codeblock 18-9 zeigt diese Umsetzung:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // Code zum tatsächlichen Zeichnen eines Auswahlfeldes
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Ja"),
                    String::from("Vielleicht"),
                    String::from("Nein"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Codeblock 18-9: Verwenden von Merkmalsobjekten zum
Speichern von Werten verschiedener Typen, die das gleiche Merkmal
implementieren</span></p>
<p>Als wir die Bibliothek schrieben, wussten wir nicht, dass jemand den Typ
<code>SelectBox</code> hinzufügen könnte, aber unsere <code>Screen</code>-Implementierung war in der
Lage, mit dem neuen Typ umzugehen und ihn zu zeichnen, weil <code>SelectBox</code> das
Merkmal <code>Draw</code> implementiert, was bedeutet, dass sie die Methode <code>draw</code>
implementiert.</p>
<p>Dieses Konzept – sich nur mit den Nachrichten zu befassen, auf die ein
Wert reagiert, und nicht mit dem konkreten Typ des Wertes – ähnelt dem
Konzept des <em>Duck-Typing</em> in dynamisch typisierten Sprachen: Wenn es wie eine
Ente läuft und wie eine Ente quakt, dann muss es eine Ente sein! Bei der
Implementierung von <code>run</code> auf <code>Screen</code> in Codeblock 18-5 braucht <code>run</code> nicht zu
wissen, was der konkrete Typ jeder Komponente ist. Es prüft nicht, ob eine
Komponente eine Instanz eines <code>Buttons</code> oder einer <code>SelectBox</code> ist, es ruft nur
die Methode <code>draw</code> auf der Komponente auf. Durch die Spezifikation von
<code>Box&lt;dyn Draw&gt;</code> als Typ der Werte im Vektor <code>components</code> haben wir <code>Screen</code> so
definiert, dass wir Werte benötigen, auf denen wir die Methode <code>draw</code> aufrufen
können.</p>
<p>Der Vorteil der Verwendung von Merkmalsobjekten und des Rust-Typsystems zum
Schreiben von Code, der dem Code mit Duck-Typing ähnelt, besteht darin, dass
wir nie prüfen müssen, ob ein Wert eine bestimmte Methode zur Laufzeit
implementiert, oder uns Sorgen machen müssen, Fehler zu bekommen, wenn ein Wert
eine Methode nicht implementiert, wir sie aber trotzdem aufrufen. Rust wird
unseren Code nicht kompilieren, wenn die Werte nicht die Merkmale
implementieren, die die Merkmalsobjekte benötigen.</p>
<p>Beispielsweise zeigt Codeblock 18-10, was passiert, wenn wir versuchen, einen
<code>Screen</code> mit einem <code>String</code> als Komponente zu erstellen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from("Hallo"))],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Codeblock 18-10: Versuch, einen Typ zu verwenden, der das
Merkmal des Merkmalsobjekts nicht implementiert</span></p>
<p>Wir werden diesen Fehler erhalten, weil <code>String</code> das Merkmal <code>Draw</code> nicht
implementiert:</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from("Hallo"))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = help: the trait `Draw` is implemented for `Button`
  = note: required for the cast from `Box&lt;String&gt;` to `Box&lt;dyn Draw&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` (bin "gui") due to 1 previous error
</code></pre>
<p>Dieser Fehler lässt uns wissen, dass wir entweder etwas an <code>Screen</code> übergeben,
das wir nicht übergeben wollten und einen anderen Typ übergeben sollten, oder
wir sollten <code>Draw</code> auf <code>String</code> implementieren, sodass <code>Screen</code> in der Lage
ist, <code>Draw</code> darauf aufzurufen.</p>
<h3 id="merkmalsobjekte-führen-dynamischen-aufruf-durch"><a class="header" href="#merkmalsobjekte-führen-dynamischen-aufruf-durch">Merkmalsobjekte führen dynamischen Aufruf durch</a></h3>
<p>Erinnere dich <a href="ch10-01-syntax.html#code-performanz-beim-verwenden-generischer-datentypen">„Code-Performanz beim Verwenden generischer
Datentypen“</a> in Kapitel 10 an unsere
Diskussion über den Monomorphisierungsprozess bei generischen Typen, den der
Compiler durchführt: Der Compiler generiert nicht-generische Implementierungen
von Funktionen und Methoden für jeden konkreten Typ, den wir anstelle eines
generischen Typparameters verwenden. Der Code, der sich aus der
Monomorphisierung ergibt, macht <em>statische Aufrufe</em> (static dispatch), d.h.
der Compiler weiß, welche Methode du zur Kompilierzeit aufrufst. Dies steht im
Gegensatz zum <em>dynamischen Aufruf</em> (dynamic dispatch), bei dem der Compiler zur
Kompilierzeit nicht weiß, welche Methode du aufrufst. In Fällen von dynamischem
Aufruf erzeugt der Compiler Code, der zur Laufzeit herausfindet, welche Methode
aufzurufen ist.</p>
<p>Wenn wir Merkmalsobjekte verwenden, muss Rust dynamische Aufrufe verwenden. Der
Compiler kennt nicht alle Typen, die mit dem Code verwendet werden könnten, der
Merkmalsobjekte verwendet, sodass er nicht weiß, welche Methode auf welchem Typ
implementiert ist, um sie aufzurufen. Stattdessen verwendet Rust zur Laufzeit
die Zeiger innerhalb des Merkmalsobjekts, um zu wissen, welche Methode
aufgerufen werden soll. Dieses Nachschlagen verursacht Laufzeitkosten, die
beim statischen Aufruf nicht anfallen. Der dynamische Aufruf verhindert auch,
dass der Compiler sich dafür entscheiden kann, den Code einer Methode inline zu
verwenden, was wiederum einige Optimierungen verhindert. Und Rust hat einige
Regeln, genannt <em>dyn compatibility</em>, wo man dynamische Aufrufe verwenden kann
und wo nicht. Diese Regeln gehen über den Rahmen dieser Diskussion hinaus, aber
du kannst mehr über sie in der
<a href="https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility">Dyn-Kompatibilitäts-Referenz</a> lesen. Wir haben jedoch
zusätzliche Flexibilität im Code erhalten, den wir in Codeblock 18-5
geschrieben haben und in Codeblock 18-9 unterstützen konnten, sodass es sich um
einen Kompromiss handelt, den es zu berücksichtigen gilt.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ein-objektorientiertes-entwurfsmuster-implementieren"><a class="header" href="#ein-objektorientiertes-entwurfsmuster-implementieren">Ein objektorientiertes Entwurfsmuster implementieren</a></h2>
<p>Das <em>Zustandsmuster</em> (state pattern) ist ein objektorientiertes Entwurfsmuster.
Der Kernpunkt des Musters besteht darin, dass wir eine Reihe von Zuständen
definieren, die ein Wert intern annehmen kann. Die Zustände werden durch eine
Reihe von <em>Zustandsobjekten</em> (state objects) dargestellt, und das Verhalten des
Wertes ändert sich je nach Zustand. Wir werden ein Beispiel für eine
Blog-Beitrags-Struktur durcharbeiten, die ein Feld für ihren Status hat, das
ein Statusobjekt mit den Möglichkeiten „Entwurf“, „Überprüfung“ und
„Veröffentlicht“ sein wird.</p>
<p>Die Zustandsobjekte haben eine gemeinsame Funktionalität: In Rust verwenden wir
Strukturen (structs) und Merkmale (traits) und nicht Objekte und Vererbung.
Jedes Zustandsobjekt ist für sein eigenes Verhalten verantwortlich und
bestimmt, wann es in einen anderen Zustand übergehen soll. Der Wert, den ein
Zustandsobjekt enthält, weiß nichts über das unterschiedliche Verhalten der
Zustände oder den Zeitpunkt des Übergangs zwischen den Zuständen.</p>
<p>Der Vorteil der Verwendung des Zustandsmusters besteht darin, dass wir, wenn
sich die geschäftlichen Anforderungen des Programms ändern, weder den Code des
Werts, der den Zustand hält, noch den Code, der den Wert verwendet, ändern
müssen. Wir müssen nur den Code in einem der Zustandsobjekte aktualisieren, um
seine Regeln zu ändern oder vielleicht weitere Zustandsobjekte hinzuzufügen.</p>
<p>Zunächst werden wir das Zustandsmuster auf eine traditionellere
objektorientierte Weise implementieren, dann werden wir einen Ansatz verwenden,
der in Rust etwas natürlicher ist. Beginnen wir mit der inkrementellen
Implementierung eines Blogbeitrag-Workflows unter Verwendung des
Zustandsmusters.</p>
<p>Die finale Funktionalität des Blogs wird wie folgt aussehen:</p>
<ol>
<li>Ein Blog-Beitrag (post) beginnt als leerer Entwurf.</li>
<li>Wenn der Entwurf fertig ist, wird um eine Überprüfung des Beitrags gebeten.</li>
<li>Wenn der Beitrag genehmigt ist, wird er veröffentlicht.</li>
<li>Nur veröffentlichte Blog-Beiträge geben anzuzeigenden Inhalt zurück, sodass
nicht genehmigte Beiträge nicht versehentlich veröffentlicht werden können.</li>
</ol>
<p>Alle anderen Änderungen, die an einem Beitrag versucht werden, sollten keine
Auswirkungen haben. Wenn wir zum Beispiel versuchen, den Entwurf eines
Blog-Beitrags zu genehmigen, bevor wir eine Überprüfung beantragt haben, sollte
der Beitrag ein unveröffentlichter Entwurf bleiben.</p>
<p>Codeblock 18-11 zeigt diesen Workflow in Codeform: Dies ist eine
Beispielverwendung der API, die wir in einer Bibliothekskiste (library crate)
<code>blog</code> implementieren werden. Dieser Code wird sich noch nicht kompilieren
lassen, da wir die Kiste (crate) <code>blog</code> noch nicht implementiert haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("Ich habe heute Mittag einen Salat gegessen");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("Ich habe heute Mittag einen Salat gegessen", post.content());
}</code></pre>
<p><span class="caption">Codeblock 18-11: Code, der das gewünschte Verhalten
demonstriert, das wir für unsere Kiste <code>blog</code> haben wollen</span></p>
<p>Wir möchten dem Benutzer erlauben, einen neuen Entwurf eines Blog-Beitrags mit
<code>Post::new</code> zu erstellen. Wir möchten dem Blog-Beitrag erlauben, Text
hinzuzufügen. Wenn wir versuchen, den Inhalt des Beitrags sofort, also vor der
Genehmigung, abzurufen, sollten wir keinen Text erhalten, da der Beitrag noch
ein Entwurf ist. Wir haben zu Demonstrationszwecken <code>assert_eq!</code> in den Code
eingefügt. Ein ausgezeichneter Modultest dafür wäre die Zusicherung, dass ein
Entwurf eines Blog-Beitrags eine leere Zeichenkette aus der Methode <code>content</code>
zurückgibt, aber wir werden für dieses Beispiel keine Tests schreiben.</p>
<p>Als nächstes wollen wir einen Antrag auf Überprüfung des Beitrags ermöglichen
und wir wollen, dass <code>content</code> eine leere Zeichenkette zurückgibt, solange wir
auf die Überprüfung warten. Wenn der Beitrag die Genehmigung erhält, soll er
veröffentlicht werden, d.h. der Text des Beitrags wird zurückgegeben, wenn
<code>content</code> aufgerufen wird.</p>
<p>Beachte, dass der einzige Typ, mit dem wir von der Kiste aus interagieren, der
Typ <code>Post</code> ist. Dieser Typ verwendet das Zustandsmuster und enthält einen Wert,
der eines von drei Zustandsobjekten ist, die die verschiedenen Zustände
repräsentieren, in denen sich ein Beitrag im Entwurf befinden, auf eine
Überprüfung warten oder veröffentlicht werden kann. Der Wechsel von einem
Zustand in einen anderen wird intern innerhalb des Typs <code>Post</code> verwaltet. Die
Zustände ändern sich als Reaktion auf die Methoden, die von den Benutzern
unserer Bibliothek auf der <code>Post</code>-Instanz aufgerufen werden, aber sie müssen
die Zustandsänderungen nicht direkt verwalten. Auch können die Benutzer keinen
Fehler mit den Zuständen machen, z.B. einen Beitrag veröffentlichen, bevor er
überprüft wurde.</p>
<h3 id="definieren-von-post-und-erstellen-einer-neuen-instanz-im-entwurfszustand"><a class="header" href="#definieren-von-post-und-erstellen-einer-neuen-instanz-im-entwurfszustand">Definieren von <code>Post</code> und Erstellen einer neuen Instanz im Entwurfszustand</a></h3>
<p>Fangen wir mit der Implementierung der Bibliothek an! Wir wissen, dass wir eine
öffentliche Struktur <code>Post</code> benötigen, die einige Inhalte enthält, also
beginnen wir mit der Definition der Struktur und einer zugehörigen öffentlichen
Funktion <code>new</code>, um eine Instanz von <code>Post</code> zu erzeugen, wie in Codeblock 18-12
gezeigt. Wir werden auch ein privates Merkmal <code>State</code> erstellen, das das
Verhalten definiert, das alle Zustandsobjekte für einen <code>Post</code> haben müssen.</p>
<p>Dann wird <code>Post</code> ein Merkmalsobjekt (trait object) von <code>Box&lt;dyn State&gt;</code>
innerhalb einer <code>Option&lt;T&gt;</code> in einem privaten Feld namens <code>state</code> halten, um
das Zustandsobjekt zu halten. Du wirst gleich sehen, warum die <code>Option&lt;T&gt;</code>
notwendig ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-12: Definition einer Struktur <code>Post</code> und
einer Funktion <code>new</code>, die eine neue <code>Post</code>-Instanz, ein Merkmal <code>State</code> sowie
eine Struktur <code>Draft</code> erzeugt</span></p>
<p>Das Merkmal <code>State</code> definiert das Verhalten, das die verschiedenen
Beitragszustände gemeinsam haben. Die Zustandsobjekte sind <code>Draft</code>,
<code>PendingReview</code> und <code>Published</code> und sie werden alle das Merkmal <code>State</code>
implementieren. Im Moment hat das Merkmal noch keine Methoden und wir werden
damit beginnen, nur den Zustand <code>Draft</code> zu definieren, weil das der Zustand
ist, in dem ein Beitrag beginnen soll.</p>
<p>Wenn wir einen neuen <code>Post</code> erstellen, setzen wir sein <code>state</code>-Feld auf einen
<code>Some</code>-Wert, der eine <code>Box</code> enthält. Diese <code>Box</code> verweist auf eine neue Instanz
der Struktur <code>Draft</code>. Dies stellt sicher, dass jedes Mal, wenn wir eine neue
Instanz von <code>Post</code> erzeugen, diese als Entwurf beginnt. Da das Feld <code>state</code> von
<code>Post</code> privat ist, gibt es keine Möglichkeit, ein <code>Post</code> in einem anderen
Zustand zu erzeugen! In der Funktion <code>Post::new</code> setzen wir das Feld <code>content</code>
auf einen neuen, leeren <code>String</code>.</p>
<h3 id="speichern-des-textes-des-beitragsinhalts"><a class="header" href="#speichern-des-textes-des-beitragsinhalts">Speichern des Textes des Beitragsinhalts</a></h3>
<p>Wir haben in Codeblock 18-11 gesehen, dass wir in der Lage sein wollen, eine
Methode namens <code>add_text</code> aufzurufen und ihr einen <code>&amp;str</code> zu übergeben, die
dann als Textinhalt des Blog-Beitrags hinzugefügt wird. Wir implementieren dies
als Methode, anstatt das Feld <code>content</code> mit <code>pub</code> offenzulegen, damit wir
später eine Methode implementieren können, die steuert, wie die Daten des
Feldes <code>content</code> gelesen werden. Die Methode <code>add_text</code> ist ziemlich einfach,
also lass uns die Implementierung in Codeblock 18-13 zum Block <code>impl Post</code>
hinzufügen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-13: Implementierung der Methode <code>add_text</code>
zum Hinzufügen von Text zum <code>content</code> eines Beitrags</span></p>
<p>Die Methode <code>add_text</code> nimmt eine veränderbare Referenz auf <code>self</code>, weil wir
die <code>Post</code>-Instanz, auf der wir <code>add_text</code> aufrufen, ändern. Dann rufen wir
<code>push_str</code> auf den <code>String</code> in <code>content</code> auf und übergeben das Argument <code>text</code>,
um es zum gespeicherten <code>content</code> hinzuzufügen. Dieses Verhalten hängt nicht
vom Zustand ab, in dem sich der Beitrag befindet, es ist also nicht Teil des
Zustandsmusters. Die Methode <code>add_text</code> interagiert überhaupt nicht mit dem
Feld <code>state</code>, aber sie ist Teil des Verhaltens, das wir unterstützen wollen.</p>
<h3 id="sicherstellen-dass-der-inhalt-eines-beitragsentwurfs-leer-ist"><a class="header" href="#sicherstellen-dass-der-inhalt-eines-beitragsentwurfs-leer-ist">Sicherstellen, dass der Inhalt eines Beitragsentwurfs leer ist</a></h3>
<p>Selbst nachdem wir <code>add_text</code> aufgerufen und unserem Beitrag etwas Inhalt
hinzugefügt haben, wollen wir immer noch, dass die Methode <code>content</code> einen
leeren Zeichenkettenanteilstyp (string slice) zurückgibt, weil sich der Beitrag
noch im Entwurfszustand befindet, wie in Zeile 7 von Codeblock 18-11 gezeigt
wird. Lass uns fürs Erste die Methode <code>content</code> mit der einfachsten Sache
implementieren, die diese Anforderung erfüllt: Immer einen leeren
Zeichenkettenanteilstyp zurückgeben. Wir werden dies später ändern, sobald wir
die Möglichkeit implementiert haben, den Zustand eines Beitrags zu ändern,
damit er veröffentlicht werden kann. Bislang können Beiträge nur im
Entwurfszustand sein, daher sollte der Beitragsinhalt immer leer sein.
Codeblock 18-14 zeigt diese Platzhalter-Implementierung.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        ""
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-14: Hinzufügen einer
Platzhalter-Implementierung für die Methode <code>content</code> auf <code>Post</code>, die immer
einen leeren Zeichenkettenanteilstyp zurückgibt</span></p>
<p>Mit dieser zusätzlichen Methode <code>content</code> funktioniert alles in Codeblock 18-11
bis hin zu Zeile 7 wie beabsichtigt.</p>
<h3 id="antrag-auf-Überprüfung-ändert-den-zustand-des-beitrags"><a class="header" href="#antrag-auf-Überprüfung-ändert-den-zustand-des-beitrags">Antrag auf Überprüfung ändert den Zustand des Beitrags</a></h3>
<p>Als nächstes müssen wir eine Funktionalität hinzufügen, um eine Überprüfung
eines Beitrags zu beantragen, die seinen Zustand von <code>Draft</code> in <code>PendingReview</code>
ändern soll. Codeblock 18-15 zeigt diesen Code.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-15: Implementierung der Methoden
<code>request_review</code> für <code>Post</code> und des Merkmals <code>State</code></span></p>
<p>Wir geben <code>Post</code> eine öffentliche Methode namens <code>request_review</code>, die eine
veränderbare Referenz auf <code>self</code> nimmt. Dann rufen wir eine interne
Methode <code>request_review</code> über den aktuellen Zustand von <code>Post</code> auf und diese
zweite Methode <code>request_review</code> konsumiert den aktuellen Zustand und gibt einen
neuen Zustand zurück.</p>
<p>Wir fügen die Methode <code>request_review</code> zum Merkmal <code>State</code> hinzu; alle Typen,
die das Merkmal implementieren, müssen nun die Methode <code>request_review</code>
implementieren. Beachte, dass wir statt <code>self</code>, <code>&amp;self</code> oder <code>&amp;mut self</code> als
ersten Parameter der Methode <code>self: Box&lt;Self&gt;</code> haben. Diese Syntax bedeutet,
dass die Methode nur gültig ist, wenn sie auf einer <code>Box</code> mit dem Typ
aufgerufen wird. Diese Syntax übernimmt die Eigentümerschaft von <code>Box&lt;Self&gt;</code>,
wodurch der alte Zustand ungültig wird, sodass der Zustandswert von <code>Post</code> in
einen neuen Zustand transformiert werden kann.</p>
<p>Um den alten Zustand zu konsumieren, muss die Methode <code>request_review</code> die
Eigentümerschaft des Zustandswerts übernehmen. Hier kommt die <code>Option</code> im Feld
<code>state</code> von <code>Post</code> ins Spiel: Wir rufen die Methode <code>take</code> auf, um den
<code>Some</code>-Wert aus dem <code>state</code>-Feld zu nehmen und an seiner Stelle ein <code>None</code> zu
hinterlassen, weil Rust es nicht zulässt, dass wir unbestückte Felder in
Strukturen haben. Dadurch können wir den Wert <code>state</code> aus <code>Post</code>
herausverschieben, anstatt ihn auszuleihen. Dann setzen wir den Wert <code>state</code>
des Beitrags auf das Ergebnis dieser Operation.</p>
<p>Wir müssen <code>state</code> vorübergehend auf <code>None</code> setzen, anstatt es direkt mit Code
wie <code>self.state = self.state.request_review();</code> zu setzen, um die
Eigentümerschaft des Wertes in <code>state</code> zu erhalten. Das stellt sicher, dass
<code>Post</code> nicht den alten Wert in <code>state</code> verwenden kann, nachdem wir ihn in einen
neuen Zustand transformiert haben.</p>
<p>Die Methode <code>request_review</code> auf <code>Draft</code> gibt eine neue, in einer Box
gespeicherte Instanz einer neuen Struktur <code>PendingReview</code> zurück, die den
Zustand darstellt, in dem ein Beitrag auf eine Überprüfung wartet. Die Struktur
<code>PendingReview</code> implementiert auch die Methode <code>request_review</code>, führt aber
keine Transformationen durch. Vielmehr gibt sie sich selbst zurück, denn wenn
wir eine Überprüfung für einen Beitrag anfordern, der sich bereits im
<code>PendingReview</code>-Zustand befindet, sollte er im <code>PendingReview</code>-Zustand bleiben.</p>
<p>Jetzt können wir anfangen, die Vorteile des Zustandsmusters zu erkennen: Die
Methode <code>request_review</code> auf <code>Post</code> ist die gleiche, unabhängig von ihrem Wert
<code>state</code>. Jeder Zustand ist für seine eigenen Regeln verantwortlich.</p>
<p>Wir lassen die Methode <code>content</code> auf <code>Post</code> so wie sie ist und geben einen
leeren Zeichenkettenanteilstyp zurück. Wir können jetzt einen <code>Post</code> sowohl im
Zustand <code>PendingReview</code> als auch im Zustand <code>Draft</code> haben, aber wir wollen das
gleiche Verhalten im Zustand <code>PendingReview</code>. Codeblock 18-11 funktioniert
jetzt bis Zeile 10!</p>
<h3 id="hinzufügen-von-approve-um-das-verhalten-von-content-zu-ändern"><a class="header" href="#hinzufügen-von-approve-um-das-verhalten-von-content-zu-ändern">Hinzufügen von <code>approve</code>, um das Verhalten von <code>content</code> zu ändern</a></h3>
<p>Die Methode <code>approve</code> ähnelt der Methode <code>request_review</code>: Sie setzt den
<code>state</code> auf den Wert, den der aktuelle Zustand nach der Genehmigung haben
sollte, wie in Codeblock 18-16 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --abschneiden--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --abschneiden--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-16: Implementieren der Methode <code>approve</code> auf
<code>Post</code> und des Merkmals <code>State</code></span></p>
<p>Wir fügen die Methode <code>approve</code> zum Merkmal <code>State</code> hinzu und fügen eine neue
Struktur <code>Published</code> hinzu, die das Merkmal <code>State</code> implementiert.</p>
<p>Ähnlich wie <code>request_review</code> bei <code>PendingReview</code> funktioniert, hat der Aufruf
der Methode <code>approve</code> bei einem <code>Draft</code> keine Wirkung, weil <code>approve</code> den Wert
<code>self</code> zurückgibt. Wenn wir die Methode <code>approve</code> bei <code>PendingReview</code> aufrufen,
gibt sie eine neue, geschlossene Instanz der Struktur <code>Published</code> zurück. Die
Struktur <code>Published</code> implementiert das Merkmal <code>State</code> und sowohl bei der
Methode <code>request_review</code> als auch bei der Methode <code>approve</code> gibt sie sich
selbst zurück, weil der Beitrag in diesen Fällen im Zustand <code>Published</code> bleiben
sollte.</p>
<p>Jetzt müssen wir die Methode <code>content</code> auf <code>Post</code> aktualisieren: Wir wollen,
dass der von <code>content</code> zurückgegebene Wert vom aktuellen Zustand von <code>Post</code>
abhängt, also delegieren wir <code>Post</code> an eine Methode <code>content</code>, die auf seinen
<code>state</code> definiert ist, wie in Codeblock 18-17 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-17: Aktualisieren der Methode <code>content</code> auf
<code>Post</code> zum Delegieren an eine Methode <code>content</code> auf <code>State</code></span></p>
<p>Da das Ziel darin besteht, all diese Regeln innerhalb der Strukturen zu halten,
die <code>State</code> implementieren, rufen wir eine Methode <code>content</code> auf dem Wert in
<code>state</code> auf und übergeben die <code>Post</code>-Instanz (d.h. <code>self</code>) als Argument. Dann
geben wir den Wert zurück, der von der Verwendung der Methode <code>content</code> für den
Wert <code>state</code> zurückgegeben wird.</p>
<p>Wir rufen die Methode <code>as_ref</code> auf <code>Option</code> auf, weil wir eine Referenz auf den
Wert innerhalb <code>Option</code> wollen und nicht die Eigentümerschaft am Wert. Weil
<code>State</code> eine <code>Option&lt;Box&lt;dyn State&gt;&gt;</code> ist, wird beim Aufruf von <code>as_ref</code> eine
<code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> zurückgegeben. Würden wir nicht <code>as_ref</code> aufrufen,
bekämen wir einen Fehler, weil wir <code>state</code> nicht aus dem ausgeliehenen <code>&amp;self</code>
im Funktionsparameter herausverschieben können.</p>
<p>Wir rufen dann die Methode <code>unwrap</code> auf, von der wir wissen, dass sie das
Programm niemals abstürzen lassen wird, weil wir wissen, dass die Methoden auf
<code>Post</code> sicherstellen, dass <code>state</code> stets einen <code>Some</code>-Wert enthält, wenn diese
Methoden fertig ausgeführt sind. Dies ist einer der Fälle, über die wir in
<a href="ch09-03-to-panic-or-not-to-panic.html#f%C3%A4lle-in-denen-du-mehr-informationen-als-der-compiler-hast">„Fälle, in denen du mehr Informationen als der Compiler
hast“</a> in Kapitel 9 gesprochen haben, bei denen wir
im Unterschied zum Compiler wissen, dass ein <code>None</code>-Wert niemals möglich ist.</p>
<p>Wenn wir nun <code>content</code> auf <code>&amp;Box&lt;dyn State&gt;</code> aufrufen, wird eine automatische
Umwandlung (deref coercion) auf <code>&amp;</code> und <code>Box</code> stattfinden, sodass die Methode
<code>content</code> letztlich auf dem Typ aufgerufen wird, der das Merkmal <code>State</code>
implementiert. Das bedeutet, dass wir die Definition des Merkmals <code>State</code> um
<code>content</code> erweitern müssen, und hier werden wir die Logik dafür unterbringen,
welcher Inhalt je nach Zustand zurückgegeben wird, wie in Codeblock 18-18 zu
sehen ist:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --abschneiden--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

// --abschneiden--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --abschneiden--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-18: Hinzufügen der Methode <code>content</code> zum
Merkmal <code>State</code></span></p>
<p>Wir fügen eine Standard-Implementierung für die Methode <code>content</code> hinzu, die
einen leeren Zeichenkettenanteilstyp zurückgibt. Das bedeutet, dass wir
<code>content</code> in den Strukturen <code>Draft</code> und <code>PendingReview</code> nicht implementieren
müssen. Die Struktur <code>Published</code> überschreibt die Methode <code>content</code> und gibt
den Wert in <code>post.content</code> zurück.</p>
<p>Beachte, dass wir Lebensdauer-Annotationen bei dieser Methode benötigen, wie
wir in Kapitel 10 besprochen haben. Wir nehmen eine Referenz auf ein <code>post</code> als
Argument und geben eine Referenz auf einen Teil dieses <code>post</code> zurück, sodass
die Lebensdauer der zurückgegebenen Referenz mit der Lebensdauer des Arguments
<code>post</code> zusammenhängt.</p>
<p>Nun sind wir fertig – der Codeblock 18-11 funktioniert jetzt! Wir haben
das Zustandsmuster mit den Regeln des Blog-Beitrags-Workflows implementiert.
Die Logik, die sich auf die Regeln bezieht, lebt in den Zustandsobjekten und
ist nicht über den gesamten <code>Post</code> verstreut.</p>
<blockquote>
<h3 id="warum-keine-aufzählung"><a class="header" href="#warum-keine-aufzählung">Warum keine Aufzählung?</a></h3>
<p>Vielleicht hast du dich gefragt, warum wir nicht ein <code>enum</code> mit den
verschiedenen möglichen <code>Post</code>-Status als Varianten verwendet haben. Das ist
sicherlich eine mögliche Lösung. Probiere es aus und vergleiche die
Endergebnisse, um zu sehen, was du bevorzugst! Ein Nachteil der Verwendung
einer Aufzählung ist, dass jede Stelle, die den Wert der Aufzählung prüft,
einen <code>match</code>-Ausdruck oder ähnliches benötigt, um jede mögliche Variante zu
behandeln. Dies könnte zu mehr Wiederholungen führen als die Lösung mit dem
Merkmals-Objekt.</p>
</blockquote>
<h3 id="kompromisse-des-zustandsmusters"><a class="header" href="#kompromisse-des-zustandsmusters">Kompromisse des Zustandsmusters</a></h3>
<p>Wir haben gezeigt, dass Rust in der Lage ist, das objektorientierte
Zustandsmuster zu implementieren, um die verschiedenen Verhaltensweisen, die
ein Beitrag im jeweiligen Zustand haben sollte, zu kapseln. Die Methoden auf
<code>Post</code> wissen nichts über die verschiedenen Verhaltensweisen. So, wie wir den
Code organisiert haben, müssen wir nur an einem einzigen Ort suchen, um zu
wissen, wie sich ein veröffentlichter Beitrag verhalten kann: Die
Implementierung des Merkmals <code>State</code> auf der Struktur <code>Published</code>.</p>
<p>Wenn wir eine alternative Implementierung erstellen würden, die nicht das
Zustandsmuster verwendet, könnten wir stattdessen <code>match</code>-Ausdrücke in den
Methoden auf <code>Post</code> oder sogar im <code>main</code>-Code verwenden, die den Zustand des
Beitrags überprüfen und das Verhalten an diesen Stellen ändern. Das würde
bedeuten, dass wir an mehreren Stellen nachschauen müssten, um alle
Auswirkungen eines Beitrags im veröffentlichten Zustand zu verstehen! Dies
würde immer mehr werden, je mehr Zustände wir hinzufügen: Jeder dieser
<code>match</code>-Ausdrücke würde einen weiteren Zweig benötigen.</p>
<p>Mit dem Zustandsmuster, den <code>Post</code>-Methoden und den Stellen, an denen wir
<code>Post</code> verwenden, brauchen wir keine <code>match</code>-Ausdrücke, und um einen neuen
Zustand hinzuzufügen, müssten wir nur eine neue Struktur hinzufügen und die
Merkmalsmethoden auf dieser einen Struktur implementieren.</p>
<p>Die Implementierung unter Verwendung des Zustandsmusters ist leicht zu
erweitern, um weitere Funktionalität hinzuzufügen. Um zu sehen, wie einfach es
ist, Code zu pflegen, der das Zustandsmuster verwendet, probiere einige dieser
Vorschläge aus:</p>
<ul>
<li>Füge eine Methode <code>reject</code> hinzu, die den Zustand des Beitrags von
<code>PendingReview</code> zurück zu <code>Draft</code> ändert.</li>
<li>Verlange zwei <code>approve</code>-Aufrufe, bevor der Zustand in <code>Published</code> geändert
werden kann.</li>
<li>Erlaube Benutzern das Hinzufügen von Textinhalten nur dann, wenn sich ein
Beitrag im Zustand <code>Draft</code> befindet. Hinweis: Lasse das Zustandsobjekt dafür
verantwortlich sein, was sich am Inhalt ändern könnte, aber nicht für die
Änderung des <code>Post</code>.</li>
</ul>
<p>Ein Nachteil des Zustandsmusters besteht darin, dass einige der Zustände
miteinander gekoppelt sind, weil die Zustände die Übergänge zwischen den
Zuständen implementieren. Wenn wir einen weiteren Zustand zwischen
<code>PendingReview</code> und <code>Published</code> hinzufügen, z.B. <code>Scheduled</code>, müssten wir den
Code in <code>PendingReview</code> ändern und stattdessen zu <code>Scheduled</code> übergehen. Es
wäre weniger Arbeit, wenn <code>PendingReview</code> nicht mit dem Hinzufügen eines neuen
Zustands geändert werden müsste, aber das würde bedeuten, zu einem anderen
Entwurfsmuster zu wechseln.</p>
<p>Ein weiterer Nachteil ist, dass wir eine gewisse Logik dupliziert haben. Um
einen Teil der Duplikation zu eliminieren, könnten wir versuchen,
Standard-Implementierungen für die Methoden <code>request_review</code> und <code>approval</code> für
das Merkmal <code>State</code> zu erstellen, die <code>self</code> zurückgeben; dies würde jedoch
nicht funktionieren: Bei der Verwendung von <code>State</code> als Merkmals-Objekt weiß
das Merkmal nicht, was das konkrete <code>self</code> genau sein wird, sodass der
Rückgabetyp zur Kompilierzeit nicht bekannt ist. (Dies ist eine der bereits
erwähnten dyn-Kompatibilitätsregeln.)</p>
<p>Eine weitere Duplikation sind die ähnlichen Implementierungen der Methoden
<code>request_review</code> und <code>approve</code> auf <code>Post</code>. Beide Methoden verwenden
<code>Option::take</code> mit dem Feld <code>state</code> von <code>Post</code>, und wenn <code>state</code> den Wert
<code>Some</code> hat, delegieren sie den Aufruf an die gleiche Methode des umschlossenen
Werts und speichern das Ergebnis im Feld <code>state</code>. Wenn wir viele Methoden auf
<code>Post</code> hätten, die diesem Muster folgen, könnten wir in Erwägung ziehen, ein
Makro zu definieren, um die Wiederholung zu eliminieren (siehe
<a href="ch20-05-macros.html">„Makros“</a> in Kapitel 20).</p>
<p>Indem wir das Zustandsmuster genau so implementieren, wie es für
objektorientierte Sprachen definiert ist, nutzen wir die Stärken Rusts nicht so
aus, wie wir es könnten. Sehen wir uns einige Änderungen an, die wir an der
Kiste <code>blog</code> vornehmen können, die ungültige Zustände und Übergänge in
Kompilierzeitfehler verwandeln können.</p>
<h4 id="kodieren-von-zuständen-und-verhalten-als-typen"><a class="header" href="#kodieren-von-zuständen-und-verhalten-als-typen">Kodieren von Zuständen und Verhalten als Typen</a></h4>
<p>Wir werden dir zeigen, wie du das Zustandsmuster überdenken kannst, um andere
Kompromisse zu erzielen. Anstatt die Zustände und Übergänge vollständig zu
kapseln, sodass Außenstehende keine Kenntnis von ihnen haben, werden wir die
Zustände in verschiedene Typen kodieren. Folglich wird Rusts
Typprüfungssystem Versuche verhindern, Entwurfsbeiträge zu verwenden, bei denen
nur veröffentlichte Beiträge erlaubt sind, indem ein Kompilierfehler ausgegeben
wird.</p>
<p>Betrachten wir den ersten Teil von <code>main</code> in Codeblock 18-11:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text("Ich habe heute Mittag einen Salat gegessen");
    assert_eq!("", post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!("", post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!("Ich habe heute Mittag einen Salat gegessen", post.content());
</span>}</code></pre>
<p>Wir ermöglichen nach wie vor das Erstellen neuer Beiträge im Entwurfsstadium
unter Verwendung von <code>Post::new</code> und der Möglichkeit, dem Inhalt des Beitrags
Text hinzuzufügen. Aber anstatt eine Methode <code>content</code> bei einem
Beitragsentwurf zu haben, die eine leere Zeichenkette zurückgibt, werden wir
es so einrichten, dass Beitragsentwürfe überhaupt keine Methode <code>content</code>
haben. Wenn wir auf diese Weise versuchen, den Inhalt eines Beitragsentwurfs
zu erhalten, erhalten wir einen Kompilierfehler, der uns sagt, dass die Methode
nicht existiert. Infolgedessen wird es für uns unmöglich, versehentlich den
Inhalt eines Beitragsentwurfs in der Produktion anzuzeigen, weil sich dieser
Code nicht einmal kompilieren lässt. Codeblock 18-19 zeigt die Definition einer
Struktur <code>Post</code> und einer Struktur <code>DraftPost</code> sowie die Methoden dieser
Strukturen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-19: Ein <code>Post</code> mit einer Methode <code>content</code>
und ein <code>DraftPost</code> ohne Methode <code>content</code></span></p>
<p>Die beiden Strukturen <code>Post</code> und <code>DraftPost</code> haben ein privates Feld <code>content</code>,
in dem der Text des Blog-Beitrags gespeichert wird. Die Strukturen haben nicht
mehr das Feld <code>state</code>, weil wir die Kodierung des Zustands auf die Typen der
Strukturen verlagert haben. Die Struktur <code>Post</code> wird einen veröffentlichten
Beitrag repräsentieren und sie hat eine Methode <code>content</code>, die den Wert des
Feldes <code>content</code> zurückgibt.</p>
<p>Wir haben immer noch die Funktion <code>Post::new</code>, aber anstatt eine Instanz von
<code>Post</code> zurückzugeben, gibt sie eine Instanz von <code>DraftPost</code> zurück. Da
<code>content</code> privat ist und es keine Funktion gibt, die <code>Post</code> zurückgibt, ist es
im Moment nicht möglich, eine Instanz von <code>Post</code> zu erzeugen.</p>
<p>Die Struktur <code>DraftPost</code> hat eine Methode <code>add_text</code>, sodass wir wie bisher
Text zum <code>content</code> hinzufügen können, aber beachte, dass <code>DraftPost</code> keine
Methode <code>content</code> definiert hat! Daher stellt das Programm jetzt sicher, dass
alle Beiträge als Beitragsentwürfe beginnen und dass der Inhalt von
Beitragsentwürfen nicht zur Anzeige verfügbar ist. Jeder Versuch, diese
Einschränkungen zu umgehen, führt zu einem Kompilierfehler.</p>
<h4 id="umsetzen-von-Übergängen-als-transformationen-in-verschiedene-typen"><a class="header" href="#umsetzen-von-Übergängen-als-transformationen-in-verschiedene-typen">Umsetzen von Übergängen als Transformationen in verschiedene Typen</a></h4>
<p>Wie bekommen wir also einen veröffentlichten Beitrag? Wir wollen die Regel
durchsetzen, dass ein Beitragsentwurf geprüft und genehmigt werden muss, bevor
er veröffentlicht werden kann. Ein Beitrag, der sich im Stadium der Überprüfung
befindet, sollte noch immer keinen Inhalt haben. Lass uns diese Bedingung
implementieren, indem wir eine weitere Struktur <code>PendingReviewPost</code> hinzufügen,
indem wir die Methode <code>request_review</code> auf <code>DraftPost</code> definieren, um einen
<code>PendingReviewPost</code> zurückzugeben, und eine Methode <code>approve</code> auf
<code>PendingReviewPost</code>, um einen <code>Post</code> zurückzugeben, wie in Codeblock 18-20
gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --abschneiden--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-20: Ein <code>PendingReviewPost</code>, der durch
Aufrufen von <code>request_review</code> auf <code>DraftPost</code> erzeugt wird, und eine Methode
<code>approve</code>, die einen <code>PendingReviewPost</code> in einen veröffentlichten <code>Post</code>
verwandelt</span></p>
<p>Die Methoden <code>request_review</code> und <code>approve</code> übernehmen die Eigentümerschaft von
<code>self</code>, wodurch die Instanzen <code>DraftPost</code> und <code>PendingReviewPost</code> verbraucht
und in einen <code>PendingReviewPost</code> bzw. einen veröffentlichten <code>Post</code> umgewandelt
werden. Auf diese Weise werden wir keine <code>DraftPost</code>-Instanzen mehr haben,
nachdem wir <code>request_review</code> darauf aufgerufen haben, und so weiter. Die
<code>PendingReviewPost</code>-Struktur hat keine Methode <code>content</code> definiert, sodass der
Versuch, ihren Inhalt zu lesen, zu einem Kompilierfehler führt, wie bei
<code>DraftPost</code>. Da der einzige Weg, eine veröffentlichte <code>Post</code>-Instanz zu
erhalten, die eine Methode <code>content</code> definiert hat, der Aufruf der Methode
<code>approve</code> auf einem <code>PendingReviewPost</code> ist, und der einzige Weg, einen
<code>PendingReviewPost</code> zu erhalten, der Aufruf der Methode <code>request_review</code> auf
einem <code>DraftPost</code> ist, haben wir jetzt den Blog-Beitrags-Workflow in das
Typsystem kodiert.</p>
<p>Aber wir müssen auch einige kleine Änderungen an <code>main</code> vornehmen. Die Methoden
<code>request_review</code> und <code>approve</code> geben neue Instanzen zurück, anstatt die
Struktur, auf der sie aufgerufen werden, zu modifizieren, sodass wir mehr <code>let post =</code> Verschattungs-Zuweisungen (shadowing assignments) hinzufügen müssen, um
die zurückgegebenen Instanzen zu speichern. Wir können auch nicht zulassen,
dass die Zusicherungen über den Inhalt des Entwurfs und der anstehenden
Überprüfungsbeiträge leere Zeichenketten sind, und wir brauchen sie auch nicht:
Wir können keinen Code mehr kompilieren, der versucht, den Inhalt von Beiträgen
in diesen Zuständen zu verwenden. Der aktualisierte Code in <code>main</code> ist in
Codeblock 18-21 zu sehen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("Ich habe heute Mittag einen Salat gegessen");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("Ich habe heute Mittag einen Salat gegessen", post.content());
}</code></pre>
<p><span class="caption">Codeblock 18-21: Änderungen an <code>main</code>, um die neue
Implementierung des Blog-Beitrags-Workflows zu nutzen</span></p>
<p>Die Änderungen, die wir an <code>main</code> vornehmen mussten, um <code>post</code> neu zuzuweisen,
bedeuten, dass diese Implementierung nicht mehr ganz dem objektorientierten
Zustandsmuster folgt: Die Transformationen zwischen den Zuständen sind nicht
mehr vollständig in der <code>Post</code>-Implementierung gekapselt. Unser Vorteil ist
jedoch, dass ungültige Zustände aufgrund des Typsystems und der Typprüfung, die
zur Kompilierzeit stattfindet, jetzt unmöglich sind! Dadurch wird
sichergestellt, dass bestimmte Fehler, z.B. das Anzeigen des Inhalts eines
unveröffentlichten Beitrags, entdeckt werden, bevor sie in die Produktion
gelangen.</p>
<p>Versuche es mit den Aufgaben, die wir zu Beginn dieses Abschnitts über die
Kiste <code>blog</code> nach Codeblock 18-20 erwähnt haben, um zu sehen, was du über das
Design dieser Version des Codes denkst. Beachte, dass einige der Aufgaben
möglicherweise bereits in diesem Entwurf abgeschlossen sind.</p>
<p>Wir haben gesehen, dass, obwohl Rust in der Lage ist, objektorientierte
Entwurfsmuster zu implementieren, auch andere Muster, z.B. das Kodieren des
Zustands in das Typsystem, in Rust verfügbar sind. Diese Muster weisen
unterschiedliche Kompromisse auf. Auch wenn du mit objektorientierten Mustern
sehr vertraut bist, kann ein Überdenken des Problems, um die Funktionen von
Rust zu nutzen, Vorteile bringen, z.B. das Vermeiden einiger Fehler zur
Kompilierzeit. Objektorientierte Muster werden in Rust nicht immer die beste
Lösung sein, da objektorientierte Sprachen bestimmte Funktionalitäten wie die
Eigentümerschaft nicht haben.</p>
<h2 id="zusammenfassung-17"><a class="header" href="#zusammenfassung-17">Zusammenfassung</a></h2>
<p>Unabhängig davon, ob du nach der Lektüre dieses Kapitels der Meinung bist, dass
Rust eine objektorientierte Sprache ist, weißt du jetzt, dass du Merkmalsobjekte
verwenden kannst, um einige objektorientierte Funktionalitäten in Rust zu
erhalten. Dynamische Aufrufe können deinem Code eine gewisse Flexibilität im
Austausch gegen ein wenig Laufzeitperformanz verleihen. Du kannst diese
Flexibilität nutzen, um objektorientierte Muster zu implementieren, die die
Wartbarkeit deines Codes verbessern können. Rust hat auch andere
Funktionalitäten wie die Eigentümerschaft, die objektorientierte Sprachen nicht
haben. Ein objektorientiertes Muster wird nicht immer der beste Weg sein, um
die Stärken von Rust zu nutzen, aber es ist eine verfügbare Option.</p>
<p>Als nächstes werden wir uns mit Mustern befassen, die eine weitere
Funktionalität von Rust sind und viel Flexibilität ermöglichen. Wir haben sie
uns im Laufe des Buches kurz angeschaut, haben aber noch nicht ihre volle
Leistungsfähigkeit gesehen. Los geht's!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="muster-patterns-und-abgleich-matching"><a class="header" href="#muster-patterns-und-abgleich-matching">Muster (patterns) und Abgleich (matching)</a></h1>
<p><em>Muster</em> sind eine spezielle Syntax in Rust für den Abgleich mit der Struktur
von Typen, sowohl komplexen als auch einfachen Typen. Das Verwenden von Mustern
in Verbindung mit <code>match</code>-Ausdrücken und anderen Konstrukten gibt dir mehr
Kontrolle über den Kontrollfluss eines Programms. Ein Muster besteht aus einer
Kombination der folgenden Elemente:</p>
<ul>
<li>Literale</li>
<li>Destrukturierte Arrays, Aufzählungen (enums), Strukturen (structs) und Tupel</li>
<li>Variablen</li>
<li>Wildcards</li>
<li>Platzhalter</li>
</ul>
<p>Einige Beispielmuster sind <code>x</code>, <code>(a, 3)</code> und <code>Some(Color::Red)</code>. In den
Kontexten, in denen Muster gültig sind, beschreiben diese Komponenten die
Datenform. Unser Programm gleicht dann Werte mit den Mustern ab, um
festzustellen, ob es die richtige Datenform hat, um ein bestimmtes Stück Code
weiter auszuführen.</p>
<p>Um ein Muster zu verwenden, vergleichen wir es mit einem Wert. Wenn das Muster
zum Wert passt, verwenden wir die Wertteile in unserem Code. Erinnere dich an
die <code>match</code>-Ausdrücke in Kapitel 6, in denen Muster verwendet wurden, z.B. die
Münzsortiermaschine. Wenn der Wert zur Form des Musters passt, können wir die
genannten Teile verwenden. Wenn dies nicht der Fall ist, wird der mit dem
Muster verbundene Code nicht ausgeführt.</p>
<p>Dieses Kapitel ist eine Referenz zu allen Dingen, die mit Mustern zu tun haben.
Wir behandeln die gültigen Stellen, an denen Muster verwendet werden können,
den Unterschied zwischen abweisbaren (refutable) und unabweisbaren
(irrefutable) Mustern und die verschiedenen Arten der Mustersyntax, die du
sehen wirst. Am Ende des Kapitels wirst du wissen, wie du Muster verwenden
kannst, um viele Konzepte auf klare Weise auszudrücken.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="alle-stellen-an-denen-muster-patterns-verwendet-werden-können"><a class="header" href="#alle-stellen-an-denen-muster-patterns-verwendet-werden-können">Alle Stellen an denen Muster (patterns) verwendet werden können</a></h2>
<p>Muster tauchen an vielen Stellen in Rust auf und du hast sie oft benutzt, ohne
es zu merken! In diesem Abschnitt werden alle Stellen besprochen, an denen
Muster gültig sind.</p>
<h3 id="match-zweige"><a class="header" href="#match-zweige"><code>match</code>-Zweige</a></h3>
<p>Wie in Kapitel 6 besprochen, verwenden wir Muster in den Zweigen von
<code>match</code>-Ausdrücken. Formal werden <code>match</code>-Ausdrücke definiert mit dem
Schlüsselwort <code>match</code>, einem Wert, mit dem verglichen wird, und einem oder
mehreren <code>match</code>-Zweigen, die aus einem Muster und einem Ausdruck bestehen, der
ausgeführt wird, wenn der Wert zum Muster dieses Zweigs passt, wie hier:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>Hier ist zum Beispiel der <code>match</code>-Ausdruck aus Codeblock 6-5, der auf einen
<code>Option&lt;i32&gt;</code>-Wert in der Variablen <code>x</code> passt:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>Die Muster in diesem <code>match</code>-Ausdruck sind <code>None</code> und <code>Some(i)</code> links von den
Pfeilen.</p>
<p>Eine Anforderung für <code>match</code>-Ausdrücke ist, dass sie <em>erschöpfend</em> (exhaustive)
in dem Sinne sein müssen, dass alle Möglichkeiten für den Wert im
<code>match</code>-Ausdruck berücksichtigt sein müssen. Ein Weg, um sicherzustellen, dass
alle Möglichkeiten abgedeckt sind, ist ein Sammel-Muster (catchall pattern) für
den letzten Zweig: Zum Beispiel kann ein Variablenname, der zu einem beliebigen
Wert passt, niemals fehlschlagen und deckt somit jeden verbleibenden Fall ab.</p>
<p>Das spezielle Muster <code>_</code> wird auf alles passen, aber es bindet nie an eine
Variable, daher wird es oft im letzten <code>match</code>-Zweig verwendet. Das Muster <code>_</code>
kann zum Beispiel nützlich sein, wenn du jeden nicht angegebenen Wert
ignorieren willst. Wir werden das Muster <code>_</code> in <a href="ch19-03-pattern-syntax.html#ignorieren-von-werten-in-einem-muster">„Ignorieren von Werten in
einem Muster“</a> später in diesem Kapitel
ausführlicher behandeln.</p>
<h3 id="bedingte-if-let-ausdrücke"><a class="header" href="#bedingte-if-let-ausdrücke">Bedingte <code>if let</code>-Ausdrücke</a></h3>
<p>In Kapitel 6 haben wir erörtert, wie man <code>if let</code>-Ausdrücke hauptsächlich als
kürzeren Weg verwendet, um das Äquivalent eines <code>match</code>-Ausdrucks zu schreiben,
der nur einen Fall prüft. Optional kann <code>if let</code> ein entsprechendes <code>else</code>
haben mit Code, der ausgeführt wird, wenn das Muster in <code>if let</code> nicht passt.</p>
<p>Codeblock 19-1 zeigt, dass es auch möglich ist, die Ausdrücke <code>if let</code>, <code>else if</code> und <code>else if let</code> zu mischen und anzupassen. Dies gibt uns mehr
Flexibilität als ein <code>match</code>-Ausdruck, in dem wir nur einen Wert zum Abgleich
mit den Mustern haben können. Auch erfordert Rust nicht, dass die Bedingungen
in einer Reihe von <code>if let</code>-, <code>else if</code>- und <code>else if let</code>-Zweigen sich
notwendigerweise aufeinander beziehen.</p>
<p>Der Code in Codeblock 19-1 bestimmt die Farbe des Hintergrunds auf der
Grundlage einer Reihe von Prüfungen mehrerer Bedingungen. Für dieses Beispiel
haben wir Variablen mit hartkodierten Werten erstellt, die ein reales Programm
von Benutzereingaben erhalten könnte.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = "34".parse();

    if let Some(color) = favorite_color {
        println!("Verwende deine Lieblingsfarbe {color} als Hintergrund");
    } else if is_tuesday {
        println!("Dienstag ist grüner Tag!");
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!("Verwende violett als Hintergrundfarbe");
        } else {
            println!("Verwende orange als Hintergrundfarbe");
        }
    } else {
        println!("Verwende blau als Hintergrundfarbe");
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 19-1: Mischen von <code>if let</code>, <code>else if</code>, <code>else if let</code> und <code>else</code></span></p>
<p>Wenn der Benutzer eine Lieblingsfarbe angibt, ist diese Farbe die
Hintergrundfarbe. Wenn keine Lieblingsfarbe angegeben wurde und heute Dienstag
ist, ist die Hintergrundfarbe grün. Ansonsten, wenn der Benutzer sein Alter als
Zeichenkette angibt und wir es erfolgreich als Zahl parsen können, ist die
Farbe entweder violett oder orange, je nach dem Wert der Zahl. Wenn keine
dieser Bedingungen zutrifft, ist die Hintergrundfarbe blau.</p>
<p>Mit dieser bedingten Struktur können wir komplexe Anforderungen unterstützen.
Mit den hartkodierten Werten, die wir hier haben, wird dieses Beispiel
<code>Verwende violett als Hintergrundfarbe</code> ausgeben.</p>
<p>Du kannst sehen, dass <code>if let</code> auch neue Variablen einführen kann, die
vorhandene Variablen verschatten (shadow) können, so wie bei <code>match</code>-Zweigen:
Die Zeile <code>if let Ok(age) = age</code> führt eine neue Variable <code>age</code> ein, die den
Wert innerhalb der <code>Ok</code>-Variante enthält und die vorhandene Variable <code>age</code>
verschattet. Das bedeutet, dass wir die Bedingung <code>if age &gt; 30</code> innerhalb
dieses Blocks platzieren müssen: Wir können diese beiden Bedingungen nicht in
<code>if let Ok(age) = age &amp;&amp; age &gt; 30</code> kombinieren. Die neue Variable <code>age</code>, die
wir mit 30 vergleichen wollen, ist erst gültig, wenn der neue
Gültigkeitsbereich mit der geschweiften Klammer beginnt.</p>
<p>Der Nachteil der Verwendung von <code>if let</code>-Ausdrücken ist, dass der Compiler die
Vollständigkeit nicht prüft, während er dies bei <code>match</code>-Ausdrücken tut. Wenn
wir den letzten <code>else</code>-Block weglassen und daher einige Fälle nicht behandelt
haben, würde uns der Compiler nicht auf den möglichen Logikfehler hinweisen.</p>
<h3 id="while-let-bedingte-schleifen"><a class="header" href="#while-let-bedingte-schleifen"><code>while let</code>-bedingte Schleifen</a></h3>
<p>Analog zu <code>if let</code> ermöglicht die bedingte Schleife <code>while let</code>, dass eine
<code>while</code>-Schleife so lange ausgeführt wird, wie ein Muster weiterhin passt. Auf
ähnliche Weise zeigen wir in Codeblock 19-2 eine <code>while let</code>-Schleife, die auf
Nachrichten wartet, die zwischen Strängen gesendet werden. In aktuellen Fall
prüfen wir ein <code>Result</code> statt einer einer <code>Option</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (tx, rx) = std::sync::mpsc::channel();
    std::thread::spawn(move || {
        for val in [1, 2, 3] {
            tx.send(val).unwrap();
        }
    });

    while let Ok(value) = rx.recv() {
        println!("{value}");
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-2: Das Verwenden einer <code>while let</code>-Schleife,
um Werte so lange auszugeben, wie <code>rx.recv()</code> ein <code>Ok</code> zurückgibt</span></p>
<p>Dieses Beispiel gibt <code>1</code>, <code>2</code> und <code>3</code> aus. Die Methode <code>recv</code> nimmt die erste
Nachricht von der Empfängerseite des Kanals und gibt <code>Ok(value)</code> zurück. Als
wir <code>recv</code> das erste Mal in Kapitel 16 gesehen haben, haben wir den Fehler
direkt ausgepackt oder mit ihm als Iterator in einer <code>for</code>-Schleife
interagiert. Wie Codeblock 19-2 zeigt, können wir aber auch <code>while let</code>
verwenden, da die Methode <code>recv</code> nach jeder angekommenen Nachricht den Wert
<code>Ok</code> zurückgibt, solange der Sender existiert, und schließlich <code>Err</code>
zurückgibt, sobald die Senderseite die Verbindung trennt.</p>
<h3 id="for-schleifen"><a class="header" href="#for-schleifen"><code>for</code>-Schleifen</a></h3>
<p>In einer <code>for</code>-Schleife ist der Wert, der direkt auf das Schlüsselwort <code>for</code>
folgt, ein Muster. Zum Beispiel ist in <code>for x in y</code> das <code>x</code> das Muster.
Codeblock 19-3 zeigt, wie man ein Muster in einer <code>for</code>-Schleife verwendet, um
ein Tupel als Teil der <code>for</code>-Schleife zu destrukturieren oder zu zerlegen.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{value} ist beim Index {index}");
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-3: Verwenden eines Musters in einer
<code>for</code>-Schleife zum Destrukturieren eines Tupels</span></p>
<p>Der Code in Codeblock 19-3 wird Folgendes ausgeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a ist beim Index 0
b ist beim Index 1
c ist beim Index 2
</code></pre>
<p>Wir passen einen Iterator mit der Methode <code>enumerate</code> so an, dass er einen
Wert und den Index für diesen Wert erzeugt, die in einem Tupel abgelegt sind.
Der erste Aufruf von <code>enumerate</code> erzeugt das Tupel <code>(0, 'a')</code>. Wenn dieser Wert
zum Muster <code>(index, value)</code> passt, ist <code>index</code> gleich <code>0</code> und <code>value</code> gleich
<code>'a'</code>, wodurch die erste Zeile der Ausgabe ausgegeben wird.</p>
<h3 id="let-anweisungen"><a class="header" href="#let-anweisungen"><code>let</code>-Anweisungen</a></h3>
<p>Vor diesem Kapitel hatten wir das Verwenden von Mustern nur explizit mit
<code>match</code> und <code>if let</code> besprochen, aber tatsächlich haben wir Muster auch an
anderen Stellen verwendet, auch in <code>let</code>-Anweisungen. Betrachte zum Beispiel
diese einfache Variablenzuweisung mit <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Jedes Mal, wenn du eine <code>let</code>-Anweisung wie diese verwendet hast, hast du
Muster verwendet, auch wenn du es vielleicht nicht bemerkt hast! Formal sieht
eine <code>let</code>-Anweisung wie folgt aus:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>In Anweisungen wie <code>let x = 5;</code> mit einem Variablennamen an der Stelle
<em>PATTERN</em> ist der Variablenname nur eine besonders einfache Form eines Musters.
Rust vergleicht den Ausdruck mit dem Muster und weist alle gefundenen Namen zu.
Im Beispiel <code>let x = 5;</code> ist <code>x</code> also ein Muster, das bedeutet: „Binde das, was
hier passt, an die Variable <code>x</code>.“ Da der Name <code>x</code> das gesamte Muster ist,
bedeutet dieses Muster effektiv „Binde alles an die Variable <code>x</code>, was auch
immer der Wert ist.“.</p>
<p>Um den Aspekt des Musterabgleichs (pattern matching) von <code>let</code> deutlicher zu
sehen, betrachte Codeblock 19-4, der ein Muster mit <code>let</code> verwendet, um ein
Tupel zu destrukturieren.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-4: Verwenden eines Musters zum
Destrukturieren eines Tupels und zum gleichzeitigen Erzeugen von drei
Variablen</span></p>
<p>Hier vergleichen wir ein Tupel mit einem Muster. Rust vergleicht den Wert <code>(1, 2, 3)</code> mit dem Muster <code>(x, y, z)</code> und sieht, dass der Wert zum Muster passt,
weil die Anzahl der Elemente in beiden Werten dieselbe ist, und bindet <code>1</code> an
<code>x</code>, <code>2</code> an <code>y</code> und <code>3</code> an <code>z</code>. Man kann sich dieses Tupelmuster als
Verschachtelung von drei einzelnen Variablen-Mustern darin vorstellen.</p>
<p>Wenn die Anzahl der Elemente im Muster nicht mit der Anzahl der Elemente im
Tupel übereinstimmt, passt der Gesamttyp nicht, und wir erhalten einen
Kompilierfehler. Beispielsweise zeigt Codeblock 19-5 einen Versuch, ein Tupel
mit drei Elementen in zwei Variablen zu destrukturieren, was nicht
funktioniert.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-5: Fehlerhaft aufgebautes Musters, dessen
Variablen nicht mit der Anzahl der Elemente im Tupel übereinstimmen</span></p>
<p>Der Versuch, diesen Code zu kompilieren, führt zu diesem Typfehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Um den Fehler zu beheben, könnten wir einen oder mehrere der Werte im Tupel
mittels <code>_</code> oder <code>..</code> ignorieren, wie du im Abschnitt <a href="ch19-03-pattern-syntax.html#ignorieren-von-werten-in-einem-muster">„Ignorieren von Werten
in einem Muster“</a> sehen wirst. Wenn das Problem
darin besteht, dass wir zu viele Variablen im Muster haben, besteht die Lösung
darin, die Typen aufeinander abzustimmen, indem Variablen entfernt werden,
sodass die Anzahl der Variablen gleich der Anzahl der Elemente im Tupel ist.</p>
<h3 id="funktionsparameter"><a class="header" href="#funktionsparameter">Funktionsparameter</a></h3>
<p>Funktionsparameter können auch Muster sein. Der Code in Codeblock 19-6, der
eine Funktion namens <code>foo</code> deklariert, die einen Parameter namens <code>x</code> vom Typ
<code>i32</code> benötigt, sollte inzwischen bekannt aussehen.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn foo(x: i32) {
    // Code kommt hierher
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-6: Eine Funktionssignatur verwendet Muster
in den Parametern</span></p>
<p>Der Teil <code>x</code> ist ein Muster! Wie wir es mit <code>let</code> taten, konnten wir ein Tupel
in den Argumenten einer Funktion dem Muster zuordnen. Codeblock 19-7 teilt die
Werte in einem Tupel auf, wenn wir es an eine Funktion übergeben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!("Aktuelle Position: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
<p><span class="caption">Codeblock 19-7: Eine Funktion mit Parametern, die ein
Tupel destrukturieren</span></p>
<p>Dieser Code gibt <code>Aktuelle Position: (3, 5)</code> aus. Die Werte <code>&amp;(3, 5)</code> passen
zum Muster <code>&amp;(x, y)</code>, sodass <code>x</code> den Wert <code>3</code> und <code>y</code> den Wert <code>5</code> hat.</p>
<p>Wir können auch Muster in Funktionsabschlussparameterlisten (closure parameter
lists) auf die gleiche Weise wie in Funktionsparameterlisten verwenden, da
Funktionsabschlüsse ähnlich wie Funktionen sind, wie in Kapitel 13 besprochen.</p>
<p>An diesem Punkt hast du verschiedene Möglichkeiten der Verwendung von Mustern
gesehen, aber Muster funktionieren nicht an allen Stellen, an denen wir sie
verwenden können, gleich. An manchen Stellen müssen die Muster unabweisbar
(irrefutable) sein, unter anderen Umständen können sie abweisbar (refutable)
sein. Wir werden diese beiden Konzepte als Nächstes besprechen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="abweisbarkeit-falls-ein-muster-pattern-mal-nicht-passt"><a class="header" href="#abweisbarkeit-falls-ein-muster-pattern-mal-nicht-passt">Abweisbarkeit: Falls ein Muster (pattern) mal nicht passt</a></h2>
<p>Es gibt zwei Arten von Mustern: Abweisbare (refutable) und unabweisbare
(irrefutable). Muster, die für jeden möglichen übergebenen Wert passen, sind
<em>unabweisbar</em>. Ein Beispiel wäre <code>x</code> in der Anweisung <code>let x = 5;</code> weil <code>x</code> auf
alles passt und daher nicht fehlschlagen kann. Muster, die für irgendeinen
möglichen Wert nicht passen können, sind <em>abweisbar</em>. Ein Beispiel wäre
<code>Some(x)</code> im Ausdruck <code>if let Some(x) = a_value</code>, denn wenn der Wert in der
Variablen <code>a_value</code> eher <code>None</code> als <code>Some</code> ist, wird das Muster <code>Some(x)</code> nicht
passen.</p>
<p>Funktionsparameter, <code>let</code>-Anweisungen und <code>for</code>-Schleifen können nur
unabweisbare Muster akzeptieren, da das Programm nichts Sinnvolles tun kann,
wenn die Werte nicht passen. Die Ausdrücke <code>if let</code> und <code>while let</code> sowie die
Anweisung <code>let...else</code> akzeptieren abweisbare und unabweisbare Muster, aber der
Compiler warnt vor unabweisbaren Mustern, weil sie per Definition dazu gedacht
sind, mit einem möglichen Fehlerfall umzugehen: Die Funktionalität einer
Bedingung besteht in ihrer Fähigkeit, sich abhängig von Erfolg oder Fehlerfall
unterschiedlich zu verhalten.</p>
<p>Im Allgemeinen solltest du dich nicht um die Unterscheidung zwischen
abweisbaren und unabweisbaren Mustern kümmern müssen; du musst jedoch mit dem
Konzept der Abweisbarkeit vertraut sein, damit du reagieren kannst, wenn du es
in einer Fehlermeldung siehst. In diesen Fällen musst du entweder das Muster
oder das Konstrukt, in dem du das Muster verwendest, ändern, je nach dem
beabsichtigten Verhalten des Codes.</p>
<p>Betrachten wir ein Beispiel dafür, was passiert, wenn wir versuchen, ein
abweisbares Muster zu verwenden, wo Rust ein unabweisbares Muster erfordert und
umgekehrt. Codeblock 19-8 zeigt eine <code>let</code>-Anweisung, allerdings haben wir für
das Muster <code>Some(x)</code> angegeben, ein abweisbares Muster. Wie zu erwarten ist,
lässt sich dieser Code nicht kompilieren.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-8: Versuch, ein abweisbares Muster mit <code>let</code>
zu verwenden</span></p>
<p>Wenn <code>some_option_value</code> den Wert <code>None</code> hätte, würde er nicht zum Muster
<code>Some(x)</code> passen, was bedeutet, dass das Muster abweisbar ist. Die
<code>let</code>-Anweisung kann jedoch nur ein unabweisbares Muster akzeptieren, weil es
nichts Gültiges gibt, was der Code mit einem <code>None</code>-Wert tun kann. Zur
Kompilierzeit wird sich Rust beschweren, dass wir versucht haben, ein
abweisbares Muster zu verwenden, wo ein unabweisbares Muster erforderlich ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch19-02-refutability.html
  = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `let else` to handle the variant that isn't matched
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Da wir nicht jeden gültigen Wert mit dem Muster <code>Some(x)</code> abgedeckt haben (und
auch nicht abdecken konnten!), erzeugt Rust zu Recht einen Kompilierfehler.</p>
<p>Wenn wir ein abweisbares Muster haben, obwohl ein unabweisbares Muster benötigt
wird, können wir den Code, der das Muster verwendet, korrigieren: Anstatt <code>let</code>
zu verwenden, können wir <code>let...else</code> verwenden. Wenn das Muster dann nicht
passt, führt das Programm einfach den Code in den geschweiften Klammern aus und
gibt ihm die Möglichkeit, gültig fortzufahren. Codeblock 19-9 zeigt, wie der
Code in Codeblock 19-8 zu korrigieren ist.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value else {
        return;
    };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-9: Verwenden von <code>let...else</code> und eines
Blocks mit abweisbaren Mustern anstelle von <code>let</code></span></p>
<p>Wir haben den Code repariert! Dieser Code ist jetzt vollkommen gültig. Wenn wir
<code>let...else</code> allerdings ein unabweisbares Muster geben, das immer passt, z.B.
<code>x</code>, wie in Codeblock 19-10 gezeigt, gibt der Compiler eine Warnung aus.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5 else {
        return;
    };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-10: Der Versuch, ein unabweisbares Muster
mit <code>let...else</code> zu verwenden</span></p>
<p>Rust beklagt, dass es keinen Sinn macht, <code>let...else</code> mit einem unabweisbaren
Muster zu verwenden:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `let...else` pattern
 --&gt; src/main.rs:2:5
  |
2 |     let x = 5 else {
  |     ^^^^^^^^^
  |
  = note: this pattern will always match, so the `else` clause is useless
  = help: consider removing the `else` clause
  = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: `patterns` (bin "patterns") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>Aus diesem Grund müssen <code>match</code>-Zweige abweisbare Muster verwenden, mit
Ausnahme des letzten Zweigs, bei dem alle verbleibenden Werte mit einem
unabweisbaren Muster übereinstimmen sollten. Rust erlaubt es uns, ein
unabweisbares Muster in einem <code>match</code> mit nur einem Zweig zu verwenden, aber
diese Syntax ist nicht besonders nützlich und könnte durch eine einfachere
<code>let</code>-Anweisung ersetzt werden.</p>
<p>Da du nun weißt, wo du Muster verwenden kannst und den Unterschied zwischen
abweisbaren und unabweisbaren Mustern kennst, lass uns alle Syntaxen behandeln,
die wir zum Erstellen von Mustern verwenden können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mustersyntax"><a class="header" href="#mustersyntax">Mustersyntax</a></h2>
<p>In diesem Abschnitt stellen wir die gesamte Syntax gültiger Muster zusammen und
erörtern, warum und wann du jedes einzelne Muster verwenden solltest.</p>
<h3 id="literale-abgleichen"><a class="header" href="#literale-abgleichen">Literale abgleichen</a></h3>
<p>Wie du in Kapitel 6 gesehen hast, kannst du Muster direkt mit Literalen
abgleichen. Der folgende Code enthält einige Beispiele:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("eins"),
        2 =&gt; println!("zwei"),
        3 =&gt; println!("drei"),
        _ =&gt; println!("sonstige"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code gibt <code>eins</code> aus, weil der Wert in <code>x</code> 1 ist. Diese Syntax ist
nützlich, wenn du willst, dass dein Code eine Aktion ausführt, wenn er einen
bestimmten konkreten Wert erhält.</p>
<h3 id="benannte-variablen-abgleichen"><a class="header" href="#benannte-variablen-abgleichen">Benannte Variablen abgleichen</a></h3>
<p>Benannte Variablen (named variables) sind unabweisbare Muster, die zu jedem
Wert passen, und wir haben sie in diesem Buch schon oft verwendet. Es gibt
jedoch eine Komplikation, wenn du benannte Variablen in <code>match</code>-, <code>if let</code>-
oder <code>while let</code>-Ausdrücken verwendest. Da mit jeder dieser Ausdrücke ein neuer
Gültigkeitsbereich beginnt, werden Variablen, die als Teil eines Musters
innerhalb des Ausdrucks deklariert sind, diejenigen Variablen mit dem gleichen
Namen außerhalb verschatten (shadow), wie es bei allen Variablen der Fall ist.
In Codeblock 19-11 deklarieren wir eine Variable mit dem Namen <code>x</code> mit dem Wert
<code>Some(5)</code> und eine Variable <code>y</code> mit dem Wert <code>10</code>. Dann erzeugen wir einen
<code>match</code>-Ausdruck für den Wert <code>x</code>. Sieh dir die Muster in den <code>match</code>-Zweigen
und <code>println!</code> am Ende an und versuche herauszufinden, was der Code ausgeben
wird, bevor du diesen Code ausführst oder weiterliest.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Habe 50 erhalten"),
        Some(y) =&gt; println!("Passt, y = {y}"),
        _ =&gt; println!("Standardfall, x = {x:?}"),
    }

    println!("Am Ende: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-11: Ein <code>match</code>-Ausdruck mit einem Zweig,
der eine neue Variable einführt, die die bereits existierende Variable <code>y</code>
verschattet</span></p>
<p>Lass uns durchgehen, was passiert, wenn der <code>match</code>-Ausdruck ausgeführt wird.
Das Muster im ersten Zweig passt nicht zum definierten Wert von <code>x</code>, also setzt
der Code fort.</p>
<p>Das Muster im zweiten Zweig führt eine neue Variable namens <code>y</code> ein, die zu
jedem Wert innerhalb eines <code>Some</code>-Wertes passt. Da wir uns in einem neuen
Gültigkeitsbereich innerhalb des <code>match</code>-Ausdrucks befinden, ist dies eine neue
Variable <code>y</code>, nicht das <code>y</code>, das wir am Anfang mit dem Wert <code>10</code> deklariert
haben. Diese neue <code>y</code>-Bindung wird mit jedem Wert innerhalb eines <code>Some</code>
übereinstimmen, das ist das, was wir in <code>x</code> haben. Daher bindet dieses neue <code>y</code>
an den inneren Wert des <code>Some</code> in <code>x</code>. Dieser Wert ist <code>5</code>, sodass der Ausdruck
für diesen Zweig ausgeführt und <code>Passt, y = 5</code> ausgegeben wird.</p>
<p>Wäre <code>x</code> ein <code>None</code>-Wert anstelle von <code>Some(5)</code> gewesen, hätten die Muster in
den ersten beiden Zweigen nicht gepasst, sodass der Wert zum Unterstrich
gepasst hätte. Wir haben die Variable <code>x</code> nicht im Muster des
Unterstrich-Zweigs verwendet, sodass <code>x</code> im Ausdruck immer noch das äußere <code>x</code>
ist, das nicht verschattet wurde. In diesem hypothetischen Fall würde <code>match</code>
den Text <code>Standardfall, x = None</code> ausgeben.</p>
<p>Wenn der <code>match</code>-Ausdruck zu Ende ist, endet sein Gültigkeitsbereich und damit
auch der Gültigkeitsbereich des inneren <code>y</code>. Das letzte <code>println!</code> gibt <code>Am Ende: x = Some(5), y = 10</code> aus.</p>
<p>Um einen <code>match</code>-Ausdruck zu erstellen, der die Werte der äußeren Variablen <code>x</code>
und <code>y</code> abgleicht, anstatt eine neue Variable einzuführen, die die existierende
Variable <code>y</code> verschattet, müssten wir stattdessen eine Abgleichsbedingung
(match guard conditional) verwenden. Wir werden über Abgleichsbedingungen
später im Abschnitt <a href="ch19-03-pattern-syntax.html#extra-bedingungen-mit-abgleichsbedingungen">„Extra-Bedingungen mit
Abgleichsbedingungen“</a> sprechen.</p>
<h3 id="mehrfache-muster"><a class="header" href="#mehrfache-muster">Mehrfache Muster</a></h3>
<p>Du kannst mehrere Muster mit der Syntax <code>|</code> abgleichen, die das
<em>oder</em>-Operator-Muster darstellt. Zum Beispiel gleicht der folgende Code den
Wert von <code>x</code> mit den <code>match</code>-Zweigen ab, wobei der erste davon eine
<em>oder</em>-Option hat, was bedeutet, wenn der Wert von <code>x</code> zu einem der Werte in
diesem Zweig passt, wird der Code dieses Zweigs ausgeführt:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("eins oder zwei"),
        3 =&gt; println!("drei"),
        _ =&gt; println!("sonstige"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code gibt <code>eins oder zwei</code> aus.</p>
<h3 id="abgleichen-von-wertebereichen-mit-"><a class="header" href="#abgleichen-von-wertebereichen-mit-">Abgleichen von Wertebereichen mit <code>..=</code></a></h3>
<p>Die Syntax <code>..=</code> erlaubt es uns, einen inklusiven Wertebereich abzugleichen.
Wenn im folgenden Code ein Muster zu einem der Werte innerhalb des
vorgegebenen Bereichs passt, wird dieser Zweig ausgeführt:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("eins bis fünf"),
        _ =&gt; println!("etwas anderes"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Wenn <code>x</code> einen der Werte <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> oder <code>5</code> hat, passt der erste
Zweig. Diese Syntax ist bequemer bei mehreren Abgleichswerten als das Verwenden
des <code>|</code>-Operators, um die gleiche Idee auszudrücken; wenn wir <code>|</code> verwenden
wollten, müssten wir <code>1 | 2 | 3 | 4 | 5</code> angeben. Die Angabe eines Bereichs ist
viel kürzer, besonders wenn wir beispielsweise eine beliebige Zahl zwischen 1
und 1.000 angeben wollen!</p>
<p>Der Compiler prüft zur Kompilierzeit, dass der Bereich nicht leer ist. Die
einzigen Typen, bei denen Rust erkennen kann, ob ein Bereich leer ist oder
nicht, sind <code>char</code> und numerische Werte, Bereiche sind nur mit numerischen oder
<code>char</code>-Werten zulässig.</p>
<p>Hier ist ein Beispiel mit Bereichen von <code>char</code>-Werten:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("früher ASCII-Buchstabe"),
        'k'..='z' =&gt; println!("später ASCII-Buchstabe"),
        _ =&gt; println!("etwas anderes"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Rust kann erkennen, dass <code>'c'</code> innerhalb des Bereichs des ersten Musters liegt
und gibt <code>früher ASCII-Buchstabe</code> aus.</p>
<h3 id="destrukturieren-um-werte-aufzuteilen"><a class="header" href="#destrukturieren-um-werte-aufzuteilen">Destrukturieren, um Werte aufzuteilen</a></h3>
<p>Wir können auch Muster verwenden, um Strukturen (structs), Aufzählungen (enums)
und Tupel zu destrukturieren, um verschiedene Teile dieser Werte zu verwenden.
Lass uns jeden Wert durchgehen.</p>
<h4 id="destrukturieren-von-strukturen"><a class="header" href="#destrukturieren-von-strukturen">Destrukturieren von Strukturen</a></h4>
<p>Codeblock 19-12 zeigt eine Struktur <code>Point</code> mit zwei Feldern, <code>x</code> und <code>y</code>, die
wir mit einem Muster in einer <code>let</code>-Anweisung aufteilen können.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<p><span class="caption">Codeblock 19-12: Destrukturieren der Felder einer
Struktur in separate Variablen</span></p>
<p>Dieser Code erzeugt die Variablen <code>a</code> und <code>b</code>, die den Werten der Felder <code>x</code>
und <code>y</code> der Struktur <code>p</code> entsprechen. Dieses Beispiel zeigt, dass die Namen der
Variablen im Muster nicht mit den Feldnamen der Struktur übereinstimmen müssen.
Aber es ist üblich, dass die Variablennamen mit den Feldnamen übereinstimmen,
damit man sich leichter merken kann, welche Variablen aus welchen Feldern
stammen. Wegen dieser häufigen Verwendung und weil das Schreiben von <code>let Point { x: x, y: y } = p;</code> eine Menge Duplikation enthält, hat Rust eine Kurzform
für Muster, die mit Strukturfeldern übereinstimmen: Du musst nur die Namen des
Struktur-Felder auflisten, und die Variablen, die aus dem Muster erzeugt
werden, haben die gleichen Namen. Codeblock 19-13 zeigt Code, der sich gleich
verhält wie der Code in Codeblock 19-12, aber die Variablen, die im Muster
<code>let</code> erzeugt werden, sind <code>x</code> und <code>y</code> anstelle von <code>a</code> und <code>b</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<p><span class="caption">Codeblock 19-13: Destrukturieren von Strukturfeldern mit
Hilfe der Strukturfeldkurznotation (struct field shorthand)</span></p>
<p>Dieser Code erzeugt die Variablen <code>x</code> und <code>y</code>, die mit den Feldern <code>x</code> und <code>y</code>
der Variablen <code>p</code> übereinstimmen. Das Ergebnis ist, dass die Variablen <code>x</code> und
<code>y</code> die Werte aus der Struktur <code>p</code> enthalten.</p>
<p>Wir können auch mit literalen Werten als Teil des Strukturmusters
destrukturieren, anstatt Variablen für alle Felder zu erstellen. Auf diese
Weise können wir einige der Felder auf bestimmte Werte testen, während wir
Variablen zum Destrukturieren der anderen Felder erstellen.</p>
<p>In Codeblock 19-14 haben wir einen <code>match</code>-Ausdruck, der <code>Point</code>-Werte in drei
Fälle unterscheidet: Punkte, die direkt auf der <code>x</code>-Achse liegen (was zutrifft,
wenn <code>y = 0</code> ist), auf der <code>y</code>-Achse liegen (<code>x = 0</code>) oder auf keiner Achse.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("Auf der x-Achse bei {x}"),
        Point { x: 0, y } =&gt; println!("Auf der y-Achse bei {y}"),
        Point { x, y } =&gt; println!("Auf keiner Achse: ({x}, {y})"),
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 19-14: Destrukturieren und Abgleichen literaler
Werte in einem Muster</span></p>
<p>Der erste Zweig passt zu jedem Punkt, der auf der <code>x</code>-Achse liegt, indem er
angibt, dass der Wert des <code>y</code>-Felds zum Literal <code>0</code> passt. Das Muster erzeugt
immer noch eine Variable <code>x</code>, die wir im Code für diesen Zweig verwenden
können.</p>
<p>In ähnlicher Weise passt der zweite Zweig zu jedem Punkt auf der y-Achse, indem
er angibt, dass der Wert des <code>x</code>-Feldes 0 ist, und eine Variable <code>y</code>  für den
Wert des <code>y</code> -Feldes erzeugt. Der dritte Zweig spezifiziert keine Literale,
sodass er zu jedem anderen <code>Point</code> passt und Variablen für die Felder <code>x</code> und
<code>y</code> erzeugt.</p>
<p>In diesem Beispiel passt der Wert <code>p</code> zum zweiten Zweig, da <code>x</code> den Wert <code>0</code>
hat, sodass dieser Code <code>Auf der y-Achse bei 7</code> ausgeben wird.</p>
<p>Denke daran, dass ein <code>match</code>-Ausdruck aufhört, weitere Zweige zu prüfen,
sobald er das erste übereinstimmende Muster gefunden hat, d.h. auch wenn der
<code>Point { x: 0, y: 0}</code> auf der <code>x</code>-Achse und der <code>y</code>-Achse liegt, würde dieser
Code nur <code>Auf der x-Achse bei 0</code> ausgeben.</p>
<h4 id="destrukturieren-von-aufzählungen"><a class="header" href="#destrukturieren-von-aufzählungen">Destrukturieren von Aufzählungen</a></h4>
<p>Wir haben in diesem Buch bereits Aufzählungen destrukturiert (z.B. Codeblock
6-5), wir sind aber noch nicht explizit darauf eingegangen, dass das Muster zur
Destrukturierung einer Aufzählung der Art und Weise entspricht, wie die in der
Aufzählung gespeicherten Daten definiert sind. Als Beispiel verwenden wir in
Codeblock 19-15 die Aufzählung <code>Message</code> aus Codeblock 6-2 und schreiben ein
<code>match</code> mit Mustern, das jeden inneren Wert destrukturiert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("Die Quit-Variante hat keine Daten zu destrukturieren.")
        }
        Message::Move { x, y } =&gt; {
            println!("Bewege in x-Richtung {x} und in y-Richtung {y}");
        }
        Message::Write(text) =&gt; {
            println!("Textnachricht: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Ändere Farbe in rot {r}, grün {g} und blau {b}");
        }
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 19-15: Destrukturieren von
Aufzählungsvarianten, die verschiedene Arten von Werten enthalten</span></p>
<p>Dieser Code gibt <code>Ändere Farbe in rot 0, grün 160 und blau 255</code> aus. Versuche,
den Wert von <code>msg</code> zu ändern, um den Code der anderen Zweige laufen zu sehen.</p>
<p>Bei Aufzählungs-Varianten ohne Daten, wie <code>Message::Quit</code>, können wir den Wert
nicht weiter destrukturieren. Wir können nur mit dem Literalwert
<code>Message::Quit</code> abgleichen und es gibt keine Variablen in diesem Muster.</p>
<p>Für strukturähnliche Aufzählungsvarianten, z.B. <code>Message::Move</code>, können wir ein
Muster verwenden, das dem von uns angegebenen Muster ähnlich ist, um Strukturen
abzugleichen. Nach dem Variantennamen setzen wir geschweifte Klammern und
listen dann die Felder mit Variablen auf, sodass wir die Teile aufteilen, die
im Code für diesen Zweig verwendet werden sollen. Hier verwenden wir die
Kurznotation, wie wir es in Codeblock 19-13 getan haben.</p>
<p>Bei tupelähnlichen Aufzählungsvarianten wie <code>Message::Write</code>, die ein Tupel mit
einem Element enthält, und <code>Message::ChangeColor</code>, die ein Tupel mit drei
Elementen enthält, ähnelt das Muster dem Muster, das wir für den Abgleich von
Tupeln angeben. Die Anzahl der Variablen im Muster muss mit der Anzahl der
Elemente in der Variante, die wir abgleichen, übereinstimmen.</p>
<h4 id="destrukturieren-verschachtelter-strukturen-und-aufzählungen"><a class="header" href="#destrukturieren-verschachtelter-strukturen-und-aufzählungen">Destrukturieren verschachtelter Strukturen und Aufzählungen</a></h4>
<p>Bis jetzt haben unsere Beispiele alle Strukturen oder Aufzählungen auf einer
Ebene abgeglichen, aber der Abgleich funktioniert auch bei verschachtelten
Elementen! Zum Beispiel können wir den Code in Codeblock 19-15 umstrukturieren,
um RGB- und HSV-Farben in der <code>ChangeColor</code>-Nachricht zu unterstützen, wie in
Codeblock 19-16 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust edition2024">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Ändere Farbe in rot {r}, grün {g} und blau {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Ändere Farbe in Farbwert {h}, Sättigung {s} und Hellwert {v}")
        }
        _ =&gt; (),
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 19-16: Abgleich bei verschachtelten
Aufzählungen</span></p>
<p>Das Muster des ersten Zweigs im <code>match</code>-Ausdruck passt zu einer
<code>Message::ChangeColor</code>-Aufzählungsvariante, die eine <code>Color::Rgb</code>-Variante
enthält; dann bindet das Muster an die drei inneren <code>i32</code>-Werte. Das Muster des
zweiten Zweigs passt ebenfalls mit einer
<code>Message::ChangeColor</code>-Aufzählungsvariante, aber die innere Aufzählung passt
stattdessen zur <code>Color::Hsv</code>-Variante. Wir können diese komplexen Bedingungen
in einem einzigen <code>match</code>-Ausdruck angeben, auch wenn es sich um zwei
Aufzählungen handelt.</p>
<h4 id="destrukturieren-von-strukturen-und-tupeln"><a class="header" href="#destrukturieren-von-strukturen-und-tupeln">Destrukturieren von Strukturen und Tupeln</a></h4>
<p>Wir können das Abgleichen und Destrukturieren verschachtelter Muster auf noch
komplexere Weise mischen. Das folgende Beispiel zeigt eine komplizierte
Destrukturierung, bei der wir Strukturen und Tupel innerhalb eines Tupels
verschachteln und alle primitiven Werte herausdestrukturieren:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code ermöglicht es uns, komplexe Typen in ihre Bestandteile zu zerlegen,
sodass wir die Werte, an denen wir interessiert sind, separat verwenden können.</p>
<p>Das Destrukturieren mit Mustern ist eine bequeme Möglichkeit, Wertteile, z.B.
Werte aus den Feldern in einer Struktur, getrennt voneinander zu verwenden.</p>
<h3 id="ignorieren-von-werten-in-einem-muster"><a class="header" href="#ignorieren-von-werten-in-einem-muster">Ignorieren von Werten in einem Muster</a></h3>
<p>Du hast gesehen, dass es manchmal nützlich ist, Werte in einem Muster zu
ignorieren, z.B. im letzten Zweig eines <code>match</code>, um einen Sammelzweig zu
erhalten, der eigentlich nichts tut, aber alle verbleibenden möglichen Werte
berücksichtigt. Es gibt ein paar Möglichkeiten, ganze Werte oder Teile von
Werten in einem Muster zu ignorieren: Verwenden des Musters <code>_</code> (das du gesehen
hast), Verwenden des Musters <code>_</code> innerhalb eines anderen Musters, Verwenden
eines Namens, der mit einem Unterstrich beginnt, oder Verwenden von <code>..</code>, um
verbleibende Teile eines Wertes zu ignorieren. Lass uns untersuchen, wie und
wann jedes dieser Muster zu verwenden ist.</p>
<h4 id="gesamtwert-mit-_"><a class="header" href="#gesamtwert-mit-_">Gesamtwert mit <code>_</code></a></h4>
<p>Wir haben den Unterstrich (<code>_</code>) als Platzhalter verwendet, der zu jedem Wert
passt, aber nicht an den Wert gebunden ist. Dies ist besonders nützlich als
letzter Zweig in einem <code>match</code>-Ausdruck ist, aber wir können es in jedem Muster
verwenden, einschließlich Funktionsparameter, wie in Codeblock 19-17 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn foo(_: i32, y: i32) {
    println!("Dieser Code verwendet nur den Parameter y: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<p><span class="caption">Codeblock 19-17: Verwenden von <code>_</code> in einer
Funktionssignatur</span></p>
<p>Dieser Code ignoriert den als erstes Argument übergebenen Wert <code>3</code> vollständig
und gibt <code>Dieser Code verwendet nur den Parameter y: 4</code> aus.</p>
<p>In den meisten Fällen, wenn du einen bestimmten Funktionsparameter nicht mehr
benötigst, würdest du die Signatur so ändern, dass sie den unbenutzten
Parameter nicht mehr enthält. Das Ignorieren eines Funktionsparameters kann in
einigen Fällen besonders nützlich sein, z.B. bei der Implementierung eines
Merkmals (trait), wenn du eine bestimmte Typsignatur benötigst, der
Funktionsrumpf in deiner Implementierung jedoch keinen der Parameter benötigt.
Du kannst dann vermeiden, dass der Compiler vor unbenutzten Funktionsparametern
warnt, wie es der Fall wäre, wenn du stattdessen einen Namen verwenden würdest.</p>
<h4 id="teile-eines-wertes-mit-einem-verschachtelten-_"><a class="header" href="#teile-eines-wertes-mit-einem-verschachtelten-_">Teile eines Wertes mit einem verschachtelten <code>_</code></a></h4>
<p>Wir können <code>_</code> auch innerhalb eines anderen Musters verwenden, um nur einen
Teil eines Wertes zu ignorieren, z.B. wenn wir nur auf einen Teil eines Wertes
testen wollen, aber keine Verwendung für die anderen Teile in dem
entsprechenden Code haben, den wir ausführen wollen. Der Codeblock 19-18 zeigt
den Code, der für die Verwaltung des Wertes einer Einrichtung verantwortlich
ist. Die Geschäftsanforderungen bestehen darin, dass es dem Benutzer nicht
erlaubt sein soll, eine bestehende Anpassung einer Einstellung zu
überschreiben, sondern dass er die Einstellung rückgängig machen kann und ihr
einen Wert zuweisen kann, wenn sie derzeit nicht gesetzt ist.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Kann einen vorhandenen benutzerdefinierten Wert nicht überschreiben.");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("Einstellung ist {setting_value:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-18: Das Verwenden eines Unterstrichs
innerhalb von Mustern, die zu <code>Some</code>-Varianten passen, wenn wir den Wert
innerhalb <code>Some</code> nicht benötigen</span></p>
<p>Dieser Code gibt <code>Kann einen vorhandenen benutzerdefinierten Wert nicht überschreiben.</code> aus und dann <code>Einstellung ist Some(5)</code>. Im ersten
<code>match</code>-Zweig müssen wir nicht die Werte innerhalb der beiden <code>Some</code>-Varianten
abgleichen oder diese verwenden, aber wir müssen den Fall prüfen, dass
<code>setting_value</code> und <code>new_setting_value</code> jeweils <code>Some</code>-Varianten sind. In
diesem Fall geben wir den Grund aus, warum wir <code>setting_value</code> nicht ändern,
und es wird nicht geändert.</p>
<p>In allen anderen Fällen (wenn entweder <code>setting_value</code> oder <code>new_setting_value</code>
den Wert <code>None</code> hat), die durch das Muster <code>_</code> im zweiten Zweig ausgedrückt
werden, wollen wir erlauben, dass <code>setting_value</code> den Wert von
<code>new_setting_value</code> erhält.</p>
<p>Wir können Unterstriche auch an mehreren Stellen innerhalb eines Musters
verwenden, um bestimmte Werte zu ignorieren. Codeblock 19-19 zeigt ein Beispiel
für das Ignorieren des zweiten und vierten Wertes in einem Tupel von fünf
Elementen.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Einige Zahlen: {first}, {third}, {fifth}")
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-19: Ignorieren mehrerer Teile eines
Tupels</span></p>
<p>Dieser Code gibt <code>Einige Zahlen: 2, 8, 32</code> aus und die Werte <code>4</code> und <code>16</code>
werden ignoriert.</p>
<h4 id="eine-unbenutzte-variable-mit-_-am-namensanfang"><a class="header" href="#eine-unbenutzte-variable-mit-_-am-namensanfang">Eine unbenutzte Variable mit <code>_</code> am Namensanfang</a></h4>
<p>Wenn du eine Variable erstellst, sie aber nirgendwo verwendest, wird Rust
normalerweise eine Warnung ausgeben, weil eine unbenutzte Variable ein Fehler
sein könnte. Aber manchmal ist es nützlich, eine Variable erstellen zu können,
die du noch nicht verwenden wirst, z.B. wenn du einen Prototyp erstellst oder
gerade ein Projekt beginnst. In dieser Situation kannst du Rust anweisen, dich
nicht vor der unbenutzten Variablen zu warnen, indem du den Namen der Variablen
mit einem Unterstrich beginnst. In Codeblock 19-20 erstellen wir zwei
unbenutzte Variablen, aber wenn wir diesen Code kompilieren, sollten wir nur
vor einer von ihnen eine Warnung erhalten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<p><span class="caption">Codeblock 19-20: Beginnen eines Variablennamens mit einem
Unterstrich, um Warnungen zu unbenutzten Variablen zu vermeiden</span></p>
<p>Hier erhalten wir eine Warnung zur unbenutzten Variablen <code>y</code>, aber wir erhalten
keine Warnung zur unbenutzten Variablen <code>_x</code>.</p>
<p>Beachte, dass es einen feinen Unterschied gibt zwischen dem Verwenden von <code>_</code>
und dem Verwenden eines Namens, der mit einem Unterstrich beginnt. Die Syntax
<code>_x</code> bindet immer noch den Wert an die Variable, während <code>_</code> überhaupt nicht
bindet. Um einen Fall zu zeigen, in dem diese Unterscheidung von Bedeutung ist,
wird uns Codeblock 19-21 einen Fehler liefern.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = Some(String::from("Hallo!"));

    if let Some(_s) = s {
        println!("Zeichenkette gefunden");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-21: Eine unbenutzte Variable, die mit einem
Unterstrich beginnt, bindet immer noch den Wert, der die Eigentümerschaft des
Wertes übernehmen könnte</span></p>
<p>Wir werden einen Fehler erhalten, weil der Wert <code>s</code> immer noch in <code>_s</code>
verschoben wird, was uns daran hindert, <code>s</code> wieder zu verwenden. Das Verwenden
des Unterstrichs an sich bindet jedoch niemals einen Wert. Codeblock 19-22 wird
ohne Fehler kompilieren, weil <code>s</code> nicht in <code>_</code> verschoben wird.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = Some(String::from("Hallo!"));

    if let Some(_) = s {
        println!("Zeichenkette gefunden");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-22: Das Verwenden eines Unterstrichs bindet
den Wert nicht</span></p>
<p>Dieser Code funktioniert prima, weil wir <code>s</code> nie an etwas binden; es wird nicht
verschoben.</p>
<h4 id="verbleibende-teile-eines-wertes-mit-"><a class="header" href="#verbleibende-teile-eines-wertes-mit-">Verbleibende Teile eines Wertes mit <code>..</code></a></h4>
<p>Bei Werten, die viele Teile haben, können wir die Syntax <code>..</code> verwenden, um nur
spezifische Teile zu verwenden und den Rest zu ignorieren, sodass es nicht
notwendig ist, für jeden ignorierten Wert Unterstriche aufzulisten. Das Muster
<code>..</code> ignoriert alle Teile eines Wertes, die wir im Rest des Musters nicht
explizit zugeordnet haben. In Codeblock 19-23 haben wir eine Struktur <code>Point</code>,
die eine Koordinate im dreidimensionalen Raum enthält. Im <code>match</code>-Ausdruck
wollen wir nur mit der Koordinate <code>x</code> operieren und die Werte in den Feldern
<code>y</code> und <code>z</code> ignorieren.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x ist {x}"),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-23: Ignorieren aller Felder eines <code>Point</code>
mit Ausnahme von <code>x</code> durch Verwenden von <code>..</code></span></p>
<p>Wir listen den Wert <code>x</code> auf und fügen dann einfach das Muster <code>..</code> ein. Das
geht schneller, als <code>y: _</code> und <code>z: _</code> anzugeben, insbesondere wenn wir mit
Strukturen arbeiten, die viele Felder haben, in Situationen, in denen nur ein
oder zwei Felder relevant sind.</p>
<p>Die Syntax <code>..</code> wird auf so viele Werte wie nötig erweitert. Codeblock 19-24
zeigt, wie man <code>..</code> mit einem Tupel verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Einige Zahlen: {first}, {last}");
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-24: Nur den ersten und letzten Wert in einem
Tupel abgleichen und alle anderen Werte ignorieren</span></p>
<p>In diesem Code werden der erste und der letzte Wert mit <code>first</code> und <code>last</code>
abgeglichen. Das <code>..</code> passt zu allem in der Mitte und ignoriert es.</p>
<p>Das Verwenden von <code>..</code> muss jedoch eindeutig sein. Wenn unklar ist, welche
Werte zum Abgleich vorgesehen sind und welche ignoriert werden sollten, gibt
uns Rust einen Fehler. Codeblock 19-25 zeigt ein Beispiel für die mehrdeutige
Verwendung von <code>..</code>, sodass es sich nicht kompilieren lässt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Einige Zahlen: {second}")
        },
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-25: Ein Versuch, <code>..</code> auf mehrdeutige Weise
zu verwenden</span></p>
<p>Wenn wir dieses Beispiel kompilieren, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Es ist für Rust unmöglich zu bestimmen, wie viele Werte im Tupel zu ignorieren
sind, bevor ein Wert zu <code>second</code> passt, und wie viele weitere Werte danach zu
ignorieren sind. Dieser Code könnte bedeuten, dass wir <code>2</code> ignorieren wollen,
<code>second</code> an <code>4</code> binden und dann <code>8</code>, <code>16</code> und <code>32</code> ignorieren wollen; oder dass
wir <code>2</code> und <code>4</code> ignorieren wollen, <code>second</code> an <code>8</code> binden und dann <code>16</code> und
<code>32</code> ignorieren wollen; und so weiter. Der Variablenname <code>second</code> bedeutet für
Rust nichts Besonderes, sodass wir einen Kompilierfehler erhalten, weil das
Verwenden von <code>..</code> an zwei Stellen wie dieser mehrdeutig ist.</p>
<h3 id="extra-bedingungen-mit-abgleichsbedingungen"><a class="header" href="#extra-bedingungen-mit-abgleichsbedingungen">Extra-Bedingungen mit Abgleichsbedingungen</a></h3>
<p>Eine <em>Abgleichsbedingung</em> (match guard) ist eine zusätzliche <code>if</code>-Bedingung,
die nach dem Muster in einem <code>match</code>-Zweig angegeben wird und die zusammen mit
dem Musterabgleich ebenfalls übereinstimmen muss, damit dieser Zweig ausgewählt
wird. Abgleichsbedingungen sind nützlich, um komplexere Ideen auszudrücken, als
es ein Muster allein erlaubt. Beachte jedoch, dass sie nur in
<code>match</code>-Ausdrücken verfügbar sind, nicht in <code>if let</code>- oder <code>while  let</code>-Ausdrücken.</p>
<p>Die Bedingung kann Variablen verwenden, die im Muster erstellt wurden.
Codeblock 19-26 zeigt ein <code>match</code>, wobei der erste Zweig das Muster <code>Some(x)</code>
und die Abgleichsbedingung <code>if x % 2 == 0</code> (die <code>true</code> ist, wenn die Zahl
gerade ist) hat.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("Die Zahl {x} ist gerade"),
        Some(x) =&gt; println!("Die Zahl {x} ist ungerade"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-26: Hinzufügen einer Abgleichsbedingung zu
einem Muster</span></p>
<p>In diesem Beispiel wird <code>Die Zahl 4 ist gerade</code> ausgegeben. Wenn <code>num</code> mit dem
Muster im ersten Zweig abgeglichen wird, passt es, weil <code>Some(4)</code> zu <code>Some(x)</code>
passt. Dann prüft die Abgleichsbedingung, ob der Rest der Division von <code>x</code>
durch 2 gleich 0 ist, und weil dies der Fall ist, wird der erste Zweig ausgewählt.</p>
<p>Wenn <code>num</code> stattdessen <code>Some(5)</code> gewesen wäre, wäre die Abgleichsbedingung im
ersten Zweig <code>false</code> gewesen, weil der Rest von 5 geteilt durch 2 den Wert 1
ergibt, was ungleich 0 ist. Rust würde dann zum zweiten Zweig gehen, der passen
würde, weil der zweite Zweig keine Abgleichsbedingung hat und daher zu allen
<code>Some</code>-Varianten passt.</p>
<p>Es gibt keine Möglichkeit, die Bedingung <code>if x % 2 == 0</code> innerhalb eines Musters
auszudrücken, also gibt uns die Abgleichsbedingung die Möglichkeit, diese Logik
anzugeben. Der Nachteil dieser zusätzlichen Ausdruckskraft ist, dass der
Compiler nicht versucht, die Vollständigkeit zu prüfen, wenn
Abgleichsbedingungs-Ausdrücke beteiligt sind.</p>
<p>In Codeblock 19-11 haben wir erwähnt, dass wir zur Lösung unseres
Musterverschattungsproblems (pattern-shadowing problem) Abgleichsbedingungen
verwenden könnten. Erinnere dich daran, dass eine neue Variable innerhalb des
Musters im <code>match</code>-Ausdruck erstellt wurde, anstatt die Variable außerhalb von
<code>match</code> zu verwenden. Diese neue Variable bedeutete, dass wir nicht gegen den
Wert der äußeren Variable testen konnten. Codeblock 19-27 zeigt, wie wir eine
Abgleichsbedingung verwenden können, um dieses Problem zu beheben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Habe 50 erhalten"),
        Some(n) if n == y =&gt; println!("Passt, n = {n}"),
        _ =&gt; println!("Standardfall, x = {x:?}"),
    }

    println!("Am Ende: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-27: Verwenden einer Abgleichsbedingung zum
Testen der Gleichheit mit einer äußeren Variablen</span></p>
<p>Dieser Code gibt nun <code>Standardfall, x = Some(5)</code> aus. Das Muster im zweiten
<code>match</code>-Zweig führt keine neue Variable <code>y</code> ein, die das äußere <code>y</code> verschatten
würde, was bedeutet, dass wir das äußere <code>y</code> in der Abgleichsbedingung
verwenden können. Anstatt das Muster mit <code>Some(y)</code> zu spezifizieren, was das
äußere <code>y</code> verschattet hätte, spezifizieren wir <code>Some(n)</code>. Dies erzeugt eine
neue Variable <code>n</code>, die nichts verschattet, weil es keine Variable <code>n</code> außerhalb
von <code>match</code> gibt.</p>
<p>Die Abgleichsbedingung <code>if n == y</code> ist kein Muster und führt daher keine neuen
Variablen ein. Dieses <code>y</code> <em>ist</em> das äußere <code>y</code> und nicht ein neues <code>y</code>, das es
verschattet, und wir können nach einem Wert suchen, der den gleichen Wert wie
das äußere <code>y</code> hat, indem wir <code>n</code> mit <code>y</code> vergleichen.</p>
<p>Du kannst auch den <em>oder</em>-Operator <code>|</code> in einer Abgleichsbedingung verwenden,
um mehrere Muster anzugeben; die Abgleichsbedingung gilt dann für alle Muster.
Codeblock 19-28 zeigt den Vorrang der Kombination einer Abgleichsbedingung mit
einem Muster, das <code>|</code> verwendet. Der wichtige Teil dieses Beispiels ist, dass
die Abgleichsbedingung <code>if y</code> auf <code>4</code>, <code>5</code> <em>und</em> <code>6</code> zutrifft, auch wenn es so
aussehen mag, als ob <code>if y</code> nur auf <code>6</code> zutrifft.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("ja"),
        _ =&gt; println!("nein"),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-28: Kombinieren mehrerer Muster mit einer
Abgleichsbedingung</span></p>
<p>Die Abgleichsbedingung besagt, dass der Zweig nur dann passt, wenn der Wert von
<code>x</code> gleich <code>4</code>, <code>5</code> oder <code>6</code> ist <em>und</em> wenn <code>y</code> <code>wahr</code> ist. Wenn dieser Code
ausgeführt wird, passt das Muster des ersten Zweigs, weil <code>x</code> gleich <code>4</code> ist,
allerdings ist die Abgleichsbedingung <code>if y</code> falsch, sodass der erste Zweig
nicht ausgewählt wird. Der Code geht weiter zum zweiten Zweig, der passt, und
dieses Programm gibt <code>nein</code> aus. Der Grund dafür ist, dass die <code>if</code>-Bedingung
für das gesamte Muster <code>4 | 5 | 6</code> gilt, nicht nur für den letzten Wert <code>6</code>.
Mit anderen Worten, der Vorrang einer Abgleichsbedingung in Bezug auf ein
Muster verhält sich wie folgt:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>und nicht so:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>Nach dem Ausführen des Codes ist das Vorrangsverhalten offensichtlich: Würde
die Abgleichsbedingung nur auf den Endwert in der mit dem <code>|</code>-Operator
angegebenen Werteliste angewendet, hätte der Zweig gepasst und das Programm
hätte <code>ja</code> ausgegeben.</p>
<h3 id="-bindungen"><a class="header" href="#-bindungen"><code>@</code>-Bindungen</a></h3>
<p>Mit dem <em>at</em>-Operator <code>@</code> können wir eine Variable erstellen, die einen Wert
enthält, während wir gleichzeitig diesen Wert testen, um festzustellen, ob er
zu einem Muster passt. Codeblock 19-29 zeigt ein Beispiel, bei dem wir testen
wollen, dass ein <code>Message::Hello</code>-Feld <code>id</code> innerhalb des Bereichs <code>3..=7</code>
liegt. Wir wollen den Wert auch an die Variable <code>id_variable</code> binden, damit wir
ihn in dem mit dem Zweig verbundenen Code verwenden können. Wir könnten diese
Variable <code>id</code> nennen, so wie das Feld, aber für dieses Beispiel werden wir
einen anderen Namen verwenden.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("id im Bereich gefunden: {id_variable}"),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("id in einem anderen Bereich gefunden")
        }
        Message::Hello { id } =&gt; println!("Eine andere id gefunden: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-29: Verwenden von <code>@</code>, um an einen Wert in
einem Muster zu binden und ihn gleichzeitig zu testen</span></p>
<p>In diesem Beispiel wird <code>id im Bereich gefunden: 5</code> ausgegeben. Durch das
Angeben von <code>id_variable @</code> vor dem Bereich <code>3..=7</code> erfassen wir den Wert, der
mit dem Bereich übereinstimmt, und testen gleichzeitig, ob der Wert zum
Bereichsmuster passt.</p>
<p>Im zweiten Zweig, wo wir im Muster nur einen Bereich spezifiziert haben, hat
der zum Zweig gehörende Code keine Variable, die den tatsächlichen Wert des
<code>id</code>-Feldes enthält. Der Wert des <code>id</code>-Feldes hätte 10, 11 oder 12 sein können,
aber der Code, der zu diesem Muster gehört, weiß nicht, welcher es ist. Der
Code des Musters ist nicht in der Lage, den Wert des <code>id</code>-Feldes zu verwenden,
weil wir den <code>id</code>-Wert nicht in einer Variablen gespeichert haben.</p>
<p>Im letzten Zweig, in dem wir eine Variable ohne Bereich angegeben haben, haben
wir den Wert, der im Code des Zweigs verfügbar ist, in einer Variablen namens
<code>id</code>. Der Grund dafür ist, dass wir die Syntax des Struktur-Feldes in
Kurznotation verwendet haben. Aber wir haben keinen Test auf den Wert im Feld
<code>id</code> in diesem Zweig angewandt, wie wir es bei den ersten beiden Zweigen getan
haben: Jeder Wert würde zu diesem Muster passen.</p>
<p>Mit <code>@</code> können wir einen Wert testen und ihn in einer Variablen innerhalb eines
Musters speichern.</p>
<h2 id="zusammenfassung-18"><a class="header" href="#zusammenfassung-18">Zusammenfassung</a></h2>
<p>Die Muster in Rust sind sehr nützlich, um zwischen verschiedenen Arten von
Daten zu unterscheiden. Wenn sie in <code>match</code>-Ausdrücken verwendet werden, stellt
Rust sicher, dass deine Muster jeden möglichen Wert abdecken oder dein Programm
sich nicht kompilieren lässt. Muster in <code>let</code>-Anweisungen und
Funktionsparametern machen diese Konstrukte nützlicher und ermöglichen das
Destrukturieren von Werten in kleinere Teile und gleichzeitig das Zuweisen
dieser Teile an Variablen. Wir können einfache oder komplexe Muster erstellen,
die unseren Bedürfnissen entsprechen.</p>
<p>Als nächstes werden wir uns im vorletzten Kapitel des Buches mit einigen
fortgeschrittenen Aspekten einer Vielzahl von Rusts Funktionalitäten befassen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fortgeschrittene-sprachelemente"><a class="header" href="#fortgeschrittene-sprachelemente">Fortgeschrittene Sprachelemente</a></h1>
<p>Inzwischen hast du die am häufigsten verwendeten Teile der Programmiersprache
Rust gelernt. Bevor wir in Kapitel 20 ein weiteres Projekt durchführen, werden
wir uns einige Aspekte der Sprache ansehen, auf die du hin und wieder stoßen
könntest, aber nicht jeden Tag verwenden wirst. Du kannst dieses Kapitel als
Referenz verwenden, wenn du auf Unbekanntes stößt. Die hier beschriebenen
Funktionalitäten sind in ganz bestimmten Situationen nützlich. Auch wenn du sie
vielleicht nicht oft brauchst, möchten wir sicherstellen, dass du alle
Funktionen von Rust kennst.</p>
<p>In diesem Kapitel werden wir behandeln:</p>
<ul>
<li>Unsicheres Rust: Wie kann man einige der Garantien von Rust ausschalten und
Verantwortung für das manuelle Aufrechterhalten dieser Garantien übernehmen?</li>
<li>Fortgeschrittene Merkmale (traits): Assoziierte Typen, Standardtypparameter,
voll qualifizierte Syntax, Supermerkmale (supertraits) und das Newtype-Muster
in Bezug auf Merkmale</li>
<li>Fortgeschrittene Typen: Mehr über das Newtype-Muster, Typ-Aliase, den Typ
never und Typen dynamischer Größe</li>
<li>Erweiterte Funktionen und Funktionsabschlüsse: Funktionszeiger und
Zurückgeben von Funktionsabschlüssen</li>
<li>Makros: Möglichkeiten, Code zu definieren, der zur Kompilierzeit mehr Code
definiert</li>
</ul>
<p>Es ist eine Reihe von Rust-Funktionalitäten, die für jeden etwas bietet! Lass
uns eintauchen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsicheres-unsafe-rust"><a class="header" href="#unsicheres-unsafe-rust">Unsicheres (unsafe) Rust</a></h2>
<p>Bei allem Code, den wir bisher besprochen haben, wurden Rusts
Speichersicherheitsgarantien zur Kompilierzeit erzwungen. Allerdings ist in
Rust eine zweite Sprache versteckt, die diese Speichersicherheitsgarantien
nicht erzwingt: Sie heißt <em>unsicheres Rust</em> (unsafe Rust) und funktioniert
genau wie das normale Rust, gibt uns aber zusätzliche Superkräfte.</p>
<p>Unsicheres Rust existiert, weil die statische Analyse von Natur aus konservativ
ist. Wenn der Compiler versucht festzustellen, ob der Code die Garantien
einhält oder nicht, ist es besser für ihn, einige gültige Programme
zurückzuweisen, als einige ungültige Programme zu akzeptieren. Obwohl der Code
<em>möglicherweise</em> in Ordnung ist, wird der Rust-Compiler den Code ablehnen, wenn
er nicht genügend Informationen hat, um sicher zu sein. In diesen Fällen kannst
du unsicheren Code verwenden, um dem Compiler zu sagen: „Vertraue mir, ich
weiß, was ich tue.“ Sei jedoch gewarnt, dass du unsicheres Rust auf eigenes
Risiko verwendest: Wenn du unsicheren Code falsch verwendest, können Probleme
aufgrund von Speicherunsicherheiten auftreten, z.B. Dereferenzierung von
Null-Zeigern.</p>
<p>Ein weiterer Grund, warum Rust ein unsicheres zweites Ich hat, ist, dass die
zugrunde liegende Computer-Hardware von Natur aus unsicher ist. Wenn Rust dich
keine unsicheren Operationen durchführen ließe, könntest du bestimmte Aufgaben
nicht ausführen. Rust muss es dir ermöglichen, Low-Level-Systemprogrammierung
zu machen, z.B. direkt mit dem Betriebssystem zu interagieren oder sogar dein
eigenes Betriebssystem zu schreiben. Arbeiten mit
Low-Level-Systemprogrammierung ist eines der Ziele der Sprache. Lass uns
untersuchen, was wir mit unsicherem Rust tun können und wie wir es tun können.</p>
<h3 id="unsichere-superkräfte"><a class="header" href="#unsichere-superkräfte">Unsichere Superkräfte</a></h3>
<p>Um auf unsicheres Rust umzuschalten, verwendest du das Schlüsselwort <code>unsafe</code>
und startest dann einen neuen Block, der den unsicheren Code enthält. In
unsicherem Rust kannst du fünf Aktionen ausführen, die du in sicherem Rust
nicht ausführen kannst, die wir <em>unsichere Superkräfte</em> nennen. Zu diesen
Superkräften gehören folgende Fähigkeiten:</p>
<ul>
<li>Dereferenzieren eines Rohzeigers</li>
<li>Aufrufen einer unsicheren Funktion oder Methode</li>
<li>Zugreifen auf oder Ändern einer veränderbaren statischen Variablen</li>
<li>Implementieren eines unsicheren Merkmals (trait)</li>
<li>Zugreifen auf Feldern in <code>union</code></li>
</ul>
<p>Es ist wichtig zu verstehen, dass <code>unsafe</code> weder den Ausleihenprüfer (borrow
checker) abschaltet noch andere Sicherheitsprüfungen von Rust deaktiviert: Wenn
du eine Referenz in einem unsicheren Code verwendest, wird diese trotzdem
geprüft. Das Schlüsselwort <code>unsafe</code> gibt dir nur Zugriff auf diese fünf
Funktionalitäten, die dann vom Compiler nicht auf Speichersicherheit geprüft
werden. In einem unsicheren Block erhältst du immer noch ein gewisses Maß an
Sicherheit.</p>
<p>Darüber hinaus bedeutet <code>unsafe</code> nicht, dass der Code innerhalb des Blocks
notwendigerweise gefährlich ist oder dass er definitiv
Speichersicherheitsprobleme haben wird: Das Ziel ist, dass du als Programmierer
sicherstellst, dass der Code innerhalb eines <code>unsafe</code>-Blocks auf gültige Weise
auf den Speicher zugreifen wird.</p>
<p>Menschen sind fehlbar und Fehler werden passieren, aber wenn du verlangst, dass
diese fünf unsicheren Operationen innerhalb von Blöcken mit dem Vermerk
<code>unsafe</code> durchgeführt werden müssen, weißt du, dass alle Fehler im Zusammenhang
mit der Speichersicherheit innerhalb eines <code>unsafe</code>-Blocks liegen müssen. Halte
<code>unsafe</code>-Blöcke klein; du wirst später dankbar sein, wenn du Speicherfehler
untersuchst.</p>
<p>Um unsicheren Code so weit wie möglich zu isolieren, ist es am besten, solchen
Code in eine sichere Abstraktion einzupacken und eine sichere API
bereitzustellen, auf die wir später im Kapitel eingehen werden, wenn wir
unsichere Funktionen und Methoden untersuchen. Teile der Standardbibliothek
sind als sichere Abstraktionen über unsicheren, geprüften Code implementiert.
Das Einpacken von unsicherem Code in eine sichere Abstraktion verhindert, dass
sich die Verwendung von <code>unsafe</code> auf alle Stellen auswirkt, an denen du oder
deine Benutzer die mit <code>unsafe</code>-Code implementierte Funktionalität verwenden
möchtest, da das Verwenden einer sicheren Abstraktion sicher ist.</p>
<p>Betrachten wir der Reihe nach jede der fünf unsicheren Superkräfte. Wir werden
uns auch einige Abstraktionen ansehen, die eine sichere Schnittstelle zu
unsicheren Codes bieten.</p>
<h3 id="dereferenzieren-eines-rohzeigers"><a class="header" href="#dereferenzieren-eines-rohzeigers">Dereferenzieren eines Rohzeigers</a></h3>
<p>In <a href="ch04-02-references-and-borrowing.html#h%C3%A4ngende-referenzen">„Hängende Referenzen“</a> in Kapitel 4 haben wir erwähnt,
dass der Compiler sicherstellt, dass Referenzen immer gültig sind. Unsicheres
Rust hat zwei neue Typen namens <em>Rohzeiger</em> (raw pointers), die ähnlich wie
Referenzen sind. Wie bei Referenzen können Rohzeiger unveränderbar oder
veränderbar sein und werden als <code>_const T</code> bzw. <code>_mut T</code> geschrieben. Das
Sternchen ist nicht der Dereferenzierungsoperator (dereference operator); es
ist Teil des Typnamens. Im Zusammenhang mit Rohzeigern bedeutet <em>unveränderbar</em>
(immutable), dass der Zeiger nach der Dereferenzierung nicht direkt zugewiesen
werden kann.</p>
<p>Rohzeiger sind anders als Referenzen und intelligente Zeiger:</p>
<ul>
<li>Sie dürfen die Ausleihregeln ignorieren, indem sie sowohl unveränderbare als
auch veränderbare Zeiger oder mehrere veränderbare Zeiger auf die gleiche
Stelle haben.</li>
<li>Sie zeigen nicht garantiert auf gültigen Speicher.</li>
<li>Sie dürfen null sein.</li>
<li>Sie implementieren kein automatisches Aufräumen.</li>
</ul>
<p>Wenn du dich dagegen entscheidest, diese Garantien von Rust erzwingen zu
lassen, kannst du auf garantierte Sicherheit verzichten und stattdessen eine
höhere Performanz oder die Möglichkeit der Interaktion mit einer anderen
Sprache oder Hardware erhalten, für die die Rust-Garantien nicht gelten.</p>
<p>Codeblock 20-1 zeigt, wie man aus Referenzen einen unveränderbaren und einen
veränderbaren Rohzeiger erzeugt.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-1: Erstellen von Rohzeigern aus
Referenzen</span></p>
<p>Beachte, dass wir das Schlüsselwort <code>unsafe</code> in diesem Code nicht verwenden.
Wir können Rohzeiger in sicherem Code erzeugen; wir können nur keine Rohzeiger
außerhalb eines unsicheren Blocks dereferenzieren, wie du gleich sehen wirst.</p>
<p>Wir haben Rohzeiger mit Hilfe des Operators <code>&amp;raw</code> erstellt: <code>&amp;raw const num</code>
erzeugt einen unveränderbaren Rohzeiger <code>*const i32</code>, und <code>&amp;raw mut num</code>
erzeugt einen veränderbaren Rohzeiger <code>*mut i32</code>. Da wir sie direkt aus
lokalen Variablen erstellt haben, wissen wir, dass diese speziellen Rohzeiger
gültig sind, aber wir können diese Annahme nicht für jeden beliebigen Rohzeiger
treffen.</p>
<p>Um dies zu demonstrieren, werden wir als Nächstes einen Rohzeiger erstellen,
dessen Gültigkeit wir nicht so sicher sein können. Wir verwenden <code>as</code> anstelle
des Operators <code>&amp;raw</code>, um einen Wert umzuwandeln (cast). Codeblock 20-2 zeigt,
wie man einen Rohzeiger auf eine willkürliche Stelle im Speicher erstellt. Der
Versuch, willkürlichen Speicher zu verwenden, ist undefiniert: Es könnten Daten
an dieser Adresse vorhanden sein oder auch nicht, der Compiler könnte den Code
so optimieren, dass es keinen Speicherzugriff gibt, oder das Programm könnte
mit einer Schutzverletzung (segmentation fault) abbrechen. Normalerweise gibt
es keinen guten Grund, solchen Code zu schreiben, vor allem, wenn man
stattdessen den Operator <code>&amp;raw</code> verwenden kann, aber es ist möglich.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-2: Erzeugen eines Rohzeigers auf eine
willkürliche Speicheradresse</span></p>
<p>Erinnere dich, dass wir Rohzeiger in sicherem Code erstellen können, aber wir
können keine Rohzeiger <em>dereferenzieren</em> und die Daten lesen, auf die gezeigt
wird. In Codeblock 20-3 wenden wir den Dereferenzierungsoperator <code>*</code> auf einen
Rohzeiger an, was einen <code>unsafe</code>-Block erfordert.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!("r1 ist: {}", *r1);
        println!("r2 ist: {}", *r2);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-3: Dereferenzieren von Rohzeigern innerhalb
eines <code>unsafe</code>-Blocks</span></p>
<p>Das Erstellen eines Zeigers schadet nicht; erst wenn wir versuchen, auf den
Wert zuzugreifen, auf den er zeigt, könnten wir es am Ende mit einem ungültigen
Wert zu tun haben.</p>
<p>Beachte auch, dass wir in Codeblock 20-1 und 20-3 die Rohzeiger <code>*const i32</code>
und <code>*mut i32</code> erstellt haben, die beide auf die gleiche Speicherstelle
zeigten, in der <code>num</code> gespeichert ist. Wenn wir stattdessen versucht hätten,
eine unveränderbare und einen veränderbare Referenz auf <code>num</code> zu erstellen,
hätte sich der Code nicht kompilieren lassen, weil die Eigentumsregeln von Rust
eine veränderbare Referenz nicht gleichzeitig mit unveränderbaren Referenzen
zulassen. Mit Rohzeigern können wir einen veränderbaren und einen
unveränderbaren Zeiger auf denselben Ort erstellen und Daten über den
veränderbaren Zeiger ändern, wodurch möglicherweise eine
Daten-Wettlaufsituation (data race) entsteht. Sei vorsichtig!</p>
<p>Warum solltest du bei all diesen Gefahren jemals Rohzeiger verwenden? Ein
Hauptanwendungsfall ist die Kopplung mit C-Code, wie du im nächsten Abschnitt
<a href="ch20-01-unsafe-rust.html#aufrufen-einer-unsicheren-funktion-oder-methode">„Aufrufen einer unsicheren Funktion oder Methode“</a> sehen wirst.
Ein anderer Fall ist der Aufbau von sicheren Abstraktionen, die der
Ausleihenprüfer nicht versteht. Wir stellen unsichere Funktionen vor und
betrachten dann ein Beispiel für eine sichere Abstraktion, die unsicheren
Code verwendet.</p>
<h3 id="aufrufen-einer-unsicheren-funktion-oder-methode"><a class="header" href="#aufrufen-einer-unsicheren-funktion-oder-methode">Aufrufen einer unsicheren Funktion oder Methode</a></h3>
<p>Die zweite Art von Operationen, die du in einem unsicheren Block ausführen
kannst, sind Aufrufe von unsicheren Funktionen. Unsichere Funktionen und
Methoden sehen genau wie reguläre Funktionen und Methoden aus, aber sie haben
ein zusätzliches <code>unsafe</code> vor dem Rest der Definition. Das Schlüsselwort
<code>unsafe</code> weist in diesem Zusammenhang darauf hin, dass die Funktion
Anforderungen hat, die wir einhalten müssen, wenn wir diese Funktion aufrufen,
denn Rust kann nicht garantieren, dass wir diese Anforderungen erfüllt haben.
Indem wir eine unsichere Funktion innerhalb eines <code>unsafe</code>-Blocks aufrufen,
sagen wir, dass wir die Dokumentation dieser Funktion gelesen haben und wir die
Verantwortung für die Einhaltung der Verträge der Funktion übernehmen.</p>
<p>Hier ist eine unsichere Funktion namens <code>dangerous</code>, die in ihrem Rumpf nichts
tut:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>Wir müssen die Funktion <code>dangerous</code> innerhalb eines separaten <code>unsafe</code>-Blocks
aufrufen. Wenn wir versuchen, <code>dangerous</code> ohne den <code>unsafe</code>-Block aufzurufen,
erhalten wir einen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>Mit dem <code>unsafe</code>-Block versichern wir Rust, dass wir die Dokumentation der
Funktion gelesen haben, dass wir verstehen, wie sie richtig zu benutzen ist,
und dass wir überprüft haben, dass wir den Vertrag der Funktion erfüllen.</p>
<p>Um unsichere Operationen im Rumpf einer unsicheren Funktion auszuführen, musst
du wie bei einer regulären Funktion einen <code>unsafe</code>-Block verwenden, und der
Compiler wird dich warnen, wenn du dies vergisst. Dies hilft dabei,
<code>unsafe</code>-Blöcke so klein wie möglich zu halten, da unsichere Operationen
möglicherweise nicht im gesamten Funktionsrumpf benötigt werden.</p>
<h4 id="erstellen-einer-sicheren-abstraktion-von-unsicherem-code"><a class="header" href="#erstellen-einer-sicheren-abstraktion-von-unsicherem-code">Erstellen einer sicheren Abstraktion von unsicherem Code</a></h4>
<p>Nur weil eine Funktion unsicheren Code enthält, bedeutet das nicht, dass wir
die gesamte Funktion als unsicher markieren müssen. Tatsächlich ist das
Einpacken von unsicherem Codes in eine sichere Funktion eine gängige
Abstraktion. Als Beispiel betrachten wir die Funktion <code>split_at_mut</code> aus der
Standardbibliothek, die unsicheren Code verwendet. Wir untersuchen, wie wir sie
implementieren könnten. Diese sichere Methode ist auf veränderbaren
Anteilstypen definiert: Sie nimmt einen Anteilstyp und macht zwei daraus, indem
sie den Anteilstyp an dem als Argument angegebenen Index teilt. Codeblock 20-4
zeigt, wie man <code>split_at_mut</code> verwendet.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-4: Verwenden der sicheren Funktion
<code>split_at_mut</code></span></p>
<p>Wir können diese Funktion nicht nur mit sicherem Rust implementieren. Ein
Versuch könnte in etwa wie in Codeblock 20-5 aussehen, der sich nicht
kompilieren lässt. Der Einfachheit halber implementieren wir <code>split_at_mut</code> als
Funktion und nicht als Methode und nur für Anteilstypen von <code>i32</code>-Werten, nicht
für einen generischen Typ <code>T</code>.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-5: Versuch einer Implementierung von
<code>split_at_mut</code> unter ausschließlicher Verwendung von sicherem Rust</span></p>
<p>Diese Funktion ermittelt zunächst die Gesamtlänge des Anteilstypen. Dann stellt
sie fest, dass der als Parameter angegebene Index innerhalb des Anteilstypen
liegt, indem sie prüft, ob er kleiner oder gleich der Länge ist. Die
Zusicherung (assertion) bedeutet, dass die Funktion abstürzt, wenn wir einen
Index übergeben, der größer als die Länge ist, bei der der Anteilstyp geteilt
werden soll, bevor sie versucht, diesen Index zu verwenden.</p>
<p>Dann geben wir zwei veränderbare Anteilstypen in einem Tupel zurück: Einen vom
Anfang des ursprünglichen Anteilstyps bis zum Index <code>mid</code> und einen weiteren
von <code>mid</code> bis zum Ende des Anteilstyps.</p>
<p>Wenn wir versuchen, den Code in Codeblock 20-5 zu kompilieren, erhalten wir
einen Fehler.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>Der Ausleihenprüfer von Rust kann nicht verstehen, dass wir verschiedene Teile
des Anteilstyps ausleihen; er weiß nur, dass wir zweimal vom selben Anteilstyp
ausleihen. Das Ausleihen verschiedener Teile eines Anteilstyps ist
grundsätzlich in Ordnung, weil sich die beiden Anteilstypen nicht überlappen,
aber Rust ist nicht schlau genug, um das zu wissen. Wenn wir wissen, dass der
Code in Ordnung ist, Rust aber nicht, ist es an der Zeit, unsicheren Code zu
verwenden.</p>
<p>Codeblock 20-6 zeigt, wie man einen <code>unsafe</code>-Block, einen Rohzeiger und einige
Aufrufe unsicherer Funktionen verwendet, um die Implementierung von
<code>split_at_mut</code> zum Funktionieren zu bringen.</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-6: Verwenden von unsicherem Codes bei der
Implementierung der Funktion <code>split_at_mut</code></span></p>
<p>Erinnere dich an <a href="ch04-03-slices.html">„Der Anteilstyp (slice)“</a> in Kapitel 4, dass
Anteilstypen Zeiger auf Daten und die Länge des Anteilstyps sind. Wir verwenden
die Methode <code>len</code>, um die Länge eines Anteilstyps zu erhalten, und die Methode
<code>as_mut_ptr</code>, um auf den Rohzeiger eines Anteilstyps zuzugreifen. Da wir in
diesem Fall einen veränderbaren Anteilstyp von <code>i32</code>-Werten haben, gibt
<code>as_mut_ptr</code> einen Rohzeiger vom Typ <code>*mut i32</code> zurück, den wir in der Variable
<code>ptr</code> gespeichert haben.</p>
<p>Wir halten an der Zusicherung fest, dass der Index <code>mid</code> innerhalb des
Anteilstyps liegt. Dann kommen wir zum unsicheren Code: Die Funktion
<code>slice::from_raw_parts_mut</code> nimmt einen Rohzeiger und eine Länge und erzeugt
einen Anteilstyp. Wir verwenden diese Funktion, um einen Anteilstyp zu
erstellen, der mit <code>ptr</code> beginnt und <code>mid</code> Elemente lang ist. Dann rufen wir
die Methode <code>add</code> auf <code>ptr</code> mit <code>mid</code> als Argument auf, um einen Rohzeiger
zu erhalten, der bei <code>mid</code> beginnt, und wir erzeugen einen Anteilstyp mit
diesem Zeiger und der verbleibenden Anzahl von Elementen nach <code>mid</code>.</p>
<p>Die Funktion <code>slice::from_raw_parts_mut</code> ist unsicher, weil sie einen Rohzeiger
nimmt und darauf vertrauen muss, dass dieser Zeiger gültig ist. Die Methode
<code>add</code> auf dem Rohzeiger ist ebenfalls unsicher, weil sie darauf vertrauen muss,
dass die Offset-Position ebenfalls ein gültiger Zeiger ist. Deshalb mussten wir
einen <code>unsafe</code>-Block um unsere Aufrufe von <code>slice::from_raw_parts_mut</code> und
<code>add</code> legen, damit wir sie aufrufen konnten. Wenn wir uns den Code ansehen und
die Zusicherung hinzufügen, dass <code>mid</code> kleiner oder gleich <code>len</code> sein muss,
können wir sagen, dass alle Rohzeiger innerhalb des <code>unsafe</code>-Blocks gültige
Zeiger auf Daten innerhalb des Anteilstyps sind. Dies ist eine akzeptable und
angemessene Verwendung von <code>unsafe</code>.</p>
<p>Beachte, dass wir die resultierende Funktion <code>split_at_mut</code> nicht als <code>unsafe</code>
markieren müssen, und wir können diese Funktion aus dem sicheren Rust aufrufen.
Wir haben eine sichere Abstraktion des unsicheren Codes mit einer
Implementierung der Funktion geschaffen, die <code>unsafe</code> Code auf sichere Weise
verwendet, weil sie nur gültige Zeiger aus den Daten erzeugt, auf die diese
Funktion Zugriff hat.</p>
<p>Im Gegensatz dazu würde die Verwendung von <code>slice::from_raw_parts_mut</code> in
Codeblock 20-7 wahrscheinlich abstürzen, wenn der Anteilstyp verwendet wird.
Dieser Code nimmt einen beliebigen Speicherplatz und erzeugt einen Anteilstyp
mit einer Länge von 10.000 Elementen.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-7: Erstellen eines Anteilstyps aus einer
beliebigen Speicherstelle</span></p>
<p>Wir besitzen den Speicher an dieser beliebigen Stelle nicht und es gibt keine
Garantie, dass der von diesem Code erzeugte Anteilstyp gültige <code>i32</code>-Werte
enthält. Der Versuch, <code>values</code> so zu benutzen, als ob er ein gültiger
Anteilstyp ist, führt zu undefiniertem Verhalten.</p>
<h4 id="verwenden-von-extern-funktionen-um-externen-code-aufzurufen"><a class="header" href="#verwenden-von-extern-funktionen-um-externen-code-aufzurufen">Verwenden von <code>extern</code>-Funktionen um externen Code aufzurufen</a></h4>
<p>Manchmal muss dein Rust-Code möglicherweise mit Code interagieren, der in einer
anderen Sprache geschrieben wurde. Hierfür hat Rust das Schlüsselwort <code>extern</code>,
das das Erstellen und Verwenden einer <em>Fremdfunktionsschnittstelle</em> (Foreign
Function Interface, kurz FFI) erleichtert. Eine FFI ist eine Möglichkeit für
eine Programmiersprache, Funktionen zu definieren und es einer anderen
(fremden) Programmiersprache zu ermöglichen, diese Funktionen aufzurufen.</p>
<p>In Codeblock 20-8 wird gezeigt, wie eine Integration der Funktion <code>abs</code> aus der
C-Standardbibliothek erfolgt. Funktionen, die in <code>extern</code>-Blöcken deklariert
sind, sind normalerweise unsicher, wenn sie aus Rust Code aufgerufen werden,
und müssen daher mit <code>unsafe</code> gekennzeichnet werden. Der Grund dafür ist, dass
andere Sprachen die Regeln und Garantien von Rust nicht erzwingen und Rust sie
nicht überprüfen kann, sodass die Verantwortung für die Sicherheit beim
Programmierer liegt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolutwert von -3 gemäß C: {}", abs(-3));
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 20-8: Deklarieren und Aufrufen einer
<code>extern</code>-Funktion, die in einer anderen Sprache definiert wurde</span></p>
<p>Innerhalb des Blocks <code>unsafe extern "C"</code> listen wir die Namen und Signaturen
von externen Funktionen aus einer anderen Sprache auf, die wir aufrufen wollen.
Der Teil <code>"C"</code> definiert, welche <em>Binärschnittstelle</em> (application binary
interface, kurz ABI) die externe Funktion benutzt: Die ABI definiert, wie die
Funktion auf der technischen Ebene (assembly level) aufgerufen wird. Die ABI
<code>"C"</code> ist die gebräuchlichste und folgt der ABI der Programmiersprache C.
Informationen über alle von Rust unterstützten ABIs finden Sie in der
<a href="https://doc.rust-lang.org/nightly/reference/items/external-blocks.html#abi">Rust-Referenz</a>.</p>
<p>Jedes Element, das innerhalb eines <code>unsafe extern</code>-Blocks deklariert wird, ist
implizit <code>unsafe</code>. Einige FFI-Funktionen sind jedoch <em>sicher aufrufbar</em>. Zum
Beispiel hat die Funktion <code>abs</code> aus der C-Standardbibliothek keine Überlegungen
zur Speichersicherheit und wir wissen, dass sie mit jedem <code>i32</code> aufgerufen
werden kann. In solchen Fällen können wir das Schlüsselwort <code>safe</code> verwenden,
um zu sagen, dass der Aufruf dieser speziellen Funktion sicher ist, obwohl sie
sich in einem <code>unsafe extern</code>-Block befindet. Sobald wir diese Änderung
vorgenommen haben, erfordert der Aufruf der Funktion keinen <code>unsafe</code>-Block
mehr, wie in Codeblock 20-9 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">unsafe extern "C" {
    safe fn abs(input: i32) -&gt; i32;
}

fn main() {
    println!("Absolutwert von -3 gemäß C: {}", abs(-3));
}</code></pre></pre>
<p><span class="caption">Codeblock 20-9: Explizite Kennzeichnung einer Funktion
mit <code>safe</code> innerhalb eines <code>unsafe extern</code>-Blocks und sicherer Aufruf dieser
Funktion</span></p>
<p>Die Kennzeichnung einer Funktion mit <code>safe</code> macht sie nicht von sich aus
sicher! Vielmehr ist es ein Versprechen, das du Rust gegenüber abgibst, dass
sie <em>sicher</em> ist. Es bleibt in deiner Verantwortung, dafür zu sorgen, dass
dieses Versprechen eingehalten wird!</p>
<blockquote>
<h4 id="aufrufen-von-rust-funktionen-aus-anderen-sprachen"><a class="header" href="#aufrufen-von-rust-funktionen-aus-anderen-sprachen">Aufrufen von Rust-Funktionen aus anderen Sprachen</a></h4>
<p>Wir können auch <code>extern</code> verwenden, um eine Schnittstelle zu schaffen, die es
anderen Sprachen erlaubt, Rust-Funktionen aufzurufen. Anstelle eines
<code>extern</code>-Blocks fügen wir das Schlüsselwort <code>extern</code> hinzu und geben die zu
verwendende ABI unmittelbar vor dem Schlüsselwort <code>fn</code> der relevanten
Funktion an. Wir müssen auch eine Annotation <code>#[unsafe(no_mangle)]</code>
hinzufügen, um dem Rust-Compiler mitzuteilen, dass er den Namen dieser
Funktion nicht verändern soll. <em>Mangling</em> bedeutet, dass ein Compiler den
Namen, den wir einer Funktion gegeben haben, in einen anderen Namen ändert,
der mehr Informationen für andere Teile des Kompiliervorgangs enthält, aber
weniger menschenlesbar ist. Jeder Programmiersprachen-Compiler verändert
Namen etwas anders. Damit eine Rust-Funktion von anderen Sprachen aufgerufen
werden kann, müssen wir also die Namensveränderung des Rust-Compilers
deaktivieren. Dies ist unsicher, da es ohne die eingebaute
Namensveränderung-Funktion zu Namenskollisionen in verschiedenen Bibliotheken
kommen kann. Es liegt also in unserer Verantwortung, sicherzustellen, dass
der von uns gewählte Name ohne Namensveränderung sicher exportiert werden
kann.</p>
<p>Im folgenden Beispiel machen wir die Funktion <code>call_from_c</code> von C-Code aus
zugänglich, nachdem sie in eine gemeinsame Bibliothek kompiliert und von C
gelinkt wurde:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Rust-Funktion von C aufgerufen!");
}
<span class="boring">}</span></code></pre></pre>
<p>Diese Verwendung von <code>extern</code> erfordert <code>unsafe</code> nur im Attribut, nicht im
<code>extern</code>-Block.</p>
</blockquote>
<h3 id="zugreifen-oder-Ändern-einer-veränderbaren-statischen-variable"><a class="header" href="#zugreifen-oder-Ändern-einer-veränderbaren-statischen-variable">Zugreifen oder Ändern einer veränderbaren, statischen Variable</a></h3>
<p>In diesem Buch haben wir noch nicht über <em>globale Variablen</em> gesprochen, die
Rust zwar unterstützt, die aber wegen der Eigentumsregeln von Rust
problematisch sein können. Wenn zwei Stränge (threads) auf dieselbe
veränderbare, globale Variable zugreifen, kann dies zu einer
Daten-Wettlaufsituation (data race) führen.</p>
<p>In Rust werden globale Variablen als <em>statische</em> Variablen bezeichnet.
Codeblock 20-10 zeigt ein Beispiel für die Deklaration und Verwendung einer
statischen Variablen mit einem Zeichenkettenanteilstyp als Wert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">static HELLO_WORLD: &amp;str = "Hallo Welt!";

fn main() {
    println!("Name ist: {HELLO_WORLD}");
}</code></pre></pre>
<p><span class="caption">Codeblock 20-10: Definieren und Verwenden einer
unveränderbaren, statischen Variablen</span></p>
<p>Statische Variablen ähneln Konstanten, die wir in
<a href="ch03-01-variables-and-mutability.html#konstanten">„Konstanten“</a> in Kapitel 3
besprochen haben. Die Namen von statischen Variablen stehen per Konvention in
<code>SCHREIENDER_SCHLANGENSCHRIFT</code>. Statische Variablen können nur Referenzen mit
der Lebensdauer <code>'static</code> speichern, was bedeutet, dass der Rust-Compiler die
Lebensdauer herausfinden kann, und wir brauchen sie nicht explizit anzugeben.
Der Zugriff auf eine unveränderbare, statische Variable ist sicher.</p>
<p>Ein feiner Unterschied zwischen Konstanten und unveränderbaren, statischen
Variablen besteht darin, dass Werte in einer statischen Variable eine feste
Adresse im Speicher haben. Beim Verwenden des Wertes wird immer auf die
gleichen Daten zugegriffen. Konstanten hingegen dürfen ihre Daten duplizieren,
wann immer sie verwendet werden. Ein weiterer Unterschied besteht darin, dass
statische Variablen veränderbar sein können. Der Zugriff auf und die Änderung
von veränderbaren, statischen Variablen ist <em>unsicher</em>. Codeblock 20-11 zeigt,
wie man eine veränderbare, statische Variable namens <code>COUNTER</code> deklariert, auf
sie zugreift und sie modifiziert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">static mut COUNTER: u32 = 0;

/// SAFETY: Calling this from more than a single thread at a time is undefined
/// behavior, so you *must* guarantee you only call it from a single thread at
/// a time.
unsafe fn add_to_count(inc: u32) {
    COUNTER += inc;
}

fn main() {
    unsafe {
        // SAFETY: This is only called from a single thread in `main`.
        add_to_count(3);
        println!("COUNTER: {}", COUNTER);
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 20-11: Lesen von und Schreiben in eine
veränderbare, statische Variable ist unsicher</span></p>
<p>Wie bei regulären Variablen spezifizieren wir die Veränderbarkeit mit dem
Schlüsselwort <code>mut</code>. Jeder Code, der <code>COUNTER</code> liest oder schreibt, muss
innerhalb eines <code>unsafe</code>-Blocks liegen. Dieser Code kompiliert und gibt
<code>COUNTER: 3</code> so, wie wir es erwarten würden, weil er nur einen einzigen Strang
hat. Wenn mehrere Stränge auf <code>COUNTER</code> zugreifen, würde dies wahrscheinlich zu
einer Daten-Wettlaufsituation führen, es handelt sich also um ein undefiniertes
Verhalten. Daher müssen wir die gesamte Funktion als <code>unsafe</code> kennzeichnen und
die Sicherheitseinschränkung dokumentieren, damit jeder, der die Funktion
aufruft, weiß, was er sicher tun darf und was nicht.</p>
<p>Immer wenn wir eine <code>unsafe</code>-Funktion schreiben, ist es idiomatisch, einen
Kommentar anzugeben, der mit <code>SAFETY</code> beginnt und erklärt, was der Aufrufer tun
muss, um die Funktion sicher aufzurufen. Ebenso ist es idiomatisch, beim Aufruf
einer <code>unsafe</code>-Operation einen Kommentar zu schreiben, der mit <code>SAFETY</code>
beginnt, um zu erklären, wie die Sicherheitsregeln eingehalten werden.</p>
<p>Außerdem erlaubt der Compiler nicht, Referenzen auf eine veränderbare statische
Variable zu erstellen. Du kannst nur über einen Rohzeiger darauf zugreifen, der
mit einem der Roh-Ausleihen-Operatoren erstellt wurde. Das gilt auch für Fälle,
in denen die Referenz unsichtbar erstellt wird, wie bei der Verwendung von
<code>println!</code> in diesem Codeblock. Die Anforderung, dass Referenzen auf statische
veränderbare Variablen nur über Rohzeiger erstellt werden können, trägt dazu
bei, die Sicherheitsanforderungen deutlicher zu machen.</p>
<p>Bei veränderbaren Daten, die global zugänglich sind, ist es schwierig,
sicherzustellen, dass es keine Daten-Wettlaufsituationen gibt, weshalb Rust
veränderbare, statische Variablen als unsicher betrachtet. Wann immer möglich,
ist es vorzuziehen, die in Kapitel 16 besprochenen Nebenläufigkeitstechniken
und Strang-sicheren, intelligenten Zeiger zu verwenden, damit der Compiler
prüft, ob der Datenzugriff von verschiedenen Strängen sicher ist.</p>
<h3 id="implementieren-eines-unsicheren-merkmals"><a class="header" href="#implementieren-eines-unsicheren-merkmals">Implementieren eines unsicheren Merkmals</a></h3>
<p>Wir können <code>unsafe</code> zum Implementieren eines unsicheren Merkmals (unsafe trait)
verwenden. Ein Merkmal ist unsicher, wenn mindestens eine ihrer Methoden eine
Invariante hat, die der Compiler nicht verifizieren kann. Wir können erklären,
dass ein Merkmal <code>unsafe</code> ist, indem wir das Schlüsselwort <code>unsafe</code> vor <code>trait</code>
einfügen und die Implementierung des Merkmals ebenfalls mit <code>unsafe</code> markieren,
wie in Codeblock 20-12 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust edition2024">unsafe trait Foo {
    // Methoden kommen hierhin
}

unsafe impl Foo for i32 {
    // Methoden-Implementierungen kommen hierhin
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-12: Definition und Implementierung eines
unsicheren Merkmals</span></p>
<p>Indem wir <code>unsafe impl</code> verwenden, versprechen wir, dass wir die Invarianten
aufrechterhalten, die der Compiler nicht verifizieren kann.</p>
<p>Erinnere dich als Beispiel an die Marker-Merkmale <code>Sync</code> und <code>Send</code>, die wir in
<a href="ch16-04-extensible-concurrency-sync-and-send.html">„Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) <code>Sync</code> und
<code>Send</code>“</a> in Kapitel 16
besprochen haben: Der Compiler implementiert diese Merkmale automatisch, wenn
unsere Typen vollständig aus anderen Typen zusammengesetzt sind, die <code>Send</code> und
<code>Sync</code> implementieren. Wenn wir einen Typ implementieren, der einen Typ
enthält, der nicht <code>Send</code> oder <code>Sync</code> implementiert, z.B. Rohzeiger, und wir
diesen Typ als <code>Send</code> oder <code>Sync</code> markieren wollen, müssen wir <code>unsafe</code>
verwenden. Rust kann nicht überprüfen, ob unser Typ die Garantien
aufrechterhält, dass er sicher über Stränge gesendet oder von mehreren Strängen
aus zugegriffen werden kann; daher müssen wir diese Prüfungen manuell
durchführen und als solche mit <code>unsafe</code> kennzeichnen.</p>
<h3 id="zugreifen-auf-felder-einer-vereinigung-union"><a class="header" href="#zugreifen-auf-felder-einer-vereinigung-union">Zugreifen auf Felder einer Vereinigung (union)</a></h3>
<p>Die letzte Aktion, die nur mit <code>unsafe</code> funktioniert, ist der Zugriff auf
Felder einer <code>union</code>, die ähnlich zu einer <code>struct</code> ist, bei der aber immer nur
ein deklariertes Feld in einer bestimmten Instanz verwendet wird. Vereinigungen
werden hauptsächlich als Schnittstelle zu Vereinigungen in C-Code verwendet.
Der Zugriff auf Vereinigungsfelder ist unsicher, da Rust den Typ der Daten, die
derzeit in der Vereinigungsinstanz gespeichert sind, nicht garantieren kann.
Weitere Informationen über Vereinigung findest du in der
<a href="https://doc.rust-lang.org/reference/items/unions.html">Unions-Referenz</a>.</p>
<h3 id="miri-zur-Überprüfung-von-unsafe-code-verwenden"><a class="header" href="#miri-zur-Überprüfung-von-unsafe-code-verwenden">Miri zur Überprüfung von <code>unsafe</code>-Code verwenden</a></h3>
<p>Wenn du unsicheren Code schreibst, möchtest du vielleicht überprüfen, ob das,
was du geschrieben hast, tatsächlich sicher und korrekt ist. Eine der besten
Möglichkeiten, dies zu tun, ist die Verwendung von Miri, einem offiziellen
Rust-Werkzeug zur Erkennung von undefiniertem Verhalten. Während der
Ausleihenprüfer ein <em>statisches</em> Werkzeug ist, das zur Kompilierzeit arbeitet,
ist Miri ein <em>dynamisches</em> Werkzeug, das zur Laufzeit arbeitet. Es prüft deinen
Code, indem es dein Programm oder deine Testfälle ausführt und erkennt, ob du
Rust-Regeln verletzt.</p>
<p>Die Verwendung von Miri erfordert einen Nightly-Build von Rust (über das wir in
<a href="appendix-07-nightly-rust.html">Anhang G: Wie Rust erstellt wird und „nächtliches Rust“</a> sprechen).
Du kannst sowohl eine nächtliche Version von Rust als auch das Miri-Tool
installieren, indem du <code>rustup +nightly component add miri</code> ausführst. Dies
ändert nicht die Rust-Version deines Projekts, sondern fügt das Werkzeug nur zu
deinem System hinzu, damit du es verwenden kannst, wenn du willst. Du kannst
Miri für ein Projekt ausführen, indem du <code>cargo +nightly miri run</code> oder <code>cargo  +nightly miri test</code> eingibst.</p>
<p>Ein Beispiel dafür, wie hilfreich dies sein kann, siehst du beim Ausführen mit
Codeblock 20-11:</p>
<pre><code class="language-console">$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `file:///home/.rustup/toolchains/nightly/bin/cargo-miri runner target/miri/debug/unsafe-example`
COUNTER: 3
</code></pre>
<p>Miri warnt uns richtigerweise, dass wir gemeinsame Referenzen auf veränderbare
Daten haben. Hier gibt Miri nur eine Warnung aus, da in diesem Fall nicht
garantiert ist, dass es sich um undefiniertes Verhalten handelt, und es sagt
uns nicht, wie wir das Problem beheben können. In einigen Fällen kann Miri auch
eindeutige Fehler erkennen – Codemuster, die <em>mit Sicherheit</em> falsch sind
– und Empfehlungen geben, wie diese Fehler behoben werden können.</p>
<p>Miri deckt nicht alles auf, was man beim Schreiben von unsicherem Code falsch
machen könnte. Miri ist ein dynamisches Analysewerkzeug, d.h. es erkennt nur
Probleme mit Code, der tatsächlich ausgeführt wird. Das bedeutet, dass du es in
Verbindung mit guten Testverfahren verwenden musst, um dein Vertrauen in den
von dir geschriebenen unsicheren Code zu erhöhen. Miri deckt auch nicht alle
Möglichkeiten ab, in denen dein Code unsauber sein kann.</p>
<p>Mit anderen Worten: Wenn Miri ein Problem <em>findet</em>, weißt du, dass es einen
Fehler gibt, aber nur weil Miri <em>keinen</em> Fehler findet, heißt das nicht, dass
kein Problem vorhanden ist. Es kann allerdings eine Menge finden. Versuche, es
auf die anderen Beispiele mit unsicherem Code in diesem Kapitel anzuwenden und
sieh, was es sagt!</p>
<p>Mehr über Miri erfährst du in seinem <a href="https://github.com/rust-lang/miri">GitHub-Repository</a>.</p>
<h3 id="wann-unsicheren-code-verwenden"><a class="header" href="#wann-unsicheren-code-verwenden">Wann unsicheren Code verwenden?</a></h3>
<p>Die Verwendung von <code>unsafe</code> für eine der fünf gerade besprochenen Superkräfte
ist nicht falsch oder gar verpönt, aber es ist kniffliger, <code>unsafe</code> Code
korrekt zu schreiben, weil der Compiler nicht helfen kann, die
Speichersicherheit aufrechtzuerhalten. Wenn du einen Grund hast, <code>unsafe</code> Code
zu verwenden, kannst du dies tun, und die explizite <code>unsafe</code>-Annotation macht
es einfacher, die Quelle von Problemen aufzuspüren, wenn sie auftreten. Wann
immer du unsicheren Code schreibst, kannst du Miri verwenden, um dich zu
vergewissern, dass der von dir geschriebene Code die Rust-Regeln einhält.</p>
<p>Wenn du dich eingehender mit der effektiven Arbeit mit unsicherem Rust befassen
möchtest, lies den offiziellen Rust-Leitfaden zum Thema
<a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fortgeschrittene-merkmale-traits"><a class="header" href="#fortgeschrittene-merkmale-traits">Fortgeschrittene Merkmale (traits)</a></h2>
<p>Merkmale behandelten wir als Erstes in <a href="ch10-02-traits.html">„Merkmale (traits): Gemeinsames
Verhalten definieren“</a> in Kapitel 10, aber wir
haben die fortgeschrittenen Details nicht besprochen. Jetzt, da du mehr über
Rust weißt, können wir zum Kern der Sache kommen.</p>
<h3 id="assoziierte-typen"><a class="header" href="#assoziierte-typen">Assoziierte Typen</a></h3>
<p><em>Assoziierte Typen</em> (associated types) verbinden einen Typ-Platzhalter mit
einem Merkmal, sodass die Definitionen der Merkmalsmethoden diese
Platzhaltertypen in ihren Signaturen verwenden können. Der Implementierer eines
Merkmals gibt den konkreten Typ an, der anstelle des Platzhaltertyps für die
jeweilige Implementierung verwendet werden soll. Auf diese Weise können wir ein
Merkmal definieren, das einige Typen verwendet, ohne dass wir genau wissen
müssen, um welche Typen es sich dabei handelt, bis das Merkmal implementiert
ist.</p>
<p>Wir haben die meisten der fortgeschrittenen Funktionalitäten in diesem Kapitel
als selten benötigt beschrieben. Assoziierte Typen liegen irgendwo dazwischen:
Sie werden seltener verwendet als die im Rest des Buches erläuterten
Funktionalitäten, aber häufiger als viele der anderen in diesem Kapitel
besprochenen Funktionalitäten.</p>
<p>Ein Beispiel für ein Merkmal mit einem assoziierten Typ ist das Merkmal
<code>Iterator</code>, das die Standardbibliothek zur Verfügung stellt. Der assoziierte
Typ wird <code>Item</code> genannt und steht für den Typ der Werte, über die der Typ, der
das Merkmal <code>Iterator</code> implementiert, iteriert. Die Definition des Merkmals
<code>Iterator</code> ist in Codeblock 20-13 zu sehen.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-13: Definition des Merkmals <code>Iterator</code>, das
einen assoziierten Typ <code>Item</code> hat</span></p>
<p>Der Typ <code>Item</code> ist ein Platzhalter und die Definition der Methode <code>next</code> zeigt,
dass sie Werte vom Typ <code>Option&lt;Self::Item&gt;</code> zurückgibt. Implementierungen des
Merkmals <code>Iterator</code> geben den konkreten Typ für <code>Item</code> an und die Methode
<code>next</code> gibt eine <code>Option</code> zurück, die einen Wert dieses konkreten Typs enthält.</p>
<p>Assoziierte Typen scheinen ein ähnliches Konzept wie generische Datentypen
(generics) zu sein, da letztere es uns ermöglichen, eine Funktion zu
definieren, ohne anzugeben, welche Typen sie handhaben kann. Um den Unterschied
zwischen den beiden Konzepten zu untersuchen, betrachten wir eine
Implementierung des Merkmals <code>Iterator</code> für einen Typ namens <code>Counter</code>, der
angibt, dass der <code>Item</code>-Typ <code>u32</code> ist:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --abschneiden--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Diese Syntax scheint mit der von generischen Datentypen vergleichbar zu sein.
Warum also nicht einfach das Merkmal <code>Iterator</code> mit generischen Datentypen
definieren, wie in Codeblock 20-14 gezeigt?</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-14: Eine hypothetische Definition des
Merkmals <code>Iterator</code> unter Verwendung eines generischen Datentyps</span></p>
<p>Der Unterschied ist, dass wir beim Verwenden von generischen Datentypen, wie in
Codeblock 20-14, die Typen in jeder Implementierung annotieren müssen; da wir
auch <code>Iterator&lt;String&gt; for Counter</code> oder jeden anderen Typ implementieren
können, könnten wir mehrere Implementierungen von <code>Iterator</code> für <code>Counter</code>
haben. Mit anderen Worten, wenn ein Merkmal einen generischen Parameter hat,
kann es für einen Typ mehrfach implementiert werden, wobei die konkreten Typen
der generischen Typparameter jedes Mal geändert werden können. Wenn wir die
Methode <code>next</code> auf <code>Counter</code> verwenden, müssten wir Typ-Annotationen
bereitstellen, um anzugeben, welche Implementierung des <code>Iterators</code> wir
verwenden wollen.</p>
<p>Bei assoziierten Typen brauchen wir Typen nicht zu annotieren, weil wir ein
Merkmal auf einem Typ nicht mehrfach implementieren können. In Codeblock 20-13
mit der Definition, die assoziierte Typen verwendet, können wir nur einmal
wählen, was der Typ von <code>Item</code> sein wird, weil es nur einen <code>impl Iterator for Counter</code> geben kann. Wir müssen nicht angeben, dass wir einen Iterator von
<code>u32</code>-Werten überall dort haben wollen, wo wir <code>next</code> auf <code>Counter</code> aufrufen.</p>
<p>Assoziierte Typen werden auch Teil des Merkmal-Vertrags: Implementierer des
Merkmals müssen einen Typ bereitstellen, der für den Platzhalter des
assoziierten Typs steht. Assoziierte Typen haben oft einen Namen, der
beschreibt, wie der Typ verwendet werden soll, und das Dokumentieren des
assoziierten Typs in der API-Dokumentation ist eine gute Praxis.</p>
<h3 id="standardparameter-für-generische-typen-und-operatorüberladung"><a class="header" href="#standardparameter-für-generische-typen-und-operatorüberladung">Standardparameter für generische Typen und Operatorüberladung</a></h3>
<p>Wenn wir generische Typparameter verwenden, können wir einen konkreten
Standardtyp für den generischen Typ angeben. Dadurch entfällt die Notwendigkeit
für Implementierer des Merkmals, einen konkreten Typ anzugeben, wenn der
Standardtyp passt. Du gibst einen Standardtyp an, wenn du einen generischen Typ
mit der Syntax <code>&lt;PlaceholderType=ConcreteType&gt;</code> deklarierst.</p>
<p>Ein gutes Beispiel für eine Situation, in der diese Technik nützlich ist, ist
die <em>Operatorüberladung</em> (operator overloading), bei der du das Verhalten eines
Operators (wie <code>+</code>) in bestimmten Situationen anpasst.</p>
<p>Rust erlaubt es dir nicht, eigene Operatoren zu erstellen oder beliebige
Operatoren zu überladen. Aber du kannst die in <code>std::ops</code> aufgeführten
Operationen und entsprechenden Merkmale überladen, indem du die mit dem
Operator assoziierten Merkmale implementierst. Beispielsweise überladen wir in
Codeblock 20-15 den Operator <code>+</code>, um zwei <code>Point</code>-Instanzen zu addieren. Wir
tun dies, indem wir das Merkmal <code>Add</code> auf eine <code>Point</code>-Struktur implementieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
<p><span class="caption">Codeblock 20-15: Implementieren des Merkmals <code>Add</code>, um
den Operator <code>+</code> für <code>Point</code>-Instanzen zu überladen</span></p>
<p>Die Methode <code>add</code> addiert die <code>x</code>-Werte zweier <code>Point</code>-Instanzen und die
<code>y</code>-Werte zweier <code>Point</code>-Instanzen, um einen neuen <code>Point</code> zu erzeugen. Das
Merkmal <code>Add</code> hat einen assoziierten Typ namens <code>Output</code>, der den von der
Methode <code>add</code> zurückgegebenen Typ bestimmt.</p>
<p>Der generische Standardtyp in diesem Code befindet sich innerhalb des Merkmals
<code>Add</code>. Hier ist seine Definition:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code sollte allgemein bekannt aussehen: Ein Merkmal mit einer Methode
und einem assoziierten Typ. Der neue Teil ist <code>Rhs=Self</code>: Diese Syntax heißt
<em>Standardtypparameter</em> (default type parameters). Der generische Typparameter
<code>Rhs</code> (kurz für „right hand side“, engl. „rechte Seite“) definiert den Typ des
Parameters <code>rhs</code> in der Methode <code>add</code>. Wenn wir keinen konkreten Typ für <code>Rhs</code>
angeben, wenn wir das Merkmal <code>Add</code> implementieren, wird der Typ <code>Rhs</code>
standardmäßig auf <code>Self</code> gesetzt, was der Typ sein wird, auf dem wir <code>Add</code>
implementieren.</p>
<p>Als wir <code>Add</code> für <code>Point</code> implementiert haben, haben wir den Standardwert für
<code>Rhs</code> verwendet, weil wir zwei <code>Point</code>-Instanzen addieren wollten. Schauen wir
uns ein Beispiel für die Implementierung des Merkmals <code>Add</code> an, bei dem wir den
Typ <code>Rhs</code> anpassen wollen, anstatt den Standardwert zu verwenden.</p>
<p>Wir haben zwei Strukturen <code>Millimeters</code> und <code>Meters</code>, die Werte in
verschiedenen Einheiten enthalten. Diese dünne Umhüllung eines bestehenden Typs
in einer anderen Struktur ist als <em>Newtype-Muster</em> bekannt, das wir im
Abschnitt <a href="ch20-02-advanced-traits.html#verwenden-des-newtype-musters-zum-implementieren-von-externen-merkmalen-auf-externen-typen">„Verwenden des Newtype-Musters zum Implementieren von externen
Merkmalen auf externen Typen“</a> ausführlicher beschreiben. Wir wollen
Werte in Millimeter zu Werten in Meter addieren und die Implementierung von
<code>Add</code> die Umrechnung korrekt durchführen lassen. Wir können <code>Add</code> für
<code>Millimeters</code> mit <code>Meters</code> als <code>Rhs</code> implementieren, wie in Codeblock 20-16
gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-16: Implementieren des Merkmals <code>Add</code> auf
<code>Millimeters</code>, um <code>Millimeters</code> zu <code>Meters</code> zu addieren</span></p>
<p>Um <code>Millimeters</code> und <code>Meters</code> zu addieren, geben wir <code>impl Add&lt;Meters&gt;</code> an, um
den Wert des Parameters vom Typ <code>Rhs</code> zu setzen, anstatt den Standardwert
<code>Self</code> zu verwenden.</p>
<p>Du wirst Standardtypparameter auf zwei Arten verwenden:</p>
<ol>
<li>Um einen Typ zu erweitern, ohne bestehenden Code zu brechen.</li>
<li>Um eine Anpassung in bestimmten Fällen zu ermöglichen, die die meisten
Benutzer nicht benötigen.</li>
</ol>
<p>Das Merkmal <code>Add</code> der Standardbibliothek ist ein Beispiel für den zweiten
Zweck: Normalerweise addierst du zwei ähnliche Typen, aber das Merkmal <code>Add</code>
bietet die Möglichkeit, darüber hinausgehende Anpassungen vorzunehmen. Das
Verwenden eines Standardtypparameters in der Merkmalsdefinition <code>Add</code> bedeutet,
dass du den zusätzlichen Parameter die meiste Zeit nicht angeben musst. Mit
anderen Worten kann etwas Implementierungscode eingespart werden, was das
Verwenden des Merkmals erleichtert.</p>
<p>Der erste Zweck ist ähnlich zum zweiten, nur umgekehrt: Wenn du einem
vorhandenen Merkmal einen Typparameter hinzufügen möchtest, kannst du ihm einen
Standardwert geben, um eine Erweiterung der Funktionalität des Merkmals zu
ermöglichen, ohne den vorhandenen Implementierungscode zu brechen.</p>
<h3 id="eindeutiger-aufruf-von-methoden-mit-gleichem-namen"><a class="header" href="#eindeutiger-aufruf-von-methoden-mit-gleichem-namen">Eindeutiger Aufruf von Methoden mit gleichem Namen</a></h3>
<p>Nichts in Rust hindert ein Merkmal daran, eine Methode mit demselben Namen wie
die Methode eines anderen Merkmals zu haben, und Rust hindert dich auch nicht
daran, beide Merkmale auf einem Typ zu implementieren. Es ist auch möglich,
eine Methode direkt auf dem Typ mit dem gleichen Namen wie Methoden von
Merkmalen zu implementieren.</p>
<p>Wenn du Methoden mit dem gleichen Namen aufrufst, musst du Rust mitteilen,
welche du verwenden willst. Betrachte den Code in Codeblock 20-17, wo wir zwei
Merkmale <code>Pilot</code> und <code>Wizard</code> definiert haben, die beide eine Methode namens
<code>fly</code> haben. Wir implementieren dann beide Merkmale auf einem Typ <code>Human</code>, der
bereits eine Methode namens <code>fly</code> implementiert hat. Jede Methode <code>fly</code> macht
etwas anderes.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("Hier spricht Ihr Kapitän.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("Hoch!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*Wütend mit den Armen wedeln*");
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-17: Zwei Merkmale sind so definiert, dass
sie eine Methode <code>fly</code> haben und auf dem Typ <code>Human</code> implementiert sind, und
eine Methode <code>fly</code> ist direkt auf dem Typ <code>Human</code> implementiert</span></p>
<p>Wenn wir <code>fly</code> auf einer Instanz von <code>Human</code> aufrufen, ruft der Compiler
standardmäßig die Methode auf, die direkt auf dem Typ implementiert ist, wie in
Codeblock 20-18 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Hier spricht Ihr Kapitän.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Hoch!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*Wütend mit den Armen wedeln*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
<p><span class="caption">Codeblock 20-18: Aufrufen von <code>fly</code> auf einer Instanz von
<code>Human</code></span></p>
<p>Wenn man diesen Code ausführt, wird <code>*Wütend mit den Armen wedeln*</code> ausgegeben,
was zeigt, dass Rust die Methode <code>fly</code>, die direkt auf <code>Human</code> implementiert
wurde, aufgerufen hat.</p>
<p>Um die Methoden <code>fly</code> entweder vom Merkmal <code>Pilot</code> oder vom Merkmal <code>Wizard</code>
aufzurufen, müssen wir eine explizitere Syntax verwenden, um anzugeben, welche
Methode <code>fly</code> wir meinen. Codeblock 20-19 demonstriert diese Syntax.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Hier spricht Ihr Kapitän.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Hoch!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*Wütend mit den Armen wedeln*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
<p><span class="caption">Codeblock 20-19: Angeben, welche Methode <code>fly</code> wir
aufrufen wollen</span></p>
<p>Das Angeben des Merkmalsnamens vor dem Methodennamen verdeutlicht Rust, welche
Implementierung von <code>fly</code> wir aufrufen wollen. Wir könnten auch
<code>Human::fly(&amp;person)</code> schreiben, was äquivalent zu <code>person.fly()</code> ist, das wir
in Codeblock 20-19 verwendet haben, aber das ist etwas länger zu schreiben, wenn
wir nicht vereindeutigen müssen.</p>
<p>Beim Ausführen dieses Codes wird Folgendes ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
Hier spricht Ihr Kapitän.
Hoch!
*Wütend mit den Armen wedeln*
</code></pre>
<p>Da die Methode <code>fly</code> einen Parameter <code>self</code> benötigt, könnte Rust, wenn wir
zwei <em>Typen</em> hätten, die beide ein <em>Merkmal</em> implementieren, herausfinden,
welche Implementierung eines Merkmals basierend auf dem Typ von <code>self</code> zu
verwenden ist.</p>
<p>Assoziierte Funktionen, die keine Methoden sind, haben jedoch keinen
<code>self</code>-Parameter. Wenn es mehrere Typen oder Merkmale gibt, die
Nicht-Methodenfunktionen mit demselben Funktionsnamen definieren, weiß Rust
nicht immer, welchen Typ du meinst, es sei denn, du verwendest eine
<em>voll-qualifizierte Syntax</em>. In Codeblock 20-20 erstellen wir zum Beispiel
ein Merkmal für ein Tierheim, das alle Hundebabys <em>Spot</em> nennen möchte. Wir
erstellen ein Merkmal <code>Animal</code> mit einer assoziierten Nicht-Methodenfunktion
<code>baby_name</code>. Das Merkmal <code>Animal</code> ist für die Struktur <code>Dog</code> implementiert, für
die wir auch direkt eine assoziierte Nicht-Methodenfunktionen <code>baby_name</code>
bereitstellen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("Welpe")
    }
}

fn main() {
    println!("Ein Hundebaby wird {} genannt.", Dog::baby_name());
}</code></pre></pre>
<p><span class="caption">Codeblock 20-20: Ein Merkmal mit einer assoziierten
Funktion und ein Typ mit einer assoziierten Funktion desselben Namens, der das
Merkmal ebenfalls implementiert</span></p>
<p>Wir implementieren den Code für die Benennung aller Welpen Spot in der
assoziierten Funktion <code>baby_name</code>, die auf <code>Dog</code> definiert ist. Der Typ <code>Dog</code>
implementiert auch das Merkmal <code>Animal</code>, das Charakteristiken beschreibt, die
alle Tiere haben. Hundebabys werden Welpen genannt und das drückt sich in der
Implementierung des Merkmals <code>Animal</code> auf <code>Dog</code> in der Funktion <code>baby_name</code>
aus, die mit dem Merkmal <code>Animal</code> assoziiert ist.</p>
<p>In <code>main</code> rufen wir die Funktion <code>Dog::baby_name</code> auf, die die assoziierte
Funktion, die auf <code>Dog</code> definiert ist, direkt aufruft. Dieser Code gibt
Folgendes aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
Ein Hundebaby wird Spot genannt.
</code></pre>
<p>Diese Ausgabe ist nicht das, was wir wollten. Wir wollen die Funktion
<code>baby_name</code> aufrufen, die Teil des Merkmals <code>Animal</code> ist, das wir auf <code>Dog</code>
implementiert haben, sodass der Code <code>Ein Hundebaby wird Welpe genannt</code>
ausgibt. Die Technik der Angabe des Merkmalsnamens, die wir in Codeblock 20-19
verwendet haben, hilft hier nicht weiter; wenn wir <code>main</code> in den Code in
Codeblock 20-21 ändern, erhalten wir einen Kompilierfehler.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Welpe")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("Ein Hundebaby wird {} genannt.", Animal::baby_name());
}
</code></pre></pre>
<p><span class="caption">Codeblock 20-21: Versuch, die Funktion <code>baby_name</code> des
Merkmals <code>Animal</code> aufzurufen, aber Rust weiß nicht, welche Implementierung es
verwenden soll</span></p>
<p>Da <code>Animal::baby_name</code> keinen <code>self</code>-Parameter hat, und es andere Typen geben
könnte, die das Merkmal <code>Animal</code> implementieren, kann Rust nicht herausfinden,
welche Implementierung von <code>Animal::baby_name</code> wir wollen. Wir werden diesen
Kompilierfehler erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("Ein Hundebaby wird {} genannt.", Animal::baby_name());
   |                                                ^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("Ein Hundebaby wird {} genannt.", &lt;Dog as Animal&gt;::baby_name());
   |                                                +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
</code></pre>
<p>Um zu vereindeutigen und Rust zu sagen, dass wir die Implementierung von
<code>Animal</code> für <code>Dog</code> verwenden wollen und nicht die Implementierung von <code>Animal</code>
für einen anderen Typ, müssen wir eine vollständig qualifizierte Syntax
verwenden. Codeblock 20-22 zeigt, wie man eine vollständig qualifizierte Syntax
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Welpe")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("Ein Hundebaby wird {} genannt.", &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
<p><span class="caption">Codeblock 20-22: Verwenden einer vollständig
qualifizierten Syntax, um anzugeben, dass wir die Funktion <code>baby_name</code> des
Merkmals <code>Animal</code> aufrufen wollen, wie sie auf <code>Dog</code> implementiert ist</span></p>
<p>Wir geben Rust mit einer Typ-Annotation innerhalb spitzer Klammern an, dass wir
die Methode <code>baby_name</code> des Merkmals <code>Animal</code>, die auf <code>Dog</code> implementiert ist,
aufrufen wollen, indem wir sagen, dass wir den Typ <code>Dog</code> für diesen
Funktionsaufruf als <code>Animal</code> behandeln wollen. Dieser Code wird nun ausgeben,
was wir wollen:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
Ein Hundebaby wird Welpe genannt.
</code></pre>
<p>Im Allgemeinen wird die vollständig qualifizierte Syntax wie folgt definiert:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>Für assoziierte Funktionen, die keine Methoden sind, gäbe es keinen <code>receiver</code>:
Es gäbe nur die Liste der anderen Argumente. Du könntest eine vollständig
qualifizierte Syntax überall dort verwenden, wo du Funktionen oder Methoden
aufrufst. Du darfst jedoch jeden Teil dieser Syntax weglassen, den Rust aus
anderen Informationen im Programm herausfinden kann. Du musst diese
ausführlichere Syntax nur in Fällen verwenden, in denen es mehrere
Implementierungen gibt, die denselben Namen verwenden, und Rust Hilfe benötigt,
um herauszufinden, welche Implementierung du aufrufen möchtest.</p>
<h3 id="verwenden-von-supermerkmalen"><a class="header" href="#verwenden-von-supermerkmalen">Verwenden von Supermerkmalen</a></h3>
<p>Manchmal kann es vorkommen, dass man eine Merkmals-Definition schreibt, die von
einem anderen Merkmal abhängt: Damit ein Typ das erste Merkmal implementieren
kann, muss dieser Typ auch das zweite Merkmal implementieren. Du würdest dies
tun, damit deine Merkmalsdefinition die zugehörigen Elemente des zweiten
Merkmals verwenden kann. Das Merkmal, auf das sich deine Merkmalsdefinition
stützt, wird als <em>Supermerkmal</em> (supertrait) deines Merkmals bezeichnet.</p>
<p>Nehmen wir zum Beispiel an, wir wollen ein Merkmal <code>OutlinePrint</code> mit einer
Methode <code>outline_print</code> erstellen, das einen bestimmten Wert so formatiert,
dass er in Sternchen eingerahmt ausgegeben wird. Das heißt, wenn wir eine
Struktur <code>Point</code> haben, die <code>Display</code> so implementiert, dass sie <code>(x, y)</code>
ausgibt, dann gibt der Aufruf von <code>outline_print</code> einer <code>Point</code>-Instanz, die
<code>1</code> für <code>x</code> und <code>3</code> für <code>y</code> hat, folgendes aus:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>Bei der Implementierung der Methode <code>outline_print</code> wollen wir die
Funktionalität des Merkmals <code>Display</code> nutzen. Daher müssen wir festlegen, dass
das Merkmal <code>OutlinePrint</code> nur bei Typen funktioniert, die auch <code>Display</code>
implementieren und die Funktionalität bieten, die <code>OutlinePrint</code> benötigt. Wir
können dies in der Merkmalsdefinition tun, indem wir <code>OutlinePrint: Display</code>
angeben. Diese Technik ähnelt dem Angeben einer Merkmalsabgrenzung (trait
bound) bei einem Merkmal. Codeblock 20-23 zeigt eine Implementierung des
Merkmals <code>OutlinePrint</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-23: Implementieren des Merkmals
<code>OutlinePrint</code>, das die Funktionalität von <code>Display</code> erfordert</span></p>
<p>Da wir festgelegt haben, dass <code>OutlinePrint</code> das Merkmal <code>Display</code> erfordert,
können wir die Funktion <code>to_string</code> verwenden, die automatisch für jeden Typ
implementiert wird, der <code>Display</code> implementiert. Wenn wir versuchen würden,
<code>to_string</code> zu verwenden, ohne einen Doppelpunkt und das Merkmal <code>Display</code> nach
dem Merkmalsnamen anzugeben, würden wir eine Fehlermeldung erhalten, die
besagt, dass keine Methode mit dem Namen <code>to_string</code> für den Typ <code>&amp;Self</code> im
aktuellen Gültigkeitsbereich gefunden wurde.</p>
<p>Lass uns sehen, was passiert, wenn wir versuchen, <code>OutlinePrint</code> auf einem Typ
zu implementieren, der <code>Display</code> nicht implementiert, z.B. die Struktur
<code>Point</code>:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
<p>Wir erhalten einen Fehler, der besagt, dass <code>Display</code> erforderlich, aber nicht
implementiert ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
</code></pre>
<p>Um dies zu beheben, implementieren wir <code>Display</code> auf <code>Point</code> und erfüllen die
Bedingung, die <code>OutlinePrint</code> erfordert, in etwa so:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
<p>Dann wird die Implementierung des Merkmals <code>OutlinePrint</code> auf <code>Point</code>
erfolgreich kompilieren und wir können <code>outline_print</code> auf einer
<code>Point</code>-Instanz aufrufen, um sie in Sternchen eingerahmt anzuzeigen.</p>
<h3 id="verwenden-des-newtype-musters-zum-implementieren-von-externen-merkmalen-auf-externen-typen"><a class="header" href="#verwenden-des-newtype-musters-zum-implementieren-von-externen-merkmalen-auf-externen-typen">Verwenden des Newtype-Musters zum Implementieren von externen Merkmalen auf externen Typen</a></h3>
<p>In <a href="ch10-02-traits.html#ein-merkmal-f%C3%BCr-einen-typ-implementieren">„Ein Merkmal für einen Typ implementieren“</a>
in Kapitel 10 erwähnten wir die Waisenregel, bei der wir ein Merkmal nur dann
auf einem Typ implementieren dürfen, wenn entweder das Merkmal oder der Typ
oder beides lokal in unserer Kiste (crate) vorhanden ist. Es ist möglich, diese
Einschränkung zu umgehen, indem man das <em>Newtype-Muster</em> (newtype pattern)
verwendet, bei dem ein neuer Typ in einer Tupelstruktur erzeugt wird. (Wir
haben Tupelstrukturen in <a href="ch05-01-defining-structs.html#verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen">„Verwenden von Tupel-Strukturen ohne benannte Felder
um verschiedene Typen zu erzeugen“</a> in Kapitel 5 behandelt.) Die
Tupelstruktur wird ein Feld haben und eine dünne Verpackung um den Typ sein,
für den wir ein Merkmal implementieren wollen. Dann ist der Verpackungstyp
lokal in unserer Kiste und wir können das Merkmal auf dem Verpackungstyp
(wrapper type) implementieren. <em>Newtype</em> ist ein Begriff, der aus der
Programmiersprache Haskell stammt. Beim Verwenden dieses Musters gibt es keine
Beeinträchtigung der Laufzeitperformanz und der Verpackungstyp wird zur
Kompilierzeit elidiert.</p>
<p>Nehmen wir als Beispiel an, wir wollen <code>Display</code> auf <code>Vec&lt;T&gt;</code> implementieren,
was uns die Waisenregel direkt verbietet, weil das Merkmal <code>Display</code> und der
Typ <code>Vec&lt;T&gt;</code> außerhalb unserer Kiste definiert sind. Wir können eine Struktur
<code>Wrapper</code> erstellen, die eine Instanz von <code>Vec&lt;T&gt;</code> enthält; dann können wir
<code>Display</code> auf <code>Wrapper</code> implementieren und den Wert <code>Vec&lt;T&gt;</code> verwenden, wie in
Codeblock 20-24 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("Hallo"), String::from("Welt")]);
    println!("w = {w}");
}</code></pre></pre>
<p><span class="caption">Codeblock 20-24: Erstellen eines Typs <code>Wrapper</code> um
<code>Vec&lt;String&gt;</code> zur Implementierung von <code>Display</code></span></p>
<p>Die Implementierung von <code>Display</code> verwendet <code>self.0</code>, um auf den inneren
<code>Vec&lt;T&gt;</code> zuzugreifen, da <code>Wrapper</code> eine Tupelstruktur ist und <code>Vec&lt;T&gt;</code> das
Element mit dem Index 0 im Tupel ist. Dann können wir die Funktionalität des
<code>Display</code>-Typs auf <code>Wrapper</code> verwenden.</p>
<p>Der Nachteil der Verwendung dieser Technik ist, dass <code>Wrapper</code> ein neuer Typ
ist, sodass er nicht die Methoden des Wertes hat, den er hält. Wir müssten alle
Methoden von <code>Vec&lt;T&gt;</code> direkt auf <code>Wrapper</code> implementieren, sodass die Methoden
an <code>self.0</code> delegieren, was uns erlauben würde, <code>Wrapper</code> genau wie einen
<code>Vec&lt;T&gt;</code> zu behandeln. Wenn wir wollten, dass der neue Typ jede Methode des
inneren Typs hat, wäre die Implementierung des Merkmals <code>Deref</code> auf dem
<code>Wrapper</code> eine Lösung, um den inneren Typ zurückzugeben (wir haben die
Implementierung des Merkmals <code>Deref</code> in <a href="ch15-02-deref.html">„Intelligente Zeiger wie normale
Referenzen behandeln mit dem Merkmal (trait) <code>Deref</code>“</a> in
Kapitel 15 besprochen). Wenn wir nicht wollten, dass der <code>Wrapper</code>-Typ alle
Methoden des inneren Typs hat – zum Beispiel, um das Verhalten des
<code>Wrapper</code>-Typs einzuschränken – müssten wir nur die Methoden, die wir
wollen, manuell implementieren.</p>
<p>Dieses Newtype-Muster ist auch dann nützlich, wenn keine Merkmale beteiligt
sind. Wechseln wir den Fokus und schauen wir uns einige fortgeschrittene
Möglichkeiten an, mit dem Typsystem von Rust zu interagieren.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fortgeschrittene-typen"><a class="header" href="#fortgeschrittene-typen">Fortgeschrittene Typen</a></h2>
<p>Das Rust-Typsystem weist einige Funktionalitäten auf, die wir bisher erwähnt,
aber noch nicht besprochen haben. Wir beginnen mit einer allgemeinen Diskussion
über Newtypes, während wir untersuchen, warum Newtypes als Typen nützlich sind.
Dann gehen wir zu Typ-Alias über, einer Funktionalität, die den Newtypes
ähnlich ist, aber eine etwas andere Semantik hat. Wir werden auch den Typ <code>!</code>
und dynamisch große Typen besprechen.</p>
<h3 id="verwenden-des-newtype-musters-für-typsicherheit-und-abstraktion"><a class="header" href="#verwenden-des-newtype-musters-für-typsicherheit-und-abstraktion">Verwenden des Newtype-Musters für Typsicherheit und Abstraktion</a></h3>
<p>Der nächste Abschnitt geht davon aus, dass du den früheren Abschnitt
<a href="ch20-02-advanced-traits.html#verwenden-des-newtype-musters-zum-implementieren-von-externen-merkmalen-auf-externen-typen">„Verwenden des Newtype-Musters zum Implementieren von externen Merkmalen auf
externen Typen“</a> gelesen hast. Das Newtype-Muster
ist auch für Aufgaben nützlich, die über die bisher besprochenen hinausgehen,
einschließlich statisch sicherzustellen, dass Werte niemals verwechselt werden,
und dem Angeben von Einheiten eines Wertes. Ein Beispiel für die Verwendung von
Newtypes zum Angeben von Einheiten hast du in Codeblock 20-16 gesehen: Erinnere
dich daran, dass die Strukturen <code>Millimeters</code> und <code>Meters</code> <code>u32</code>-Werte in einem
Newtype einpacken. Wenn wir eine Funktion mit einem Parameter vom Typ
<code>Millimeters</code> schreiben würden, könnten wir kein Programm kompilieren, das
versehentlich versucht, diese Funktion mit einem Wert vom Typ <code>Meters</code> oder
einem einfachen <code>u32</code> aufzurufen.</p>
<p>Wir können auch das Newtype-Muster verwenden, um einige Implementierungsdetails
eines Typs zu abstrahieren: Der neue Typ kann eine öffentliche API
bereitstellen, die sich von der API des privaten, inneren Typs unterscheidet.</p>
<p>Newtypes können auch die interne Implementierung verbergen. Zum Beispiel
könnten wir einen Typ <code>People</code> zur Verfügung stellen, um eine <code>HashMap&lt;i32, String&gt;</code> einzupacken, die die ID einer Person in Verbindung mit ihrem Namen
speichert. Code, der <code>People</code> verwendet, würde nur mit der öffentlichen API
interagieren, die wir zur Verfügung stellen, z.B. eine Methode, um eine
Namenszeichenkette zur <code>People</code>-Kollektion hinzuzufügen; dieser Code müsste
nicht wissen, dass wir Namen intern eine <code>i32</code>-ID zuordnen. Das Newtype-Muster
ist ein leichtgewichtiger Weg, eine Kapselung zu erreichen, um
Implementierungsdetails zu verbergen, die wir in <a href="ch18-01-what-is-oo.html#kapselung-die-implementierungsdetails-verbirgt">„Kapselung, die
Implementierungsdetails verbirgt“</a> in Kapitel 18 besprochen
haben.</p>
<h3 id="erstellen-von-typ-synonymen-mit-typ-alias"><a class="header" href="#erstellen-von-typ-synonymen-mit-typ-alias">Erstellen von Typ-Synonymen mit Typ-Alias</a></h3>
<p>Rust bietet die Möglichkeit, einen <em>Typ-Alias</em> zu deklarieren, um einem
vorhandenen Typ einen anderen Namen zu geben. Hierfür verwenden wir das
Schlüsselwort <code>type</code>. Zum Beispiel können wir den Alias <code>Kilometers</code> für <code>i32</code>
so anlegen:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>Der Alias <code>Kilometers</code> ist ein <em>Synonym</em> für <code>i32</code>; im Gegensatz zu den Typen
<code>Millimeters</code> und <code>Meters</code>, die wir in Codeblock 20-16 erstellt haben, ist
<code>Kilometers</code> kein separater, neuer Typ. Werte, die den Typ <code>Kilometers</code> haben,
werden genauso behandelt wie Werte des Typs <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre></pre>
<p>Da <code>Kilometers</code> und <code>i32</code> vom gleichen Typ sind, können wir Werte beider Typen
addieren und wir können <code>Kilometers</code>-Werte an Funktionen übergeben, die
<code>i32</code>-Parameter verwenden. Mit dieser Methode erhalten wir jedoch nicht die
Vorteile der Typprüfung, die wir vom zuvor besprochenen Newtype-Muster haben.
Mit anderen Worten, wenn wir irgendwo <code>Kilometers</code>- und <code>i32</code>-Werte
verwechseln, wird uns der Compiler keinen Fehler anzeigen.</p>
<p>Der Hauptanwendungsfall für Typ-Synonyme ist das Reduzieren von Wiederholungen.
Zum Beispiel könnten wir einen längeren Typ wie diesen haben:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>Das Schreiben dieses langen Typs in Funktionssignaturen und als
Typ-Annotationen im gesamten Code kann ermüdend und fehleranfällig sein. Stelle
dir vor, du hättest ein Projekt voller Code wie das in Codeblock 20-25.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("hallo"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --abschneiden--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --abschneiden--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-25: Verwenden eines langen Typs an vielen
Stellen</span></p>
<p>Ein Typ-Alias macht diesen Code leichter handhabbar, indem er die Wiederholung
reduziert. In Codeblock 20-26 haben wir einen Alias namens <code>Thunk</code> für den
verbosen Typ eingeführt und können alle Verwendungen des Typs durch den
kürzeren Alias <code>Thunk</code> ersetzen.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("hallo"));

    fn takes_long_type(f: Thunk) {
        // --abschneiden--
    }

    fn returns_long_type() -&gt; Thunk {
        // --abschneiden--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-26: Einführen eines Typ-Alias <code>Thunk</code> zur
Reduzierung von Wiederholungen</span></p>
<p>Dieser Code ist viel einfacher zu lesen und zu schreiben! Die Wahl eines
aussagekräftigen Namens für einen Typ-Alias kann auch helfen, deine Absicht zu
kommunizieren (<em>thunk</em> ist ein Wort für Code, der zu einem späteren Zeitpunkt
ausgewertet wird, also ein passender Name für einen Funktionsabschluss
(closure), der gespeichert wird).</p>
<p>Typ-Alias werden auch häufig mit dem Typ <code>Result&lt;T, E&gt;</code> verwendet, um
Wiederholungen zu reduzieren. Betrachte das Modul <code>std::io</code> in der
Standardbibliothek. E/A-Operationen geben oft ein <code>Result&lt;T, E&gt;</code> zurück, um
Situationen zu behandeln, in denen Operationen nicht funktionieren. Diese
Bibliothek hat eine Struktur <code>std::io::Error</code>, die alle möglichen E/A-Fehler
repräsentiert. Viele der Funktionen in <code>std::io</code> geben <code>Result&lt;T, E&gt;</code> zurück,
wobei für <code>E</code> der Typ <code>std::io::Error</code> verwendet wird, so wie bei diesen
Funktionen im Merkmal (trait) <code>Write</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>Result&lt;..., Error&gt;</code> wird oft wiederholt. Daher hat <code>std::io</code> diese Art von
Alias-Deklaration:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>Da sich diese Deklaration im Modul <code>std::io</code> befindet, können wir den
vollständig qualifizierten Alias <code>std::io::Result&lt;T&gt;</code> verwenden; das ist
ein <code>Result&lt;T, E&gt;</code> mit <code>E</code> als <code>std::io::Error</code>. Die Funktionssignaturen des
Merkmals <code>Write</code> sehen am Ende so aus:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>Der Typ-Alias hilft in zweierlei Hinsicht: Er macht es einfacher, Code zu
schreiben <em>und</em> er gibt uns eine konsistente Schnittstelle innerhalb <code>std::io</code>.
Weil es ein Alias ist, ist es nur ein weiteres <code>Result&lt;T, E&gt;</code>, was bedeutet,
dass wir alle Methoden, die mit <code>Result&lt;T, E&gt;</code> funktionieren, mit ihm verwenden
können, einschließlich spezieller Syntax wie der <code>?</code>-Operator.</p>
<h3 id="der-niemals-typ-der-niemals-zurückkehrt"><a class="header" href="#der-niemals-typ-der-niemals-zurückkehrt">Der Niemals-Typ, der niemals zurückkehrt</a></h3>
<p>Rust hat einen speziellen Typ namens <code>!</code>, der im Fachjargon der Typtheorie als
<em>leerer Typ</em> (empty type) bekannt ist, weil er keine Werte hat. Wir ziehen es
vor, ihn den <em>Niemals-Typ</em> (never type) zu nennen, weil er an der Stelle des
Rückgabetyps steht, wenn eine Funktion niemals zurückkehrt. Hier ist ein
Beispiel:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --abschneiden--
<span class="boring">    panic!();
</span>}</code></pre>
<p>Dieser Code wird als „die Funktion <code>bar</code> kehrt niemals zurück“ gelesen.
Funktionen, die niemals zurückkehren, werden <em>divergierende Funktionen</em>
(diverging functions) genannt. Wir können keine Werte vom Typ <code>!</code> erzeugen,
also kann <code>bar</code> niemals zurückkehren.</p>
<p>Aber was nützt ein Typ, für den man nie Werte erzeugen kann? Erinnere dich an
den Code aus Codeblock 2-5, der Teil des Zahlenratespiels ist; wir haben einen
Teil davon hier in Codeblock 20-27 wiedergegeben.</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!("Die Geheimzahl ist: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Bitte gib deine Schätzung ein.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --abschneiden--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Fehler beim Lesen der Zeile");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("Du hast geschätzt: {guess}");
</span><span class="boring">
</span><span class="boring">        // --abschneiden--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Zu klein!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Zu groß!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("Du hast gewonnen!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 20-27: Ein <code>match</code> mit einem Zweig, der in
<code>continue</code> endet</span></p>
<p>Damals haben wir einige Details in diesem Code übersprungen. In <a href="ch06-02-match.html">„Das
Kontrollflusskonstrukt <code>match</code>“</a> in Kapitel 6 haben wir
erwähnt, dass alle Zweige den gleichen Typ zurückgeben müssen. So funktioniert
zum Beispiel der folgende Code nicht:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hallo",
    };
<span class="boring">}</span></code></pre></pre>
<p>Der Typ von <code>guess</code> in diesem Code müsste eine ganze Zahl <em>und</em> eine
Zeichenkette sein und Rust verlangt, dass <code>guess</code> nur einen Typ hat. Was gibt
also <code>continue</code> zurück? Wie war es uns erlaubt, ein <code>u32</code> von einem Zweig
zurückzugeben und einen anderen Zweig zu haben, der in Codeblock 20-26 mit
<code>continue</code> endet?</p>
<p>Wie du vielleicht schon vermutet hast, hat <code>continue</code> einen <code>!</code>-Wert. Das
heißt, wenn Rust den Typ von <code>guess</code> berechnet, betrachtet es beide
<code>match</code>-Zweige, den ersten mit einem Wert von <code>u32</code> und den zweiten mit einem
<code>!</code>-Wert. Da <code>!</code> niemals einen Wert haben kann, entscheidet Rust, dass <code>guess</code>
den Typ <code>u32</code> hat.</p>
<p>Der formale Weg, dieses Verhalten zu beschreiben, besteht darin, dass Ausdrücke
vom Typ <code>!</code> in jeden anderen Typ umgewandelt werden können. Es ist uns erlaubt,
diesen <code>match</code>-Zweig mit <code>continue</code> zu beenden, weil <code>continue</code> keinen Wert
zurückgibt; stattdessen bringt es die Kontrolle zurück an den Anfang der
Schleife, sodass wir im <code>Err</code>-Fall <code>guess</code> niemals einen Wert zuweisen.</p>
<p>Der Niemals-Typ ist auch beim Makro <code>panic!</code> nützlich. Erinnere dich an die
Funktion <code>unwrap</code>, die wir auf <code>Option&lt;T&gt;</code> Werte aufrufen, um einen Wert zu
erzeugen oder das Programm abstürzen zu lassen. Hier ist ihre Definition:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!("Aufruf von `Option::unwrap()` auf einem `None`-Wert"),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In diesem Code geschieht dasselbe wie bei <code>match</code> in Codeblock 20-27: Rust
sieht, dass <code>val</code> den Typ <code>T</code> und <code>panic!</code> den Typ <code>!</code> hat, sodass das Ergebnis
des gesamten <code>match</code>-Ausdrucks <code>T</code> ist. Dieser Code funktioniert, weil <code>panic!</code>
keinen Wert produziert; es beendet das Programm. Im Fall von <code>None</code> geben wir
keinen Wert von <code>unwrap</code> zurück, also ist dieser Code gültig.</p>
<p>Ein letzter Ausdruck, der den Typ <code>!</code> hat, ist <code>loop</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    print!("für immer ");

    loop {
        print!("und ewig ");
    }
<span class="boring">}</span></code></pre></pre>
<p>Hier endet die Schleife nie, also ist <code>!</code> der Typ des Ausdrucks. Dies wäre
jedoch nicht der Fall, wenn wir <code>break</code> einfügen würden, da die Schleife enden
würde, wenn sie bei <code>break</code> ankommt.</p>
<h3 id="dynamisch-große-typen-und-das-merkmal-sized"><a class="header" href="#dynamisch-große-typen-und-das-merkmal-sized">Dynamisch große Typen und das Merkmal <code>Sized</code></a></h3>
<p>Rusts muss bestimmte Details über seine Typen kennen, z.B. wie viel Platz für
einen Wert eines bestimmten Typs zuzuweisen ist. Das lässt eine Ecke des
Typsystems zunächst etwas verwirrend erscheinen: Das Konzept der <em>dynamisch
großen Typen</em> (dynamically sized types). Diese Typen, die manchmal als <em>DSTs</em>
oder <em>Typen ohne Größe</em> (unsized types) bezeichnet werden, erlauben es uns,
Code mit Werten zu schreiben, deren Größe wir nur zur Laufzeit kennen können.</p>
<p>Schauen wir uns die Details eines dynamisch großen Typs namens <code>str</code> an, den
wir im ganzen Buch verwendet haben. Das stimmt, nicht <code>&amp;str</code>, sondern <code>str</code> an
sich ist ein DST. Wir können nicht wissen, wie lang die Zeichenkette zur
Laufzeit ist, d.h. wir können weder eine Variable vom Typ <code>str</code> erzeugen, noch
können wir ein Argument vom Typ <code>str</code> nehmen. Betrachte den folgenden Code, der
nicht funktioniert:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s1: str = "Guten Tag!";
    let s2: str = "Wie geht es dir?";

<span class="boring">}</span></code></pre></pre>
<p>Rust muss wissen, wie viel Speicher jedem Wert eines bestimmten Typs zuzuweisen
ist, und alle Werte eines Typs müssen die gleiche Speichermenge verwenden. Wenn
Rust uns erlauben würde, diesen Code zu schreiben, müssten diese beiden
<code>str</code>-Werte die gleiche Speichermenge beanspruchen. Aber sie haben
unterschiedliche Längen: <code>s1</code> benötigt 10 Bytes Speicherplatz und <code>s2</code> 16
Bytes. Aus diesem Grund ist es nicht möglich, eine Variable zu erzeugen, die
einen dynamisch großen Typ enthält.</p>
<p>Was sollen wir also tun? In diesem Fall kennst du die Antwort bereits: Wir
machen die Typen <code>s1</code> und <code>s2</code> zu einem <code>&amp;str</code> anstatt zu einem <code>str</code>. Erinnere
dich, dass wir in <a href="ch04-03-slices.html#zeichenkettenanteilstypen-string-slices">„Zeichenkettenanteilstypen (string slices)“</a>
in Kapitel 4 gesagt haben, dass die Anteilstypen-Datenstruktur die
Startposition und die Länge des Anteilstyps speichert. Obwohl also <code>&amp;T</code> ein
einzelner Wert ist, der die Speicheradresse des Ortes speichert, an dem sich
<code>T</code> befindet, hat <code>&amp;str</code> <em>zwei</em> Werte: Die Adresse von <code>str</code> und seine Länge.
Als solches können wir die Größe eines <code>&amp;str</code>-Wertes zur Kompilierzeit kennen:
Er ist doppelt so lang wie ein <code>usize</code>. Das heißt, wir wissen immer die Größe
einer <code>&amp;str</code>, egal wie lang die Zeichenkette ist, auf die sie sich bezieht. Im
Allgemeinen werden in Rust Typen mit dynamischer Größe auf diese Weise
verwendet: Sie haben ein zusätzliches Stück Metadaten, das die Größe der
dynamischen Information speichert. Die goldene Regel für Typen dynamischer
Größe lautet, dass wir Werte von Typen mit dynamischer Größe immer hinter eine
Art Zeiger stellen müssen.</p>
<p>Wir können <code>str</code> mit allen Arten von Zeigern kombinieren: Zum Beispiel
<code>Box&lt;str&gt;</code> oder <code>Rc&lt;str&gt;</code>. Tatsächlich hast du das schon einmal gesehen, aber
mit einem anderen dynamisch großen Typ: Merkmale (traits). Jedes Merkmal ist
ein dynamisch großer Typ, auf den wir uns beziehen können, indem wir den Namen
des Merkmals verwenden. In <a href="ch18-02-trait-objects.html">„Merkmalsobjekte (trait objects) die Werte
unterschiedlicher Typen erlauben“</a> in Kapitel 18 haben wir
erwähnt, dass wir, um Merkmale als Merkmalsobjekte zu verwenden, diese hinter
einen Zeiger setzen müssen, z.B. <code>&amp;dyn Trait</code> oder <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> würde auch funktionieren).</p>
<p>Um mit DSTs zu arbeiten, hat Rust das Merkmal <code>Sized</code>, um zu bestimmen, ob die
Größe eines Typs zur Kompilierzeit bekannt ist oder nicht. Dieses Merkmal wird
automatisch für alles implementiert, dessen Größe zur Kompilierzeit bekannt
ist. Zusätzlich fügt Rust implizit jeder generischen Funktion eine
Merkmalsabgrenzung auf <code>Sized</code> hinzu. Das heißt, eine generische
Funktionsdefinition wie diese:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T&gt;(t: T) {
    // --abschneiden--
}
<span class="boring">}</span></code></pre></pre>
<p>wird tatsächlich so behandelt, als hätten wir das geschrieben:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: Sized&gt;(t: T) {
    // --abschneiden--
}
<span class="boring">}</span></code></pre></pre>
<p>Standardmäßig funktionieren generische Funktionen nur bei Typen, die zur
Kompilierzeit eine bekannte Größe haben. Du kannst jedoch die folgende
spezielle Syntax verwenden, um diese Einschränkung zu lockern:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --abschneiden--
}
<span class="boring">}</span></code></pre></pre>
<p>Eine Merkmalsabgrenzung durch <code>?Sized</code> bedeutet „<code>T</code> kann <code>Sized</code> sein oder
nicht“ und diese Notation hebt die Vorgabe auf, dass generische Typen zur
Kompilierzeit eine bekannte Größe haben müssen. Die Syntax <code>?Trait</code> mit dieser
Bedeutung ist nur für <code>Sized</code> verfügbar, nicht für andere Merkmale.</p>
<p>Beachte auch, dass wir den Typ des Parameters <code>t</code> von <code>T</code> auf <code>&amp;T</code> geändert
haben. Da der Typ möglicherweise nicht <code>Sized</code> ist, müssen wir ihn hinter einer
Art Zeiger verwenden. In diesem Fall haben wir eine Referenz gewählt.</p>
<p>Als nächstes werden wir über Funktionen und Funktionsabschlüsse sprechen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="erweiterte-funktionen-und-funktionsabschlüsse-closures"><a class="header" href="#erweiterte-funktionen-und-funktionsabschlüsse-closures">Erweiterte Funktionen und Funktionsabschlüsse (closures)</a></h2>
<p>Dieser Abschnitt befasst sich mit fortgeschrittenen Funktionalitäten im
Zusammenhang mit Funktionen und Funktionsabschlüsse, einschließlich
Funktionszeigern und Zurückgeben von Funktionsabschlüssen.</p>
<h3 id="funktionszeiger"><a class="header" href="#funktionszeiger">Funktionszeiger</a></h3>
<p>Wir haben darüber gesprochen, wie man Funktionsabschlüsse an Funktionen
übergibt; man kann auch reguläre Funktionen an Funktionen übergeben! Diese
Technik ist nützlich, wenn du eine Funktion, die du bereits definiert hast,
übergeben willst, anstatt einen neuen Funktionsabschluss zu definieren.
Funktionen haben den Typ <code>fn</code> (mit kleinem <em>f</em>), nicht zu verwechseln mit dem
Funktionsabschlussmerkmal (closure trait) <code>Fn</code>. Der Typ <code>fn</code> wird
<em>Funktionszeiger</em> (function pointer) genannt. Die Übergabe von Funktionen mit
Funktionszeigern ermöglicht es dir, Funktionen als Argumente für andere
Funktionen zu verwenden.</p>
<p>Die Syntax für die Angabe, dass ein Parameter ein Funktionszeiger ist, ähnelt
der von Funktionsabschlüssen, wie in Codeblock 20-28 gezeigt, wo wir eine
Funktion <code>add_one</code> definiert haben, die ihrem Parameter 1 hinzufügt. Die
Funktion <code>do_twice</code> nimmt zwei Parameter entgegen: Einen Funktionszeiger auf
eine beliebige Funktion mit einem <code>i32</code>-Parameter und einem <code>i32</code>-Rückgabewert,
und einen <code>i32</code>-Parameter. Die Funktion <code>do_twice</code> ruft die Funktion <code>f</code>
zweimal auf, übergibt ihr den Wert <code>arg</code> und addiert dann die Ergebnisse der
beiden Funktionsaufrufe zusammen. Die Funktion <code>main</code> ruft <code>do_twice</code> mit den
Argumenten <code>add_one</code> und <code>5</code> auf.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("Die Antwort ist: {answer}");
}</code></pre></pre>
<p><span class="caption">Codeblock 20-28: Verwenden des Typs <code>fn</code> zum
Entgegennehmen eines Funktionszeigers als Argument</span></p>
<p>Dieser Code gibt <code>Die Antwort ist: 12</code> aus. Wir spezifizieren, dass der
Parameter <code>f</code> in <code>do_twice</code> ein <code>fn</code> ist, das einen Parameter vom Typ <code>i32</code>
nimmt und ein <code>i32</code> zurückgibt. Wir können dann <code>f</code> im Rumpf von <code>do_twice</code>
aufrufen. In <code>main</code> können wir den Funktionsnamen <code>add_one</code> als erstes Argument
an <code>do_twice</code> übergeben.</p>
<p>Im Gegensatz zu Funktionsabschlüssen ist <code>fn</code> ein Typ, nicht ein Merkmal, daher
spezifizieren wir <code>fn</code> direkt als Parametertyp, anstatt einen generischen
Typparameter mit einem Merkmal <code>Fn</code> als Merkmalsabgrenzung (trait bound) zu
deklarieren.</p>
<p>Funktionszeiger implementieren alle drei Funktionsabschlussmerkmale (<code>Fn</code>,
<code>FnMut</code> und <code>FnOnce</code>), was bedeutet, dass du immer einen Funktionszeiger als
Argument an eine Funktion übergeben kannst, die einen Funktionsabschluss
erwartet. Es ist am besten, Funktionen mit einem generischen Typ und einer der
Funktionsabschlussmerkmale zu schreiben, sodass deine Funktionen entweder
Funktionen oder Funktionsabschlüsse akzeptieren können.</p>
<p>Ein Beispiel, bei dem du nur <code>fn</code> und keine Funktionsabschlüsse akzeptieren
möchtest, ist die Schnittstelle zu externem Code, der keine Funktionsabschlüsse
hat: C-Funktionen können Funktionen als Argumente akzeptieren, aber C hat keine
Funktionsabschlüsse.</p>
<p>Als Beispiel dafür, wo du entweder einen inline definierten Funktionsabschluss
oder eine benannte Funktion verwenden könntest, sehen wir uns die Verwendung
der Methode <code>map</code> an, die vom Merkmal <code>Iterator</code> in der Standardbibliothek
bereitgestellt wird. Um die Methode <code>map</code> zu verwenden, um einen Vektor von
Zahlen in einen Vektor von Zeichenketten zu verwandeln, könnten wir einen
Funktionsabschluss verwenden, wie in Codeblock 20-29.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-29: Verwendung eines Funktionsabschlusses
mit der Methode <code>map</code> zur Umwandlung von Zahlen in Zeichenketten</span></p>
<p>Oder wir könnten eine Funktion als Argument für <code>map</code> angeben anstelle des
Funktionsabschlusses. Codeblock 20-30 zeigt, wie das aussehen würde.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-30: Verwenden der Methode
<code>String::to_string</code> zur Umwandlung von Zahlen in Zeichenketten</span></p>
<p>Beachte, dass wir die vollständig qualifizierte Syntax verwenden müssen, über
die wir iin <a href="ch20-02-advanced-traits.html">„Fortgeschrittene Merkmale (traits)“</a> gesprochen
haben, weil es mehrere Funktionen namens <code>to_string</code> gibt.</p>
<p>Hier verwenden wir die Funktion <code>to_string</code>, die im Merkmal <code>ToString</code>
definiert ist, welche die Standardbibliothek für jeden Typ implementiert hat,
der <code>Display</code> implementiert.</p>
<p>Aus <a href="ch06-01-defining-an-enum.html#werte-in-aufz%C3%A4hlungen">„Werte in Aufzählungen“</a> in Kapitel 6 wissen wir, dass der
Name jeder definierten Aufzählungsvariante auch eine Initialisierungsfunktion
ist. Wir können diese Initialisierungsfunktionen als Funktionszeiger verwenden,
die die Funktionsabschlussmerkmale implementieren, was bedeutet, dass wir die
Initialisierungsfunktionen als Argumente für Methoden angeben können, die
Funktionsabschlüsse nehmen, wie in Codeblock 20-32 zu sehen ist.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-31: Verwenden eines
Aufzählungs-Initialisierers mit der Methode <code>map</code> zum Erstellen einer
<code>Status</code>-Instanz aus Zahlen</span></p>
<p>Hier erzeugen wir <code>Status::Value</code>-Instanzen für die <code>u32</code>-Werte im Bereich, für
den <code>map</code> aufgerufen wird, indem wir die Initialisierungsfunktion von
<code>Status::Value</code> verwenden. Einige Leute bevorzugen diesen Stil und einige Leute
ziehen es vor, Funktionsabschlüsse zu verwenden. Sie kompilieren zum gleichen
Code, also verwende den Stil, der für dich am klarsten ist.</p>
<h3 id="zurückgeben-von-funktionsabschlüssen"><a class="header" href="#zurückgeben-von-funktionsabschlüssen">Zurückgeben von Funktionsabschlüssen</a></h3>
<p>Funktionsabschlüsse werden durch Merkmale repräsentiert, was bedeutet, dass du
Funktionsabschlüsse nicht direkt zurückgeben kannst. In den meisten Fällen, in
denen du ein Merkmal zurückgeben möchtest, kannst du stattdessen den konkreten
Typ, der das Merkmal implementiert, als Rückgabewert der Funktion verwenden.
Aber das kannst du bei Funktionsabschlüssen normalerweise nicht tun, weil sie
keinen konkreten Typ haben, den man zurückgeben kann. Es ist dir beispielsweise
nicht erlaubt, den Funktionszeiger <code>fn</code> als Rückgabetyp zu verwenden, wenn der
Funktionsabschluss irgendwelche Werte aus seinem Gültigkeitsbereich erfasst.</p>
<p>Stattdessen wirst du normalerweise die Syntax <code>impl Trait</code> verwenden, die wir
in Kapitel 10 kennengelernt haben. Du kannst jeden Funktionstyp zurückgeben,
indem du <code>Fn</code>, <code>FnOnce</code> und <code>FnMut</code> verwendest. Zum Beispiel wird der Code in
Codeblock 20-32 problemlos funktionieren.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-32: Rückgeben eines Funktionsabschlusses aus
einer Funktion unter Verwendung der Syntax <code>impl Trait</code></span></p>
<p>Wie wir jedoch in <a href="ch13-01-closures.html#funktionsabschluss-typinferenz-und-annotation">„Funktionsabschluss-Typinferenz und
Annotation“</a> in Kapitel 13 festgestellt haben, ist jeder
Funktionsabschluss auch ein eigener Typ. Wenn du mit mehreren Funktionen
arbeiten musst, die dieselbe Signatur, aber unterschiedliche Implementierungen
haben, musst du ein Merkmals-Objekt für sie verwenden. Überlege, was passiert,
wenn du einen Code wie in Codeblock 20-33 schreibst.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{output}");
    }
}

fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}

fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |x| x + init
}</code></pre></pre>
<p><span class="caption">Codeblock 20-33: Erstellen eines <code>Vec&lt;T&gt;</code> von
Funktionsabschlüssen, die durch Funktionen definiert sind, die <code>impl Fn</code>
zurückgeben</span></p>
<p>Hier haben wir zwei Funktionen <code>returns_closure</code> und
<code>returns_initialized_closure</code>, die beide <code>impl Fn(i32) -&gt; i32</code> zurückgeben. Man
beachte, dass die Funktionsabschlüsse, die sie zurückgeben, unterschiedlich
sind, obwohl sie den gleichen Typ implementieren. Wenn wir versuchen, dies zu
kompilieren, lässt uns Rust wissen, dass es nicht funktionieren wird:</p>
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
    error[E0308]: mismatched types
    --&gt; src/main.rs:4:9
       |
    4  |         returns_initialized_closure(123)
       |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different opaque type
    ...
    12 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
       |                         ------------------- the expected opaque type
    ...
    16 | fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
       |                                              ------------------- the found opaque type
       |
    = note: expected opaque type `impl Fn(i32) -&gt; i32` (opaque type at &lt;src/main.rs:12:25&gt;)
                found opaque type `impl Fn(i32) -&gt; i32` (opaque type at &lt;src/main.rs:16:46&gt;)
    = note: distinct uses of `impl Trait` result in different opaque types

    For more information about this error, try `rustc --explain E0308`.
    error: could not compile `functions-example` (bin "functions-example") due to 1 previous error
</code></pre>
<p>Die Fehlermeldung sagt uns, dass Rust jedes Mal, wenn wir ein <code>impl Trait</code>
zurückgeben, einen eindeutigen <em>undurchsichtigen Typ</em> (opaque type) erzeugt,
einen Typ, bei dem wir nicht in die Details dessen sehen können, was Rust für
uns konstruiert. Obwohl diese Funktionen also beide Funktionsabschlüsse
zurückgeben, die dasselbe Merkmal implementieren, nämlich <code>Fn(i32) -&gt; i32</code>,
sind die undurchsichtigen Typen, die Rust für jede Funktion erzeugt,
unterschiedlich. (Dies ist vergleichbar mit der Art und Weise, wie Rust
unterschiedliche konkrete Typen für verschiedene asynchrone Blöcke erzeugt,
selbst wenn sie denselben Ausgabetyp haben, wie wir in <a href="ch17-03-more-futures.html">„Arbeiten mit einer
beliebigen Anzahl von Futures“</a> in Kapitel 17 gesehen
haben. Eine Lösung für dieses Problem haben wir jetzt schon ein paar Mal
gesehen: Wir können ein Merkmals-Objekt verwenden, wie in Codeblock 20-34.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
</span><span class="boring">    for handler in handlers {
</span><span class="boring">        let output = handler(5);
</span><span class="boring">        println!("{output}");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(move |x| x + init)
}</code></pre></pre>
<p><span class="caption">Codeblock 20-34: Erstellen eines <code>Vec&lt;T&gt;</code> von
Funktionsabschlüssen, die durch Funktionen definiert sind, die <code>Box&lt;dyn Fn&gt;</code>
zurückgeben, damit sie denselben Typ haben</span></p>
<p>Dieser Code lässt sich sehr gut kompilieren. Weitere Informationen über
Merkmalsobjekte findest du im Abschnitt <a href="ch18-02-trait-objects.html">„Merkmalsobjekte (trait objects) die
Werte unterschiedlicher Typen erlauben“</a> in Kapitel 18.</p>
<p>Als nächstes wollen wir uns Makros ansehen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="makros"><a class="header" href="#makros">Makros</a></h2>
<p>Wir haben in diesem Buch Makros wie <code>println!</code> verwendet, aber wir haben noch
nicht vollständig erforscht, was ein Makro ist und wie es funktioniert. Der
Begriff <em>Makro</em> bezieht sich auf eine Familie von Funktionalitäten in Rust:
<em>Deklarative</em> Makros mit <code>macro_rules!</code> und drei Arten <em>prozeduraler</em> Makros:</p>
<ul>
<li>Benutzerdefinierte Makros mit <code>#[derive]</code>, die Code spezifizieren, der mit
dem Attribut <code>derive</code> hinzugefügt wurde, das bei Strukturen (structs) und
Aufzählungen (enums) verwendet wird</li>
<li>Attribut-ähnliche Makros, die benutzerdefinierte Attribute definieren, die
bei jedem Element verwendet werden können</li>
<li>Funktions-ähnliche Makros, die wie Funktionsaufrufe aussehen, aber auf den
als Argument angegebenen Token operieren</li>
</ul>
<p>Wir werden der Reihe nach über jedes dieser Themen sprechen, aber zuerst wollen
wir uns ansehen, warum wir Makros überhaupt brauchen, wenn wir bereits
Funktionen haben.</p>
<h3 id="der-unterschied-zwischen-makros-und-funktionen"><a class="header" href="#der-unterschied-zwischen-makros-und-funktionen">Der Unterschied zwischen Makros und Funktionen</a></h3>
<p>Im Grunde genommen sind Makros eine Möglichkeit, Code zu schreiben, der anderen
Code schreibt, was als <em>Metaprogrammierung</em> bekannt ist. In Anhang C besprechen
wir das Attribut <code>derive</code>, das dir eine Implementierung verschiedener Merkmale
(traits) generiert. Wir haben im ganzen Buch auch die Makros <code>println!</code> und
<code>vec!</code> verwendet. All diese Makros werden <em>expandiert</em>, um mehr Code zu
erzeugen als der Code, den du manuell geschrieben hast.</p>
<p>Metaprogrammierung ist nützlich, um die Menge an Code zu reduzieren, die du
schreiben und pflegen musst, was auch eine der Aufgaben von Funktionen ist.
Makros haben jedoch einige zusätzliche Fähigkeiten, die Funktionen nicht haben.</p>
<p>Eine Funktionssignatur muss die Anzahl und den Typ der Parameter deklarieren,
die die Funktion hat. Makros hingegen können eine variable Anzahl von
Parametern entgegennehmen: Wir können <code>println!("Hallo")</code> mit einem Argument
oder <code>println!("Hallo {}", name)</code> mit zwei Argumenten aufrufen. Außerdem werden
Makros expandiert, bevor der Compiler die Bedeutung des Codes interpretiert,
sodass ein Makro beispielsweise ein Merkmal auf einen bestimmten Typ
implementieren kann. Eine Funktion kann das nicht, weil sie zur Laufzeit
aufgerufen wird und ein Merkmal zur Kompilierzeit implementiert werden muss.</p>
<p>Der Nachteil des Implementierens eines Makros anstelle einer Funktion besteht
darin, dass Makrodefinitionen komplexer sind als Funktionsdefinitionen, weil du
Rust-Code schreibst, der Rust-Code schreibt. Aufgrund dieser Indirektion sind
Makrodefinitionen im Allgemeinen schwieriger zu lesen, zu verstehen und zu
pflegen als Funktionsdefinitionen.</p>
<p>Ein weiterer wichtiger Unterschied zwischen Makros und Funktionen besteht
darin, dass du Makros definieren oder in den Gültigkeitsbereich bringen musst,
<em>bevor</em> du sie in einer Datei aufrufst, im Gegensatz zu Funktionen, die du
überall definieren und überall aufrufen kannst.</p>
<h3 id="deklarative-makros-mit-macro_rules-für-allgemeine-metaprogrammierung"><a class="header" href="#deklarative-makros-mit-macro_rules-für-allgemeine-metaprogrammierung">Deklarative Makros mit <code>macro_rules!</code> für allgemeine Metaprogrammierung</a></h3>
<p>Die am häufigsten verwendete Form von Makros in Rust ist das <em>deklarative
Makro</em>. Diese werden manchmal auch als „Makros am Beispiel“ (macros by
example), „<code>macro_rules!</code>-Makros“ oder einfach nur „Makros“ bezeichnet. In
ihrem Kern erlauben deklarative Makros, etwas Ähnliches wie einen Rust-Ausdruck
zu schreiben. Wie in Kapitel 6 besprochen, sind <code>match</code>-Ausdrücke
Kontrollstrukturen, die einen Ausdruck entgegennehmen, den resultierenden Wert
des Ausdrucks mit Mustern abgleichen und dann den Code ausführen, der mit dem
passenden Muster verknüpft ist. Deklarative Makros vergleichen ebenfalls einen
Wert mit Mustern, die mit einem bestimmten Code verknüpft sind. Bei deklarativen
Makros ist der Wert der dem Makro übergebene literale Rust-Quellcode. Die Muster
werden mit der Struktur dieses Quellcodes verglichen. Bei Übereinstimmung ersetzt
der mit dem Muster verknüpfte Code den an das Makro übergebenen Code. Dies alles
geschieht während der Kompilierung.</p>
<p>Um ein Makro zu definieren, verwendest du das Konstrukt <code>macro_rules!</code>. Lass
uns untersuchen, wie man <code>macro_rules!</code> benutzt, indem wir uns ansehen, wie das
Makro <code>vec!</code> definiert wird. Kapitel 8 behandelte, wie wir das Makro <code>vec!</code>
verwenden können, um einen neuen Vektor mit bestimmten Werten zu erzeugen. Zum
Beispiel erzeugt das folgende Makro einen neuen Vektor mit drei ganze Zahlen:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>Wir könnten auch das Makro <code>vec!</code> verwenden, um einen Vektor aus zwei ganzen
Zahlen oder einen Vektor aus fünf Zeichenkettenanteilstypen (string slices) zu
erstellen. Mit einer Funktion wäre das nicht möglich,
da uns weder die Anzahl noch den Typ der Werte im Voraus bekannt ist.</p>
<p>Codeblock 20-35 zeigt eine leicht vereinfachte Definition des Makros <code>vec!</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-35: Eine vereinfachte Version der
Makrodefinition <code>vec!</code></span></p>
<blockquote>
<p>Hinweis: Die eigentliche Definition des Makros <code>vec!</code> in der
Standardbibliothek enthält Code zum Vorbelegen der korrekten Speichermenge.
Dieser Code ist eine Optimierung, die wir hier zur Vereinfachung des
Beispiels nicht darstellen.</p>
</blockquote>
<p>Die Annotation <code>#[macro_export]</code> gibt an, dass dieses Makro immer dann zur
Verfügung gestellt werden soll, wenn die Kiste (crate), in der das Makro
definiert ist, in den Gültigkeitsbereich gebracht wird. Ohne diese Annotation
kann das Makro nicht in den Gültigkeitsbereich gebracht werden.</p>
<p>Dann beginnen wir die Makrodefinition mit <code>macro_rules!</code> und dem Namen des
Makros, das wir definieren, <em>ohne</em> Ausrufezeichen. Auf den Name, in diesem Fall
<code>vec</code>, folgen geschweifte Klammern, die den Rumpf der
Makrodefinition kennzeichnen.</p>
<p>Die Struktur im <code>vec!</code> -Rumpf ähnelt der Struktur eines <code>match</code>-Ausdrucks. Hier
haben wir einen Zweig mit dem Muster <code>( $( $x:expr ),* )</code>, gefolgt von <code>=&gt;</code> und
dem mit diesem Muster verknüpften Codeblock. Wenn das Muster passt, wird der
zugehörige Codeblock ausgegeben. Da dies das einzige Muster in diesem Makro
ist, kann es nur einen passenden Zweig geben; jedes andere Muster führt
zu einem Fehler. Komplexere Makros werden mehr als einen Zweig haben.</p>
<p>Die gültige Mustersyntax in Makrodefinitionen unterscheidet sich von der in
Kapitel 19 behandelten Mustersyntax, da Makromuster mit der Rust-Codestruktur
und nicht mit Werten abgeglichen werden. Lass uns im Folgenden die Bedeutung
der Musterteile in Codeblock 20-28 betrachten; die vollständige Makromustersyntax
findest du in der <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Rust-Referenz</a>.</p>
<p>Zunächst verwenden wir ein äußeres Klammernpaar, um das gesamte Muster zu
umfassen. Wir verwenden ein Dollarzeichen (<code>$</code>), um eine Variable im
Makrosystem zu deklarieren, die den Rust-Code enthält, der zum Muster passt.
Das Dollarzeichen macht deutlich, dass es sich um eine Makrovariable und nicht
um eine normale Rust-Variable handelt. Danach folgt eine Reihe von Klammern,
die Werte erfassen, die mit dem Muster innerhalb der Klammern übereinstimmen,
um sie im Ersetzungscode zu verwenden. Innerhalb von <code>$()</code> befindet sich
<code>$x:expr</code>, das mit jedem beliebigen Rust-Ausdruck übereinstimmt und dem
Ausdruck den Namen <code>$x</code> gibt.</p>
<p>Das Komma nach <code>$()</code> gibt an, dass ein literales Komma-Trennzeichen zwischen
allen Code-Teilen, die mit dem Code in <code>$()</code> übereinstimmen, vorhanden sein
muss. Der <code>*</code> besagt, dass das Muster keinmal oder mehrmals zu dem passt, was
vor dem <code>*</code> steht.</p>
<p>Wenn wir dieses Makro mit <code>vec![1, 2, 3];</code> aufrufen, passt das Muster <code>$x</code>
dreimal zu den drei Ausdrücken <code>1</code>, <code>2</code> und <code>3</code>.</p>
<p>Betrachten wir nun das Muster im Hauptteil des mit diesem Zweig verknüpften
Codes: <code>temp_vec.push()</code> innerhalb von <code>$()*</code> wird für jeden Teil erzeugt, der
keinmal oder mehrmals mit <code>$()</code> im Muster übereinstimmt, je nachdem, wie oft
das Muster passt. Das <code>$x</code> wird durch jeden passenden Ausdruck ersetzt. Wenn
wir dieses Makro mit <code>vec![1, 2, 3];</code> aufrufen, wird durch diesen Aufruf
folgender Code generiert:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>Wir haben ein Makro definiert, das eine beliebige Anzahl von Argumenten
beliebigen Typs aufnehmen und Code zur Erstellung eines Vektors erzeugen
kann, der die angegebenen Elemente enthält.</p>
<p>Um mehr darüber zu erfahren, wie man Makros schreibt, konsultiere die
Online-Dokumentation oder andere Ressourcen, wie zum Beispiel <a href="https://veykril.github.io/tlborm/">„The Little Book
of Rust Macros“</a> (engl. „Das kleine Buch der Rust-Makros“).</p>
<h3 id="prozedurale-makros-zur-code-generierung-aus-attributen"><a class="header" href="#prozedurale-makros-zur-code-generierung-aus-attributen">Prozedurale Makros zur Code-Generierung aus Attributen</a></h3>
<p>Die zweite Form von Makros ist das <em>prozedurale Makro</em>, das sich eher wie eine
Funktion verhält (und eine Art Prozedur ist). <em>Prozedurale Makros</em> akzeptieren
etwas Code als Eingabe, operieren mit diesem Code und erzeugen etwas Code als
Ausgabe, anstatt gegen Muster abzugleichen und den Code durch anderen Code zu
ersetzen, wie es deklarative Makros tun. Die drei Arten von prozeduralen Makros
(benutzerdefinierte <code>derive</code>-Makros, Attribut-ähnliche und Funktions-ähnliche)
arbeiten alle auf ähnliche Weise.</p>
<p>Beim Erstellen von prozeduralen Makros müssen sich die Definitionen in einer
eigenen Kiste mit einem speziellen Kistentyp befinden. Dies geschieht aus
komplexen technischen Gründen, die wir hoffentlich in Zukunft eliminieren
werden. In Codeblock 20-36 zeigen wir, wie man ein prozedurales Makro
definiert, wobei <code>some_attribute</code> ein Platzhalter für die Verwendung einer
bestimmten Makro-Variante ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<p><span class="caption">Codeblock 20-36: Beispiel für die Definition eines
prozeduralen Makros</span></p>
<p>Die Funktion, die ein prozedurales Makro definiert, nimmt einen <code>TokenStream</code>
als Eingabe und erzeugt einen <code>TokenStream</code> als Ausgabe. Der Typ <code>TokenStream</code>
wird durch die Kiste <code>proc_macro</code> definiert, die in Rust enthalten ist und eine
Folge von Token darstellt. Dies ist der Kern des Makros: Der Quellcode, mit dem
das Makro arbeitet, bildet die Eingabe <code>TokenStream</code>, und der Code, den das
Makro erzeugt, ist die Ausgabe <code>TokenStream</code>. Die Funktion hat auch ein
Attribut, das angibt, welche Art prozedurales Makro wir erstellen. Wir können
mehrere Arten prozeduraler Makros in derselben Kiste haben.</p>
<p>Schauen wir uns die verschiedenen Arten prozeduraler Makros an. Wir beginnen
mit einem benutzerdefinierten <code>derive</code>-Makro und erklären dann die kleinen
Unterschiede, in denen sich die anderen Formen unterscheiden.</p>
<h3 id="wie-man-ein-benutzerdefiniertes-makro-mit-derive-schreibt"><a class="header" href="#wie-man-ein-benutzerdefiniertes-makro-mit-derive-schreibt">Wie man ein benutzerdefiniertes Makro mit <code>derive</code> schreibt</a></h3>
<p>Lass uns eine Kiste namens <code>hello_macro</code> erstellen, die ein Merkmal namens
<code>HelloMacro</code> mit einer assoziierten Funktion namens <code>hello_macro</code> definiert.
Anstatt unsere Benutzer dazu zu bringen, das Merkmal <code>HelloMacro</code> für jeden
ihrer Typen zu implementieren, werden wir ein prozedurales Makro zur Verfügung
stellen, damit die Benutzer ihren Typ mit <code>#[derive(HelloMacro)]</code> annotieren
können, um eine Standardimplementierung der Funktion <code>hello_macro</code> zu erhalten.
Die Standardimplementierung gibt <code>Hallo Makro! Mein Name ist TypeName!</code> aus,
wobei <code>TypeName</code> der Name des Typs ist, auf dem dieses Merkmal definiert wurde.
Mit anderen Worten, wir werden eine Kiste schreiben, die es einem anderen
Programmierer ermöglicht, mit unserer Kiste Code wie Codeblock 20-37 zu
schreiben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p><span class="caption">Codeblock 20-37: Code, den ein Benutzer unserer Kiste
schreiben kann, wenn er unser prozedurales Makro benutzt</span></p>
<p>Dieser Code gibt <code>Hallo Makro! Mein Name ist Pancakes!</code> aus, wenn wir fertig
sind. Der erste Schritt ist das Erstellen einer neuen Bibliothekskiste (library
crate), etwa so:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Als Nächstes definieren wir das Merkmal <code>HelloMacro</code> und die damit assoziierte
Funktion:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-38: Ein einfaches Merkmal, das wir mit dem
Makro <code>derive</code> verwenden werden</span></p>
<p>Wir haben ein Merkmal und seine Funktion. An diesem Punkt könnte unser
Kistenbenutzer das Merkmal so implementieren, dass die gewünschte
Funktionalität erreicht wird, wie in Codeblock 20-39.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hallo Makro! Mein Name ist Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p><span class="caption">Codeblock 20-39: Wie es aussehen würde, wenn Benutzer
eine manuelle Implementierung des Merkmals <code>HelloMacro</code> schreiben würden</span></p>
<p>Allerdings müssten sie den Implementierungsblock für jeden Typ, den sie mit
<code>hello_macro</code> verwenden wollten, schreiben; wir wollen ihnen diese Arbeit
ersparen.</p>
<p>Außerdem können wir die Funktion <code>hello_macro</code> noch nicht mit einer
Standardimplementierung versehen, die den Namen des Typs ausgibt, auf dem das
Merkmal implementiert ist: Rust hat keine Reflektionsfähigkeiten, sodass es den
Namen des Typs zur Laufzeit nicht nachschlagen kann. Wir benötigen ein Makro,
um zur Kompilierzeit Code zu generieren.</p>
<p>Der nächste Schritt ist das Definieren des prozeduralen Makros. Zum Zeitpunkt
der Abfassung dieses Dokuments müssen sich die prozeduralen Makros in einer
eigenen Kiste befinden. Irgendwann könnte diese Einschränkung aufgehoben
werden. Die Konvention für die Strukturierung von Kisten und Makrokisten lautet
wie folgt: Für eine Kiste mit dem Namen <code>foo</code> wird eine prozedurale Makrokiste
mit einem benutzerdefinierten <code>derive</code>-Makro als <code>foo_derive</code> bezeichnet.
Beginnen wir eine neue Kiste mit dem Namen <code>hello_macro_derive</code> innerhalb
unseres <code>hello_macro</code>-Projekts:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Unsere beiden Kisten sind eng miteinander verwandt, daher erstellen wir die
prozedurale Makrokiste innerhalb des Verzeichnisses unserer Kiste
<code>hello_macro</code>. Wenn wir die Merkmalsdefinition in <code>hello_macro</code> ändern, müssen
wir auch die Implementierung des prozeduralen Makros in <code>hello_macro_derive</code>
ändern. Die beiden Kisten müssen getrennt veröffentlicht werden und
Programmierer, die diese Kisten verwenden, müssen beide als Abhängigkeiten
hinzufügen und beide in den Gültigkeitsbereich bringen. Wir könnten stattdessen
die Kiste <code>hello_macro</code> als Abhängigkeit <code>hello_macro_derive</code> verwenden lassen
und den prozeduralen Makrocode erneut exportieren. Wie auch immer, die Art und
Weise, wie wir das Projekt strukturiert haben, ermöglicht es den
Programmierern, <code>hello_macro</code>  zu benutzen, selbst wenn sie die
<code>derive</code>-Funktionalität nicht wollen.</p>
<p>Wir müssen die Kiste <code>hello_macro_derive</code> als prozedurale Makro-Kiste
deklarieren. Wie du gleich sehen wirst, benötigen wir auch Funktionalität von
den Kisten <code>syn</code> und <code>quote</code>, also müssen wir sie als Abhängigkeiten angeben.
Füge das Folgende zur Datei <em>Cargo.toml</em> für <code>hello_macro_derive</code> hinzu:</p>
<p><span class="filename">Dateiname: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
</code></pre>
<p>Um mit der Definition des prozeduralen Makros zu beginnen, platziere den Code
in Codeblock 20-40 in deine Datei <em>src/lib.rs</em> der Kiste <code>hello_macro_derive</code>.
Beachte, dass dieser Code nicht kompiliert werden kann, bis wir eine Definition
für die Funktion <code>impl_hello_macro</code> hinzufügen.</p>
<p><span class="filename">Dateiname: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Konstruiere eine Repräsentation des Rust-Codes als Syntaxbaum,
    // den wir manipulieren können
    let ast = syn::parse(input).unwrap();

    // Baue die Merkmal-Implementierung
    impl_hello_macro(&amp;ast)
}</code></pre>
<p><span class="caption">Codeblock 20-40: Code, den die meisten prozeduralen
Makrokisten benötigen, um Rust-Code zu verarbeiten</span></p>
<p>Beachte, dass wir den Code aufgeteilt haben in die Funktion
<code>hello_macro_derive</code>, die für das Parsen des <code>TokenStream</code> verantwortlich ist,
und die Funktion <code>impl_hello_macro</code>, die für die Transformation des Syntaxbaums
verantwortlich ist: Dies macht das Schreiben eines prozeduralen Makros
bequemer. Der Code in der äußeren Funktion (in diesem Fall
<code>hello_macro_derive</code>) wird für fast jede prozedurale Makro-Kiste, die du siehst
oder erstellst, derselbe sein. Der Code, den du im Rumpf der inneren Funktion
(in diesem Fall <code>impl_hello_macro</code>) angibst, wird je nach Zweck deines
prozeduralen Makros unterschiedlich sein.</p>
<p>Wir haben drei neue Kisten eingeführt: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a> und
<a href="https://crates.io/crates/quote"><code>quote</code></a>. Die Kiste <code>proc_macro</code> kommt mit Rust, sodass wir das
nicht zu den Abhängigkeiten in <em>Cargo.toml</em> hinzufügen mussten. Die Kiste
<code>proc_macro</code> ist die API des Compilers, die es uns erlaubt, den Rust-Code aus
unserem Code zu lesen und zu manipulieren.</p>
<p>Die Kiste <code>syn</code> parst den Rust-Code von einer Zeichenkette in eine
Datenstruktur, auf der wir Operationen durchführen können. Die Kiste <code>quote</code>
wandelt <code>syn</code>-Datenstrukturen wieder in Rust-Code um. Diese Kisten machen es
viel einfacher, jede Art von Rust-Code zu parsen, den wir vielleicht
verarbeiten wollen: Einen vollständigen Parser für Rust-Code zu schreiben, ist
keine einfache Aufgabe.</p>
<p>Die Funktion <code>hello_macro_derive</code> wird aufgerufen, wenn ein Benutzer unserer
Bibliothek <code>#[derive(HelloMacro)]</code> an einen Typ spezifiziert. Dies ist möglich,
weil wir die Funktion <code>hello_macro_derive</code> hier mit <code>proc_macro_derive</code>
annotiert und den Namen <code>HelloMacro</code> angegeben haben, der unserem Merkmalsnamen
entspricht; dies ist die Konvention, der die meisten prozeduralen Makros
folgen.</p>
<p>Die Funktion <code>hello_macro_derive</code> wandelt zunächst <code>input</code> aus einem
<code>TokenStream</code> in eine Datenstruktur um, die wir dann interpretieren und
Operationen darauf ausführen können. Hier kommt <code>syn</code> ins Spiel. Die Funktion
<code>parse</code> in <code>syn</code> nimmt einen <code>TokenStream</code> und gibt eine <code>DeriveInput</code>-Struktur
zurück, die den geparsten Rust-Code repräsentiert. Codeblock 20-41 zeigt die
relevanten Teile der Struktur <code>DeriveInput</code>, die wir vom Parsen der
Zeichenkette <code>struct Pancakes;</code> erhalten:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --abschneiden--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<p><span class="caption">Codeblock 20-41: Die <code>DeriveInput</code>-Instanz erhalten wir
beim Parsen des Codes, den das Attribut des Makros in Codeblock 20-37
hat</span></p>
<p>Die Felder dieser Struktur zeigen, dass der Rust-Code, den wir geparst haben,
eine Einheitsstruktur (unit struct) mit dem <code>ident</code> (<em>identifier</em>, engl.
Bezeichner, d.h. dem Namen) von <code>Pancakes</code> ist. Es gibt weitere Felder in
dieser Struktur zur Beschreibung aller Arten von Rust-Code; weitere
Informationen findest du in der <a href="https://docs.rs/syn/2.0/syn/struct.DeriveInput.html"><code>syn</code>-Dokumentation für
<code>DeriveInput</code></a>.</p>
<p>Bald werden wir die Funktion <code>impl_hello_macro</code> definieren, wo wir den neuen
Rust-Code bauen werden, den wir einbinden wollen. Aber bevor wir das tun,
beachte, dass die Ausgabe für unser <code>derive</code>-Makro ebenfalls ein <code>TokenStream</code>
ist. Der zurückgegebene <code>TokenStream</code> wird dem Code hinzugefügt, den unsere
Kisten-Benutzer schreiben. Wenn sie also ihre Kiste kompilieren, erhalten sie
die zusätzliche Funktionalität, die wir im modifizierten <code>TokenStream</code> zur
Verfügung stellen.</p>
<p>Du hast vielleicht bemerkt, dass wir <code>unwrap</code> aufrufen, um die Funktion
<code>hello_macro_derive</code> abstürzen zu lassen, wenn der Aufruf der Funktion
<code>syn::parse</code> hier fehlschlägt. Es ist notwendig, dass unser prozedurales Makro
bei Fehlern abstürzt, weil <code>proc_macro_derive</code>-Funktionen einen <code>TokenStream</code>
zurückgeben müssen, kein <code>Result</code>, um mit der prozeduralen Makro-API konform zu
sein. Wir haben dieses Beispiel vereinfacht, indem wir <code>unwrap</code> verwendet
haben; in Produktionscode solltest du spezifischere Fehlermeldungen darüber
angeben, was schief gelaufen ist, indem du <code>panic!</code> oder <code>expect</code> verwendest.</p>
<p>Da wir nun den Code haben, um den annotierten Rust-Code aus einem <code>TokenStream</code>
in eine <code>DeriveInput</code>-Instanz zu verwandeln, lass uns den Code generieren, der
das Merkmal <code>HelloMacro</code> auf dem annotierten Typ implementiert, wie in
Codeblock 20-42 gezeigt.</p>
<p><span class="filename">Dateiname: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">extern crate proc_macro;
</span><span class="boring">
</span><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Konstruiere eine Repräsentation des Rust-Codes als Syntaxbaum,
</span><span class="boring">    // den wir manipulieren können
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Baue die Merkmal-Implementierung
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hallo Makro! Mein Name ist {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}</code></pre>
<p><span class="caption">Codeblock 20-42: Implementierung des Merkmals
<code>HelloMacro</code> unter Verwendung des geparsten Rust-Codes</span></p>
<p>Wir erhalten eine <code>Ident</code>-Strukturinstanz, die den Namen (Bezeichner) des
annotierten Typs enthält, indem wir <code>ast.ident</code> verwenden. Die Struktur in
Codeblock 20-33 zeigt, dass, wenn wir die Funktion <code>impl_hello_macro</code> auf den
Code in Codeblock 20-31 anwenden, das erhaltene <code>ident</code> ein Feld <code>ident</code> mit
dem Wert <code>"Pancakes"</code> enthält. So wird die Variable <code>name</code> in Codeblock 20-34
eine Instanz der Struktur <code>Ident</code> enthalten, die die Zeichenkette <code>"Pancakes"</code>
ausgibt, der Name der Struktur in Codeblock 20-37.</p>
<p>Mit dem Makro <code>quote!</code> können wir den Rust-Code definieren, den wir zurückgeben
wollen. Der Compiler erwartet etwas anderes als das direkte Ergebnis der
Ausführung des <code>quote!</code>-Makros, also müssen wir es in einen <code>TokenStream</code>
konvertieren. Wir tun dies, indem wir die Methode <code>into</code> aufrufen, die diese
Zwischendarstellung konsumiert und einen Wert des erforderlichen Typs
<code>TokenStream</code> zurückgibt.</p>
<p>Das Makro <code>quote!</code> bietet auch einige sehr coole Vorlage-Mechanismen: Wir
können <code>#name</code> eingeben und <code>quote!</code> wird es durch den Wert in der Variablen
<code>name</code> ersetzen. Du kannst sogar einige Wiederholungen machen, ähnlich wie
normale Makros funktionieren. Schaue dir die <a href="https://docs.rs/quote">Dokumentation der Kiste
<code>quote!</code></a> für eine gründliche Einführung an.</p>
<p>Wir wollen, dass unser prozedurales Makro eine Implementierung unseres Merkmals
<code>HelloMacro</code> für den Typ, den der Benutzer annotiert hat, erzeugt, die wir mit
<code>#name</code> erhalten können. Die Merkmalssimplementierung hat eine Funktion
<code>hello_macro</code>, deren Rumpf die Funktionalität enthält, die wir zur Verfügung
stellen wollen: Ausgeben von <code>Hallo Makro! Mein Name ist</code> und dann der Name des
annotierten Typs.</p>
<p>Das hier verwendete Makro <code>stringify!</code> ist in Rust eingebaut. Es nimmt einen
Rust-Ausdruck, z.B. <code>1 + 2</code>, und verwandelt diesen zur Kompilierzeit in ein
Zeichenketten-Literal, z.B. <code>"1 + 2"</code>. Dies unterscheidet sich von <code>format!</code>
oder <code>println!</code>; Makros, die den Ausdruck auswerten und dann das Ergebnis in
einen <code>String</code> umwandeln. Es besteht die Möglichkeit, dass die Eingabe <code>#Name</code>
ein Ausdruck ist, der literal auszugeben ist, also verwenden wir <code>stringify!</code>.
Die Verwendung von <code>stringify!</code> erspart zudem eine Speicherzuweisung, indem
<code>#name</code> zur Kompilierzeit in ein Zeichenketten-Literal umgewandelt wird.</p>
<p>An diesem Punkt sollte <code>cargo build</code> sowohl bei <code>hello_macro</code> als auch bei
<code>hello_macro_derive</code> erfolgreich durchlaufen. Schließen wir diese Kisten an den
Code in Codeblock 20-31 an, um das prozedurale Makro in Aktion zu sehen!
Erstelle ein neues Binärprojekt in deinem <em>projects</em>-Verzeichnis durch Aufrufen
von <code>cargo new pancakes</code>. Wir müssen <code>hello_macro</code> und <code>hello_macro_derive</code> als
Abhängigkeiten in der Datei <em>Cargo.toml</em> der Kiste <code>pancakes</code> hinzufügen. Wenn
du deine Versionen von <code>hello_macro</code> und <code>hello_macro_derive</code> in
<a href="https://crates.io/">crates.io</a> veröffentlichst, wären das reguläre Abhängigkeiten; wenn
nicht, kannst du sie wie folgt als <code>path</code>-Abhängigkeiten angeben:</p>
<pre><code class="language-toml">hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
</code></pre>
<p>Gib den Code in Codeblock 20-37 in <em>src/main.rs</em> ein und rufe <code>cargo run</code> auf:
Es sollte <code>Hallo Makro! Mein Name ist Pancakes!</code> ausgeben. Die Implementierung
des Merkmals <code>HelloMacro</code> aus dem prozeduralen Makro wurde eingefügt, ohne dass
die Kiste <code>pancakes</code> es implementieren musste; <code>#[derive(HelloMacro)]</code> fügte
die Merkmalsimplementierung hinzu.</p>
<p>Als Nächstes wollen wir untersuchen, inwiefern sich die anderen Arten
prozeduraler Makros von den benutzerdefinierten derive-Makros unterscheiden.</p>
<h3 id="attribut-ähnliche-makros"><a class="header" href="#attribut-ähnliche-makros">Attribut-ähnliche Makros</a></h3>
<p>Attribut-ähnliche Makros ähneln den benutzerdefinierten derive-Makros, aber
anstatt Code für das <code>derive</code>-Attribut zu generieren, erlauben sie dir, neue
Attribute zu erstellen. Sie sind auch flexibler: <code>derive</code> funktioniert nur bei
Strukturen und Aufzählungen; Attribute können auch auf andere Elemente, z.B.
Funktionen, angewendet werden. Hier ist ein Beispiel für die Verwendung eines
Attribut-ähnlichen Makros. Nehmen wir an, du hast ein Attribut namens <code>route</code>,
das Funktionen annotiert, wenn du ein Webapplikations-Framework verwendest:</p>
<pre><code class="language-rust ignore">#[route(GET, "/")]
fn index() {</code></pre>
<p>Dieses Attribut <code>#[route]</code> würde durch das Framework als prozedurales Makro
definiert werden. Die Signatur der Makrodefinitionsfunktion würde wie folgt
aussehen:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Hier haben wir zwei Parameter vom Typ <code>TokenStream</code>. Der erste ist für die
Inhalte <code>GET, "/"</code> des Attributs. Der zweite ist für den Rumpf des Elements, an
den das Attribut angehängt ist: In diesem Fall <code>fn index() {}</code> und der Rest des
Funktionsrumpfs.</p>
<p>Abgesehen davon funktionieren Attribut-ähnliche Makros auf die gleiche Weise
wie benutzerdefinierte <code>derive</code>-Makros: Sie erstellen eine Kiste mit dem
Kistentyp <code>proc-macro</code> und implementieren eine Funktion, die den gewünschten
Code generiert!</p>
<h3 id="funktions-ähnliche-makros"><a class="header" href="#funktions-ähnliche-makros">Funktions-ähnliche Makros</a></h3>
<p>Funktions-ähnliche Makros definieren Makros, die wie Funktionsaufrufe aussehen.
Ähnlich wie <code>macro_rules!</code>-Makros sind sie flexibler als Funktionen; sie können
zum Beispiel eine unbekannte Anzahl von Argumenten aufnehmen. Makros können
jedoch nur mit der <code>match</code>-ähnlichen Syntax definiert werden, die wir in
<a href="ch20-05-macros.html#deklarative-makros-mit-macro_rules-f%C3%BCr-allgemeine-metaprogrammierung">„Deklarative Makros mit <code>macro_rules!</code> für allgemeine
Metaprogrammierung“</a> besprochen haben. Funktions-ähnliche Makros nehmen
einen <code>TokenStream</code>-Parameter und ihre Definition manipuliert diesen
<code>TokenStream</code> unter Verwendung von Rust-Code, wie es die beiden anderen Arten
prozeduraler Makros tun. Ein Beispiel für ein Funktions-ähnliches Makro ist ein
Makro <code>sql!</code>, das auf diese Weise aufgerufen werden könnte:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>Dieses Makro würde die darin enthaltene SQL-Anweisung parsen und prüfen, ob sie
syntaktisch korrekt ist, was eine viel komplexere Verarbeitung ist, als es ein
<code>macro_rules!</code>-Makro tun kann. Das Makro <code>sql!</code> würde wie folgt definiert
werden:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>Diese Definition ähnelt der Signatur des benutzerdefinierten <code>derive</code>-Makros:
Wir erhalten die Token, die sich innerhalb der Klammern befinden, und geben den
Code zurück, den wir generieren wollen.</p>
<h2 id="zusammenfassung-19"><a class="header" href="#zusammenfassung-19">Zusammenfassung</a></h2>
<p>Puh! Jetzt hast du einige Rust-Funktionalitäten in deinem Werkzeugkasten, die
du nicht oft verwenden wirst, aber du wirst wissen, dass sie unter ganz
bestimmten Umständen verfügbar sind. Wir haben mehrere komplexe Themen
eingeführt, sodass du diese Konzepte und Syntax erkennen kannst, wenn du ihnen
in Vorschlägen für Fehlermeldungen oder im Code anderer Leute begegnest.
Verwende dieses Kapitel als Referenz, um Lösungen zu finden.</p>
<p>Als Nächstes werden wir alles, was wir im Laufe des Buches besprochen haben, in
die Praxis umsetzen und ein weiteres Projekt durchführen!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abschlussprojekt-einen-mehrsträngigen-multi-threaded-webserver-erstellen"><a class="header" href="#abschlussprojekt-einen-mehrsträngigen-multi-threaded-webserver-erstellen">Abschlussprojekt: Einen mehrsträngigen (multi-threaded) Webserver erstellen</a></h1>
<p>Es war eine lange Reise, aber wir haben das Ende des Buches erreicht. In diesem
Kapitel werden wir gemeinsam ein weiteres Projekt aufbauen, um einige der
Konzepte zu demonstrieren, die wir in den letzten Kapiteln behandelt haben, und
einige frühere Lektionen zusammenfassen.</p>
<p>Für unser Abschlussprojekt werden wir einen Webserver erstellen, der „Hallo“
sagt und in einem Webbrowser wie Abbildung 21-1 aussieht.</p>
<p><img src="img/trpl21-01.png" alt="Hallo von Rust" /></p>
<p><span class="caption">Abbildung 21-1: Unser letztes gemeinsames Projekt</span></p>
<p>Hier ist unser Plan zum Bauen des Webservers:</p>
<ol>
<li>Lerne ein wenig über TCP und HTTP.</li>
<li>Lausche auf TCP-Verbindungen an einem Netzwerkknoten (socket).</li>
<li>Parse eine kleine Anzahl von HTTP-Anfragen.</li>
<li>Erstelle eine korrekte HTTP-Antwort.</li>
<li>Verbessere den Durchsatz unseres Servers mit einem Strang-Vorrat (thread
pool).</li>
</ol>
<p>Bevor wir anfangen, sollten wir ein Detail erwähnen. Die Methode, die wir
verwenden werden, wird nicht der beste Weg sein, einen Webserver mit Rust zu
bauen. Gemeinschaftsmitglieder haben eine Reihe von produktionsreifen Kisten
auf <a href="https://crates.io/">crates.io</a> veröffentlicht, die umfassendere Webserver- und
Strang-Vorrats-Implementierungen bereitstellen, als wir sie bauen werden.
Unsere Absicht in diesem Kapitel ist es jedoch, dir beim Lernen zu helfen, und
nicht, den einfachen Weg zu gehen. Da es sich bei Rust um eine
Systemprogrammiersprache handelt, können wir die Abstraktionsebene wählen, mit
der wir arbeiten wollen, und können auf eine niedrigere Ebene gehen, als dies
in anderen Sprachen möglich oder zweckmäßig ist. Wir werden daher den
grundlegenden HTTP-Server und den Strang-Vorrat manuell schreiben, damit du die
allgemeinen Ideen und Techniken hinter den Kisten lernst, die du in Zukunft
verwenden kannst.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="einen-einsträngigen-single-threaded-webserver-erstellen"><a class="header" href="#einen-einsträngigen-single-threaded-webserver-erstellen">Einen einsträngigen (single-threaded) Webserver erstellen</a></h2>
<p>Wir beginnen damit, einen einsträngigen Webserver zum Laufen zu bringen. Bevor
wir beginnen, wollen wir uns einen kurzen Überblick über die Protokolle
verschaffen, die beim Aufbau von Webservern eine Rolle spielen. Die
Einzelheiten dieser Protokolle sprengen den Rahmen dieses Buches, aber ein
kurzer Überblick wird dir die Informationen geben, die du benötigst.</p>
<p>Die beiden wichtigsten Protokolle, die bei Webservern zum Einsatz kommen, sind
das <em>Hypertext-Übertragungsprotokoll</em> (Hypertext Transfer Protocol, kurz
<em>HTTP</em>) und das <em>Übertragungssteuerungsprotokoll</em> (Transmission Control
Protocol, kurz <em>TCP</em>). Beide Protokolle sind <em>Anfrage-Antwort-Protokolle</em>, d.h.
ein <em>Client</em> initiiert Anfragen und ein <em>Server</em> hört auf die Anfragen und gibt
eine Antwort an den Client. Der Inhalt dieser Anfragen und Antworten wird durch
die Protokolle definiert.</p>
<p>TCP ist das Protokoll der untergeordneten Ebene, das im Detail beschreibt, wie
Informationen von einem Server zu einem anderen gelangen, aber nicht
spezifiziert, um welche Informationen es sich dabei handelt. HTTP baut auf TCP
auf, indem es den Inhalt der Anfragen und Antworten definiert. Es ist technisch
möglich, HTTP mit anderen Protokollen zu verwenden, aber in den allermeisten
Fällen sendet HTTP seine Daten über TCP. Wir werden mit den Roh-Bytes von TCP-
und HTTP-Anfragen und -Antworten arbeiten.</p>
<h3 id="lauschen-auf-eine-tcp-verbindung"><a class="header" href="#lauschen-auf-eine-tcp-verbindung">Lauschen auf eine TCP-Verbindung</a></h3>
<p>Unser Webserver muss auf eine TCP-Verbindung lauschen (listen), also ist das
der erste Teil, an dem wir arbeiten werden. Die Standardbibliothek bietet ein
Modul <code>std::net</code> an, mit dem wir dies tun können. Lass uns ein neues Projekt
auf die übliche Art und Weise erstellen:</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Gib nun den Code in Codeblock 21-1 in <em>src/main.rs</em> ein, um zu beginnen. Dieser
Code lauscht unter der lokalen Adresse <code>127.0.0.1:7878</code> auf eingehende
TCP-Ströme (TCP streams). Wenn er einen eingehenden Strom erhält, wird er
<code>Verbindung hergestellt!</code> ausgeben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run edition2024">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Verbindung hergestellt!");
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 21-1: Warten auf eingehende Ströme und Ausgeben
einer Nachricht, wenn wir einen Strom empfangen</span></p>
<p>Mit <code>TcpListener</code> können wir unter der Adresse <code>127.0.0.1:7878</code> auf
TCP-Verbindungen warten. In der Adresse ist der Abschnitt vor dem Doppelpunkt
eine IP-Adresse, die deinen Computer repräsentiert (dies ist auf jedem Computer
gleich und gilt nicht nur speziell für den Computer der Autoren), und <code>7878</code>
ist der Port. Wir haben diesen Port aus zwei Gründen gewählt: HTTP wird auf
diesem Port normalerweise nicht akzeptiert, sodass unser Server wahrscheinlich
nicht mit anderen Webservern in Konflikt geraten wird, die du auf deinem
Rechner hast, und 7878 steht für <em>rust</em>, wenn du es auf einem Telefon tippst.</p>
<p>Die Funktion <code>bind</code> in diesem Szenario arbeitet wie die Funktion <code>new</code>, indem
sie eine neue <code>TcpListener</code>-Instanz zurückgibt. Die Funktion wird <code>bind</code>
genannt, weil in Netzwerken das Verbinden mit einem Port zum Lauschen als
„Binden (binding) an einen Port“ bezeichnet wird.</p>
<p>Die Funktion <code>bind</code> gibt ein <code>Result&lt;T, E&gt;</code> zurück, was anzeigt, dass es
möglich ist, dass das Binden fehlschlagen könnte. Zum Beispiel erfordert das
Binden an Port 80 Administrator-Rechte (Nicht-Administratoren können nur auf
Ports größer als 1023 lauschen). Wenn wir also versuchen würden, an Port 80 zu
lauschen, ohne Administrator zu sein, würde das Binden nicht funktionieren. Das
Binden wäre beispielsweise auch nicht möglich, wenn wir zwei Instanzen unseres
Programms laufen lassen und somit zwei Programme auf dem gleichen Port lauschen
würden. Da wir einen einfachen Server nur für Lernzwecke schreiben, werden wir
uns nicht um die Behandlung dieser Art von Fehlern kümmern; stattdessen
verwenden wir <code>unwrap</code>, um das Programm zu stoppen, wenn Fehler auftreten.</p>
<p>Die Methode <code>incoming</code> von <code>TcpListener</code> gibt einen Iterator zurück, der uns
eine Sequenz von Strömen (genauer gesagt Ströme vom Typ <code>TcpStream</code>) liefert.
Ein einzelner <em>Strom</em> (stream) stellt eine offene Verbindung zwischen dem
Client und dem Server dar. Eine <em>Verbindung</em> (connection) ist der Name für den
vollständigen Anfrage- und Antwortprozess, bei dem sich ein Client mit dem
Server verbindet, der Server eine Antwort erzeugt und der Server die Verbindung
schließt. Daher werden wir aus dem <code>TcpStream</code> lesen, um zu sehen, was der
Client gesendet hat, und dann unsere Antwort in den Strom schreiben, um Daten
zurück an den Client zu senden. Insgesamt wird diese <code>for</code>-Schleife jede
Verbindung der Reihe nach verarbeiten und eine Reihe von Strömen erzeugen, die
wir verarbeiten müssen.</p>
<p>Im Moment besteht unsere Behandlung des Stroms darin, dass wir <code>unwrap</code>
aufrufen, um unser Programm zu beenden, wenn der Strom Fehler aufweist; wenn
keine Fehler vorliegen, gibt das Programm eine Nachricht aus. Wir werden im
nächsten Codeblock mehr Funktionalität für den Erfolgsfall hinzufügen. Der
Grund, warum wir Fehler von der Methode <code>incoming</code> erhalten könnten, wenn sich
ein Client mit dem Server verbindet, ist, dass wir nicht wirklich über
Verbindungen iterieren. Stattdessen iterieren wir über <em>Verbindungsversuche</em>.
Die Verbindung kann aus einer Reihe von Gründen nicht erfolgreich sein, viele
davon sind betriebssystemspezifisch. Zum Beispiel haben viele Betriebssysteme
ein Limit für die Anzahl der gleichzeitig offenen Verbindungen, die sie
unterstützen können; neue Verbindungsversuche über diese Anzahl hinaus führen
zu einem Fehler, bis einige der offenen Verbindungen geschlossen werden.</p>
<p>Lass uns versuchen, diesen Code auszuführen! Rufe <code>cargo run</code> im Terminal auf
und öffne dann <em>127.0.0.1:7878</em> in einem Web-Browser. Der Browser sollte eine
Fehlermeldung wie „Verbindung abgebrochen“ anzeigen, da der Server derzeit
keine Daten zurücksendet. Aber wenn du auf dein Terminal siehst, solltest du
mehrere Meldungen sehen, die ausgegeben wurden, als der Browser eine Verbindung
mit dem Server herstellte!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Verbindung hergestellt!
Verbindung hergestellt!
Verbindung hergestellt!
</code></pre>
<p>Manchmal werden mehrere Nachrichten für eine Browser-Anfrage ausgegeben; der
Grund dafür könnte sein, dass der Browser sowohl eine Anfrage für die Seite als
auch eine Anfrage für andere Ressourcen stellt, z.B. das Symbol <em>favicon.ico</em>,
das in der Browser-Registerkarte erscheint.</p>
<p>Es könnte auch sein, dass der Browser mehrmals versucht, eine Verbindung mit
dem Server herzustellen, weil der Server nicht mit Daten antwortet. Wenn
<code>stream</code> den Gültigkeitsbereich verlässt und am Ende der Schleife aufgeräumt
wird, wird die Verbindung als Teil der <code>drop</code>-Implementierung geschlossen.
Browser reagieren auf geschlossene Verbindungen manchmal damit, es erneut zu
versuchen, weil das Problem möglicherweise nur vorübergehend ist. Der wichtige
Punkt ist, dass wir erfolgreich eine TCP-Verbindung hergestellt haben!</p>
<p>Denke daran, das Programm durch Drücken von <kbd>Strg</kbd>+<kbd>c</kbd> zu
beenden, wenn du mit der Ausführung einer bestimmten Version des Codes fertig
bist. Starte dann das Programm neu, indem du den Befehl <code>cargo run</code> aufrufst,
nachdem du die einzelnen Codeänderungen vorgenommen hast, um sicherzustellen,
dass du den neuesten Code ausführst.</p>
<h3 id="lesen-der-anfrage"><a class="header" href="#lesen-der-anfrage">Lesen der Anfrage</a></h3>
<p>Lass uns die Funktionalität zum Lesen der Anfrage vom Browser implementieren!
Um die Zuständigkeiten zu trennen, also zuerst eine Verbindung entgegenzunehmen
und dann mit der Verbindung etwas zu machen, werden wir eine neue Funktion zur
Verarbeitung von Verbindungen anfangen. In dieser neuen Funktion
<code>handle_connection</code> lesen wir Daten aus dem TCP-Strom und geben sie aus, sodass
wir sehen können, welche Daten vom Browser gesendet werden. Ändere den Code so,
dass er wie Codeblock 21-2 aussieht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run edition2024">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("Request: {http_request:#?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 21-2: Lesen aus dem <code>TcpStream</code> und Ausgeben
der Daten</span></p>
<p>Wir bringen <code>std::io::prelude</code> und <code>std::io::BufReader</code> in den
Gültigkeitsbereich, um Zugang zu Merkmalen (traits) und Typen zu erhalten, die
es uns ermöglichen, aus dem Strom zu lesen und in den Strom zu schreiben. In
der <code>for</code>-Schleife in der Funktion <code>main</code> rufen wir jetzt, statt eine Nachricht
auszugeben, dass wir eine Verbindung hergestellt haben, die neue Funktion
<code>handle_connection</code> auf und übergeben ihr den <code>stream</code>.</p>
<p>In der Funktion <code>handle_connection</code> erstellen wir eine neue
<code>BufReader</code>-Instanz, die eine Referenz auf den <code>stream</code> enthält. <code>BufReader</code>
sorgt für die Pufferung, indem es die Aufrufe der Merkmals-Methoden von
<code>std::io::Read</code> für uns verwaltet.</p>
<p>Wir erstellen eine Variable namens <code>http_request</code>, um die Zeilen der Anfrage zu
aufzusammeln, die der Browser an unseren Server sendet. Wir geben an, dass wir
diese Zeilen in einem Vektor sammeln wollen, indem wir die Typ-Annotation
<code>Vec&lt;_&gt;</code> hinzufügen.</p>
<p><code>BufReader</code> implementiert das Merkmal <code>std::io::BufRead</code>, das die Methode
<code>lines</code> bereitstellt. Die Methode <code>lines</code> gibt einen Iterator von
<code>Result&lt;String, std::io::Error&gt;</code> zurück, indem sie den Datenstrom immer dann
aufteilt, wenn sie ein Neue-Zeile-Byte sieht. Um jeden <code>String</code> zu erhalten,
wird jedes <code>Result</code> abgebildet und <code>unwrap</code> aufgerufen. Das <code>Result</code> könnte
einen Fehler darstellen, wenn die Daten kein gültiges UTF-8 sind oder wenn es
ein Problem beim Lesen aus dem Strom gab. Auch hier sollte ein
Produktivprogramm diese Fehler besser behandeln, aber der Einfachheit halber
brechen wir das Programm im Fehlerfall ab.</p>
<p>Der Browser signalisiert das Ende einer HTTP-Anfrage, indem er zwei
Zeilenumbrüche hintereinander sendet. Um also eine Anfrage aus dem Strom zu
erhalten, nehmen wir so lange Zeilen an, bis wir eine leere Zeile erhalten.
Sobald wir die Zeilen im Vektor gesammelt haben, geben wir sie mit einer
hübschen Debug-Formatierung aus, damit wir einen Blick auf die Anweisungen
werfen können, die der Webbrowser an unseren Server sendet.</p>
<p>Lass uns diesen Code ausprobieren! Starte das Programm und stelle erneut eine
Anfrage in einem Webbrowser. Beachte, dass wir immer noch eine Fehlerseite im
Browser erhalten, aber die Ausgabe unseres Programms im Terminal wird nun
ähnlich aussehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/_;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
</code></pre>
<p>Je nach Browser erhältst du möglicherweise eine etwas andere Ausgabe. Jetzt, wo
wir die Anfragedaten ausgeben, können wir sehen, warum wir mehrere Verbindungen
von einer Browser-Anfrage erhalten, wenn wir uns den Pfad nach <code>GET</code> in der
ersten Zeile der Anfrage ansehen. Wenn die wiederholten Verbindungen alle <code>/</code>
anfordern, wissen wir, dass der Browser wiederholt versucht, <code>/</code> abzurufen,
weil er keine Antwort von unserem Programm erhält.</p>
<p>Lass uns diese Anfragedaten aufschlüsseln, um zu verstehen, was der Browser von
unserem Programm will.</p>
<h3 id="ein-genauerer-blick-auf-eine-http-anfrage"><a class="header" href="#ein-genauerer-blick-auf-eine-http-anfrage">Ein genauerer Blick auf eine HTTP-Anfrage</a></h3>
<p>HTTP ist ein textbasiertes Protokoll und eine Anfrage hat dieses Format an:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>Die erste Zeile ist die <em>Anfragezeile</em> (request line), die Informationen
darüber enthält, was der Client anfragt. Der erste Teil der Anfragezeile gibt
die <em>Methode</em> an, die verwendet wird, z.B. <code>GET</code> oder <code>POST</code>, die beschreibt,
wie der Client diese Anfrage stellt. Unser Client benutzte eine <code>GET</code>-Anfrage,
was bedeutet, dass er nach Informationen fragt.</p>
<p>Der nächste Teil der Anfragezeile ist <code>/</code>, der den <em>einheitlichen
Ressourcenbezeichner</em> (Uniform Resource Identifier, kurz <em>URI</em>) angibt, den der
Client anfragt: Ein URI ist fast, aber nicht ganz dasselbe wie ein
<em>einheitlicher Ressourcenzeiger</em> (Uniform Resource Locator, kurz <em>URL</em>). Der
Unterschied zwischen URIs und URLs ist für unsere Zwecke in diesem Kapitel
nicht wichtig, aber die HTTP-Spezifikation verwendet den Begriff URI, sodass
wir hier einfach gedanklich URL durch URI ersetzen können.</p>
<p>Der letzte Teil ist die HTTP-Version, die der Client verwendet, und dann endet
die Anfragezeile mit einer <em>CRLF-Sequenz</em>. (CRLF steht für <em>carriage return</em>
(Wagenrücklauf) und <em>line feed</em> (Zeilenvorschub), das sind Begriffe aus der
Schreibmaschinenzeit!) Die CRLF-Sequenz kann auch als <code>\r\n</code> geschrieben
werden, wobei <code>\r</code> ein Wagenrücklauf und <code>\n</code> ein Zeilenvorschub ist. Die
CRLF-Sequenz trennt die Anfragezeile von den restlichen Anfragedaten. Beachte,
dass wir beim Ausgeben von CRLF eine neue Zeile sehen und nicht <code>\r\n</code>.</p>
<p>Wenn wir uns die Daten der Anfragezeile ansehen, die wir bisher beim Ausführen
unseres Programms erhalten haben, sehen wir, dass <code>GET</code> die Methode, <code>/</code> die
Anfrage-URI und <code>HTTP/1.1</code> die Version ist.</p>
<p>Nach der Anfragezeile sind die restlichen Zeilen ab <code>Host:</code> Kopfzeilen.
<code>GET</code>-Anfragen haben keinen Rumpf (body).</p>
<p>Versuche, eine Anfrage von einem anderen Browser aus zu stellen oder nach einer
anderen Adresse zu fragen, z.B. <em>127.0.0.1:7878/test</em>, um zu sehen, wie sich
die Anfragedaten ändern.</p>
<p>Jetzt, da wir wissen, was der Browser anfragt, schicken wir ein paar Daten
zurück!</p>
<h3 id="schreiben-einer-antwort"><a class="header" href="#schreiben-einer-antwort">Schreiben einer Antwort</a></h3>
<p>Wir implementieren das Senden von Daten als Antwort auf eine Clientanfrage. Die
Antworten haben das folgende Format:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>Die erste Zeile ist eine <em>Statuszeile</em>, die die in der Antwort verwendete
HTTP-Version, einen numerischen Statuscode, der das Ergebnis der Anfrage
zusammenfasst, und eine Begründungsphrase, die eine Textbeschreibung des
Statuscodes liefert, enthält. Nach der CRLF-Sequenz folgen beliebige
Kopfzeilen, eine weitere CRLF-Sequenz und der Rumpf der Antwort.</p>
<p>Hier ist eine Beispielantwort, die HTTP-Version 1.1 verwendet, den Statuscode
200, eine OK-Begründungsphrase, keine Kopfzeilen und keinen Rumpf hat:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>Der Statuscode 200 ist die Standard-Erfolgsantwort. Der Text ist eine winzige
erfolgreiche HTTP-Antwort. Lass uns dies als Antwort auf eine erfolgreiche
Anfrage in den Strom schreiben! Entferne aus der Funktion <code>handle_connection</code>
das <code>println!</code>, das die Anfragedaten ausgegeben hat, und ersetze es durch den
Code in Codeblock 21-3.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 21-3: Schreiben einer kleinen erfolgreichen
HTTP-Antwort in den Strom</span></p>
<p>Die erste neue Zeile definiert die Variable <code>response</code>, die die Daten der
Erfolgsmeldung enthält. Dann rufen wir <code>as_bytes</code> auf unserer <code>response</code> auf,
um die Zeichenkettendaten in Bytes zu konvertieren. Die Methode <code>write_all</code> auf
<code>stream</code> nimmt ein <code>&amp;[u8]</code> und sendet diese Bytes direkt in die Verbindung. Da
die Operation <code>write_all</code> fehlschlagen könnte, verwenden wir wie bisher bei
jedem Fehlerergebnis <code>unwrap</code> . Auch hier würdest du in einer echten Anwendung
eine Fehlerbehandlung hinzufügen.</p>
<p>Lass uns mit diesen Änderungen unseren Code ausführen und eine Anfrage stellen.
Wir geben keine Daten mehr im Terminal aus, sodass wir außer der Ausgabe von
Cargo keine weiteren Ausgaben sehen werden. Wenn du <em>127.0.0.1:7878</em> in einem
Webbrowser lädst, solltest du statt eines Fehlers eine leere Seite sehen. Du
hast soeben das Empfangen einer HTTP-Anfrage und das Senden einer Antwort von
Hand programmiert!</p>
<h3 id="echtes-html-zurückgeben"><a class="header" href="#echtes-html-zurückgeben">Echtes HTML zurückgeben</a></h3>
<p>Lass uns die Funktionalität für die Rückgabe von mehr als einer leeren Seite
implementieren. Erstelle die neue Datei <em>hello.html</em> in der Wurzel deines
Projektverzeichnisses, nicht im Verzeichnis <em>src</em>. Du kannst beliebiges HTML
eingeben, das du willst; Codeblock 21-4 zeigt eine Möglichkeit.</p>
<p><span class="filename">Dateiname: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hallo!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hallo!&lt;/h1&gt;
    &lt;p&gt;Hallo von Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Codeblock 21-4: Eine Beispiel-HTML-Datei, die in einer
Antwort zurückgegeben werden soll</span></p>
<p>Dies ist ein minimales HTML5-Dokument mit einer Überschrift und etwas Text. Um
dies vom Server zurückzugeben, wenn eine Anfrage empfangen wird, modifizieren
wir <code>handle_connection</code> wie in Codeblock 21-5 gezeigt, um die HTML-Datei zu
lesen, sie der Antwort als Rumpf hinzuzufügen und sie zu senden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run edition2024">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --abschneiden--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 21-5: Senden des Inhalts von <em>hello.html</em> als
Rumpf der Antwort</span></p>
<p>Wir haben <code>fs</code> zur <code>use</code>-Deklaration hinzugefügt, um das Dateisystemmodul der
Standardbibliothek in den Gültigkeitsbereich zu bringen. Der Code zum Lesen des
Inhalts einer Datei in eine Zeichenkette sollte vertraut aussehen; wir haben
ihn verwendet, als wir den Inhalt einer Datei für unser E/A-Projekt in
Codeblock 12-4 gelesen haben.</p>
<p>Als Nächstes verwenden wir <code>format!</code>, um den Inhalt der Datei als Rumpf der
Erfolgsantwort hinzuzufügen. Um eine gültige HTTP-Antwort zu gewährleisten,
fügen wir den Header <code>Content-Length</code> hinzu, der auf die Größe unseres
Antwortrumpfs gesetzt wird, in diesem Fall auf die Größe von <code>hello.html</code>.</p>
<p>Führe diesen Code mit <code>cargo run</code> aus und lade <em>127.0.0.1:7878</em> im Browser; du
solltest dein HTML gerendert sehen!</p>
<p>Gegenwärtig ignorieren wir die Anfragedaten in <code>http_request</code> und senden
einfach den Inhalt der HTML-Datei bedingungslos zurück. Das heißt, wenn du
versuchst, <em>127.0.0.1:7878/something-else</em> in deinem Browser anzufragen,
erhältst du immer noch dieselbe HTML-Antwort zurück. Unser Server ist im Moment
sehr begrenzt und macht nicht das, was die meisten Webserver tun. Wir wollen
unsere Antworten je nach Anfrage anpassen und nur die HTML-Datei für eine
wohlgeformte Anfrage an <code>/</code> zurücksenden.</p>
<h3 id="validieren-der-anfrage-und-selektives-beantworten"><a class="header" href="#validieren-der-anfrage-und-selektives-beantworten">Validieren der Anfrage und selektives Beantworten</a></h3>
<p>Im Moment wird unser Webserver das HTML in der Datei zurückgeben, unabhängig
davon, was der Client angefragt hat. Fügen wir Funktionen hinzu, um zu
überprüfen, ob der Browser <code>/</code> anfragt, bevor er die HTML-Datei zurückgibt, und
um einen Fehler zurückzugeben, wenn der Browser etwas anderes anfragt. Dazu
müssen wir <code>handle_connection</code> modifizieren, wie in Codeblock 21-6 gezeigt.
Dieser neue Code prüft den Inhalt der erhaltenen Anfrage, ob <code>/</code> angefragt
wird, und fügt <code>if</code>- und <code>else</code>-Blöcke hinzu, um die Anfragen unterschiedlich
zu behandeln.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // eine andere Anfrage
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 21-6: Behandlung von Anfragen an <code>/</code> anders als
andere Anfragen</span></p>
<p>Wir werden uns nur die erste Zeile der HTTP-Anfrage ansehen. Anstatt also die
gesamte Anfrage in einen Vektor zu lesen, rufen wir <code>next</code> auf, um das erste
Element aus dem Iterator zu erhalten. Das erste <code>unwrap</code> kümmert sich um die
<code>Option</code> und hält das Programm an, wenn der Iterator keine Elemente hat. Das
zweite <code>unwrap</code> behandelt das <code>Result</code> und hat den gleichen Effekt wie das
<code>unwrap</code> in  <code>map</code> in Codeblock 21-2.</p>
<p>Als nächstes überprüfen wir <code>request_line</code>, um zu sehen, ob es der Anfragezeile
einer GET-Anfrage mit dem Pfad <code>/</code> entspricht. Ist dies der Fall, gibt der
<code>if</code>-Block den Inhalt unserer HTML-Datei zurück.</p>
<p>Wenn <code>request_line</code> <em>nicht</em> der GET-Anfrage mit dem <code>/</code> Pfad entspricht,
bedeutet das, dass wir eine andere Anfrage erhalten haben. Wir werden dem
<code>else</code>-Block gleich Code hinzufügen, um auf alle anderen Anfragen zu reagieren.</p>
<p>Führe diesen Code jetzt aus und frage <em>127.0.0.1:7878</em> an; du solltest das HTML
in <em>hello.html</em> erhalten. Wenn du eine andere Anfrage stellst, z.B.
<em>127.0.0.1:7878/something-else</em>, erhältst du einen Verbindungsfehler, wie du
ihn beim Ausführen des Codes in Codeblock 21-1 und Codeblock 21-2 gesehen hast.</p>
<p>Fügen wir nun den Code in Codeblock 21-7 in den <code>else</code>-Block ein, um eine
Antwort mit dem Statuscode 404 zurückzugeben, der signalisiert, dass der Inhalt
für die Anfrage nicht gefunden wurde. Wir geben auch etwas HTML für eine Seite
zurück, die im Browser dargestellt werden soll, um dem Endbenutzer die Antwort
anzuzeigen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == "GET / HTTP/1.1" {
</span><span class="boring">        let status_line = "HTTP/1.1 200 OK";
</span><span class="boring">        let contents = fs::read_to_string("hello.html").unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --abschneiden--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 21-7: Antworten mit Statuscode 404 und einer
Fehlerseite, wenn etwas anderes als <code>/</code> angefragt wurde</span></p>
<p>Hier hat unsere Antwort eine Statuszeile mit Statuscode 404 und der
Begründungsphrase <code>NOT FOUND</code> (nicht gefunden). Der Rumpf der Antwort wird das
HTML in der Datei <em>404.html</em> sein. Du musst neben <em>hallo.html</em> eine Datei
<em>404.html</em> für die Fehlerseite erstellen; auch hier kannst du jedes beliebige
HTML verwenden oder das Beispiel-HTML in Codeblock 21-8.</p>
<p><span class="filename">Dateiname: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="de"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hallo!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Ups!&lt;/h1&gt;
    &lt;p&gt;Entschuldige, ich weiß nicht wonach du gefragt hast.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Codeblock 21-8: Beispielinhalt für die Seite, die mit
jeder 404-Antwort zurückgesendet werden soll</span></p>
<p>Lass deinen Server mit diesen Änderungen erneut laufen. Die Anfrage
<em>127.0.0.1:7878</em> sollte den Inhalt von <em>hallo.html</em> zurückgeben und jede andere
Anfrage, wie <em>127.0.0.1:7878/foo</em>, sollte das Fehler-HTML von <em>404.html</em>
zurückgeben.</p>
<h3 id="ein-hauch-von-refaktorierung"><a class="header" href="#ein-hauch-von-refaktorierung">Ein Hauch von Refaktorierung</a></h3>
<p>Im Moment haben die <code>if</code>- und <code>else</code>-Blöcke eine Menge Wiederholungen: Sie
lesen beide Dateien und schreiben den Inhalt der Dateien in den Strom. Die
einzigen Unterschiede sind die Statuszeile und der Dateiname. Lass uns den Code
prägnanter gestalten, indem wir diese Unterschiede in separate <code>if</code>- und
<code>else</code>-Zeilen herausziehen, die die Werte der Statuszeile und des Dateinamens
Variablen zuweisen; wir können diese Variablen dann bedingungslos im Code
verwenden, um die Datei zu lesen und die Antwort zu schreiben. Codeblock 21-9
zeigt den resultierenden Code nach dem Ersetzen der großen <code>if</code>- und
<code>else</code>-Blöcke.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--

fn handle_connection(mut stream: TcpStream) {
    // --abschneiden--

<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 21-9: Refaktorieren der <code>if</code>- und
<code>else</code>-Blöcke, sodass sie nur den Code enthalten, der sich zwischen den beiden
Fällen unterscheidet</span></p>
<p>Die Blöcke <code>if</code> und <code>else</code> geben jetzt nur noch die entsprechenden Werte für
die Statuszeile und den Dateinamen in einem Tupel zurück; wir verwenden dann
die Destrukturierung, um diese beiden Werte den Variablen <code>status_line</code> und
<code>filename</code> zuzuweisen, unter Verwendung eines Musters in der <code>let</code>-Anweisung,
wie in Kapitel 18 besprochen.</p>
<p>Der zuvor duplizierte Code befindet sich jetzt außerhalb der Blöcke <code>if</code> und
<code>else</code> und verwendet die Variablen <code>status_line</code> und <code>filename</code>. Dies macht es
einfacher, den Unterschied zwischen den beiden Fällen zu erkennen, und es
bedeutet, dass wir nur einen Ort haben, an dem wir den Code aktualisieren
müssen, wenn wir ändern wollen, wie das Lesen der Datei und das Schreiben der
Antwort funktionieren. Das Verhalten des Codes in Codeblock 21-9 ist dasselbe
wie in Codeblock 21-7.</p>
<p>Fantastisch! Wir haben jetzt einen einfachen Webserver mit etwa 40 Zeilen
Rust-Code, der auf eine Anfrage mit einer Inhaltsseite antwortet und auf alle
anderen Anfragen mit einer 404-Antwort.</p>
<p>Derzeit läuft unser Server in einem einzigen Strang (thread), d.h. er kann
immer nur eine Anfrage gleichzeitig bedienen. Lass uns untersuchen, warum das
ein Problem sein kann, indem wir einige langsame Anfragen simulieren. Dann
werden wir es beheben, indem unser Server mehrere Anfragen auf einmal
bearbeiten kann.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unseren-einsträngigen-single-threaded-webserver-in-einen-mehrsträngigen-multi-threaded-webserver-verwandeln"><a class="header" href="#unseren-einsträngigen-single-threaded-webserver-in-einen-mehrsträngigen-multi-threaded-webserver-verwandeln">Unseren einsträngigen (single-threaded) Webserver in einen mehrsträngigen (multi-threaded) Webserver verwandeln</a></h2>
<p>Im Moment verarbeitet der Server jede Anfrage der Reihe nach, d.h. er wird erst
dann eine zweite Verbindung verarbeiten, wenn die erste abgeschlossen ist.
Würde der Server mehr und mehr Anfragen erhalten, wäre diese serielle
Ausführung immer weniger optimal. Wenn der Server eine Anfrage erhält, deren
Bearbeitung sehr lange dauert, müssen nachfolgende Anfragen warten, bis die
lange dauernde Anfrage beendet ist, auch wenn die neuen Anfragen schnell
bearbeitet werden können. Das müssen wir beheben, aber zuerst werden wir uns
das Problem in Aktion ansehen.</p>
<h3 id="simulieren-einer-langsamen-anfrage-in-der-aktuellen-server-implementierung"><a class="header" href="#simulieren-einer-langsamen-anfrage-in-der-aktuellen-server-implementierung">Simulieren einer langsamen Anfrage in der aktuellen Server-Implementierung</a></h3>
<p>Wir werden untersuchen, wie sich eine Anfrage mit langsamer Verarbeitung auf
andere Anfragen an unsere aktuelle Server-Implementierung auswirken kann.
Codeblock 21-10 implementiert die Behandlung einer Anfrage an <em>/sleep</em> mit
einer simulierten langsamen Antwort, die den Server veranlasst, fünf Sekunden
lang zu schlafen, bevor er antwortet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run edition2024">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --abschneiden--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    // --abschneiden--

<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --abschneiden--
<span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre></pre>
<p><span class="caption">Codeblock 21-10: Simulieren einer langsamen Anfrage durch
Schlafen von 5 Sekunden</span></p>
<p>Wir haben von <code>if</code> zu <code>match</code> gewechselt, da wir nun drei Fälle haben. Wir
müssen explizit auf ein Stück von <code>request_line</code> abgleichen, um einen
Musterabgleich mit den Zeichenketten-Literalwerten durchzuführen; <code>match</code> führt
keine automatische Referenzierung und Dereferenzierung durch, wie es die
Gleichheitsmethode tut.</p>
<p>Der erste Zweig ist der gleiche wie der <code>if</code>-Block aus Codeblock 21-9. Der
zweite Zweig entspricht einer Anfrage an <em>/sleep</em>. Wenn diese Anfrage empfangen
wird, schläft der Server für fünf Sekunden, bevor er die erfolgreiche
HTML-Seite rendert. Der dritte Zweig entspricht dem <code>else</code>-Block aus Codeblock
21-9.</p>
<p>Du kannst sehen, wie primitiv unser Server ist: Echte Bibliotheken würden das
Erkennen mehrerer Anfragen viel weniger wortreich handhaben!</p>
<p>Starte den Server mit <code>cargo run</code>. Öffne dann zwei Browser-Fenster: Eines für
<em>http://127.0.0.1:7878/</em> und das andere für <em>http://127.0.0.1:7878/sleep</em>. Wenn
du die URI <code>/</code> wie bisher ein paar Mal eingibst, wirst du sehen, dass er
schnell reagiert. Aber wenn du <em>/sleep</em> eingibst und dann <code>/</code> lädst, wirst du
sehen, dass <code>/</code> wartet, bis <code>sleep</code> für volle 5 Sekunden geschlafen hat, bevor
es geladen wird.</p>
<p>Es gibt mehrere Techniken, um zu vermeiden, dass sich Anfragen hinter einer
langsamen Anfrage stauen; diejenige, die wir implementieren werden, ist ein
Strang-Vorrat (thread pool).</p>
<h3 id="verbessern-des-durchsatzes-mit-einem-strang-vorrat"><a class="header" href="#verbessern-des-durchsatzes-mit-einem-strang-vorrat">Verbessern des Durchsatzes mit einem Strang-Vorrat</a></h3>
<p>Ein <em>Strang-Vorrat</em> (thread pool) ist eine Gruppe von erzeugten Strängen, die
warten und bereit sind, eine Aufgabe zu bearbeiten. Wenn das Programm eine neue
Aufgabe erhält, ordnet es einen der Stränge im Pool der Aufgabe zu, und dieser
Strang wird die Aufgabe bearbeiten. Die verbleibenden Stränge im Pool stehen
für alle anderen Aufgaben zur Verfügung, die während der Verarbeitung des
ersten Strangs hereinkommen. Wenn der erste Strang mit der Verarbeitung seiner
Aufgabe fertig ist, kehrt er in den Vorrat der unbeschäftigten Stränge zurück
und ist bereit, eine neue Aufgabe zu bearbeiten. Ein Strang-Vorrat ermöglicht
es dir, Verbindungen gleichzeitig zu verarbeiten und so den Durchsatz deines
Servers zu erhöhen.</p>
<p>Wir beschränken die Anzahl der Stränge im Vorrat auf eine kleine Anzahl, um uns
vor Dienstverweigerungsangriffen (Denial-of-Service, kurz DoS) zu schützen;
wenn unser Programm für jede eingehende Anfrage einen neuen Strang erstellen
würde, könnte jemand, der 10 Millionen Anfragen an unseren Server stellt, ein
Chaos anrichten, indem er alle Ressourcen unseres Servers aufbraucht und die
Bearbeitung der Anfragen zum Erliegen bringt.</p>
<p>Anstatt unbegrenzt viele Stränge zu erzeugen, werden wir eine feste Anzahl von
Strängen im Vorrat warten lassen. Wenn Anfragen eingehen, werden sie zur
Verarbeitung an den Vorrat geschickt. Der Vorrat verwaltet eine Warteschlange
für eingehende Anfragen. Jeder der Stränge im Vorrat wird eine Anfrage aus
dieser Warteschlange holen, die Anfrage bearbeiten und dann die Warteschlange
um eine weitere Anfrage fragen. Mit diesem Design können wir bis zu <em><code>N</code></em>
Anfragen gleichzeitig bearbeiten, wobei <em><code>N</code></em> die Anzahl der Stränge ist. Wenn
jeder Strang auf eine lang laufende Anfrage antwortet, können sich nachfolgende
Anfragen immer noch in der Warteschlange rückstauen, aber wir haben die Anzahl
der lang laufenden Anfragen erhöht, die wir bearbeiten können, bevor wir diesen
Punkt erreichen.</p>
<p>Diese Technik ist nur eine von vielen Möglichkeiten, den Durchsatz eines
Webservers zu verbessern. Weitere Optionen, die du untersuchen könntest, sind
das <em>Fork/Join-Modell</em>, das <em>asynchrone E/A-Modell mit einem Strang</em> und das
<em>asynchrone E/A-Modell mit mehreren Strängen</em>. Wenn du an diesem Thema
interessiert bist, kannst du mehr über andere Lösungen lesen und versuchen, sie
in Rust zu implementieren; mit einer systemnahen Sprache wie Rust sind alle
diese Optionen möglich.</p>
<p>Bevor wir mit der Implementierung eines Strang-Vorrats beginnen, lass uns
darüber sprechen, wie die Verwendung des Vorrats aussehen sollte. Wenn du
versuchst, Code zu entwerfen, kann das Schreiben der Client-Benutzeroberfläche
beim Entwurf helfen. Schreibe die API des Codes so, dass sie so strukturiert
ist, wie du sie aufrufen möchtest; implementiere dann die Funktionalität
innerhalb dieser Struktur, anstatt zuerst die Funktionalität zu implementieren
und danach die öffentliche API zu entwerfen.</p>
<p>Ähnlich wie wir die testgetriebene Entwicklung im Projekt in Kapitel 12
angewendet haben, werden wir hier die compilergetriebene Entwicklung verwenden.
Wir werden den Code schreiben, der die von uns gewünschten Funktionen aufruft,
und dann schauen wir uns Fehler des Compilers an, um zu bestimmen, was wir als
Nächstes ändern sollten, damit der Code funktioniert. Bevor wir das tun, werden
wir jedoch die Technik erkunden, die wir nicht als Ausgangspunkt verwenden
werden.</p>
<h4 id="für-jede-anfrage-einen-eigenen-strang-erstellen"><a class="header" href="#für-jede-anfrage-einen-eigenen-strang-erstellen">Für jede Anfrage einen eigenen Strang erstellen</a></h4>
<p>Lass uns zunächst untersuchen, wie unser Code aussehen könnte, wenn er für jede
Verbindung einen neuen Strang erstellen würde. Wie bereits erwähnt, ist dies
nicht unser endgültiger Plan, da es Probleme mit dem potenziellen Erzeugen
einer unbegrenzten Anzahl von Strängen gibt, aber es ist ein Ausgangspunkt, um
zunächst einen funktionierenden mehrsträngigen Server zu erhalten. Dann fügen
wir den Strang-Vorrat als Verbesserung hinzu, und es wird einfacher, die beiden
Lösungen zu vergleichen. Codeblock 21-11 zeigt die Änderungen, die an <code>main</code>
vorgenommen werden müssen, um einen neuen Strang zu erzeugen, der jeden Strom
innerhalb der <code>for</code>-Schleife verarbeitet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 21-11: Erstellen eines neuen Strangs für jeden
Strom</span></p>
<p>Wie du in Kapitel 16 gelernt hast, wird <code>thread::spawn</code> einen neuen Strang
erstellen und dann den Code im Funktionsabschluss (closure) im neuen Strang
ausführen. Wenn du diesen Code ausführst und <em>/sleep</em> in deinem Browser lädst,
dann <code>/</code> in zwei weiteren Browser-Tabs, wirst du in der Tat sehen, dass die
Anfragen an <code>/</code> nicht auf die Beendigung von <em>/sleep</em> warten müssen. Aber wie
wir bereits erwähnt haben, wird dies letztendlich das System überfordern, weil
du neue Stränge ohne jede Begrenzung erstellen würdest.</p>
<h4 id="erstellen-einer-endliche-anzahl-von-strängen"><a class="header" href="#erstellen-einer-endliche-anzahl-von-strängen">Erstellen einer endliche Anzahl von Strängen</a></h4>
<p>Wir möchten, dass unser Strang-Vorrat in einer ähnlichen, vertrauten Weise
arbeitet, sodass der Wechsel von Strängen zu einem Strang-Vorrat keine großen
Änderungen am Code erfordert, der unsere API verwendet. Codeblock 21-12 zeigt
die hypothetische Schnittstelle für eine Struktur (struct) <code>ThreadPool</code>, die
wir anstelle von <code>thread::spawn</code> verwenden wollen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 21-12: Unsere ideale
<code>ThreadPool</code>-Schnittstelle</span></p>
<p>Wir verwenden <code>ThreadPool::new</code>, um einen neuen Strang-Vorrat mit einer
konfigurierbaren Anzahl von Strängen zu erstellen, in diesem Fall vier. In der
<code>for</code>-Schleife hat <code>pool.execute</code> eine ähnliche Schnittstelle wie
<code>thread::spawn</code>, indem es einen Funktionsabschluss entgegennimmt, den der
Vorrat für jeden Strom ausführen soll. Wir müssen <code>pool.execute</code>
implementieren, sodass es den Funktionsabschluss entgegennimmt und ihn einem
Strang im Vorrat zur Ausführung übergibt. Dieser Code lässt sich noch nicht
kompilieren, aber wir werden es versuchen, damit der Compiler uns anleiten
kann, wie wir das Problem beheben können.</p>
<h4 id="aufbau-von-threadpool-mit-compilergetriebener-entwicklung"><a class="header" href="#aufbau-von-threadpool-mit-compilergetriebener-entwicklung">Aufbau von <code>ThreadPool</code> mit compilergetriebener Entwicklung</a></h4>
<p>Nimm die Änderungen in Codeblock 21-12 an <em>src/main.rs</em> vor und lass uns dann
die Kompilierfehler von <code>cargo check</code> verwenden, um unsere Entwicklung
voranzutreiben. Hier ist der erste Fehler, den wir erhalten:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:10:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>Großartig! Dieser Fehler sagt uns, dass wir einen Typ oder ein Modul
<code>ThreadPool</code> benötigen, also werden wir jetzt eines bauen. Unsere
<code>ThreadPool</code>-Implementierung wird unabhängig von der Art der Arbeit unseres
Webservers sein. Lass uns also die Kiste (crate) <code>hello</code> von einer Binär-Kiste
(binary crate) auf eine Bibliotheks-Kiste (library crate) umstellen, um unsere
<code>ThreadPool</code>-Implementierung aufzunehmen. Nachdem wir zu einer Bibliothekskiste
umgestellt haben, könnten wir die separate Strang-Vorrats-Bibliothek auch für
alle Arbeiten verwenden, die wir mit einem Strang-Vorrat durchführen wollen,
nicht nur für die Bedienung von Webanfragen.</p>
<p>Erstelle eine Datei <em>src/lib.rs</em>, die das Folgende enthält, was die einfachste
Definition einer <code>ThreadPool</code>-Struktur ist, die wir im Moment haben können:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
<p>Bearbeite dann die Datei <em>main.rs</em>, um <code>ThreadPool</code> in den Gültigkeitsbereich
der Bibliothekskiste zu bringen, indem du den folgenden Code am Anfang von
<em>src/main.rs</em> hinzufügst:</p>
<p><span class="filename">Dateiname: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p>Dieser Code wird immer noch nicht funktionieren, aber lass uns ihn noch einmal
überprüfen, um den nächsten Fehler zu erhalten, den wir beheben müssen:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/bin/main.rs:11:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>Dieser Fehler deutet darauf hin, dass wir als Nächstes eine zugehörige Funktion
namens <code>new</code> für <code>ThreadPool</code> erstellen müssen. Wir wissen auch, dass <code>new</code>
einen Parameter haben muss, der <code>4</code> als Argument akzeptieren kann und eine
<code>ThreadPool</code>-Instanz zurückgeben sollte. Lass uns die einfachste Funktion <code>new</code>
implementieren, die diese Eigenschaften haben wird:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Wir haben <code>usize</code> als Typ des Parameters <code>size</code> gewählt, weil wir wissen, dass
eine negative Anzahl von Strängen keinen Sinn macht. Wir wissen auch, dass wir
diese <code>4</code> als die Anzahl der Elemente in einer Kollektion von Strängen
verwenden werden, wofür der Typ <code>usize</code> gedacht ist, wie im Abschnitt
<a href="ch03-02-data-types.html#ganzzahl-typen">„Ganzzahl-Typen“</a> in Kapitel 3 besprochen.</p>
<p>Lass uns den Code noch einmal überprüfen:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |         -----^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>Der Fehler tritt jetzt auf, weil wir keine Methode <code>execute</code> auf <code>ThreadPool</code>
haben. Erinnere dich an <a href="ch21-02-multithreaded.html#erstellen-einer-endliche-anzahl-von-str%C3%A4ngen">„Erstellen einer endlichen Anzahl von
Strängen“</a>, wo wir beschlossen haben, dass unser
Strang-Vorrat eine ähnliche Schnittstelle wie <code>thread::spawn</code> haben sollte.
Zusätzlich werden wir die Funktion <code>execute</code> implementieren, sodass sie den
Funktionsabschluss, der ihr gegeben wird, nimmt und sie einem unbeschäftigten
Strang im Vorrat zur Ausführung übergibt.</p>
<p>Wir werden die Methode <code>execute</code> auf <code>ThreadPool</code> definieren, um einen
Funktionsabschluss als Parameter zu nehmen. Aus <a href="ch13-01-closures.html#verschieben-erfasster-werte-aus-funktionsabschl%C3%BCssen-und-fn-merkmalen">„Verschieben erfasster Werte
aus Funktionsabschlüssen und Fn-Merkmalen“</a> in Kapitel 13 erinnern
wir uns, dass wir Funktionsabschlüsse als Parameter mit drei verschiedenen
Merkmalen nehmen können: <code>Fn</code>, <code>FnMut</code> und <code>FnOnce</code>. Wir müssen entscheiden,
welche Art von Funktionsabschluss wir hier verwenden. Wir wissen, dass wir am
Ende etwas Ähnliches wie die Implementierung <code>thread::spawn</code> der
Standardbibliothek tun werden, sodass wir uns ansehen können, welche
Abgrenzungen die Signatur von <code>thread::spawn</code> in ihrem Parameter hat. Die
Dokumentation zeigt uns Folgendes:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static</code></pre>
<p>Der Parameter vom Typ <code>F</code> ist derjenige, um den es hier geht; der Parameter vom
Typ <code>T</code> bezieht sich auf den Rückgabewert, und darum geht es uns nicht. Wir
können sehen, dass <code>spawn</code> <code>FnOnce</code> als Merkmal (trait) verwendet, das an <code>F</code>
gebunden ist. Das ist wahrscheinlich auch das, was wir wollen, denn wir werden
das Argument, das wir bei <code>execute</code> bekommen, letztendlich an <code>spawn</code>
weitergeben. Wir können weiterhin zuversichtlich sein, dass <code>FnOnce</code> das
Merkmal ist, das wir verwenden wollen, weil der Strang zum Ausführen einer
Anfrage den Funktionsabschluss dieser Anfrage nur einmal ausführt, was zu
<code>Once</code> in <code>FnOnce</code> passt.</p>
<p>Der Parameter vom Typ <code>F</code> hat auch die Merkmalsabgrenzung <code>Send</code> und die
Lebensdauer <code>'static</code>, die in unserer Situation nützlich sind: Wir brauchen
<code>Send</code>, um die Merkmalsabgrenzung von einem Strang zu einem anderen zu
übertragen und <code>'static</code>, weil wir nicht wissen, wie lange die Ausführung des
Strangs dauern wird. Lass uns eine Methode <code>execute</code> auf <code>ThreadPool</code>
erstellen, die einen generischen Parameter vom Typ <code>F</code> mit diesen Abgrenzungen
annimmt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --abschneiden--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}</code></pre>
<p>Wir verwenden immer noch <code>()</code> nach <code>FnOnce</code>, weil dieses <code>FnOnce</code> einen
Funktionsabschluss darstellt, der keine Parameter benötigt und den Einheitstyp
<code>()</code> zurückgibt. Genau wie bei Funktionsdefinitionen kann der Rückgabetyp in
der Signatur weggelassen werden, aber selbst wenn wir keine Parameter haben,
benötigen wir immer noch die Klammern.</p>
<p>Auch hier handelt es sich um die einfachste Implementierung der Methode
<code>execute</code>: Sie tut nichts, aber wir versuchen nur, unseren Code kompilieren zu
lassen. Lass es uns noch einmal überprüfen:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>Er kompiliert! Aber beachte, dass du, wenn du <code>cargo run</code> versuchst und eine
Anfrage im Browser stellst, die Fehler im Browser sehen wirst, die wir am
Anfang des Kapitels gesehen haben. Unsere Bibliothek ruft den
Funktionsabschluss, den wir an <code>execute</code> übergeben, noch nicht wirklich auf!</p>
<blockquote>
<p>Hinweis: Ein Sprichwort, das man möglicherweise über Sprachen mit strengen
Compilern wie Haskell und Rust hört, lautet: „Wenn der Code kompiliert,
funktioniert er.“ Aber dieses Sprichwort ist nicht universell wahr. Unser
Projekt kompiliert, aber es tut absolut nichts! Wenn wir ein echtes,
vollständiges Projekt aufbauen würden, wäre dies ein guter Zeitpunkt, mit dem
Schreiben von Modultests zu beginnen, um zu überprüfen, ob der Code
kompiliert <em>und</em> das von uns gewünschte Verhalten aufweist.</p>
</blockquote>
<h4 id="validieren-der-anzahl-der-stränge-in-new"><a class="header" href="#validieren-der-anzahl-der-stränge-in-new">Validieren der Anzahl der Stränge in <code>new</code></a></h4>
<p>Wir tun nichts mit den Parametern von <code>new</code> und <code>execute</code>. Lass uns die Rümpfe
dieser Funktionen mit dem Verhalten implementieren, das wir wollen. Lass uns
zunächst über <code>new</code> nachdenken. Früher wählten wir einen vorzeichenlosen Typ
für den Parameter <code>size</code>, weil ein Vorrat mit einer negativen Anzahl von
Strängen keinen Sinn ergibt. Ein Vorrat mit null Strängen ergibt jedoch auch
keinen Sinn, dennoch ist null ein vollkommen gültiges <code>usize</code>. Wir fügen Code
hinzu, um zu prüfen, ob <code>size</code> größer als null ist, bevor wir eine
<code>ThreadPool</code>-Instanz zurückgeben, und das Programm abstürzen lassen, wenn er
eine Null erhält, indem wir das Makro <code>assert!</code> verwenden, wie in Codeblock
21-13 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Erzeuge einen neuen ThreadPool.
    ///
    /// Die Größe ist die Anzahl der Stränge im Vorrat.
    ///
    /// # Panics
    ///
    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Codeblock 21-13: Implementierung von <code>ThreadPool::new</code>
stürzt ab, wenn <code>size</code> gleich Null ist</span></p>
<p>Wir haben auch etwas Dokumentation für unseren <code>ThreadPool</code> mit
Dokumentationskommentaren (doc comments) hinzugefügt. Beachte, dass wir uns an
gute Dokumentationspraktiken gehalten haben, indem wir einen Abschnitt
hinzugefügt haben, der die Situationen aufzeigt, in denen unsere Funktion
abstürzen kann, wie in Kapitel 14 besprochen. Versuche, <code>cargo doc --open</code>
auszuführen und die Struktur <code>ThreadPool</code> anzuklicken, um zu sehen, wie die
generierte Dokumentation für <code>new</code> aussieht!</p>
<p>Anstatt das Makro <code>assert!</code> hinzuzufügen, wie wir es hier getan haben, könnten
wir <code>new</code> zu <code>build</code> ändern und ein <code>Result</code> zurückgeben lassen, wie wir es mit
<code>Config::build</code> im E/A-Projekt in Codeblock 12-9 getan haben. Aber wir haben in
diesem Fall entschieden, dass der Versuch, einen Strang-Vorrat ohne Stränge zu
erstellen, ein nicht behebbarer Fehler sein sollte. Wenn du ehrgeizig bist,
versuche, eine Funktion namens <code>build</code> mit der folgenden Signatur zu schreiben,
um sie mit der Funktion <code>new</code> zu vergleichen:</p>
<pre><code class="language-rust ignore">pub fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="platz-zum-speichern-der-stränge-schaffen"><a class="header" href="#platz-zum-speichern-der-stränge-schaffen">Platz zum Speichern der Stränge schaffen</a></h4>
<p>Jetzt, da wir eine Möglichkeit haben, zu wissen, dass wir eine gültige Anzahl
von Strängen im Vorrat haben, können wir diese Stränge erstellen und sie in der
Struktur <code>ThreadPool</code> speichern, bevor wir die Struktur zurückgeben. Aber wie
„speichern“ wir einen Strang? Werfen wir noch einmal einen Blick auf die
Signatur von <code>Thread::spawn</code>:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>Die Funktion <code>spawn</code> gibt einen <code>JoinHandle&lt;T&gt;</code> zurück, wobei <code>T</code> der Typ ist,
den der Funktionsabschluss zurückgibt. Lass uns versuchen, auch <code>JoinHandle</code> zu
benutzen und sehen, was passiert. In unserem Fall werden die
Funktionsabschlüsse, die wir an den Strang-Vorrat übergeben, die Verbindung
behandeln und nichts zurückgeben, also wird <code>T</code> der Unit-Typ <code>()</code> sein.</p>
<p>Der Code in Codeblock 21-14 lässt sich kompilieren, erzeugt aber noch keine
Stränge. Wir haben die Definition von <code>ThreadPool</code> so geändert, dass sie einen
Vektor von <code>thread::JoinHandle&lt;()&gt;</code>-Instanzen enthält, den Vektor mit der
Kapazität <code>size</code> initialisiert, eine <code>for</code>-Schleife eingerichtet, die etwas
Code zum Erzeugen der Stränge ausführt, und eine <code>ThreadPool</code>-Instanz
zurückgibt, die diese enthält.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // einige Stränge erstellen und im Vektor speichern
        }

        ThreadPool { threads }
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Codeblock 21-14: Erstellen eines Vektors für <code>ThreadPool</code>
zum Aufnehmen der Stränge</span></p>
<p>Wir haben <code>std::thread</code> in der Bibliothekskiste in den Gültigkeitsbereich
gebracht, weil wir <code>thread::JoinHandle</code> als den Typ der Elemente im Vektor in
<code>ThreadPool</code> verwenden.</p>
<p>Sobald wir eine gültige Größe erhalten haben, erzeugt unser <code>ThreadPool</code> einen
neuen Vektor, der <code>size</code> Elemente aufnehmen kann. Die Funktion <code>with_capacity</code>
erfüllt die gleiche Aufgabe wie <code>Vec::new</code>, aber mit einem wichtigen
Unterschied: Sie weist dem Vektor Platz im Voraus zu. Da wir wissen, dass wir
<code>size</code> Elemente im Vektor speichern müssen, ist diese Allokation im Voraus
etwas effizienter als die Verwendung von <code>Vec::new</code>, das sich selbst in der
Größe verändert, wenn Elemente eingefügt werden.</p>
<p>Wenn du <code>cargo check</code> erneut ausführst, sollte es erfolgreich sein.</p>
<h4 id="struktur-worker-zum-senden-von-code-vom-threadpool-an-einen-strang"><a class="header" href="#struktur-worker-zum-senden-von-code-vom-threadpool-an-einen-strang">Struktur <code>Worker</code> zum Senden von Code vom <code>ThreadPool</code> an einen Strang</a></h4>
<p>Wir haben einen Kommentar in der <code>for</code>-Schleife in Codeblock 21-14 bezüglich
der Erstellung von Strängen hinterlassen. Hier werden wir uns ansehen, wie wir
tatsächlich Stränge erstellen. Die Standardbibliothek bietet <code>thread::spawn</code>
als eine Möglichkeit, Stränge zu erstellen, und <code>thread::spawn</code> erwartet, dass
es Code erhält, den der Strang ausführen soll, sobald der Strang erstellt ist.
In unserem Fall wollen wir jedoch die Stränge erstellen und sie auf Code
<em>warten</em> lassen, den wir später senden werden. Die Implementierung von Strängen
in der Standardbibliothek enthält keine Möglichkeit, dies zu tun; wir müssen
sie manuell implementieren.</p>
<p>Wir werden dieses Verhalten implementieren, indem wir eine neue Datenstruktur
zwischen dem <code>ThreadPool</code> und den Strängen, die dieses neue Verhalten verwalten
werden, einführen. Wir nennen diese Datenstruktur <code>Worker</code>, was ein gängiger
Begriff in Vorrats-Implementierungen ist. Der <code>Worker</code> holt den Code ab, der
ausgeführt werden muss, und führt ihn im Strang des <code>Worker</code> aus. Denke an
Menschen, die in der Küche eines Restaurants arbeiten: Die Arbeiter warten, bis
Bestellungen von Kunden eingehen, und dann sind sie dafür verantwortlich, diese
Bestellungen entgegenzunehmen und auszuführen.</p>
<p>Anstatt einen Vektor von <code>JoinHandle&lt;()&gt;</code>-Instanzen im Strang-Vorrat zu
speichern, werden wir Instanzen der <code>Worker</code>-Struktur speichern. Jeder <code>Worker</code>
wird eine einzelne <code>JoinHandle&lt;()&gt;</code>-Instanz speichern. Dann werden wir eine
Methode auf <code>Worker</code> implementieren, die einen Funktionsabschluss zur
Ausführung benötigt und ihn zur Ausführung an den bereits laufenden Strang
sendet. Wir werden auch jedem <code>Worker</code> eine <code>id</code> geben, damit wir beim
Protokollieren oder Debuggen zwischen den verschiedenen <code>Worker</code>-Instanzen im
Vorrat unterscheiden können.</p>
<p>Hier ist der neue Prozess, der abläuft, wenn wir einen <code>ThreadPool</code> erstellen.
Wir werden den Code implementieren, der den Funktionsabschluss an den Strang
sendet, nachdem wir <code>Worker</code> auf diese Weise eingerichtet haben:</p>
<ol>
<li>Definiere eine Struktur <code>Worker</code>, die eine <code>id</code> und einen <code>JoinHandle&lt;()&gt;</code>
enthält.</li>
<li>Ändere <code>ThreadPool</code>, um einen Vektor von <code>Worker</code>-Instanzen zu halten.</li>
<li>Definiere eine Funktion <code>Worker::new</code>, die eine <code>id</code>-Nummer nimmt und eine
<code>Worker</code>-Instanz zurückgibt, die die <code>id</code> enthält, sowie einen Strang, der
mit einem leeren Funktionsabschluss erzeugt wurde.</li>
<li>Verwende in <code>ThreadPool::new</code> den <code>for</code>-Schleifenzähler, um eine <code>id</code> zu
erzeugen, erzeuge einen neuen <code>Worker</code> mit dieser <code>id</code> und speichere den
<code>Worker</code> im Vektor.</li>
</ol>
<p>Wenn du zu einer Herausforderung bereit bist, versuche, diese Änderungen selbst
zu implementieren, bevor du dir den Code in Codeblock 21-15 ansiehst.</p>
<p>Bereit? Hier ist Codeblock 21-15 mit einer Möglichkeit, die vorhergehenden
Änderungen vorzunehmen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Codeblock 21-15: Modifizieren von <code>ThreadPool</code>, um
<code>Worker</code>-Instanzen zu halten, anstatt Stränge direkt zu halten</span></p>
<p>Wir haben den Namen des Feldes in <code>ThreadPool</code> von <code>threads</code> in <code>workers</code>
geändert, weil es jetzt <code>Worker</code>-Instanzen statt <code>JoinHandle&lt;()&gt;</code>-Instanzen
enthält. Wir benutzen den Zähler in der <code>for</code>-Schleife als Argument für
<code>Worker::new</code> und wir speichern jeden neuen <code>Worker</code> im Vektor mit dem Namen
<code>workers</code>.</p>
<p>Externer Code (wie unser Server in <em>src/main.rs</em>) muss die
Implementierungsdetails bezüglich der Verwendung einer <code>Worker</code>-Struktur
innerhalb von <code>ThreadPool</code> nicht kennen, also machen wir die <code>Worker</code>-Struktur
und ihre Funktion <code>new</code> privat. Die Funktion <code>Worker::new</code> verwendet die <code>id</code>,
die wir ihr geben, und speichert eine <code>JoinHandle&lt;()&gt;</code>-Instanz, die durch das
Erzeugen eines neuen Strangs unter Verwendung eines leeren Funktionsabschlusses
erzeugt wird.</p>
<blockquote>
<p>Hinweis: Wenn das Betriebssystem keinen Strang erstellen kann, weil nicht
genügend Systemressourcen vorhanden sind, bringt <code>thread::spawn</code> das Programm
zum Abstürzen. Das führt dazu, dass unser gesamter Server abstürzt, auch wenn
die Erstellung einiger Stränge erfolgreich wäre. Der Einfachheit halber
lassen wir es bei diesem Verhalten, aber in einer produktiven
Strang-Pool-Implementierung würdest du wahrscheinlich
<a href="https://doc.rust-lang.org/std/thread/struct.Builder.html"><code>std::thread::Builder</code></a> mit der Methode <a href="https://doc.rust-lang.org/std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a>
verwenden wollen, die stattdessen <code>Result</code> zurückgibt.</p>
</blockquote>
<p>Dieser Code kompiliert und speichert die Anzahl der <code>Worker</code>-Instanzen, die wir
als Argument für <code>ThreadPool::new</code> angegeben haben. Aber wir <em>verarbeiten</em> noch
nicht den Funktionsabschluss, den wir in <code>execute</code> erhalten. Schauen wir uns
als Nächstes an, wie wir das machen.</p>
<h4 id="senden-von-anfragen-an-stränge-über-kanäle"><a class="header" href="#senden-von-anfragen-an-stränge-über-kanäle">Senden von Anfragen an Stränge über Kanäle</a></h4>
<p>Das nächste Problem, das wir angehen, ist dass die Funktionsabschlüsse bei
<code>thread::spawn</code> absolut nichts bewirken. Gegenwärtig erhalten wir den
Funktionsabschluss, den wir ausführen wollen, mit der Methode <code>execute</code>. Aber
wir müssen <code>thread::spawn</code> einen Funktionsabschluss geben, der ausgeführt
werden soll, wenn wir jeden <code>Worker</code> während der Erstellung des <code>ThreadPool</code>
erstellen.</p>
<p>Wir möchten, dass die Struktur <code>Worker</code>, die wir gerade erstellt haben, um den
Code aus einer Warteschlange im <code>ThreadPool</code> zu holen, diesen Code zur
Ausführung an seinen Strang sendet.</p>
<p>In Kapitel 16 hast du etwas über <em>Kanäle</em> (channels) gelernt – eine
einfache Art der Kommunikation zwischen zwei Strängen –, die für diesen
Anwendungsfall perfekt geeignet ist. Wir verwenden einen Kanal, der als
Warteschlange von Aufträgen fungiert, und <code>execute</code> sendet einen Auftrag aus
dem <code>ThreadPool</code> an die <code>Worker</code>-Instanzen, die den Auftrag an ihren Strang
sendet. Hier ist der Plan:</p>
<ol>
<li>Der <code>ThreadPool</code> erstellt einen Kanal und hält den Sender.</li>
<li>Jeder <code>Worker</code> hält den Empfänger.</li>
<li>Wir werden eine neue Struktur <code>Job</code> erstellen, die den Funktionsabschluss
aufnimmt, den wir über den Kanal senden wollen.</li>
<li>Die Methode <code>execute</code> sendet den Auftrag, der ausgeführt werden soll, durch
den Sender.</li>
<li>In seinem Strang wird der <code>Worker</code> auf den Empfänger warten und die
Funktionsabschlüsse aller Aufträge, die er erhält, ausführen.</li>
</ol>
<p>Beginnen wir damit, einen Kanal in <code>ThreadPool::new</code> zu erstellen und den
Sender in der <code>ThreadPool</code>-Instanz zu halten, wie in Codeblock 21-16
gezeigt. Die Struktur <code>Job</code> enthält vorerst nichts, aber sie wird die Art von
Element sein, die wir in den Kanal senden.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 21-16: Ändern von <code>ThreadPool</code>, um den Sender
zu speichern, der <code>Job</code>-Instanzen übermittelt</span></p>
<p>In <code>ThreadPool::new</code> erstellen wir unseren neuen Kanal und lassen den Pool das
sendende Ende halten. Dies kompiliert erfolgreich.</p>
<p>Lass uns versuchen, einen Empfänger an jeden <code>Worker</code> weiterzugeben, während
der Strang-Vorrat den Kanal erstellt. Wir wissen, dass wir den Empfänger
im Strang verwenden wollen, den die <code>Worker</code>-Instanzen erzeugen, also werden
wir den Parameter <code>receiver</code> im Funktionsabschluss referenzieren. Der Code in
Codeblock 21-17 lässt sich noch nicht ganz kompilieren.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --abschneiden--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Codeblock 21-17: Übergeben des Empfängers an jeden
<code>Worker</code></span></p>
<p>Wir haben einige kleine und unkomplizierte Änderungen vorgenommen: Wir geben
den Empfänger an <code>Worker::new</code> und dann verwenden wir ihn innerhalb des
Funktionsabschlusses.</p>
<p>Wenn wir versuchen, diesen Code zu überprüfen, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
25 |         for id in 0..size {
   |         ----------------- inside of this loop
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop
   |
note: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary
  --&gt; src/lib.rs:47:33
   |
47 |     fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value
help: consider moving the expression out of the loop so it is only moved once
   |
25 ~         let mut value = Worker::new(id, receiver);
26 ~         for id in 0..size {
27 ~             workers.push(value);
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>Der Code versucht, <code>receiver</code> an mehrere <code>Worker</code>-Instanzen weiterzugeben. Das
wird nicht funktionieren, wie du dich aus Kapitel 16 erinnern wirst: Die
Kanalimplementierung, die Rust bietet, erlaubt mehrere <em>Produzenten</em> und einen
einzigen <em>Konsumenten</em>. Das bedeutet, dass wir nicht einfach das konsumierende
Ende des Kanals klonen können, um diesen Code zu reparieren. Selbst wenn wir
das könnten, ist das nicht die Technik, die wir anwenden wollen; stattdessen
wollen wir die Aufträge auf mehrere Stränge verteilen, indem wir den einzigen
<code>receiver</code> unter allen <code>Worker</code>-Instanzen aufteilen.</p>
<p>Außerdem erfordert das Entfernen eines Auftrags aus der Warteschlange des
Kanals eine Mutation von <code>receiver</code>, sodass die Stränge einen sicheren Weg
benötigen, um <code>receiver</code> gemeinsam zu nutzen und zu modifizieren; andernfalls
könnten wir Wettlaufsituationen (race conditions) erhalten (wie in Kapitel 16
behandelt).</p>
<p>Erinnere dich an die Strang-sicheren intelligenten Zeiger, die in Kapitel 16
besprochen wurden: Um die Eigentümerschaft über mehrere Stränge zu teilen und
den Strängen zu erlauben, den Wert zu mutieren, müssen wir <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>
verwenden. Der Typ <code>Arc</code> ermöglicht es mehreren <code>Worker</code>-Instanzen, den
Empfänger zu besitzen, und <code>Mutex</code> stellt sicher, dass immer nur ein <code>Worker</code>
zur gleichen Zeit einen Auftrag vom Empfänger erhält. Der Codeblock 21-18 zeigt
die Änderungen, die wir vornehmen müssen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --abschneiden--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --abschneiden--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --abschneiden--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
<p><span class="caption">Codeblock 21-18: Den Empfänger unter den <code>Worker</code>
teilen, die <code>Arc</code> und <code>Mutex</code> benutzen</span></p>
<p>In <code>ThreadPool::new</code> setzen wir den Empfänger in einen <code>Arc</code> und einen
<code>Mutex</code>. Für jeden neuen <code>Worker</code> klonen wir den <code>Arc</code>, um die Referenzzählung
zu erhöhen, sodass die <code>Worker</code>-Instanzen die Eigentümerschaft des Empfängers
teilen können.</p>
<p>Mit diesen Änderungen kompiliert der Code! Wir haben es geschafft!</p>
<h4 id="implementieren-der-methode-execute"><a class="header" href="#implementieren-der-methode-execute">Implementieren der Methode <code>execute</code></a></h4>
<p>Lass uns endlich die Methode <code>execute</code> auf <code>ThreadPool</code> implementieren. Wir
werden auch <code>Job</code> von einer Struktur in einen Typ-Alias für ein Merkmalsobjekt
(trait object) ändern, das den Typ des Funktionsabschlusses enthält, den
<code>execute</code> erhält. Wie in <a href="ch20-03-advanced-types.html#erstellen-von-typ-synonymen-mit-typ-alias">„Erstellen von Typ-Synonymen mit
Typ-Alias“</a> in Kapitel 19 besprochen, ermöglichen uns
Typ-Aliase, lange Typen kürzer zu machen, um sie einfacher nutzen zu können.
Siehe Codeblock 21-19.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --abschneiden--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 21-19: Erstellen eines Alias vom Typ <code>Job</code> für
eine <code>Box</code>, die jeden Funktionsabschluss enthält, und danach Senden des
Auftrags in den Kanal</span></p>
<p>Nachdem wir eine neue <code>Job</code>-Instanz unter Verwendung des Funktionsabschlusses,
den wir in <code>execute</code> erhalten, erstellt haben, senden wir diesen Auftrag an das
sendende Ende des Kanals. Wir rufen <code>unwrap</code> auf <code>send</code> auf für den Fall, dass
das Senden fehlschlägt. Das kann zum Beispiel passieren, wenn wir alle unsere
Stränge von der Ausführung abhalten, was bedeutet, dass das empfangende Ende
keine neuen Nachrichten mehr empfängt. Im Moment können wir die Ausführung
unserer Stränge nicht stoppen: Unsere Stränge werden so lange ausgeführt, wie
der Vorrat existiert. Der Grund, warum wir <code>unwrap</code> verwenden, ist, dass wir
wissen, dass der Fehlerfall nicht passieren wird, aber der Compiler das nicht
weiß.</p>
<p>Aber wir sind noch nicht ganz fertig! Im <code>Worker</code> wird unser Funktionsabschluss
an <code>thread::spawn</code> weitergereicht, der immer noch nur auf das empfangende Ende
des Kanals <em>referenziert</em>. Stattdessen müssen wir den Funktionsabschluss für
immer in einer Schleife laufen lassen, indem wir das empfangende Ende des
Kanals um einen Auftrag bitten und den Auftrag ausführen, wenn er einen
bekommt. Lass uns die in Codeblock 21-20 gezeigte Änderung in <code>Worker::new</code>
vornehmen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {id} hat einen Auftrag erhalten; führe ihn aus.");

            job();
        });

        Worker { id, thread }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 21-20: Empfangen und Ausführen der Aufträge im
Strang des <code>Worker</code></span></p>
<p>Hier rufen wir zuerst <code>lock</code> auf <code>receiver</code> auf, um den Mutex zu erwerben, und
dann rufen wir <code>unwrap</code> auf, um das Programm bei eventuellen Fehlern abstürzen
zu lassen. Das Akquirieren einer Sperre kann fehlschlagen, wenn sich der Mutex
in einem <em>vergifteten</em> Zustand befindet, was passieren kann, wenn ein anderer
Strang abstürzt, während er die Sperre hält, anstatt sie freizugeben. In dieser
Situation ist der Aufruf von <code>unwrap</code>, damit dieser Strang abstürzt, die
richtige Maßnahme. Fühle dich frei, dieses <code>unwrap</code> in ein <code>expect</code> mit einer
Fehlermeldung zu ändern, die für dich von Bedeutung ist.</p>
<p>Wenn wir die Sperre auf dem Mutex erhalten, rufen wir <code>recv</code> auf, um einen
<code>Job</code> vom Kanal zu empfangen. Ein abschließendes <code>unwrap</code> geht auch hier an
eventuellen Fehlern vorbei, die auftreten könnten, wenn sich der Strang, der
den Sender hält, beendet hat, ähnlich wie die Methode <code>send</code> den Wert <code>Err</code>
zurückgibt, wenn der Empfänger abschaltet.</p>
<p>Der Aufruf von <code>recv</code> blockiert, wenn also noch kein Auftrag vorhanden ist,
wartet der aktuelle Strang, bis ein Auftrag verfügbar wird. Der <code>Mutex&lt;T&gt;</code>
stellt sicher, dass immer nur ein <code>Worker</code>-Strang zur gleichen Zeit versucht,
einen Auftrag anzufordern.</p>
<p>Unser Strang-Vorrat ist jetzt in einem funktionierenden Zustand! Führe <code>cargo run</code> aus und stelle einige Anfragen:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field `workers` is never read
 --&gt; src/lib.rs:7:5
  |
6 | pub struct ThreadPool {
  |            ---------- field in this struct
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: fields `id` and `thread` are never read
  --&gt; src/lib.rs:48:5
   |
47 | struct Worker {
   |        ------ fields in this struct
48 |     id: usize,
   |     ^^
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^

warning: `hello` (lib) generated 2 warnings
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 4.91s
     Running `target/debug/hello`
Worker 0 hat einen Auftrag erhalten; führe ihn aus.
Worker 2 hat einen Auftrag erhalten; führe ihn aus.
Worker 1 hat einen Auftrag erhalten; führe ihn aus.
Worker 3 hat einen Auftrag erhalten; führe ihn aus.
Worker 0 hat einen Auftrag erhalten; führe ihn aus.
Worker 2 hat einen Auftrag erhalten; führe ihn aus.
Worker 1 hat einen Auftrag erhalten; führe ihn aus.
Worker 3 hat einen Auftrag erhalten; führe ihn aus.
Worker 0 hat einen Auftrag erhalten; führe ihn aus.
Worker 2 hat einen Auftrag erhalten; führe ihn aus.
</code></pre>
<p>Erfolg! Wir haben jetzt einen Strang-Vorrat, der Verbindungen asynchron
ausführt. Es werden nie mehr als vier Stränge erzeugt, sodass unser System
nicht überlastet wird, wenn der Server viele Anfragen erhält. Wenn wir eine
Anfrage an <em>/sleep</em> stellen, ist der Server immer noch in der Lage, andere
Anfragen zu bedienen, indem er sie von einem anderen Strang ausführen lässt.</p>
<blockquote>
<p>Hinweis: Wenn du <em>/sleep</em> in mehreren Browser-Fenstern gleichzeitig öffnest,
werden diese möglicherweise in 5-Sekunden-Intervallen nacheinander geladen.
Einige Web-Browser führen aus Gründen der Zwischenspeicherung mehrere
Instanzen der gleichen Anfrage nacheinander aus. Diese Beschränkung wird
nicht durch unseren Webserver verursacht.</p>
</blockquote>
<p>Nachdem du die <code>while let</code>-Schleife in Kapitel 18 kennengelernt hast, fragst du
dich vielleicht, warum wir den Code für den <code>Worker</code>-Strang nicht geschrieben
haben, wie in Codeblock 21-21 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --abschneiden--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} hat einen Auftrag erhalten; führe ihn aus.");

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Codeblock 21-21: Eine alternative Implementierung von
<code>Worker::new</code> unter Verwendung von <code>while let</code></span></p>
<p>Dieser Code wird kompiliert und ausgeführt, führt aber nicht zum gewünschten
Strang-Verhalten: Eine langsame Anfrage führt immer noch dazu, dass andere
Anfragen auf ihre Bearbeitung warten. Der Grund dafür ist etwas subtil: Die
Struktur <code>Mutex</code> hat keine öffentliche Methode <code>unlock</code>, weil die
Eigentümerschaft der Sperre auf der Lebensdauer von <code>MutexGuard&lt;T&gt;</code> innerhalb
von <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> basiert, die die Methode <code>lock</code> zurückgibt. Zur
Kompilierzeit kann der Ausleihenprüfer (borrow checker) dann die Regel
durchsetzen, dass auf eine von einem <code>Mutex</code> bewachte Ressource nicht
zugegriffen werden kann, wenn wir die Sperre nicht halten. Diese
Implementierung kann aber auch dazu führen, dass die Sperre länger als
beabsichtigt gehalten wird, wenn wir nicht sorgfältig über die Lebensdauer von
<code>MutexGuard&lt;T&gt;</code> nachdenken.</p>
<p>Der Code in Codeblock 21-20, der <code>let job = receiver.lock().unwrap().recv().unwrap();</code> verwendet, funktioniert, weil mit
<code>let</code> alle temporären Werte, die in dem Ausdruck auf der rechten Seite des
Gleichheitszeichens verwendet werden, sofort verworfen werden, wenn die
<code>let</code>-Anweisung endet. Allerdings gibt <code>while let</code> (und <code>if let</code> und <code>match</code>)
temporäre Werte erst am Ende des zugehörigen Blocks frei. In Codeblock 21-21
bleibt die Sperre für die Dauer des Aufrufs von <code>job()</code> erhalten, was bedeutet,
dass andere <code>Worker</code>-Instanzen keine Aufträge erhalten können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kontrolliertes-beenden-und-aufräumen"><a class="header" href="#kontrolliertes-beenden-und-aufräumen">Kontrolliertes Beenden und Aufräumen</a></h2>
<p>Der Code in Codeblock 21-20 antwortet auf Anfragen asynchron durch die
Verwendung eines Strang-Vorrats (thread pool), wie von uns beabsichtigt. Wir
erhalten einige Warnungen über die Felder <code>workers</code>, <code>id</code> und <code>thread</code>, die wir
nicht direkt benutzen, was uns daran erinnert, dass wir nichts aufräumen. Wenn
wir die weniger elegante Methode <kbd>Strg</kbd>+<kbd>c</kbd> verwenden, um den
Hauptstrang (main thread) anzuhalten, werden auch alle anderen Stränge sofort
gestoppt, selbst wenn sie gerade dabei sind, eine Anfrage zu bedienen.</p>
<p>Als Nächstes werden wir das Merkmal (trait) <code>Drop</code> implementieren, um <code>join</code>
für jeden der Stränge im Vorrat aufzurufen, damit sie die Anfragen, an denen
sie arbeiten, vor dem Schließen beenden können. Dann werden wir einen Weg
implementieren, um den Strängen mitzuteilen, dass sie keine neuen Anfragen mehr
annehmen und herunterfahren sollen. Um diesen Code in Aktion zu sehen, werden
wir unseren Server so modifizieren, dass er nur zwei Anfragen annimmt, bevor er
seinen Strang-Vorrat kontrolliert herunterfährt.</p>
<h3 id="implementieren-des-merkmals-drop-auf-threadpool"><a class="header" href="#implementieren-des-merkmals-drop-auf-threadpool">Implementieren des Merkmals <code>Drop</code> auf <code>ThreadPool</code></a></h3>
<p>Lass uns damit beginnen, <code>Drop</code> auf unseren Strang-Vorrat zu implementieren.
Wenn der Vorrat aufgeräumt wird, sollten wir auf das Ende unsere Stränge
warten, um sicherzustellen, dass sie ihre Arbeit beenden. Codeblock 21-22 zeigt
einen ersten Versuch einer <code>Drop</code>-Implementierung; dieser Code wird noch nicht
ganz funktionieren.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!("Worker {} herunterfahren", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("Worker {id} hat einen Auftrag erhalten; führe ihn aus.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 21-22: Warten auf das Ende der einzelnen
Stränge, wenn der Strang-Vorrat den Gültigkeitsbereich verlässt</span></p>
<p>Zuerst iterieren wir über alle <code>workers</code> im Strang-Vorrat. Wir verwenden dafür
<code>&amp;mut</code>, weil <code>self</code> eine veränderbare Referenz ist und wir auch in der Lage
sein müssen, <code>worker</code> zu verändern. Für jeden <code>worker</code> geben wir eine Nachricht
aus, die besagt, dass diese bestimmte <code>worker</code>-Instanz heruntergefahren wird,
und dann rufen wir auf dem Strang dieser <code>worker</code>-Instanz <code>join</code> auf. Wenn der
Aufruf von <code>join</code> fehlschlägt, benutzen wir <code>unwrap</code>, um das Programm abstürzen
zu lassen.</p>
<p>Hier ist der Fehler, den wir erhalten, wenn wir diesen Code kompilieren:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
   |             |
   |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
   |
note: `JoinHandle::&lt;T&gt;::join` takes ownership of the receiver `self`, which moves `worker.thread`
  --&gt; /rustc/07dca489ac2d933c78d3c5158e3f43be/library/std/src/thread/mod.rs:1649:17

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>Der Fehler sagt uns, dass wir <code>join</code> nicht aufrufen können, weil wir nur eine
veränderbare Ausleihe von jedem <code>worker</code> haben und <code>join</code> die Eigentümerschaft
für sein Argument übernimmt. Um dieses Problem zu lösen, müssen wir den Strang
<code>thread</code> aus der <code>Worker</code>-Instanz herausnehmen, damit <code>join</code> den Strang
konsumieren kann. Eine Möglichkeit, dies zu tun, besteht darin, den gleichen
Ansatz wie in Codeblock 18-15 zu verfolgen. Wenn <code>Worker</code> ein
<code>Option&lt;Thread::JoinHandle&lt;()&gt;&gt;</code> hielte, könnten wir die Methode <code>take</code> auf
<code>Option</code> aufrufen, um den Wert aus der Variante <code>Some</code> herauszuverschieben und
eine Variante <code>None</code> an ihrer Stelle zu belassen. Mit anderen Worten, ein
<code>Worker</code>, der läuft, würde eine Variante <code>Some</code> in <code>thread</code> haben, und wenn wir
einen <code>Worker</code> aufräumen wollten, würden wir <code>Some</code> durch <code>None</code> ersetzen,
sodass der <code>Worker</code> keinen Strang zum Laufen haben würde.</p>
<p>Das <em>einzige</em> Mal, dass dies der Fall wäre, wäre, wenn man den <code>Worker</code>
aufräumt. Im Gegenzug müssten wir überall, wo wir auf <code>Worker.thread</code>
zugreifen, mit einer <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> umgehen. Idiomatisch
verwendet Rust <code>Option</code> ziemlich oft, aber wenn du etwas in <code>Option</code> einpackst,
von dem du weißt dass es immer vorhanden sein wird, ist es eine gute Idee, nach
alternativen Ansätzen zu suchen. Du könntest deinen Code sauberer und weniger
fehleranfällig machen.</p>
<p>In diesem Fall gibt es eine bessere Alternative: Die Methode <code>Vec::drain</code>. Sie
akzeptiert einen Bereichsparameter, um anzugeben, welche Elemente aus dem <code>Vec</code>
entfernt werden sollen, und gibt einen Iterator dieser Elemente zurück. Die
Angabe der Bereichssyntax <code>..</code> entfernt <em>alle</em> Werte aus dem <code>Vec</code>.</p>
<p>Wir müssen also die <code>drop</code>-Implementierung von <code>ThreadPool</code> wie folgt
aktualisieren:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in self.workers.drain(..) {
            println!("Worker {} herunterfahren", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || {
</span><span class="boring">            loop {
</span><span class="boring">                let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">                println!("Worker {id} hat einen Auftrag erhalten; führe ihn aus.");
</span><span class="boring">
</span><span class="boring">                job();
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>Dadurch wird der Compilerfehler behoben, und es sind keine weiteren Änderungen
an unserem Code erforderlich.</p>
<h3 id="den-strängen-signalisieren-nicht-mehr-nach-aufträgen-zu-lauschen"><a class="header" href="#den-strängen-signalisieren-nicht-mehr-nach-aufträgen-zu-lauschen">Den Strängen signalisieren, nicht mehr nach Aufträgen zu lauschen</a></h3>
<p>Mit all den Änderungen, die wir vorgenommen haben, lässt sich unser Code ohne
jede Warnung kompilieren. Aber die schlechte Nachricht ist, dass dieser Code
noch nicht so funktioniert, wie wir es uns wünschen. Der Schlüssel ist die
Logik in den Funktionsabschlüssen, die von den Strängen der <code>Worker</code>-Instanzen
ausgeführt werden: Im Moment rufen wir <code>join</code> auf, aber das wird die Stränge
nicht herunterfahren, weil sie sich in einer Endlosschleife auf der Suche nach
Aufträgen befinden. Wenn wir versuchen, unseren <code>ThreadPool</code> mit unserer
aktuellen Implementierung von <code>Drop</code> aufräumen zu lassen, wird der Hauptstrang
für immer blockieren und auf das Beenden des ersten Strangs warten.</p>
<p>Um dieses Problem zu beheben, brauchen wir eine Änderung in der Implementierung
von <code>drop</code> in <code>ThreadPool</code> und dann eine Änderung in der <code>Worker</code>-Schleife.</p>
<p>Zuerst ändern wir die Implementierung von <code>drop</code> in <code>ThreadPool</code>, um den
<code>sender</code> explizit zu aufzuräumen, bevor wir auf das Ende der Stränge warten.
Codeblock 21-23 zeigt die Änderungen an <code>ThreadPool</code>, um den <code>sender</code> explizit
aufzuräumen. Anders als beim Strang, <em>müssen</em> wir hier eine <code>Option</code> verwenden,
um den <code>sender</code> mit <code>Option::take</code> aus dem <code>ThreadPool</code> herausnehmen zu können.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}
// --abschneiden--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span>          // --abschneiden--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
<span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!("Worker {} herunterfahren", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">         
</span><span class="boring">            println!("Worker {id} got a job; executing.");
</span><span class="boring">         
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 21-23: <code>sender</code> vor dem Warten auf die
<code>Worker</code>-Stränge explizit aufräumen</span></p>
<p>Das Aufräumen von <code>sender</code> schließt den Kanal, was bedeutet, dass keine
weiteren Nachrichten gesendet werden. Wenn das passiert, geben alle Aufrufe
von <code>recv</code>, die die <code>Worker</code>-Instanzen in der Endlosschleife machen, einen
Fehler zurück. In Codeblock 21-24 ändern wir die <code>Worker</code>-Schleife so, dass die
Schleife in diesem Fall ordnungsgemäß beendet wird, was bedeutet, dass die
Stränge beendet werden, wenn die Implementierung von <code>drop</code> in <code>ThreadPool</code>
<code>join</code> für sie aufruft.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Message&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(Message::NewJob(job)).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!("Worker {} herunterfahren", worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            match receiver.lock().unwrap().recv() {
                Ok(job) =&gt; {
                    println!("Worker {id} hat einen Auftrag erhalten; führe ihn aus.");

                    job();
                }
                Err(_) =&gt; {
                    println!("Worker {id} nicht mehr verbunden, wird beendet.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p><span class="caption">Codeblock 21-24: Explizites Verlassen der Schleife, wenn
<code>recv</code> einen Fehler zurückgibt</span></p>
<p>Um diesen Code in Aktion zu sehen, modifizieren wir <code>main</code> so, dass nur zwei
Anfragen akzeptiert werden, bevor der Server kontrolliert heruntergefahren
wird, wie in Codeblock 21-25 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Fahre herunter.");
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 21-25: Herunterfahren des Servers, nachdem er
zwei Anfragen bearbeitet hat, durch Verlassen der Schleife</span></p>
<p>Du würdest nicht wollen, dass ein Webserver aus der realen Welt
heruntergefahren wird, nachdem er nur zwei Anfragen bearbeitet hat. Dieser Code
zeigt nur, dass das kontrollierte Herunterfahren und Aufräumen funktioniert.</p>
<p>Die Methode <code>take</code> ist im Merkmal <code>Iterator</code> definiert und beschränkt die
Iteration auf die ersten beiden Elemente. Der <code>ThreadPool</code> wird am Ende von
<code>main</code> den Gültigkeitsbereich verlassen und die <code>drop</code>-Implementierung
ausgeführt werden.</p>
<p>Starte den Server mit <code>cargo run</code> und stelle drei Anfragen. Die dritte Anfrage
sollte fehlerhaft sein und in deinem Terminal solltest du eine ähnliche Ausgabe
wie diese sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 hat einen Auftrag erhalten; führe ihn aus.
Fahre herunter.
Worker 0 herunterfahren
Worker 3 hat einen Auftrag erhalten; führe ihn aus.
Worker 1 nicht mehr verbunden, wird beendet.
Worker 2 nicht mehr verbunden, wird beendet.
Worker 3 nicht mehr verbunden, wird beendet.
Worker 0 nicht mehr verbunden, wird beendet.
Worker 1 herunterfahren
Worker 2 herunterfahren
Worker 3 herunterfahren
</code></pre>
<p>Möglicherweise siehst du eine andere Reihenfolge der <code>Worker</code>-IDs und der
ausgegebenen Nachrichten. Wir können anhand der Nachrichten sehen, wie dieser
Code funktioniert: Die <code>Worker</code> 0 und 3 haben die ersten beiden Anfragen
erhalten. Der Server hat nach der zweiten Verbindung aufgehört, Verbindungen
anzunehmen, und die <code>Drop</code>-Implementierung auf <code>ThreadPool</code> beginnt mit der
Ausführung, bevor <code>Worker</code> 3 überhaupt seinen Job beginnt. Wenn man den
<code>sender</code> aufräumt, werden alle <code>Worker</code>-Instanzen getrennt und angewiesen, sich
zu beenden. Die <code>Worker</code>-Instanzen geben jeweils eine Nachricht aus, wenn sie
die Verbindung trennen, und dann ruft der Strang-Vorrat <code>join</code> auf, um das Ende
jedes <code>Worker</code>-Strangs zu warten.</p>
<p>Beachte einen interessanten Aspekt diesem speziellen Programmlauf: Der
<code>ThreadPool</code> hat den <code>sender</code> aufgeräumt, und bevor ein <code>Worker</code> einen Fehler
erhalten hat, haben wir versucht, auf <code>Worker</code> 0 zu warten. <code>Worker</code> 0 hatte
noch keinen Fehler von <code>recv</code> erhalten, also blockierte der Hauptstrang und
wartete darauf, dass <code>Worker</code> 0 fertig wird. In der Zwischenzeit erhielt
<code>Worker</code> 3 einen Auftrag, und dann erhielten alle Stränge einen Fehler. Als
<code>Worker</code> 0 fertig war, wartete der Hauptstrang darauf, dass die restlichen
<code>Worker</code>-Instanzen fertig wurden. Zu diesem Zeitpunkt hatten sie alle ihre
Schleifen verlassen und konnten sich beenden.</p>
<p>Herzlichen Glückwunsch! Wir haben jetzt unser Projekt abgeschlossen; wir haben
einen einfachen Webserver, der einen Strang-Vorrat verwendet, um asynchron zu
antworten. Wir sind in der Lage, den Server kontrolliert herunterzufahren,
wodurch alle Stränge im Vorrat aufgeräumt werden.</p>
<p>Hier ist der vollständige Code als Referenz:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Fahre herunter.");
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Erzeuge einen neuen ThreadPool.
    ///
    /// Die Größe ist die Anzahl der Stränge im Vorrat.
    ///
    /// # Panics
    ///
    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!("Worker {} herunterfahren", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Ok(job) =&gt; {
                    println!("Worker {id} hat einen Auftrag erhalten; führe ihn aus.");

                    job();
                }
                Err(_) =&gt; {
                    println!("Worker {id} nicht mehr verbunden, wird beendet.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Wir könnten hier mehr tun! Wenn du dieses Projekt weiter verbessern willst,
findest du hier einige Ideen:</p>
<ul>
<li>Füge weitere Dokumentation zu <code>ThreadPool</code> und seinen öffentlichen Methoden
hinzu.</li>
<li>Füge Tests der Funktionalität der Bibliothek hinzu.</li>
<li>Ändere Aufrufe von <code>unwrap</code> in eine robustere Fehlerbehandlung.</li>
<li>Verwende <code>ThreadPool</code>, um eine andere Aufgabe als das Beantworten von
Web-Anfragen durchzuführen.</li>
<li>Suche eine Strang-Vorrats-Kiste auf <a href="https://crates.io/">crates.io</a> und
implementiere damit einen ähnlichen Webserver unter Verwendung der Kiste.
Vergleiche dann dessen API und Robustheit mit dem von uns implementierten
Strang-Vorrat.</li>
</ul>
<h2 id="zusammenfassung-20"><a class="header" href="#zusammenfassung-20">Zusammenfassung</a></h2>
<p>Gut gemacht! Du hast es bis ans Ende des Buchs geschafft! Wir möchten dir
danken, dass du uns auf dieser Tour durch Rust begleitet hast. Du bist nun
bereit, deine eigenen Rust-Projekte umzusetzen und bei den Projekten anderer zu
helfen. Denke daran, dass es eine gastfreundliche Gemeinschaft von anderen
Rust-Entwicklern gibt, die dir bei allen Herausforderungen, denen du auf deiner
Rust-Reise begegnest, gerne helfen würden.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anhang"><a class="header" href="#anhang">Anhang</a></h1>
<p>Die folgenden Abschnitte enthalten Referenzmaterial, das dir auf deiner
Rust-Reise nützlich sein könnten.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-a-schlüsselwörter"><a class="header" href="#anhang-a-schlüsselwörter">Anhang A: Schlüsselwörter</a></h2>
<p>Die folgende Liste enthält Schlüsselwörter, die für die gegenwärtige oder
zukünftige Verwendung durch die Sprache Rust reserviert sind. Als solche können
sie nicht als Bezeichner verwendet werden (außer als Roh-Bezeichner, die wir im
Abschnitt <a href="appendix-01-keywords.html#roh-bezeichner">„Roh-Bezeichner“</a> besprechen werden). Bezeichner
sind Namen von Funktionen, Variablen, Parametern, Strukturfeldern
(struct fields), Modulen, Kisten (crates), Konstanten, Makros, statischen
Werten, Attributen, Typen, Merkmalen (traits) und Lebensdauern (lifetimes).</p>
<h3 id="derzeit-verwendete-schlüsselwörter"><a class="header" href="#derzeit-verwendete-schlüsselwörter">Derzeit verwendete Schlüsselwörter</a></h3>
<p>Nachstehend findest du eine Liste der derzeit verwendeten Schlüsselwörter mit
einer Beschreibung ihrer Funktion.</p>
<ul>
<li><code>as</code> – primitive Typen umwandeln; ein spezifisches Merkmal mit einem
Element eindeutig machen; Elemente in <code>use</code>-Anweisungen umbenennen</li>
<li><code>async</code> – ein <code>Future</code> zurückgeben, anstatt den aktuellen Strang
(thread) zu blockieren</li>
<li><code>await</code> – Ausführung anhalten, bis das Ergebnis eines <code>Future</code> vorliegt</li>
<li><code>break</code> – Schleife sofort verlassen</li>
<li><code>const</code> – konstante Elemente oder konstante Roh-Referenzen definieren</li>
<li><code>continue</code> – weiter zur nächsten Schleifeniteration</li>
<li><code>crate</code> – in einem Modulpfad verweist auf das Stammverzeichnis der Kiste (crate)</li>
<li><code>dyn</code> – dynamischer Aufruf (dispatch) eines Merkmalsobjekts (trait
object)</li>
<li><code>else</code> – Ersatzkontrollflusszweig bei <code>if</code> und <code>if let</code></li>
<li><code>enum</code> – eine Aufzählung (enumeration) definieren</li>
<li><code>extern</code> – externe Funktion oder Variable verlinken</li>
<li><code>false</code> – Boolesches Literal für „falsch“</li>
<li><code>fn</code> – Funktion oder Funktionsreferenztyp definieren</li>
<li><code>for</code> – wiederhole über Elemente einer Iteration; ein Merkmal (trait)
implementieren; eine höherrangige Lebensdauer angeben</li>
<li><code>if</code> – Verzweigen abhängig vom Ergebnis eines Bedingungsausdrucks</li>
<li><code>impl</code> – Implementieren einer inhärenten oder Merkmalsfunktionalität
(trait functionality)</li>
<li><code>in</code> – Teil der <code>for</code>-Schleifensyntax</li>
<li><code>let</code> – eine Variable binden</li>
<li><code>loop</code> – wiederhole bedingungslos</li>
<li><code>match</code> – einen Wert mit Muster abgleichen</li>
<li><code>mod</code> – ein Modul definieren</li>
<li><code>move</code> – Funktionsabschluss (closure) übernimmt Eigentümerschaft
(ownership) all seiner Parameter</li>
<li><code>mut</code> – Referenzen, Roh-Referenzen und Variablenbindungen als
veränderbar kennzeichnen</li>
<li><code>pub</code> – Strukturfelder (struct fields), <code>impl</code>-Blöcke und Module als
öffentlich sichtbar kennzeichnen</li>
<li><code>ref</code> – als Referenz binden</li>
<li><code>return</code> – aus Funktion zurückkehren</li>
<li><code>Self</code> – Typ-Alias für den zu definierenden oder implementierenden Typ</li>
<li><code>self</code> – Methoden-Instanzobjekt; aktuelles Modul</li>
<li><code>static</code> – globale Variable oder Lebensdauer während der gesamten
Programmausführung</li>
<li><code>struct</code> – eine Struktur definieren</li>
<li><code>super</code> – Elternmodul des aktuellen Moduls</li>
<li><code>trait</code> – ein Merkmal (trait) definieren</li>
<li><code>true</code> – Boolesches Literal für „wahr“</li>
<li><code>type</code> – einen Typ-Alias oder assoziierten Typ definieren</li>
<li><code>union</code> – eine <a href="https://doc.rust-lang.org/reference/items/unions.html">Vereinigung (union)</a> definieren; ist nur ein
Schlüsselwort innerhalb einer Vereinigungdeklaration</li>
<li><code>unsafe</code> – Code, Funktionen, Merkmale (traits) und Implementierungen
als unsicher kennzeichnen</li>
<li><code>use</code> – Symbole in den Gültigkeitsbereich bringen; genaue Spezifikation
von generischen und Lebensdauer-Grenzen</li>
<li><code>where</code> – Klauseln zur Typabgrenzung angeben</li>
<li><code>while</code> – wiederhole abhängig vom Ergebnis eines Bedingungsausdrucks</li>
</ul>
<h3 id="schlüsselwörter-reserviert-für-zukünftige-verwendung"><a class="header" href="#schlüsselwörter-reserviert-für-zukünftige-verwendung">Schlüsselwörter reserviert für zukünftige Verwendung</a></h3>
<p>Die folgenden Schlüsselwörter haben noch keine Funktionalität, sondern sind von
Rust für eine mögliche zukünftige Verwendung reserviert.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>gen</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="roh-bezeichner"><a class="header" href="#roh-bezeichner">Roh-Bezeichner</a></h3>
<p><em>Roh-Bezeichner</em> (raw identifiers) sind eine Syntax, die es dir ermöglicht,
Schlüsselwörter dort zu verwenden, wo sie normalerweise nicht erlaubt wären. Du
verwendest einen Roh-Bezeichner, indem du einem Schlüsselwort das Präfix <code>r#</code>
voranstellst.</p>
<p>Zum Beispiel ist <code>match</code> ein Schlüsselwort. Versuche, folgende Funktion zu
kompilieren, die <code>match</code> als Namen benutzt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
<span class="boring">}</span></code></pre></pre>
<p>Dann erhältst du diesen Fehler:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>Der Fehler zeigt, dass du das Schlüsselwort <code>match</code> nicht als
Funktionsbezeichner verwenden kannst. Um <code>match</code> als Funktionsnamen zu
verwenden, musst du die Syntax für Roh-Bezeichner wie folgt verwenden:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}</code></pre></pre>
<p>Dieser Code lässt sich fehlerfrei kompilieren. Beachte das <code>r#</code>-Präfix im
Funktionsnamen in seiner Definition sowie an der Stelle, an der die Funktion in
<code>main</code> aufgerufen wird.</p>
<p>Roh-Bezeichner erlauben es dir, jedes beliebige Wort als Bezeichner zu
verwenden, auch wenn dieses Wort ein reserviertes Schlüsselwort ist. Dies gibt
uns mehr Freiheit bei der Wahl der Bezeichner und ermöglicht uns die
Integration in Programme, die in einer Sprache geschrieben wurden, in der diese
Wörter keine Schlüsselwörter sind. Darüber hinaus ermöglicht dir der
Roh-Bezeichner das Verwenden von Bibliotheken, die in einer anderen
Rust-Ausgabe, als deine Kiste verwendet, geschrieben wurden. Zum Beispiel ist
<code>try</code> in Ausgabe 2015 kein Schlüsselwort, in den Ausgaben 2018, 2021 und 2024
aber schon. Wenn du auf eine Bibliothek angewiesen bist, die mit Ausgabe 2015
geschrieben wurde und eine Funktion <code>try</code> hat, musst du die
Roh-Bezeichner-Syntax verwenden, in diesem Fall <code>r#try</code>, um diese Funktion von
deinem Code in einer neueren Ausgabe aus aufzurufen. Siehe <a href="appendix-05-editions.html">Anhang
E</a> für weitere Informationen zu Ausgaben.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-b-operatoren-und-symbole"><a class="header" href="#anhang-b-operatoren-und-symbole">Anhang B: Operatoren und Symbole</a></h2>
<p>Dieser Anhang enthält ein Glossar der Rust-Syntax, einschließlich Operatoren
und anderer Symbole, die allein oder im Zusammenhang mit Pfaden, generischen
Datentypen (generics), Merkmalsabgrenzungen (trait bounds), Makros, Attributen,
Kommentaren, Tupeln und Klammern auftreten.</p>
<h3 id="operatoren"><a class="header" href="#operatoren">Operatoren</a></h3>
<p>Tabelle B-1 enthält die Operatoren in Rust, ein Beispiel, wie der Operator im
Kontext erscheinen würde, eine kurze Erklärung und ob dieser Operator überladen
werden kann. Wenn ein Operator überladen werden kann, wird das relevante
Merkmal (trait) aufgeführt, mit dem dieser Operator überladen werden kann.</p>
<p><span class="caption">Tabelle B-1: Operatoren</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Operator</th><th style="text-align: left">Beispiel</th><th style="text-align: left">Erklärung</th><th style="text-align: left">Überladbar?</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>!</code></td><td style="text-align: left"><code>ident!(...)</code>,<br> <code>ident!{...}</code>,<br> <code>ident![...]</code></td><td style="text-align: left">Makro-Expansion</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>!</code></td><td style="text-align: left"><code>!expr</code></td><td style="text-align: left">Bitweises oder logisches Komplement</td><td style="text-align: left"><code>Not</code></td></tr>
<tr><td style="text-align: left"><code>!=</code></td><td style="text-align: left"><code>expr != expr</code></td><td style="text-align: left">Vergleich auf Ungleichheit</td><td style="text-align: left"><code>PartialEq</code></td></tr>
<tr><td style="text-align: left"><code>%</code></td><td style="text-align: left"><code>expr % expr</code></td><td style="text-align: left">Arithmetischer Restbetrag</td><td style="text-align: left"><code>Rem</code></td></tr>
<tr><td style="text-align: left"><code>%=</code></td><td style="text-align: left"><code>var %= expr</code></td><td style="text-align: left">Arithmetischer Restbetrag und Zuweisung</td><td style="text-align: left"><code>RemAssign</code></td></tr>
<tr><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left"><code>&amp;expr</code>,<br> <code>&amp;mut expr</code></td><td style="text-align: left">Ausleihe</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left"><code>&amp;type</code>,<br> <code>&amp;mut type</code>,<br> <code>&amp;'a type</code>,<br> <code>&amp;'a mut type</code></td><td style="text-align: left">Ausleih-Referenz-Typ</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left"><code>expr &amp; expr</code></td><td style="text-align: left">Bitweises UND</td><td style="text-align: left"><code>BitAnd</code></td></tr>
<tr><td style="text-align: left"><code>&amp;=</code></td><td style="text-align: left"><code>var &amp;= expr</code></td><td style="text-align: left">Bitweises UND und Zuweisung</td><td style="text-align: left"><code>BitAndAssign</code></td></tr>
<tr><td style="text-align: left"><code>&amp;&amp;</code></td><td style="text-align: left"><code>expr &amp;&amp; expr</code></td><td style="text-align: left">Logisches UND mit Kurzschlussauswertung</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left"><code>expr * expr</code></td><td style="text-align: left">Arithmetische Multiplikation</td><td style="text-align: left"><code>Mul</code></td></tr>
<tr><td style="text-align: left"><code>*=</code></td><td style="text-align: left"><code>var *= expr</code></td><td style="text-align: left">Arithmetische Multiplikation und Zuweisung</td><td style="text-align: left"><code>MulAssign</code></td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left"><code>*expr</code></td><td style="text-align: left">Dereferenzierung</td><td style="text-align: left"><code>Deref</code></td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left"><code>*const type</code>,<br> <code>*mut type</code></td><td style="text-align: left">Roh-Referenz</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>+</code></td><td style="text-align: left"><code>trait + trait</code>,<br> <code>'a + trait</code></td><td style="text-align: left">Verbundtypabgrenzung</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>+</code></td><td style="text-align: left"><code>expr + expr</code></td><td style="text-align: left">Arithmetische Addition</td><td style="text-align: left"><code>Add</code></td></tr>
<tr><td style="text-align: left"><code>+=</code></td><td style="text-align: left"><code>var += expr</code></td><td style="text-align: left">Arithmetische Addition und Zuweisung</td><td style="text-align: left"><code>AddAssign</code></td></tr>
<tr><td style="text-align: left"><code>,</code></td><td style="text-align: left"><code>expr, expr</code></td><td style="text-align: left">Argument- und Elementseparator</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>-</code></td><td style="text-align: left"><code>- expr</code></td><td style="text-align: left">Arithmetische Negation</td><td style="text-align: left"><code>Neg</code></td></tr>
<tr><td style="text-align: left"><code>-</code></td><td style="text-align: left"><code>expr - expr</code></td><td style="text-align: left">Arithmetische Subtraktion</td><td style="text-align: left"><code>Sub</code></td></tr>
<tr><td style="text-align: left"><code>-=</code></td><td style="text-align: left"><code>var -= expr</code></td><td style="text-align: left">Arithmetische Subtraktion und Zuweisung</td><td style="text-align: left"><code>SubAssign</code></td></tr>
<tr><td style="text-align: left"><code>-&gt;</code></td><td style="text-align: left"><code>fn(...) -&gt; type</code>,<br> <code>|...| -&gt; type</code></td><td style="text-align: left">Funktion und Funktionsabschlussrückgabetyp</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>.</code></td><td style="text-align: left"><code>expr.ident</code></td><td style="text-align: left">Feldzugriff</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>.</code></td><td style="text-align: left"><code>expr.ident(expr, ...)</code></td><td style="text-align: left">Methodenaufruf</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>.</code></td><td style="text-align: left"><code>expr.0</code>, <code>expr.1</code>, etc.</td><td style="text-align: left">Tupel-Indexzugriff</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>..</code></td><td style="text-align: left"><code>..</code>,<br> <code>expr..</code>,<br> <code>..expr</code>,<br> <code>expr..expr</code></td><td style="text-align: left">Rechts-ausschließendes Bereichsliteral</td><td style="text-align: left"><code>PartialOrd</code></td></tr>
<tr><td style="text-align: left"><code>..=</code></td><td style="text-align: left"><code>..=expr</code>,<br> <code>expr..=expr</code></td><td style="text-align: left">Rechts-einschließendes Bereichsliteral</td><td style="text-align: left"><code>PartialOrd</code></td></tr>
<tr><td style="text-align: left"><code>..</code></td><td style="text-align: left"><code>..expr</code></td><td style="text-align: left">Aktualisierungssyntax für Strukturliterale</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>..</code></td><td style="text-align: left"><code>variant(x, ..)</code>,<br> <code>struct_type { x, .. }</code></td><td style="text-align: left">„Und der Rest“-Musterbindung</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>...</code></td><td style="text-align: left"><code>expr...expr</code></td><td style="text-align: left">(Veraltet, verwende stattdessen <code>..=</code>) In einem Muster: inklusives Bereichsmuster</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>/</code></td><td style="text-align: left"><code>expr / expr</code></td><td style="text-align: left">Arithmetische Division</td><td style="text-align: left"><code>Div</code></td></tr>
<tr><td style="text-align: left"><code>/=</code></td><td style="text-align: left"><code>var /= expr</code></td><td style="text-align: left">Arithmetische Division und Zuweisung</td><td style="text-align: left"><code>DivAssign</code></td></tr>
<tr><td style="text-align: left"><code>:</code></td><td style="text-align: left"><code>pat: type</code>,<br> <code>ident: type</code></td><td style="text-align: left">Typabgrenzung</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>:</code></td><td style="text-align: left"><code>ident: expr</code></td><td style="text-align: left">Struktur-Feld-Initialisierer</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>:</code></td><td style="text-align: left"><code>'a: loop {...}</code></td><td style="text-align: left">Schleifen-Label</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>;</code></td><td style="text-align: left"><code>expr;</code></td><td style="text-align: left">Anweisungs- und Element-Endezeichen</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>;</code></td><td style="text-align: left"><code>[...; len]</code></td><td style="text-align: left">Syntaxteil für Array fester Größe</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>&lt;&lt;</code></td><td style="text-align: left"><code>expr &lt;&lt; expr</code></td><td style="text-align: left">Bitweise Links-Schiebung</td><td style="text-align: left"><code>Shl</code></td></tr>
<tr><td style="text-align: left"><code>&lt;&lt;=</code></td><td style="text-align: left"><code>var &lt;&lt;= expr</code></td><td style="text-align: left">Bitweise Links-Schiebung und Zuweisung</td><td style="text-align: left"><code>ShlAssign</code></td></tr>
<tr><td style="text-align: left"><code>&lt;</code></td><td style="text-align: left"><code>expr &lt; expr</code></td><td style="text-align: left">Kleiner-als-Vergleich</td><td style="text-align: left"><code>PartialOrd</code></td></tr>
<tr><td style="text-align: left"><code>&lt;=</code></td><td style="text-align: left"><code>expr &lt;= expr</code></td><td style="text-align: left">Kleiner-gleich-Vergleich</td><td style="text-align: left"><code>PartialOrd</code></td></tr>
<tr><td style="text-align: left"><code>=</code></td><td style="text-align: left"><code>var = expr</code>,<br> <code>ident = type</code></td><td style="text-align: left">Zuweisung/Äquivalenz</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>==</code></td><td style="text-align: left"><code>expr == expr</code></td><td style="text-align: left">Gleichheitsvergleich</td><td style="text-align: left"><code>PartialEq</code></td></tr>
<tr><td style="text-align: left"><code>=&gt;</code></td><td style="text-align: left"><code>pat =&gt; expr</code></td><td style="text-align: left">Teilsyntax im Abgleichs-Zweig (match arm)</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>&gt;</code></td><td style="text-align: left"><code>expr &gt; expr</code></td><td style="text-align: left">Größer-als-Vergleich</td><td style="text-align: left"><code>PartialOrd</code></td></tr>
<tr><td style="text-align: left"><code>&gt;=</code></td><td style="text-align: left"><code>expr &gt;= expr</code></td><td style="text-align: left">Größer-gleich-Vergleich</td><td style="text-align: left"><code>PartialOrd</code></td></tr>
<tr><td style="text-align: left"><code>&gt;&gt;</code></td><td style="text-align: left"><code>expr &gt;&gt; expr</code></td><td style="text-align: left">Bitweise Rechts-Schiebung</td><td style="text-align: left"><code>Shr</code></td></tr>
<tr><td style="text-align: left"><code>&gt;&gt;=</code></td><td style="text-align: left"><code>var &gt;&gt;= expr</code></td><td style="text-align: left">Bitweise Rechts-Schiebung und Zuweisung</td><td style="text-align: left"><code>ShrAssign</code></td></tr>
<tr><td style="text-align: left"><code>@</code></td><td style="text-align: left"><code>ident @ pat</code></td><td style="text-align: left">Muster-Bindung</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>^</code></td><td style="text-align: left"><code>expr ^ expr</code></td><td style="text-align: left">Bitweises exklusives ODER</td><td style="text-align: left"><code>BitXor</code></td></tr>
<tr><td style="text-align: left"><code>^=</code></td><td style="text-align: left"><code>var ^= expr</code></td><td style="text-align: left">Bitweises exklusives ODER und Zuweisung</td><td style="text-align: left"><code>BitXorAssign</code></td></tr>
<tr><td style="text-align: left"><code>|</code></td><td style="text-align: left"><code>pat | pat</code></td><td style="text-align: left">Muster-Alternativen</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>|</code></td><td style="text-align: left"><code>expr | expr</code></td><td style="text-align: left">Bitweises ODER</td><td style="text-align: left"><code>BitOr</code></td></tr>
<tr><td style="text-align: left"><code>|=</code></td><td style="text-align: left"><code>var |= expr</code></td><td style="text-align: left">Bitweises ODER und Zuweisung</td><td style="text-align: left"><code>BitOrAssign</code></td></tr>
<tr><td style="text-align: left"><code>||</code></td><td style="text-align: left"><code>expr || expr</code></td><td style="text-align: left">Logisches ODER mit Kurzschlussauswertung</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>?</code></td><td style="text-align: left"><code>expr?</code></td><td style="text-align: left">Fehler-Weitergabe</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<h3 id="nicht-operator-symbole"><a class="header" href="#nicht-operator-symbole">Nicht-Operator-Symbole</a></h3>
<p>Die folgende Liste enthält alle Symbole, die nicht als Operatoren fungieren,
d.h. sich nicht wie ein Funktions- oder Methodenaufruf verhalten.</p>
<p>Tabelle B-2 zeigt Symbole, die für sich allein stehen und an verschiedenen
Stellen gültig sind.</p>
<p><span class="caption">Tabelle B-2: Eigenständige Syntax</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>'ident</code></td><td style="text-align: left">Benannte Lebensdauer oder Schleifenbeschriftung</td></tr>
<tr><td style="text-align: left"><code>...u8</code>,<br> <code>...i32</code>,<br> <code>...f64</code>,<br> <code>...usize</code><br> usw.</td><td style="text-align: left">Numerisches Literal eines bestimmten Typs</td></tr>
<tr><td style="text-align: left"><code>"..."</code></td><td style="text-align: left">Zeichenketten-Literal</td></tr>
<tr><td style="text-align: left"><code>r"..."</code>,<br> <code>r#"..."#</code>,<br> <code>r##"..."##</code><br> usw.</td><td style="text-align: left">Roh-Zeichenketten-Literal, Escape-Zeichen werden nicht verarbeitet</td></tr>
<tr><td style="text-align: left"><code>b"..."</code></td><td style="text-align: left">Byte-Zeichenkettenliteral, erzeugt ein Byte-Array anstelle einer Zeichenkette</td></tr>
<tr><td style="text-align: left"><code>br"..."</code>,<br> <code>br#"..."#</code>,<br> <code>br##"..."##</code><br> usw.</td><td style="text-align: left">Roh-Byte-Zeichenkettenliteral, Kombination aus Roh- und Byte-Zeichenkettenliteral</td></tr>
<tr><td style="text-align: left"><code>'...'</code></td><td style="text-align: left">Zeichen-Literal</td></tr>
<tr><td style="text-align: left"><code>b'...'</code></td><td style="text-align: left">ASCII-Byte-Literal</td></tr>
<tr><td style="text-align: left"><code>|...| expr</code></td><td style="text-align: left">Funktionsabschluss (closure)</td></tr>
<tr><td style="text-align: left"><code>!</code></td><td style="text-align: left">Leerer Typ (bottom type) für nicht-endende Funktionen</td></tr>
<tr><td style="text-align: left"><code>_</code></td><td style="text-align: left">Musterbindung für „sonstige“; wird auch verwendet, um Ganzzahl-Literale lesbar zu machen</td></tr>
</tbody></table>
</div>
<p>Tabelle B-3 zeigt Symbole, die im Zusammenhang mit Pfaden für die
Modulhierarchie eines Elements vorkommen.</p>
<p><span class="caption">Tabelle B-3: Pfad-bezogene Syntax</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ident::ident</code></td><td style="text-align: left">Namensraum-Pfad</td></tr>
<tr><td style="text-align: left"><code>::path</code></td><td style="text-align: left">Pfad relativ zum externen Präludium, auf dem alle anderen Kisten basieren<br> (d.h. ein explizit absoluter Pfad inklusive Kistenname)</td></tr>
<tr><td style="text-align: left"><code>self::path</code></td><td style="text-align: left">Pfad relativ zum aktuellen Modul<br> (d.h. ein explizit relativer Pfad)</td></tr>
<tr><td style="text-align: left"><code>super::path</code></td><td style="text-align: left">Pfad relativ zum Elternmodul</td></tr>
<tr><td style="text-align: left"><code>type::ident</code>,<br> <code>&lt;type as trait&gt;::ident</code></td><td style="text-align: left">Zugehörige Konstanten, Funktionen<br> und Typen</td></tr>
<tr><td style="text-align: left"><code>&lt;type&gt;::...</code></td><td style="text-align: left">Zugehöriges Element für einen Typ,<br> der nicht direkt benannt werden kann<br> (z.B. <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;:::...</code> usw.)</td></tr>
<tr><td style="text-align: left"><code>trait::method(...)</code></td><td style="text-align: left">Methodenaufruf durch Angeben des<br> Merkmals eindeutig machen</td></tr>
<tr><td style="text-align: left"><code>type::method(...)</code></td><td style="text-align: left">Methodenaufruf durch Angeben des<br> Typs eindeutig machen</td></tr>
<tr><td style="text-align: left"><code>&lt;type as trait&gt;::method(...)</code></td><td style="text-align: left">Methodenaufruf durch Angeben des<br> Merkmals und Typs eindeutig machen</td></tr>
</tbody></table>
</div>
<p>Tabelle B-4 zeigt Symbole, die im Zusammenhang mit generischen Typparametern
auftreten.</p>
<p><span class="caption">Tabelle B-4: Generische Datentypen</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>path&lt;...&gt;</code></td><td style="text-align: left">Spezifiziert Parameter zum generischen Typ in einem Typ (z.B. <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td style="text-align: left"><code>path::&lt;...&gt;</code>,<br> <code>method::&lt;...&gt;</code></td><td style="text-align: left">Spezifiziert Parameter zu einem generischen Typ, einer Funktion oder Methode in einem Ausdruck; oft als „turbofish“ bezeichnet (z.B. <code>"42".parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td style="text-align: left"><code>fn ident&lt;...&gt; ...</code></td><td style="text-align: left">Generische Funktion definieren</td></tr>
<tr><td style="text-align: left"><code>struct ident&lt;...&gt; ...</code></td><td style="text-align: left">Generische Struktur definieren</td></tr>
<tr><td style="text-align: left"><code>enum ident&lt;...&gt; ...</code></td><td style="text-align: left">Generische Aufzählung definieren</td></tr>
<tr><td style="text-align: left"><code>impl&lt;...&gt; ...</code></td><td style="text-align: left">Generische Implementierung definieren</td></tr>
<tr><td style="text-align: left"><code>for&lt;...&gt; type</code></td><td style="text-align: left">Höherstufige Lebensdauerbegrenzungen</td></tr>
<tr><td style="text-align: left"><code>type&lt;ident=type&gt;</code></td><td style="text-align: left">Generischer Typ, bei dem ein oder mehrere assoziierte Typen bestimmte Zuordnungen haben (z.B. <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div>
<p>Tabelle B-5 zeigt Symbole, die im Zusammenhang mit generischen Typparametern
mit Merkmalsabgrenzung (trait bounds) auftreten.</p>
<p><span class="caption">Tabelle B-5: Merkmalsabgrenzungen</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>T: U</code></td><td style="text-align: left">Generischer Parameter <code>T</code>, beschränkt auf Typen,<br> die <code>U</code> implementieren</td></tr>
<tr><td style="text-align: left"><code>T: 'a</code></td><td style="text-align: left">Generischer Typ <code>T</code>, der die Lebensdauer <code>'a</code> überdauert<br> (d.h. der Typ darf transitiv keine Referenzen mit einer<br> kürzeren Lebensdauer als <code>'a</code> enthalten)</td></tr>
<tr><td style="text-align: left"><code>T: 'static</code></td><td style="text-align: left">Generischer Typ <code>T</code> mit Lebensdauer <code>'static</code></td></tr>
<tr><td style="text-align: left"><code>'b: 'a</code></td><td style="text-align: left">Generische Lebensdauer <code>'b</code>, muss Lebensdauer <code>'a</code> überdauern</td></tr>
<tr><td style="text-align: left"><code>T: ?Sized</code></td><td style="text-align: left">Erlaube einen generischen Typparameter, der ein<br> dynamisch dimensionierter Typ ist</td></tr>
<tr><td style="text-align: left"><code>'a + trait</code>,<br> <code>trait + trait</code></td><td style="text-align: left">Zusammengesetzte Typabgrenzung</td></tr>
</tbody></table>
</div>
<p>Tabelle B-6 zeigt Symbole, die im Zusammenhang mit dem Aufruf oder der
Definition von Makros und der Angabe von Attributen an einem Element
vorkommen.</p>
<p><span class="caption">Tabelle B-6: Makros und Attribute</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>#[meta]</code></td><td style="text-align: left">Äußeres Attribut</td></tr>
<tr><td style="text-align: left"><code>#![meta]</code></td><td style="text-align: left">Inneres Attribut</td></tr>
<tr><td style="text-align: left"><code>$ident</code></td><td style="text-align: left">Makro-Ersetzung</td></tr>
<tr><td style="text-align: left"><code>$ident:kind</code></td><td style="text-align: left">Makro-Erfassung</td></tr>
<tr><td style="text-align: left"><code>$(…)…</code></td><td style="text-align: left">Makro-Wiederholung</td></tr>
<tr><td style="text-align: left"><code>ident!(...)</code>,<br> <code>ident!{...}</code>,<br> <code>ident![...]</code></td><td style="text-align: left">Makro-Aufruf</td></tr>
</tbody></table>
</div>
<p>Tabelle B-7 zeigt Symbole, die Kommentare erzeugen.</p>
<p><span class="caption">Tabelle B-7: Kommentare</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>//</code></td><td style="text-align: left">Einzeiliger Kommentar</td></tr>
<tr><td style="text-align: left"><code>//!</code></td><td style="text-align: left">Einzeiliger Dokumentationskommentar innen</td></tr>
<tr><td style="text-align: left"><code>///</code></td><td style="text-align: left">Einzeiliger Dokumentationskommentar außen</td></tr>
<tr><td style="text-align: left"><code>/*...*/</code></td><td style="text-align: left">Block-Kommentar</td></tr>
<tr><td style="text-align: left"><code>/*!...*/</code></td><td style="text-align: left">Mehrzeiliger Dokumentationskommentar innen</td></tr>
<tr><td style="text-align: left"><code>/**...*/</code></td><td style="text-align: left">Mehrzeiliger Dokumentationskommentar außen</td></tr>
</tbody></table>
</div>
<p>Tabelle B-8 zeigt die Kontexte, in denen Klammern verwendet werden.</p>
<p><span class="caption">Tabelle B-8: Klammern</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>()</code></td><td style="text-align: left">Leeres Tupel (auch Einheit (unit) genannt), Literal und Typ</td></tr>
<tr><td style="text-align: left"><code>(expr)</code></td><td style="text-align: left">Eingeklammerter Ausdruck</td></tr>
<tr><td style="text-align: left"><code>(expr,)</code></td><td style="text-align: left">Ein-Element-Tupel-Ausdruck</td></tr>
<tr><td style="text-align: left"><code>(type,)</code></td><td style="text-align: left">Ein-Element-Tupel-Typ</td></tr>
<tr><td style="text-align: left"><code>(expr, ...)</code></td><td style="text-align: left">Tupel-Ausdruck</td></tr>
<tr><td style="text-align: left"><code>(type, ...)</code></td><td style="text-align: left">Tupel-Typ</td></tr>
<tr><td style="text-align: left"><code>expr(expr, ...)</code></td><td style="text-align: left">Funktionsaufruf-Ausdruck; wird auch zur Initialisierung von Tupel-Strukturen und Tupel-Aufzählungs-Varianten verwendet</td></tr>
</tbody></table>
</div>
<p>Tabelle B-9 zeigt die Kontexte, in denen geschweifte Klammern verwendet werden.</p>
<p><span class="caption">Tabelle B-9: Geschweifte Klammern</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Context</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>{...}</code></td><td style="text-align: left">Block-Ausdruck</td></tr>
<tr><td style="text-align: left"><code>Type {...}</code></td><td style="text-align: left"><code>struct</code>-Literal</td></tr>
</tbody></table>
</div>
<p>Tabelle B-10 zeigt die Kontexte, in denen eckige Klammern verwendet werden.</p>
<p><span class="caption">Tabelle B-10: Eckige Klammern</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Context</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>[...]</code></td><td style="text-align: left">Array-Literal</td></tr>
<tr><td style="text-align: left"><code>[expr; len]</code></td><td style="text-align: left">Array-Literal mit <code>len</code> Kopien von <code>expr</code></td></tr>
<tr><td style="text-align: left"><code>[type; len]</code></td><td style="text-align: left">Array-Typ mit <code>len</code> Instanzen von <code>type</code></td></tr>
<tr><td style="text-align: left"><code>expr[expr]</code></td><td style="text-align: left">Sammlungs-Indexierung, ist überladbar (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td style="text-align: left"><code>expr[..]</code>,<br> <code>expr[a..]</code>,<br> <code>expr[..b]</code>,<br> <code>expr[a..b]</code></td><td style="text-align: left">Sammlungs-Indexierung, die wie ein Sammlungsanteil aussieht, unter Verwendung von <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code> oder <code>RangeFull</code> als „Index“</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-c-ableitbare-merkmale-traits"><a class="header" href="#anhang-c-ableitbare-merkmale-traits">Anhang C: Ableitbare Merkmale (traits)</a></h2>
<p>An verschiedenen Stellen im Buch haben wir das Attribut <code>derive</code> besprochen,
das du auf eine Struktur- oder Aufzählungsdefinition anwenden kannst. Das
Attribut <code>derive</code> generiert Code, der ein Merkmal (trait) mit seiner eigenen
Standard-Implementierung auf dem Typ implementiert, den du mit der
<code>derive</code>-Syntax annotiert hast.</p>
<p>In diesem Anhang findest du eine Referenz aller Merkmale in der
Standardbibliothek, die du mit <code>derive</code> verwenden kannst. Jeder Abschnitt
umfasst:</p>
<ul>
<li>Welche Operatoren und Methoden nach Ableiten dieses Merkmals ermöglicht
werden</li>
<li>Was die Implementierung des durch <code>derive</code> bereitgestellten Merkmals bewirkt</li>
<li>Was die Implementierung des Merkmals über den Typ aussagt</li>
<li>Die Bedingungen, unter denen du das Merkmal implementieren darfst oder nicht</li>
<li>Beispiele für Operationen, die dieses Merkmal erfordern</li>
</ul>
<p>Wenn du ein anderes Verhalten wünschst als das, das durch das Attribut <code>derive</code>
bereitgestellt wird, schaue in die <a href="https://doc.rust-lang.org/std/index.html">Standardbibliotheksdokumentation</a>
zu den Merkmalen, um zu erfahren, wie sie manuell implementiert werden können.</p>
<p>Die hier aufgelisteten Merkmale sind die einzigen, die von der
Standardbibliothek definiert werden und die mit <code>derive</code> in deinen Typen
implementiert werden können. Andere in der Standardbibliothek definierte
Merkmale haben kein sinnvolles Standardverhalten, sodass es an dir liegt, sie
so zu implementieren, wie es für dein Vorhaben sinnvoll ist.</p>
<p>Ein Beispiel für ein Merkmal, das nicht abgeleitet werden kann, ist <code>Display</code>,
das die Formatierung für Endbenutzer übernimmt. Du solltest immer eine
geeignete Art und Weise in Betracht ziehen, einen Typ für einen Endbenutzer
anzuzeigen. Welche Teile des Typs sollte ein Endbenutzer sehen dürfen? Welche
Teile würden sie für relevant halten? Welches Datenformat wäre für sie am
relevantesten? Der Rust-Compiler verfügt nicht über dieses Wissen, sodass er
kein angemessenes Standardverhalten für dich bereitstellen kann.</p>
<p>Die Liste der ableitbaren Merkmale in diesem Anhang ist nicht vollständig:
Bibliotheken können <code>derive</code> für ihre eigenen Merkmale implementieren, sodass
die Liste der Merkmale, die du mit <code>derive</code> verwenden kannst, wahrlich
unbegrenzt ist. Das Implementieren von <code>derive</code> verwendet ein prozedurales
Makro, das im Abschnitt <a href="ch20-05-macros.html">„Makros“</a> in Kapitel 20 behandelt wird.</p>
<h3 id="debug-für-die-programmierer-ausgabe"><a class="header" href="#debug-für-die-programmierer-ausgabe"><code>Debug</code> für die Programmierer-Ausgabe</a></h3>
<p>Das Merkmal <code>Debug</code> ermöglicht das Debuggen von Formatierungen in
Formatierungszeichenketten, die du durch Angeben von <code>:?</code> innerhalb Platzhalter
<code>{}</code> angibst.</p>
<p>Das Merkmal <code>Debug</code> erlaubt es dir, Instanzen eines Typs zu Debugging-Zwecken
auszugeben, sodass du und andere Programmierer, die deinen Typ verwenden, eine
Instanz zu einem bestimmten Zeitpunkt der Programmausführung untersuchen
können.</p>
<p>Das Merkmal <code>Debug</code> ist beispielsweise beim Verwenden des Makros <code>assert_eq!</code>
erforderlich. Dieses Makro gibt die Werte der Instanzen, die als Argumente
angegeben wurden, aus, wenn die Gleichheitszusicherung fehlschlägt, damit
Programmierer sehen können, warum die beiden Instanzen nicht gleich waren.</p>
<h3 id="partialeq-und-eq-für-gleichheitsvergleiche"><a class="header" href="#partialeq-und-eq-für-gleichheitsvergleiche"><code>PartialEq</code> und <code>Eq</code> für Gleichheitsvergleiche</a></h3>
<p>Das Merkmal <code>PartialEq</code> erlaubt dir, Instanzen eines Typs auf Gleichheit zu
prüfen und ermöglicht das Verwenden der Operatoren <code>==</code> und <code>!=</code>.</p>
<p>Das Ableiten von <code>PartialEq</code> implementiert die Methode <code>eq</code>. Wenn <code>PartialEq</code>
für Strukturen abgeleitet wird, sind zwei Instanzen nur dann gleich, wenn
<em>alle</em> Felder gleich sind, und die Instanzen sind nicht gleich, wenn wenigstens
ein Feld nicht gleich ist. Beim Ableiten für Aufzählungen ist jede Variante
gleich sich selbst und nicht gleich den anderen Varianten.</p>
<p>Das Merkmal <code>PartialEq</code> ist beispielsweise beim Verwenden des Makros
<code>assert_eq!</code> erforderlich, das in der Lage sein muss, zwei Instanzen eines Typs
auf Gleichheit zu prüfen.</p>
<p>Das Merkmal <code>Eq</code> hat keine Methoden. Sein Zweck ist es, zu signalisieren, dass
für jeden Wert des annotierten Typs der Wert gleich sich selbst ist. Das
Merkmal <code>Eq</code> kann nur auf Typen angewandt werden, die auch <code>PartialEq</code>
implementieren, obwohl nicht alle Typen, die <code>PartialEq</code> implementieren, <code>Eq</code>
implementieren können. Ein Beispiel dafür sind Fließkomma-Zahlentypen: Die
Implementierung von Fließkomma-Zahlen besagt, dass zwei Instanzen des
Keine-Zahl-Wertes (<code>NaN</code>) nicht gleichwertig sind.</p>
<p>Ein Beispiel dafür, wann <code>Eq</code> erforderlich ist, ist für Schlüssel in einer
<code>HashMap&lt;K, V&gt;</code>, damit <code>HashMap&lt;K, V&gt;</code> erkennen kann, ob zwei Schlüssel gleich
sind.</p>
<h3 id="partialord-und-ord-für-sortiervergleiche"><a class="header" href="#partialord-und-ord-für-sortiervergleiche"><code>PartialOrd</code> und <code>Ord</code> für Sortiervergleiche</a></h3>
<p>Das Merkmal <code>PartialOrd</code> erlaubt dir, Instanzen eines Typs zum Sortieren zu
vergleichen. Ein Typ, der <code>PartialOrd</code> implementiert, kann mit den Operatoren
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> und <code>&gt;=</code> verwendet werden. Du kannst das Merkmal <code>PartialOrd</code>
nur auf Typen anwenden, die auch <code>PartialEq</code> implementieren.</p>
<p>Das Ableiten von <code>PartialOrd</code> implementiert die Methode <code>partial_cmp</code>, die eine
<code>Option&lt;Ordering&gt;</code> zurückgibt, die <code>None</code> ist, wenn die angegebenen Werte nicht
vergleichbar sind. Ein Beispiel für einen Wert, der nicht vergleichbar ist,
obwohl die meisten Werte dieses Typs verglichen werden können, ist die
Fließkommazahl <code>NaN</code>. Der Aufruf von <code>partial_cmp</code> mit einer beliebigen
Fließkommazahl und dem Fließkommawert <code>NaN</code> ergibt <code>None</code>.</p>
<p>Beim Ableiten auf Strukturen vergleicht <code>PartialOrd</code> zwei Instanzen, indem es
den Wert in jedem Feld in der Reihenfolge vergleicht, in der die Felder in der
Strukturdefinition erscheinen. Beim Ableiten auf Aufzählungen werden Varianten,
die in der Aufzählungsdefinition früher deklariert sind, als kleiner als die
später aufgeführten Varianten betrachtet.</p>
<p>Das Merkmal <code>PartialOrd</code> ist z.B. für die Methode <code>gen_range</code> aus der Kiste
<code>rand</code> erforderlich, die einen Zufallswert aus einem Wertebereich erzeugt, der
durch einen Bereichsausdruck festgelegt wird.</p>
<p>Das Merkmal <code>Ord</code> erlaubt dir zu wissen, dass für zwei beliebige Werte des
annotierten Typs eine gültige Reihenfolge existiert. Das Merkmal <code>Ord</code>
implementiert die Methode <code>cmp</code>, die <code>Ordering</code> statt <code>Option&lt;Ordering&gt;</code>
zurückgibt, weil eine gültige Reihenfolge immer möglich sein wird. Du kannst
das Merkmal <code>Ord</code> nur auf Typen anwenden, die auch <code>PartialOrd</code> und <code>Eq</code>
implementieren (und <code>Eq</code> erfordert <code>PartialEq</code>). Beim Ableiten auf Strukturen
und Aufzählungen verhält sich <code>cmp</code> genauso wie die abgeleitete Implementierung
für <code>partial_cmp</code> mit <code>PartialOrd</code>.</p>
<p>Ein Beispiel dafür, wann <code>Ord</code> erforderlich ist, ist das Speichern von Werten
in einem <code>BTreeSet&lt;T&gt;</code>, einer Datenstruktur, die Daten auf Grundlage der
Sortierreihenfolge der Werte speichert.</p>
<h3 id="clone-und-copy-zum-duplizieren-von-werten"><a class="header" href="#clone-und-copy-zum-duplizieren-von-werten"><code>Clone</code> und <code>Copy</code> zum Duplizieren von Werten</a></h3>
<p>Das Merkmal <code>Clone</code> erlaubt es dir, explizit eine tiefe Kopie eines Wertes zu
erstellen, und der Vervielfältigungsprozess könnte die Ausführung von
beliebigem Code und das Kopieren von Daten im Haldenspeicher beinhalten. Siehe
den Abschnitt <a href="ch04-01-what-is-ownership.html#variablen-und-daten-im-zusammenspiel-mit-clone">„Variablen und Daten im Zusammenspiel mit
Clone“</a> in Kapitel 4 für weitere
Informationen zu <code>Clone</code>.</p>
<p>Das Ableiten von <code>Clone</code> implementiert die Methode <code>clone</code>, die, wenn sie für
den gesamten Typ implementiert ist, <code>clone</code> auf jedem der Teile des Typs
aufruft. Das bedeutet, dass alle Felder oder Werte des Typs auch <code>Clone</code>
implementieren müssen, um <code>Clone</code> abzuleiten.</p>
<p>Ein Beispiel dafür, wann <code>Clone</code> erforderlich ist, ist der Aufruf der Methode
<code>to_vec</code> auf einem Anteilstyp. Der Anteilstyp besitzt die Typ-Instanzen nicht,
die er enthält, aber der von <code>to_vec</code> zurückgegebene Vektor muss seine
Instanzen besitzen, also ruft <code>to_vec</code> bei jedem Element <code>clone</code> auf. Daher
muss der im Anteilstyp gespeicherte Typ <code>Clone</code> implementieren.</p>
<p>Das Merkmal <code>Copy</code> erlaubt es dir, einen Wert zu duplizieren, indem nur die auf
dem Stapelspeicher gespeicherten Bits kopiert werden; es ist kein spezieller
Code notwendig. Weitere Informationen zu <code>Copy</code> findest du im Abschnitt <a href="ch04-01-what-is-ownership.html#nur-stapelspeicher-daten-kopieren-copy">„Nur
Stapelspeicher-Daten: Kopieren (copy)“</a> in Kapitel 4.</p>
<p>Das Merkmal <code>Copy</code> definiert keine Methoden, um Programmierer daran zu hindern,
diese Methoden zu überladen und die Annahme zu verletzen, dass kein spezieller
Code ausgeführt wird. Auf diese Weise können alle Programmierer davon ausgehen,
dass das Kopieren eines Wertes sehr schnell gehen wird.</p>
<p>Du kannst <code>Copy</code> auf jeden Typ ableiten, dessen Teile alle <code>Copy</code>
implementieren. Du kannst das Merkmal <code>Copy</code> nur auf Typen anwenden, die auch
<code>Clone</code> implementieren, weil ein Typ, der <code>Copy</code> implementiert, eine triviale
Implementierung von <code>Clone</code> hat, das die gleiche Aufgabe wie <code>Copy</code> erfüllt.</p>
<p>Das Merkmal <code>Copy</code> ist selten erforderlich; Typen, die <code>Copy</code> implementieren,
verfügen über Optimierungen, d. h. du musst nicht <code>clone</code> aufrufen, was den
Code prägnanter macht.</p>
<p>Alles, was mit <code>Copy</code> möglich ist, kannst du auch mit <code>Clone</code> erreichen, aber
der Code könnte langsamer sein oder an manchen Stellen <code>clone</code> erforderlich
machen.</p>
<h3 id="hash-für-die-abbildung-eines-wertes-auf-einen-wert-fester-größe"><a class="header" href="#hash-für-die-abbildung-eines-wertes-auf-einen-wert-fester-größe"><code>Hash</code> für die Abbildung eines Wertes auf einen Wert fester Größe</a></h3>
<p>Das Merkmal <code>Hash</code> erlaubt es dir, eine Instanz eines Typs beliebiger Größe zu
nehmen und diese Instanz mithilfe einer Hash-Funktion auf einen Wert fester
Größe abzubilden. Das Ableiten von <code>Hash</code> implementiert die Methode <code>hash</code>. Die
abgeleitete Implementierung der Methode <code>hash</code> kombiniert das Ergebnis des
Aufrufs von <code>hash</code> für alle Teile des Typs, d. h. alle Felder oder Werte müssen
ebenfalls <code>Hash</code> implementieren, um <code>Hash</code> abzuleiten.</p>
<p>Ein Beispiel dafür, wann <code>Hash</code> erforderlich ist, ist das Speichern von
Schlüsseln in einer <code>HashMap&lt;K, V&gt;</code>, um Daten effizient zu speichern.</p>
<h3 id="default-für-standardwerte"><a class="header" href="#default-für-standardwerte"><code>Default</code> für Standardwerte</a></h3>
<p>Das Merkmal <code>Default</code> erlaubt es dir, einen Standardwert für einen Typ zu
definieren. Das Ableiten von <code>Default</code> implementiert die Funktion <code>default</code>.
Die abgeleitete Implementierung der Funktion <code>default</code> ruft die Funktion
<code>default</code> für jeden Teil des Typs auf, d. h. alle Felder oder Werte in dem Typ
müssen auch <code>Default</code> implementieren, um <code>Default</code> abzuleiten.</p>
<p>Die Funktion <code>Default::default</code> wird häufig in Kombination mit der Syntax zur
Aktualisierung von Strukturen verwendet, die im Abschnitt <a href="ch05-01-defining-structs.html#instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax">„Instanzen aus
anderen Instanzen erzeugen mit der
Strukturaktualisierungssyntax“</a>
in Kapitel 5 besprochen wird. Du kannst einige Felder einer Struktur anpassen
und dann einen Standardwert für den Rest der Felder festlegen und verwenden,
indem du <code>...Default::default()</code> schreibst.</p>
<p>Das Merkmal <code>Default</code> ist erforderlich, wenn du die Methode <code>unwrap_or_default</code>
z. B. auf Instanzen von <code>Option&lt;T&gt;</code> verwendest. Wenn die <code>Option&lt;T&gt;</code> den Wert
<code>None</code> hat, gibt die Methode <code>unwrap_or_default</code> das Ergebnis von
<code>Default::default</code> für den Typ <code>T</code> zurück, der in <code>Option&lt;T&gt;</code> gespeichert ist.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-d-nützliche-entwicklungswerkzeuge"><a class="header" href="#anhang-d-nützliche-entwicklungswerkzeuge">Anhang D: Nützliche Entwicklungswerkzeuge</a></h2>
<p>In diesem Anhang sprechen wir über einige nützliche Entwicklungswerkzeuge, die
das Rust-Projekt bietet. Wir werden uns mit automatischer Formatierung,
schnellen Möglichkeiten zum Beheben von Warnhinweisen, einem Tool zur
statischen Code-Analyse (linter) und der Integration in integrierte
Entwicklungsumgebungen (IDEs) befassen.</p>
<h3 id="automatische-formatierung-mit-rustfmt"><a class="header" href="#automatische-formatierung-mit-rustfmt">Automatische Formatierung mit <code>rustfmt</code></a></h3>
<p>Das Tool <code>rustfmt</code> formatiert deinen Code entsprechend des
Gemeinschafts-Codestils. Viele kollaborative Projekte verwenden <code>rustfmt</code>, um
Diskussionen zum Stil beim Schreiben von Rust zu vermeiden: Jeder formatiert
seinen Code mithilfe des Tools.</p>
<p>Rust-Installationen enthalten standardmäßig rustfmt, daher solltest du die
Programme <code>rustfmt</code> und <code>cargo-fmt</code> bereits auf deinem System haben. Diese
beiden Befehle funktionieren analog zu <code>rustc</code> und <code>cargo</code>, wobei <code>rustfmt</code>
eine feingranularere Steuerung erlaubt und <code>cargo-fmt</code> die Konventionen eines
Projekts versteht, das Cargo verwendet. Um ein beliebiges Cargo-Projekt zu
formatieren, gibst du Folgendes ein:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Mit diesem Befehl wird der gesamte Rust-Code in der aktuellen Kiste neu
formatiert. Dies sollte nur den Stil des Codes ändern, nicht die Semantik des
Codes. Weitere Informationen zu <code>rustfmt</code> findest du in <a href="https://github.com/rust-lang/rustfmt">seiner
Dokumentation</a>.</p>
<h3 id="korrigiere-deinen-code-mit-rustfix"><a class="header" href="#korrigiere-deinen-code-mit-rustfix">Korrigiere deinen Code mit <code>rustfix</code></a></h3>
<p>Das Werkzeug <code>rustfix</code> ist in Rust-Installationen enthalten und kann
automatisch Compiler-Warnungen beheben, die eine klare Möglichkeit haben, das
Problem zu beheben, was wahrscheinlich das ist, was du willst. Wahrscheinlich
hast du schon einmal Compiler-Warnungen gesehen. Betrachte zum Beispiel diesen
Code:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut x = 42;
    println!("{x}");
}</code></pre></pre>
<p>Hier definieren wir die Variable <code>x</code> als veränderbar, aber wir verändern sie nie
wirklich. Rust warnt uns vor dieser Tatsache:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: variable does not need to be mutable
 --&gt; src/main.rs:2:9
  |
2 |     let mut x = 0;
  |         ----^
  |         |
  |         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default
</code></pre>
<p>Die Warnung empfiehlt, dass wir das Schlüsselwort <code>mut</code> entfernen. Wir können
diesen Vorschlag automatisch mit dem Werkzeug <code>rustfix</code> übernehmen, indem wir
den Befehl <code>cargo fix</code> ausführen:</p>
<p>Die Warnung empfiehlt, stattdessen <code>_i</code> als Namen zu verwenden: Der Unterstrich
zeigt an, dass wir diese Variable nicht verwenden wollen. Wir können diesen
Vorschlag mit dem Werkzeug <code>rustfix</code> automatisch übernehmen, indem wir das
Kommando <code>cargo fix</code> ausführen:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Wenn wir uns <em>src/main.rs</em> noch einmal ansehen, werden wir sehen, dass
<code>cargo fix</code> den Code geändert hat:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 42;
    println!("{x}");
}</code></pre></pre>
<p>Die Variable <code>x</code> ist jetzt unveränderlich, und die Warnung erscheint nicht
mehr.</p>
<p>Du kannst den Befehl <code>cargo fix</code> auch dazu verwenden, deinen Code zwischen
verschiedenen Rust-Ausgaben zu konvertieren. Die Ausgaben sind in <a href="appendix-05-editions.html">Anhang
E</a> aufgeführt.</p>
<h3 id="mehr-statische-codeanalyse-mit-clippy"><a class="header" href="#mehr-statische-codeanalyse-mit-clippy">Mehr statische Codeanalyse mit Clippy</a></h3>
<p>Das Tool Clippy ist eine Sammlung von Tools zur statischen Codeanalyse, mit dem
du häufige Fehler aufspüren und deinen Rust-Code verbessern kannst. Clippy ist
in den Standardinstallationen von Rust enthalten.</p>
<p>Um Clippy bei einem Cargo-Projekt auszuführen, gib folgendes ein:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>Angenommen, du schreibst ein Programm, das eine Annäherung an eine
mathematische Konstante wie Pi verwendet, wie dieses Programm es tut:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!("Die Kreisfläche ist {}", x * r * r);
}</code></pre></pre>
<p>Das Ausführen von <code>cargo clippy</code> in diesem Projekt führt zu diesem Fehler:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>Dieser Fehler weist dich darauf hin, dass in Rust bereits eine präzisere
Konstante <code>PI</code> definiert ist und dass dein Programm korrekter wäre, wenn du
stattdessen diese Konstante verwenden würdest. Du würdest dann deinen Code
ändern, um die Konstante <code>PI</code> zu verwenden. Der folgende Code führt zu keinen
Fehlern oder Warnungen von Clippy:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!("Die Kreisfläche ist {}", x * r * r);
}</code></pre></pre>
<p>Für weitere Informationen über Clippy siehe <a href="https://github.com/rust-lang/rust-clippy">seine Dokumentation</a>.</p>
<h3 id="ide-integration-mittels-rust-analyzer"><a class="header" href="#ide-integration-mittels-rust-analyzer">IDE-Integration mittels <code>rust-analyzer</code></a></h3>
<p>Um die IDE-Integration zu erleichtern, empfiehlt die Rust-Gemeinschaft die
Verwendung des <a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a>. Bei diesem Werkzeug handelt es
sich um eine Reihe von Compiler-zentrierten Hilfsprogrammen, die das
<a href="http://langserver.org/">Sprach-Server-Protokoll (Language Server Protocol)</a> beherrschen, eine
Spezifikation für IDEs und Programmiersprachen zur Kommunikation untereinander.
Verschiedene Clients können <code>rust-analyzer</code> verwenden, wie zum Beispiel <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">das
Rust-Plugin für Visual Studio Code</a>.</p>
<p>Besuche die <a href="https://rust-analyzer.github.io">Homepage</a> des Projekts <code>rust-analyzer</code>, um
Installationsanweisungen zu erhalten, und installiere dann die
Sprachserver-Unterstützung in deiner speziellen IDE. Deine IDE wird
Fähigkeiten wie Autovervollständigung, Sprung zur Definition und im Code
eingeblendete Fehlermeldungen erhalten.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-e-ausgaben"><a class="header" href="#anhang-e-ausgaben">Anhang E: Ausgaben</a></h2>
<p>In Kapitel 1 hast du gesehen, dass <code>cargo new</code> Metadaten zur Ausgabe (edition)
in deiner Datei <em>Cargo.toml</em> hinzufügt. Dieser Anhang erläutert, was das
bedeutet!</p>
<p>Die Sprache Rust und der Compiler haben einen sechswöchigen
Veröffentlichungszyklus, was bedeutet, dass die Nutzer einen konstanten Strom
neuer Funktionen erhalten. Andere Programmiersprachen geben weniger oft größere
Änderungen heraus; Rust gibt häufiger kleinere Aktualisierungen heraus. Nach
einer Weile summieren sich all diese kleinen Änderungen. Aber von
Veröffentlichung zu Veröffentlichung kann es schwierig sein, zurückzublicken
und zu sagen: "Wow, zwischen Rust 1.10 und Rust 1.31 hat sich Rust sehr
verändert!</p>
<p>Etwa alle drei Jahre gibt das Rust-Team eine neue <em>Rust-Ausgabe</em> (edition)
heraus. Jede Ausgabe fasst die neuen Funktionalitäten in einem übersichtlichen
Paket mit vollständig aktualisierter Dokumentation und Werkzeugausstattung
zusammen. Neue Ausgaben werden im Rahmen des üblichen sechswöchigen
Freigabeprozesses ausgeliefert.</p>
<p>Ausgaben dienen unterschiedlichen Zwecken für verschiedene Menschen:</p>
<ul>
<li>Für aktive Rust-Nutzer fasst eine neue Ausgabe inkrementelle Änderungen in
einem leicht verständlichen Paket zusammen.</li>
<li>Für Nicht-Nutzer signalisiert eine neue Ausgabe, dass einige wichtige
Fortschritte hinzugekommen sind, sodass sich ein erneuter Blick auf Rust
lohnen könnte.</li>
<li>Für diejenigen, die Rust entwickeln, stellt eine neue Ausgabe einen
Treffpunkt für das gesamte Projekt dar.</li>
</ul>
<p>Zum Verfassungszeitpunkt dieses Artikels sind vier Rust-Ausgaben verfügbar:
Rust 2015, Rust 2018, Rust 2021 und Rust 2024. Dieses Buch wurde unter
Verwendung der Rust-Ausgabe 2024 geschrieben.</p>
<p>Der Schlüssel <code>edition</code> in <em>Cargo.toml</em> gibt an, welche Ausgabe der Compiler
für deinen Code verwenden soll. Wenn der Schlüssel nicht existiert, verwendet
Rust aus Gründen der Abwärtskompatibilität die Edition <code>2015</code>.</p>
<p>Jedes Projekt kann sich für eine Ausgabe abweichend von der Standardausgabe
2015 entscheiden. Ausgaben können inkompatible Änderungen enthalten, z.B. die
Aufnahme eines neuen Schlüsselworts, das mit Bezeichnern im Code in Konflikt
steht. Selbst wenn du dich nicht für diese Änderungen entscheidest, wird dein
Code weiterhin kompilieren, auch wenn du die verwendete
Rust-Compiler-Version aktualisierst.</p>
<p>Alle Rust-Compiler-Versionen unterstützen jede Ausgabe, die vor der
Veröffentlichung dieses Compilers existierte, und es können Kisten (crates)
aller unterstützten Ausgaben miteinander verknüpft werden. Ausgabenänderungen
wirken sich nur auf die Art und Weise aus, wie der Compiler anfangs den Code
analysiert. Wenn du also Rust 2015 verwendest und eine deiner Abhängigkeiten
Rust 2018 verwendet, wird dein Projekt diese Abhängigkeit kompilieren und
nutzen können. Die umgekehrte Situation, in der dein Projekt Rust 2018
und eine Abhängigkeit Rust 2015 verwendet, funktioniert ebenfalls.</p>
<p>Um es klar zu sagen: Die meisten Funktionen werden in allen Ausgaben verfügbar
sein. Entwickler, die eine beliebige Rust-Ausgabe verwenden, werden auch
weiterhin Verbesserungen sehen, wenn neue stabile Versionen erstellt werden. In
einigen Fällen, vor allem wenn neue Schlüsselwörter hinzugefügt werden, sind
einige neue Funktionalitäten jedoch möglicherweise erst in späteren Ausgaben
verfügbar. Du wirst die Ausgabe wechseln müssen, wenn du die Vorteile solcher
Funktionalitäten nutzen möchtest.</p>
<p>Für weitere Einzelheiten schaue in den <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Ausgabe-Leitfaden</em> (Edition
Guide)</a>, einem vollständigen Buch über Ausgaben, das die
Unterschiede zwischen den Ausgaben aufzählt und erklärt, wie du deinen Code
automatisch per <code>cargo fix</code> auf eine neue Ausgabe aktualisieren kannst.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-f-Übersetzungen-des-buchs"><a class="header" href="#anhang-f-Übersetzungen-des-buchs">Anhang F: Übersetzungen des Buchs</a></h2>
<p>Für Ressourcen in anderen Sprachen als Englisch. Die meisten sind noch in
Arbeit; siehe das <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">Label <code>Translations</code></a>, um zu helfen oder uns über
eine neue Übersetzung zu informieren!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português (BR)</a></li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português (PT)</a></li>
<li>简体中文: <a href="https://github.com/KaiserY/trpl-zh-cn">KaiserY/trpl-zh-cn</a>, <a href="https://github.com/gnu4cn/rust-lang-Zh_CN">gnu4cn/rust-lang-Zh_CN</a></li>
<li><a href="https://github.com/rust-tw/book-tw">正體中文</a></li>
<li><a href="https://rust-lang-ua.github.io/rustbook_ukrainian">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a>, <a href="https://github.com/RustLangES/rust-book-es">Español por RustLangES</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rust-kr/doc.rust-kr.org">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/RustFarsi/book">Farsi</a>, <a href="https://github.com/persian-rust/book">Persian (FA)</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">हिंदी</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">ไทย</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-g-wie-rust-erstellt-wird-und-nächtliches-rust"><a class="header" href="#anhang-g-wie-rust-erstellt-wird-und-nächtliches-rust">Anhang G: Wie Rust erstellt wird und „nächtliches Rust“</a></h2>
<p>In diesem Anhang geht es darum, wie Rust erstellt wird und wie sich das auf
dich als Rust-Entwickler auswirkt.</p>
<h3 id="stabilität-ohne-stillstand"><a class="header" href="#stabilität-ohne-stillstand">Stabilität ohne Stillstand</a></h3>
<p>Als Sprache kümmert sich Rust <em>viel</em> um die Stabilität deines Codes. Wir
wollen, dass Rust ein felsenfestes Fundament ist, auf dem du aufbauen kannst,
und wenn sich die Dinge ständig ändern würden, wäre das unmöglich. Gleichzeitig
werden wir, wenn wir nicht mit neuen Funktionen experimentieren können,
wichtige Mängel vielleicht erst nach ihrer Veröffentlichung entdecken, wenn wir
die Dinge nicht mehr ändern können.</p>
<p>Unsere Lösung für dieses Problem ist das, was wir „Stabilität ohne Stillstand“
nennen, und unser Leitsatz lautet: Du solltest niemals Angst vor einem Upgrade
auf eine neue Version des stabilen Rust haben müssen. Jedes Upgrade sollte
schmerzlos sein, aber auch neue Funktionalitäten, weniger Fehler und schnellere
Kompilierzeiten mit sich bringen.</p>
<h3 id="tüff-tüff-veröffentlichungs-kanäle-und-zugfahren"><a class="header" href="#tüff-tüff-veröffentlichungs-kanäle-und-zugfahren">Tüff, tüff! Veröffentlichungs-Kanäle und Zugfahren</a></h3>
<p>Die Rust-Entwicklung erfolgt nach einem <em>Zugfahrplan</em> (train schedule). Das
bedeutet, dass die gesamte Entwicklung auf dem <code>master</code>-Zweig der
Rust-Versionsverwaltung durchgeführt wird. Die Veröffentlichungen folgen einem
Software-Veröffentlichungs-Zugmodell, das von Cisco IOS und anderen
Softwareprojekten verwendet wurde. Es gibt drei <em>Veröffentlichungskanäle</em>
(release channels) für Rust:</p>
<ul>
<li>Nächtlich (nightly)</li>
<li>Beta</li>
<li>Stabil (stable)</li>
</ul>
<p>Die meisten Rust-Entwickler verwenden in erster Linie den stabilen Kanal, aber
diejenigen, die experimentelle neue Funktionen ausprobieren wollen, können
nächtlich oder beta verwenden.</p>
<p>Hier ist ein Beispiel dafür, wie der Entwicklungs- und Veröffentlichungsprozess
funktioniert: Nehmen wir an, das Rust-Team arbeitet an der Veröffentlichung von
Rust 1.5. Diese Veröffentlichung erfolgte im Dezember 2015, aber sie wird uns
realistische Versionsnummern liefern. Eine neue Funktionalität wird zu Rust
hinzugefügt: Eine neue Änderung (commit) kommt in den <code>master</code>-Zweig. Jede
Nacht wird eine neue nächtliche Version von Rust produziert. Jeder Tag ist ein
Veröffentlichungs-Tag und diese Veröffentlichungen werden automatisch von
unserer Veröffentlichungs-Infrastruktur erstellt. Mit der Zeit sehen unsere
Veröffentlichungen also so aus, einmal pro Nacht:</p>
<pre><code class="language-text">nächtlich: * - - * - - *
</code></pre>
<p>Alle sechs Wochen ist es an der Zeit, eine neue Version vorzubereiten! Der
<code>beta</code>-Zweig der Rust-Versionsverwaltung verzweigt vom <code>master</code>-Zweig, der von
„nächtlich“ benutzt wird. Jetzt gibt es zwei Versionen:</p>
<pre><code class="language-text">nächtlich: * - - * - - *
                       |
beta:                  *
</code></pre>
<p>Die meisten Rust-Nutzer verwenden Beta-Versionen nicht aktiv, sondern testen
gegen die Beta-Version in ihrem CI-System, um Rust bei der Entdeckung möglicher
Regressionen zu unterstützen. In der Zwischenzeit gibt es immer noch jede Nacht
eine nächtliche Veröffentlichung:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - *
                       |
beta:                  *
</code></pre>
<p>Sagen wir, es wird eine Regression gefunden. Gut, dass wir etwas Zeit hatten,
die Beta-Version zu testen, bevor sich die Regression in eine stabile Version
eingeschlichen hat! Die Fehlerkorrektur wird auf <code>master</code> angewendet, sodass
„nächtlich“ korrigiert wird, und dann wird die Fehlerkorrektur in den
<code>beta</code>-Zweig zurückportiert und eine neue Version der Beta erzeugt:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - * - - *
                       |
beta:                  * - - - - - - - - *
</code></pre>
<p>Sechs Wochen nachdem die erste Beta-Version erstellt wurde, ist es Zeit für
eine stabile Veröffentlichung! Der <code>stable</code>-Zweig wird aus dem <code>beta</code>-Zweig
erstellt:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - * - - * - * - *
                       |
beta:                  * - - - - - - - - *
                                         |
stabil:                                  *
</code></pre>
<p>Hurra! Rust 1.5 ist geschafft! Eines haben wir jedoch vergessen: Da die sechs
Wochen vergangen sind, brauchen wir auch eine neue Beta der <em>nächsten</em> Version,
Rust 1.6. Nachdem also <code>stable</code> von <code>beta</code> abzweigt, zweigt die nächste Version
von <code>beta</code> wieder von <code>nightly</code> ab:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - * - - * - * - *
                       |                         |
beta:                  * - - - - - - - - *       *
                                         |
stabil:                                  *
</code></pre>
<p>Dies wird als „Zugmodell“ (train model) bezeichnet, weil alle sechs Wochen eine
Veröffentlichung „den Bahnhof verlässt“, aber immer noch eine Reise durch den
Betakanal machen muss, bevor sie als stabile Version ankommt.</p>
<p>Alle sechs Wochen veröffentlicht Rust eine Version, wie ein Uhrwerk. Wenn du
das Datum einer Rust-Veröffentlichung kennst, kennst du auch das Datum der
nächsten: Sie ist sechs Wochen später. Ein schöner Aspekt der alle sechs Wochen
geplanten Veröffentlichungen ist, dass der nächste Zug bald kommt. Wenn eine
Funktionalität eine bestimmte Veröffentlichung verpasst, brauchst du dir keine
Sorgen zu machen: In kurzer Zeit kommt die nächste! Dies trägt dazu bei, den
Druck zu verringern, bevor sich möglicherweise unausgefeilte Funktionalitäten
kurz vor Ablauf der Veröffentlichungsfrist einschleichen.</p>
<p>Dank dieses Prozesses kannst du jederzeit die nächste Rust-Version ausprobieren
und dich selbst davon überzeugen, dass ein Upgrade leicht möglich ist: Wenn
eine Beta-Version nicht wie erwartet funktioniert, kannst du dies dem Team
melden und sie vor der nächsten stabilen Version korrigieren lassen! Ein Bruch
in einer Beta-Version ist relativ selten, aber <code>rustc</code> ist immer noch ein Stück
Software und es gibt Fehler.</p>
<h3 id="wartungsdauer"><a class="header" href="#wartungsdauer">Wartungsdauer</a></h3>
<p>Das Rust-Projekt unterstützt die neueste stabile Version. Wenn eine neue
stabile Version veröffentlicht wird, erreicht die alte Version ihr
Lebensende (engl. end of life, EOL). Das bedeutet, dass jede Version
sechs Wochen lang unterstützt wird.</p>
<h3 id="instabile-funktionalitäten"><a class="header" href="#instabile-funktionalitäten">Instabile Funktionalitäten</a></h3>
<p>Bei diesem Veröffentlichungsmodell gibt es noch einen weiteren Haken: instabile
Funktionalitäten. Rust verwendet eine Technik namens „Funktionalitäts-Schalter“
(feature flags), um festzulegen, welche Funktionalitäten in einer bestimmten
Version aktiviert sind. Wenn eine neue Funktionalität aktiv entwickelt wird,
landet sie auf dem <code>master</code> und damit in „nächtlich“, aber hinter einem
<em>Funktionalitäts-Schalter</em>. Wenn du als Nutzer eine in Entwicklung befindliche
Funktionalität ausprobieren möchtest, kannst du dies tun, aber du musst eine
nächtliche Version von Rust verwenden und deinen Quellcode mit dem
entsprechenden Schalter versehen, um sie nutzen zu können.</p>
<p>Wenn du eine Beta- oder stabile Version von Rust verwendest, kannst du keine
Funktionalitäts-Schalter verwenden. Dies ist der Schlüssel, der es uns
ermöglicht, neue Funktionen praktisch zu nutzen, bevor wir sie für immer für
stabil erklären. Diejenigen, die sich für das Allerneueste entscheiden wollen,
können dies tun, und diejenigen, die eine felsenfeste Erfahrung machen wollen,
können bei der stabilen Version bleiben und wissen, dass ihr Code nicht brechen
wird. Stabilität ohne Stillstand.</p>
<p>Dieses Buch enthält nur Informationen über stabile Funktionalitäten, da sich in
Entwicklung befindliche Funktionalitäten noch ändern, und sicherlich werden sie
sich zwischen dem Zeitpunkt, an dem dieses Buch geschrieben wurde, und dem
Zeitpunkt, an dem sie in stabilen Versionen aktiviert werden, unterscheiden.
Die Dokumentation für die nur nächtlich verfügbaren Funktionalitäten findest du
online.</p>
<h3 id="rustup-und-die-rolle-des-nächtlichen-rust"><a class="header" href="#rustup-und-die-rolle-des-nächtlichen-rust">Rustup und die Rolle des nächtlichen Rust</a></h3>
<p>Rustup macht es einfach, zwischen verschiedenen Veröffentlichungskanälen von
Rust zu wechseln, auf globaler oder projektbezogener Basis. Standardmäßig hast
du stabiles Rust installiert. Um die nächtliche Version zu installieren, mache
folgenden Aufruf:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>Du kannst auch alle <em>Werkzeugketten</em> (toolchains) (Versionen von Rust und
zugehörigen Komponenten) sehen, die du mit <code>rustup</code> installiert hast. Hier ist
ein Beispiel auf dem Windows-Rechner einer deiner Autoren:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>Wie du sehen kannst, ist die stabile Werkzeugkette die Standardeinstellung. Die
meisten Rust-Nutzer verwenden meistens die stabile Version. Vielleicht möchtest
du die meiste Zeit die stabile Version verwenden, aber für ein bestimmtes
Projekt mit der nächtlichen Version arbeiten, weil dir eine innovative
Funktionalität wichtig ist. Um dies zu tun, kannst du <code>rustup override</code> im
Verzeichnis dieses Projekts benutzen, um die nächtliche Werkzeugkette als
diejenige zu setzen, die <code>rustup</code> benutzen soll, wenn du dich in diesem
Verzeichnis befindest:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Jedes Mal, wenn du nun <code>rustc</code> oder <code>cargo</code> innerhalb von
<em>~/projects/needs-nightly</em> aufrufst, stellt <code>rustup</code> sicher, dass du das
nächtliche Rust verwendest und nicht dein standardmäßiges, stabiles Rust. Das
ist praktisch, wenn du viele Rust-Projekte hast!</p>
<h3 id="der-rfc-prozess-und-die-teams"><a class="header" href="#der-rfc-prozess-und-die-teams">Der RFC-Prozess und die Teams</a></h3>
<p>Wie erfährst du also von diesen neuen Funktionalitäten? Das Entwicklungsmodell
von Rust folgt einem <em>Bitte-um-Kommentare-Prozess</em> (Request For Comments, RFC).
Wenn du eine Verbesserung von Rust wünschst, kannst du einen Vorschlag
schreiben, einen sogenannten RFC.</p>
<p>Jeder kann RFCs zur Verbesserung von Rust schreiben und die Vorschläge werden
vom Rust-Team, das aus vielen thematischen Unterteams besteht, geprüft und
diskutiert. Es gibt eine vollständige Liste der Teams auf der
<a href="https://www.rust-lang.org/governance">Rust-Website</a>, in der die Teams für jeden Projektbereich
aufgeführt sind: Sprachdesign, Compiler-Implementierung, Infrastruktur,
Dokumentation und weitere. Das zuständige Team liest den Vorschlag und die
Kommentare, schreibt einige eigene Kommentare und schließlich gibt es einen
Konsens, die Funktionalität anzunehmen oder abzulehnen.</p>
<p>Wenn die Funktionalität angenommen wird, wird ein Ticket (issue) in der
Rust-Versionsverwaltung eröffnet, und jemand kann es implementieren. Die
Person, die es sehr gut umsetzt, ist möglicherweise nicht die Person, die die
Funktionalität ursprünglich vorgeschlagen hat! Wenn die Implementierung fertig
ist, landet sie auf dem <code>master</code>-Zweig hinter einem Funktionalitäts-Schalter,
wie wir im Abschnitt <a href="appendix-07-nightly-rust.html#instabile-funktionalit%C3%A4ten">„Instabile
Funktionalitäten“</a> besprochen haben.</p>
<p>Nach einiger Zeit, in der Rust-Entwickler die neue Funktionalität in den
nächtlichen Veröffentlichungen ausprobieren konnten, werden die Teammitglieder
die Ausarbeitung der Funktionalität im nächtlichen Zweig diskutieren und
entscheiden, ob sie ins stabile Rust kommen soll oder nicht. Wenn die
Entscheidung positiv ist, wird das Funktionalitätstor (feature gate) entfernt
und die Funktionalität gilt jetzt als stabil! Sie fährt mit den Zügen in eine
neue stabile Version von Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
