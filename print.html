<!DOCTYPE HTML>
<html lang="de" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Die Programmiersprache Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Die Programmiersprache Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Vorwort</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Einführung</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Erste Schritte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hallo Welt</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hallo Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Ein Ratespiel programmieren</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Allgemeine Programmierkonzepte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variablen und Veränderbarkeit</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Datentypen</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funktionen</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Kommentare</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrollfluss</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Eigentümerschaft (ownership) verstehen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Was ist Eigentümerschaft (ownership)?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referenzen und Ausleihen (borrowing)</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Der Anteilstyp (slice)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Strukturen (structs) für zusammenhängende Daten verwenden</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Strukturen (structs) definieren und instanziieren</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Beispielprogramm mit Strukturen (structs)</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Methodensyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Aufzählungen (enums) und Musterabgleich (pattern matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Eine Aufzählung (enum) definieren</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Das Kontrollflusskonstrukt match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Prägnanter Kontrollfluss mit if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Wachsende Projekte verwalten mit Paketen (packages), Kisten (crates) und Modulen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Pakete (packages) und Kisten (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Mit Modulen den Kontrollumfang und Datenschutz steuern</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Mit Pfaden auf ein Element im Modulbaum verweisen</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Pfade in den Gültigkeitsbereich bringen mit dem Schlüsselwort use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Module in verschiedene Dateien aufteilen</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Allgemeine Kollektionen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Wertlisten in Vektoren ablegen</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8-kodierten Text in Zeichenketten (strings) ablegen</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Schlüssel mit zugehörigen Werten in Hashtabellen ablegen</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Fehlerbehandlung</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Nicht behebbare Fehler mit panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Behebbare Fehler mit Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Wann panic! aufrufen und wann nicht?</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generische Typen, Merkmale (traits) und Lebensdauer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generische Datentypen</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Merkmale (traits): Gemeinsames Verhalten definieren</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referenzen validieren mit Lebensdauern</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Automatisierte Tests schreiben</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Tests schreiben</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Steuern wie Tests ausgeführt werden</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Testverwaltung</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Ein E/A-Projekt: Ein Kommandozeilenprogramm erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Kommandozeilenargumente entgegennehmen</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Eine Datei einlesen</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Bibliotheksfunktionalität mit testgetriebener Entwicklung erstellen</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Mit Umgebungsvariablen arbeiten</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Fehlermeldungen in die Standardfehlerausgabe anstatt der Standardausgabe schreiben</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Funktionale Sprachelemente: Iteratoren und Funktionsabschlüsse (closures)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Funktionsabschlüsse (closures): Anonyme Funktionen, die ihre Umgebung erfassen</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Eine Reihe von Elementen verarbeiten mit Iteratoren</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Unser E/A-Projekt verbessern</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performanzvergleich: Schleifen vs. Iteratoren</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Mehr über Cargo und Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Bauvorgang anpassen mit Freigabeprofilen (release profiles)</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Kisten (crate) auf crates.io veröffentlichen</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo-Arbeitsbereiche</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installieren von Binärdateien mit  cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Cargo um benutzerdefinierte Befehle erweitern</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Intelligente Zeiger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Mit Box&lt;T&gt; auf Daten im Haldenspeicher zeigen</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Programmcode beim Aufräumen ausführen mit dem Merkmal (trait) Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Der referenzzählende intelligente Zeiger Rc&lt;T&gt;</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; und das innere Veränderbarkeitsmuster</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referenzzyklen können zu einem Speicherleck führen</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Furchtlose Nebenläufigkeit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Mit Strängen (threads) Programmcode gleichzeitig ausführen</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Nachrichtenaustausch zwischen Strängen (threads)</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Nebenläufigkeit mit gemeinsamem Zustand</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) Sync und Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Objektorientierte Sprachelemente von Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Charakteristiken objektorientierter Sprachen</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen erlauben</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Ein objektorientiertes Entwurfsmuster implementieren</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Muster (patterns) und Abgleich (matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Alle Stellen an denen Muster (patterns) verwendet werden können</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Abweisbarkeit: Falls ein Muster (pattern) mal nicht passt</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Mustersyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Fortgeschrittene Sprachelemente</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsicheres (unsafe) Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Fortgeschrittene Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Fortgeschrittene Typen</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Erweiterte Funktionen und Funktionsabschlüsse (closures)</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Abschlussprojekt: Einen mehrsträngigen (multi-threaded) Webserver erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Einen einsträngigen (single-threaded) Webserver erstellen</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Unseren einsträngigen (single-threaded) Webserver in einen mehrsträngigen (multi-threaded) Webserver verwandeln</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Kontrolliertes Beenden und Aufräumen</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Anhang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Schlüsselwörter</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatoren und Symbole</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Ableitbare Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Nützliche Entwicklungswerkzeuge</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ausgaben</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Übersetzungen des Buchs</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Wie Rust erstellt wird und „nächtliches Rust“</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="die-programmiersprache-rust"><a class="header" href="#die-programmiersprache-rust">Die Programmiersprache Rust</a></h1>
<p><em>von Steve Klabnik und Carol Nichols, unter Mitarbeit der Rust-Gemeinschaft;</em>
<em>übersetzt ins Deutsche durch die Rust-Gemeinschaft</em></p>
<p>Diese Version des Textes geht davon aus, dass du Rust 1.65 (veröffentlicht am
2022-11-03) oder später verwendest. Siehe <a href="ch01-01-installation.html">Abschnitt „Installation“ in Kapitel
1</a> zum Installieren und Aktualisieren von Rust.</p>
<p>Die HTML-Version ist online verfügbar unter
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
(englisches Original) und unter
<a href="https://rust-lang-de.github.io/rustbook-de/">https://rust-lang-de.github.io/rustbook-de/</a>
(deutsche Übersetzung) und offline mit Rust-Installationen, die mit <code>rustup</code>
erfolgt sind; führe <code>rustup docs --book</code> aus um es zu öffnen.</p>
<p>Es sind weitere <a href="appendix-06-translation.html">Gemeinschaftsübersetzungen</a> verfügbar.</p>
<p>Der englische Text ist auch als <a href="https://nostarch.com/rust-programming-language-2nd-edition">Taschenbuch und E-Book bei No Starch
Press</a> erhältlich.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vorwort"><a class="header" href="#vorwort">Vorwort</a></h1>
<p>Es war nicht immer so klar, aber bei der Programmiersprache Rust geht es im
Grunde um <em>Befähigung</em>: Egal, welche Art von Code du jetzt schreibst, Rust
befähigt dich dazu, weiter zu gehen, mit Vertrauen in einer größeren Vielfalt
von Bereichen zu programmieren, als du es zuvor getan hast.</p>
<p>Denken wir zum Beispiel an systemnahe Arbeiten, bei denen Details wie
Speicherverwaltung, Datenrepräsentation und Nebenläufigkeit wichtig sind.
Traditionellerweise gilt dieser Bereich der Programmierung als geheimnisvoll
und nur wenigen Auserwählten zugänglich, die die erforderliche Erfahrung
gesammelt haben, um berüchtigte Fallstricke vermeiden zu können. Und selbst
diejenigen, die damit arbeiten, tun dies mit Sorgfalt, damit ihr Code nicht
angreifbar ist, abstürzt oder fehlerhaft ist.</p>
<p>Rust baut diese Barrieren ab, indem es die alten Fallstricke beseitigt und ein
freundliches, ausgefeiltes Instrumentarium zur Verfügung stellt, das dich auf
deinem Weg unterstützt. Programmierer, die in die systemnahen Kontrollebenen
„eintauchen“ müssen, können dies mit Rust tun, ohne das übliche Risiko von
Abstürzen oder Sicherheitslücken einzugehen und ohne die Finessen einer
wankelmütigen Werkzeugkette erlernen zu müssen. Besser noch, die Sprache ist so
konzipiert, dass sie dich auf natürliche Weise zu zuverlässigem Code führt, der
effizient in Bezug auf Geschwindigkeit und Speichernutzung ist.</p>
<p>Programmierer, die bereits mit systemnahem Code arbeiten, können Rust nutzen,
um ihre Ambitionen zu steigern. Beispielsweise ist die Einführung von
Parallelität in Rust ein relativ risikoarmes Unterfangen: Der Compiler fängt
die klassischen Fehler für dich ab. Und du kannst aggressivere Optimierungen in
deinem Code wagen mit der Gewissheit, keine versehentlichen Abstürze oder
Verwundbarkeiten einzuführen.</p>
<p>Aber Rust ist nicht auf systemnahe Programmierung beschränkt. Es ist
ausdrucksstark und ergonomisch genug, um das Schreiben von
Kommandozeilen-Anwendungen, Webservern und vielen anderen Arten an Code recht
angenehm zu machen – du wirst später in diesem Buch einfache Beispiele
dazu finden. Die Arbeit mit Rust ermöglicht es dir, Fähigkeiten zu entwickeln,
die von einer Domäne auf eine andere übertragen werden können; du kannst Rust
durch Schreiben einer Webanwendung erlernen und dann diese Fähigkeiten auf
deinem Raspberry Pi anwenden.</p>
<p>In diesem Buch wird das Potenzial von Rust zur Befähigung seiner Nutzer voll
ausgeschöpft. Es ist ein freundlicher und zugänglicher Text, der dir helfen
soll, nicht nur dein Wissen über Rust zu erweitern, sondern auch deine
Reichweite und dein Selbstvertrauen als Programmierer im Allgemeinen. Also
tauche ein, mach dich bereit zum Lernen – und willkommen in der
Rust-Gemeinschaft!</p>
<p>– Nicholas Matsakis und Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="einführung"><a class="header" href="#einführung">Einführung</a></h1>
<p>Willkommen bei <em>Die Programmiersprache Rust</em>, einem einführenden Buch über
Rust. Die Programmiersprache Rust hilft dir, schnellere und zuverlässigere
Software zu schreiben. Ergonomie und systemnahe Kontrolle stehen beim Entwurf
von Programmiersprachen oft im Widerspruch – Rust stellt sich diesem
Konflikt. Durch den Ausgleich zwischen leistungsstarken, technischen
Möglichkeiten und einer großartigen Entwicklererfahrung bietet dir Rust die
Möglichkeit, Details systemnah (z.B. Speichernutzung) zu kontrollieren, ohne
den ganzen Ärger, der damit typischerweise einhergeht.</p>
<h2 id="für-wen-rust-ist"><a class="header" href="#für-wen-rust-ist">Für wen Rust ist</a></h2>
<p>Rust ist für viele Menschen aus einer Vielzahl von Gründen ideal. Schauen wir
uns einige der wichtigsten Nutzergruppen an.</p>
<h3 id="entwicklerteams"><a class="header" href="#entwicklerteams">Entwicklerteams</a></h3>
<p>Rust erweist sich als produktives Werkzeug in der Zusammenarbeit großer
Entwicklerteams mit unterschiedlichem Kenntnisstand in der
Systemprogrammierung. Systemnaher Code ist anfällig für eine Vielzahl subtiler
Fehler, die in den meisten anderen Sprachen nur durch ausgiebige Tests und
sorgfältige Überprüfung des Codes durch erfahrene Entwickler erkannt werden
können. In Rust spielt der Compiler eine Art Pförtnerrolle, indem er Code
mit diesen schwer fassbaren Fehlern verweigert zu kompilieren, darunter auch
Nebenläufigkeitsfehler. Mit der Arbeit an der Seite des Compilers kann sich
das Team auf die Programmlogik konzentrieren, anstatt Fehler zu suchen.</p>
<p>Rust bringt auch zeitgemäße Entwicklerwerkzeuge in die Welt der
Systemprogrammierung:</p>
<ul>
<li>Cargo, das mitgelieferte Abhängigkeitsmanagement- und Bau-Werkzeug, macht das
Hinzufügen, Kompilieren und Verwalten von Abhängigkeiten im gesamten
Rust-Ökosystem schmerzlos und konsistent.</li>
<li>Das Formatierungstool Rustfmt sorgt für einen einheitlichen Codierstil bei 
den Entwicklern.</li>
<li>Der Rust Sprachdienst (Language Server) ermöglicht Codevervollständigung und
im Code angezeigte Fehlermeldungen innerhalb der Entwicklungsumgebung (IDE).</li>
</ul>
<p>Durch den Einsatz dieser und anderer Werkzeuge des Rust-Ökosystems können
Entwickler produktiv arbeiten, während sie Code auf Systemebene schreiben.</p>
<h3 id="studenten"><a class="header" href="#studenten">Studenten</a></h3>
<p>Rust ist für Studenten und alle, die sich für Systemkonzepte interessieren. Mit
Rust haben viele Menschen etwas über Themen wie die Entwicklung von
Betriebssystemen gelernt. Die Gemeinschaft ist sehr einladend und beantwortet
gerne Fragen der Studenten. Durch Bemühungen wie dieses Buch will das Rust-Team
Systemkonzepte mehr Menschen zugänglich machen, insbesondere denen, die neu in
der Programmierung sind.</p>
<h3 id="unternehmen"><a class="header" href="#unternehmen">Unternehmen</a></h3>
<p>Hunderte von Unternehmen, große und kleine, setzen Rust für eine Vielzahl von
Aufgaben in der Produktion ein, dazu gehören Kommandozeilenwerkzeuge,
Webdienste, DevOps-Werkzeuge, eingebettete Geräte, Audio- und Videoanalyse und
-transkodierung, Kryptowährungen, Bioinformatik, Suchmaschinen, Anwendungen für
das Internet der Dinge, maschinelles Lernen und sogar wesentliche Teile des
Webbrowsers Firefox.</p>
<h3 id="open-source-entwickler"><a class="header" href="#open-source-entwickler">Open-Source-Entwickler</a></h3>
<p>Rust ist für Menschen, die die Programmiersprache Rust, die Gemeinschaft,
Entwickler-Werkzeuge und Bibliotheken aufbauen möchten. Wir würden uns freuen,
wenn du zur Programmiersprache Rust beiträgst.</p>
<h3 id="menschen-die-geschwindigkeit-und-stabilität-schätzen"><a class="header" href="#menschen-die-geschwindigkeit-und-stabilität-schätzen">Menschen, die Geschwindigkeit und Stabilität schätzen</a></h3>
<p>Rust ist für Menschen, die sich nach Geschwindigkeit und Stabilität einer
Sprache sehnen. Mit Geschwindigkeit meinen wir sowohl die Geschwindigkeit, mit
der Rust-Code ausgeführt werden kann, als auch die Geschwindigkeit, mit der du
mit Rust Programme schreiben kannst. Die Prüfungen des Rust-Compilers
gewährleisten Stabilität während du neue Funktionen hinzufügst und deinen Code
änderst. Dies steht im Gegensatz zu brüchigen Code-Altlasten in Sprachen ohne
diese Prüfungen, die Entwickler sich oft scheuen zu verändern. Durch das
Streben nach kostenneutralen Abstraktionen, also Funktionalität auf höherer
Ebene, die zu genauso schnellem Code wie manuell geschriebener Code auf
niedrigerer Ebene kompiliert, bemüht sich Rust, sicheren Code auch zu schnellem
Code zu machen.</p>
<p>Die Sprache Rust hofft, auch viele andere Nutzer zu unterstützen; die hier
genannten sind nur einige der größten Interessensgruppen. Insgesamt ist es
Rusts größtes Bestreben, den Zielkonflikt zu beseitigen, den Programmierer
jahrzehntelang hingenommen haben, wenn sie Sicherheit <em>und</em> Produktivität bzw.
Geschwindigkeit <em>und</em> Ergonomie erreichen wollten. Versuche es mit Rust und
finde heraus, ob dessen Möglichkeiten für dich geeignet sind.</p>
<h2 id="für-wen-dieses-buch-gedacht-ist"><a class="header" href="#für-wen-dieses-buch-gedacht-ist">Für wen dieses Buch gedacht ist</a></h2>
<p>In diesem Buch wird davon ausgegangen, dass du bereits Code in einer anderen
Programmiersprache geschrieben hast, es spielt aber keine Rolle in welcher. Wir
haben versucht, das Material einem breiten Publikum mit unterschiedlichem
Programmierhintergrund zugänglich zu machen. Wir verbringen nicht viel Zeit
damit, darüber zu sprechen, was Programmieren <em>ist</em> oder wie man darüber denkt.
Wenn Programmieren für dich ganz neu ist, wäre es besser, wenn du ein Buch
speziell zur Einführung in die Programmierung liest.</p>
<h2 id="wie-man-dieses-buch-verwendet"><a class="header" href="#wie-man-dieses-buch-verwendet">Wie man dieses Buch verwendet</a></h2>
<p>Im Allgemeinen geht dieses Buch davon aus, dass du es der Reihe nach von vorne
nach hinten liest. Spätere Kapitel bauen auf den Konzepten früherer Kapitel
auf. Frühere Kapitel gehen möglicherweise nicht auf die Einzelheiten eines
Themas ein, denn in der Regel werden wir es in einem späteren Kapitel erneut
aufgreifen.</p>
<p>Du findest in diesem Buch zwei Kapitelarten: Konzeptkapitel und
Projektkapitel. In Konzeptkapiteln erfährst du etwas über einen Aspekt von
Rust. In Projektkapiteln schreiben wir gemeinsam kleine Programme und wenden
das bisher Gelernte an. Die Kapitel 2, 12 und 20 sind Projektkapitel; die
übrigen sind Konzeptkapitel.</p>
<p>Kapitel 1 erklärt, wie man Rust installiert, wie man ein „Hallo Welt“-Programm
schreibt und wie man Cargo, den Paketmanager und das Bauwerkzeug von Rust,
benutzt. Kapitel 2 ist eine praktische Einführung in die Sprache Rust. Hier
werden Konzepte auf hohem Niveau behandelt, spätere Kapitel werden zusätzliche
Einzelheiten liefern. Wenn du dir schon jetzt die Hände schmutzig machen
willst, dann ist Kapitel 2 der richtige Ort dafür. Zunächst willst du
vielleicht sogar Kapitel 3 überspringen, in dem es um Rust-Funktionen geht, die
denen anderer Programmiersprachen ähneln, und direkt zu Kapitel 4 übergehen, um
mehr über den Eigentümerschaftsansatz von Rust zu erfahren. Wenn du jedoch ein
besonders akribischer Lerner bist, der lieber erst jedes Detail lernen will,
bevor er zum nächsten übergeht, willst du vielleicht Kapitel 2 überspringen und
direkt zu Kapitel 3 gehen und danach zu Kapitel 2 zurückkehren, um dann an
einem Projekt zu arbeiten und die gelernten Details anzuwenden.</p>
<p>Kapitel 5 bespricht Strukturen und Methoden, und Kapitel 6 behandelt
Aufzählungen, <code>match</code>-Ausdrücke und das <code>if let</code>-Kontrollflusskonstrukt. Du
wirst Strukturen und Aufzählungen verwenden, um benutzerdefinierte Typen in
Rust zu erstellen.</p>
<p>In Kapitel 7 erfährst du mehr über das Modulsystem von Rust und über die
Datenschutzregeln zum Organisieren deines Codes und dessen öffentlich
zugängliche Programmierschnittstelle (API). In Kapitel 8 werden einige gängige
Kollektionsdatenstrukturen, die die Standardbibliothek zur Verfügung stellt,
behandelt, z.B. Vektoren, Zeichenketten und Hashtabellen. Kapitel 9 befasst
sich mit Rusts Philosophie und Techniken der Fehlerbehandlung.</p>
<p>Kapitel 10 vertieft generische Datentypen, Merkmale und Lebensdauern, die dir
die Möglichkeit geben, Code zu schreiben, der für mehrere Typen passt. In
Kapitel 11 dreht sich alles um das Testen, das selbst mit den
Sicherheitsgarantien von Rust erforderlich ist, um eine korrekte Logik deines
Programms sicherzustellen. In Kapitel 12 werden wir unsere eigene
Implementierung für eine Teilfunktionalität des Kommandozeilenwerkzeugs <code>grep</code>
schreiben, das nach Text in Dateien sucht. Dazu werden wir viele Konzepte
anwenden, die wir in den vorangegangenen Kapiteln kennengelernt haben.</p>
<p>Kapitel 13 befasst sich mit Funktionsabschlüssen und Iteratoren, also
Sprachmerkmalen, die von funktionalen Programmiersprachen stammen. In Kapitel
14 werden wir einen genaueren Blick auf Cargo werfen und über bewährte
Vorgehensweisen beim Bereitstellen deiner Bibliotheken für andere sprechen. In
Kapitel 15 werden intelligente Zeiger, die die Standardbibliothek bereitstellt,
und Merkmale, die ihre Funktionalität ermöglichen, erörtert.</p>
<p>In Kapitel 16 gehen wir durch verschiedene Modelle der nebenläufigen
Programmierung und sprechen darüber, wie Rust dir hilft, furchtlos mit mehreren
Strängen zu programmieren. Kapitel 17 befasst sich mit dem Vergleich zwischen
Rust-Idiomen und den Prinzipien der objektorientierten Programmierung, mit
denen du vielleicht vertraut bist.</p>
<p>Kapitel 18 ist ein Nachschlagewerk zu Muster und Musterabgleich, einem
mächtigen Mittel zum Ausdrücken von Ideen in Rust-Programmen. Kapitel 19
enthält ein Sammelsurium an interessanten fortgeschrittenen Themen, darunter
unsicheres Rust, Makros und mehr zu Lebensdauer, Merkmalen, Typen, Funktionen
und Funktionsabschlüssen.</p>
<p>In Kapitel 20 werden wir ein Projekt abschließen, bei dem wir einen
systemnahen, nebenläufigen Webdienst implementieren!</p>
<p>Schließlich enthalten einige Anhänge nützliche Informationen über die Sprache
in einem eher referenzartigen Format. Anhang A enthält die Schlüsselwörter von
Rust, Anhang B die Operatoren und Symbole von Rust, Anhang C ableitbare
Merkmalen, die von der Standardbibliothek mitgebracht werden, Anhang D
nützliche Entwicklungswerkzeuge und Anhang E erläutert die Rust-Ausgaben. In
Anhang F findest du Übersetzungen des Buches, und in Anhang G erfährst du, wie
Rust erstellt wird und was nächtliches (nightly) Rust ist.</p>
<p>Es gibt keinen falschen Weg, dieses Buch zu lesen: Wenn du was überspringen
willst, nur zu! Möglicherweise musst du zu früheren Kapiteln zurückkehren, wenn
du irritiert bist. Aber tue, was immer für dich passt.</p>
<p><span id="ferris"></span></p>
<p>Ein wichtiger Teil beim Lernen von Rust ist das Verstehen der Fehlermeldungen,
die der Compiler anzeigt: Diese leiten dich zum funktionierenden Code. Daher
werden wir viele Beispiele bringen, die nicht kompilieren, zusammen mit der
jeweiligen Fehlermeldung des Compilers. Wenn du also ein zufälliges Beispiel
eingibst und ausführen willst, lässt es sich möglicherweise nicht kompilieren!
Stelle sicher, dass du den umgebenden Text liest, um zu wissen, ob das
Beispiel, das du ausführen willst, für einen Fehler gedacht ist. Ferris gibt
dir einen Hinweis bei Code, der nicht funktionieren soll:</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>Bedeutung</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris mit Fragezeichen" /></td><td>Dieser Code lässt sich nicht kompilieren!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris reißt die Hände hoch" /></td><td>Dieser Code bricht ab (panic)!</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris mit einer Kralle nach oben, achselzuckend" /></td><td>Dieser Code liefert nicht das gewünschte Verhalten.</td></tr>
</tbody></table>
</div>
<p>In den meisten Situationen führen wir dich zu einer funktionierenden
Codeversion, wenn er sich nicht kompilieren lässt.</p>
<h2 id="quellcode"><a class="header" href="#quellcode">Quellcode</a></h2>
<p>Die Quelldateien, aus denen dieses Buch generiert wird, findest du unter
<a href="https://github.com/rust-lang-de/rustbook-de/tree/master/src">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erste-schritte"><a class="header" href="#erste-schritte">Erste Schritte</a></h1>
<p>Lass uns mit Rust loslegen! Es gibt viel zu lernen, aber irgendwo muss man
bekanntlich anfangen. In diesem Kapitel geht es um folgende Themen:</p>
<ul>
<li>Die Installation von Rust in Linux, macOS und Windows</li>
<li>Das Schreiben eines Programms, das <code>Hallo Welt!</code> ausgibt</li>
<li>Die Verwendung von <code>cargo</code>, Rusts Paketmanager und Bauwerkzeug </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Der erste Schritt ist, Rust zu installieren. Wir werden Rust mittels <code>rustup</code>
herunterladen, einem Kommandozeilenwerkzeug für die Verwaltung von Rust-Versionen
und dazugehörigen Werkzeugen. Du wirst eine Internetverbindung für den Download
benötigen.</p>
<blockquote>
<p>Anmerkung: Falls du <code>rustup</code> aus irgendeinem Grund nicht verwenden möchtest,
schaue bitte auf der Seite <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">Andere Rust-Installationsmethoden</a>
nach anderen Möglichkeiten.</p>
</blockquote>
<p>Die folgenden Schritte installieren die neueste stabile Version des
Rust-Compilers. Rust garantiert Stabilität und stellt somit sicher,
dass alle kompilierbaren Beispiele in diesem Buch auch mit neueren
Rust-Versionen kompilierbar bleiben werden. Die Konsolenausgabe
der Beispiele kann sich zwischen Versionen leicht unterscheiden,
weil Rust oft Fehlermeldungen und Warnungen verbessert.
Anders ausgedrückt, jede neuere stabile Version von Rust, die du
mithilfe dieser Schritte installierst, sollte wie erwartet mit dem
Inhalt dieses Buches funktionieren.</p>
<blockquote>
<h3 id="kommandozeilen-schreibweise"><a class="header" href="#kommandozeilen-schreibweise">Kommandozeilen-Schreibweise</a></h3>
<p>In diesem Kapitel und im ganzen Buch werden wir einige Befehle auf der
Konsole zeigen. Alle Zeilen, die du in die Konsole eingeben sollst,
beginnen mit <code>$</code>. Du brauchst das <code>$</code>-Zeichen nicht einzugeben;
es weist nur auf den Beginn jedes Befehls hin. Zeilen, die nicht mit
<code>$</code> beginnen, zeigen normalerweise die Ausgabe eines vorherigen Befehls.
PowerShell-spezifische Beispiele werden außerdem <code>&gt;</code> anstelle von <code>$</code>
verwenden.</p>
</blockquote>
<h3 id="die-installation-von-rustup-in-linux-und-macos"><a class="header" href="#die-installation-von-rustup-in-linux-und-macos">Die Installation von <code>rustup</code> in Linux und macOS</a></h3>
<p>Falls du Linux oder macOS verwendest, öffne ein Konsolenfenster und gib den
folgenden Befehl ein:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Dieser Befehl lädt ein Skript herunter und startet die Installation
von <code>rustup</code>, welches die neueste stabile Version von Rust installiert.
Du wirst ggf. aufgefordert, dein Passwort einzugeben. Nach erfolgreicher
Installation erscheint folgende Zeile:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Außerdem benötigst su einen Programmbinder (linker), ein Programm, das Rust
verwendet, um die kompilierten Ausgaben in eine Datei zusammenzuführen.
Wahrscheinlich hast du bereits einen. Wenn du Linker-Fehler erhältst, solltest
du einen C-Compiler installieren, der in der Regel auch einen Linker enthält.
Ein C-Compiler ist auch deshalb nützlich, weil einige gängige Rust-Pakete von
C-Code abhängen und daher einen C-Compiler benötigen.</p>
<p>Unter macOS erhältst du einen C-Compiler, indem du folgendes ausführst:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Linux-Benutzer sollten in der Regel GCC oder Clang installieren, je nach
Dokumentation ihrer Distribution. Wenn du zum Beispiel Ubuntu verwendest,
kannst du das Paket <code>build-essential</code> installieren.</p>
<h3 id="die-installation-von-rustup-in-windows"><a class="header" href="#die-installation-von-rustup-in-windows">Die Installation von <code>rustup</code> in Windows</a></h3>
<p>Rufe <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> auf und folge
den Anweisungen, um Rust in Windows zu installieren. Während der Installation
wirst du eine Meldung erhalten, dass du auch die MSVC Bauwerkzeuge für Visual
Studio 2013 oder höher benötigst.</p>
<p>Um die Bauwerkzeuge zu erhalten, musst du <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2022</a>
installieren. Wenn du gefragt wirst, welche Komponenten installiert werden
sollen, gib folgendes an:</p>
<ul>
<li>„Desktop Development with C++“</li>
<li>Das Windows 10 oder 11 SDK</li>
<li>Das englische Sprachpaket zusammen mit einem beliebigen anderen Sprachpaket
deiner Wahl.</li>
</ul>
<p>Der Rest dieses Buchs verwendet Befehle, die sowohl in <em>cmd.exe</em> als auch
in der PowerShell funktionieren. Falls es spezifische Unterschiede geben sollte,
werden wir diese erläutern.</p>
<h3 id="fehlersuche"><a class="header" href="#fehlersuche">Fehlersuche</a></h3>
<p>Um zu überprüfen, ob du Rust korrekt installiert hast, öffne eine
Kommandozeile und gib folgende Zeile ein:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Du solltest die Versionsnummer, den Commit-Hash und das Commit-Datum für die
letzte stabile Version, die veröffentlicht wurde, in folgendem Format sehen:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc jjjj-mm-tt)
</code></pre>
<p>Wenn du diese Information siehst, hast du Rust erfolgreich installiert! Wenn du
diese Information nicht siehst, überprüfe, ob Rust in deiner Systemvariable
<code>%PATH%</code> wie folgt enthalten ist.</p>
<p>In Windows CMD verwende:</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>In PowerShell verwende:</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>In Linux und macOS verwende:</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>Wenn das alles korrekt ist und Rust immer noch nicht funktioniert, gibt es
mehrere Stellen, an denen du Hilfe bekommen kannst. Wie du mit anderen
Rust-Entwicklern in Kontakt treten kannst, erfährst du auf der
<a href="https://www.rust-lang.org/community">Gemeinschafts-Seite</a>.</p>
<h3 id="aktualisieren-und-deinstallieren"><a class="header" href="#aktualisieren-und-deinstallieren">Aktualisieren und Deinstallieren</a></h3>
<p>Nachdem du Rust mithilfe von <code>rustup</code> installiert hast, ist es einfach,
auf die neueste Version zu aktualisieren. Führe folgenden Befehl auf der
Kommandozeile aus:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Um Rust und <code>rustup</code> zu deinstallieren, führe folgenden Befehl aus:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="lokale-dokumentation"><a class="header" href="#lokale-dokumentation">Lokale Dokumentation</a></h3>
<p>Die Rust-Installation enthält auch eine lokale Kopie der Dokumentation, sodass
du sie ohne Internetverbindung lesen kannst. Führe <code>rustup doc</code> aus, um die
lokale Dokumentation in deinem Browser zu öffnen.</p>
<p>Falls du dir nicht sicher bist, wie du einen Typ oder eine Funktion aus der
Standardbibliothek verwenden sollst, dann schau in der API-Dokumentation nach!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hallo-welt"><a class="header" href="#hallo-welt">Hallo Welt</a></h2>
<p>Nun, da du Rust installiert hast, lass uns dein erstes Rust-Programm schreiben.
Wenn man eine neue Sprache lernt, ist es üblich, ein kleines Programm zu
schreiben, das den Text <code>Hallo Welt!</code> auf dem Bildschirm ausgibt, also werden
wir hier das gleiche tun!</p>
<blockquote>
<p>Hinweis: Dieses Buch setzt grundlegende Vertrautheit mit der Kommandozeile
voraus. Rust stellt keine besonderen Anforderungen an deine Textbearbeitung
oder Werkzeuge oder an den Ort, an dem dein Code lebt. Wenn du also lieber
eine integrierte Entwicklungsumgebung (IDE) statt der Kommandozeile verwenden
möchtest, kannst du deine bevorzugte IDE verwenden. Viele IDEs bieten
mittlerweile einen gewissen Grad an Rust-Unterstützung; Einzelheiten findest
du in der Dokumentation der IDE. Das Rust-Team hat sich darauf konzentriert,
eine großartige IDE-Unterstützung mittels <code>rust-analyzer</code> zu ermöglichen.
Siehe <a href="appendix-04-useful-development-tools.html">Anhang D</a> für weitere Details.</p>
</blockquote>
<h3 id="erstellen-eines-projektverzeichnisses"><a class="header" href="#erstellen-eines-projektverzeichnisses">Erstellen eines Projektverzeichnisses</a></h3>
<p>Du beginnst damit, ein Verzeichnis zum Speichern deines Rust-Codes zu
erstellen. Es ist Rust egal, wo dein Code lebt, aber für die Übungen und
Projekte in diesem Buch schlagen wir vor, ein Verzeichnis <em>projects</em> in deinem
Hauptverzeichnis anzulegen und all deine Projekte dort abzulegen.</p>
<p>Öffne eine Kommandozeile und gib die folgenden Befehle ein, um ein Verzeichnis
<em>projects</em> und ein Verzeichnis für das Projekt „Hallo Welt!“ innerhalb des
Verzeichnisses <em>projects</em> zu erstellen.</p>
<p>Gib dies bei Linux, macOS und PowerShell unter Windows ein:</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Bei Windows CMD gib dies ein:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="schreiben-und-ausführen-eines-rust-programms"><a class="header" href="#schreiben-und-ausführen-eines-rust-programms">Schreiben und Ausführen eines Rust-Programms</a></h3>
<p>Als nächstes erstelle eine neue Quelldatei und nenne sie <em>main.rs</em>.
Rust-Dateien enden immer mit der Erweiterung <em>.rs</em>. Wenn du mehr als ein Wort
in deinem Dateinamen verwendest, verwende einen Unterstrich, um sie zu trennen.
Verwende zum Beispiel <em>hello_world.rs</em> statt <em>helloworld.rs</em>.</p>
<p>Öffne nun die Datei <em>main.rs</em>, die du gerade erstellt hast, und gib den Code in
Codeblock 1-1 ein.</p>
<p><span class="filename">Dateiname: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hallo Welt!&quot;);
}</code></pre></pre>
<p><span class="caption">Codeblock 1-1: Ein Programm, das <code>Hallo Welt!</code>
ausgibt</span></p>
<p>Speichere die Datei und gehe zurück zu deinem Konsolenfenster. Gib unter Linux
oder MacOS die folgenden Befehle ein, um die Datei zu kompilieren und auszuführen:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hallo Welt!
</code></pre>
<p>Unter Windows gib den Befehl <code>.\main.exe</code> anstelle von <code>./main</code> ein:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hallo Welt!
</code></pre>
<p>Unabhängig von deinem Betriebssystem sollte die Zeichenfolge <code>Hallo Welt!</code> auf
der Kommandozeile ausgegeben werden. Wenn du diese Ausgabe nicht siehst, lies
im Abschnitt <a href="ch01-01-installation.html#fehlersuche">„Fehlersuche“</a> des Installationsabschnitts nach,
wie du Hilfe erhalten kannst.</p>
<p>Wenn <code>Hallo Welt!</code> ausgegeben wurde, herzlichen Glückwunsch! Du hast offiziell
ein Rust-Programm geschrieben. Das macht dich zu einem Rust-Programmierer
– willkommen!</p>
<h3 id="anatomie-eines-rust-programms"><a class="header" href="#anatomie-eines-rust-programms">Anatomie eines Rust-Programms</a></h3>
<p>Lass uns im Detail Revue passieren, was gerade in deinem „Hallo Welt!“-Programm
passiert ist. Hier ist das erste Teil des Puzzles:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}</code></pre></pre>
<p>Diese Zeilen definieren eine Funktion namens <code>main</code> in Rust. Die Funktion
<code>main</code> ist eine Besonderheit: Sie ist immer der erste Code, der in jedem
ausführbaren Rust-Programm ausgeführt wird. In diesem Fall deklariert die erste
Zeile eine Funktion mit dem namen <code>main</code>, die keine Parameter hat und nichts
zurückgibt. Wenn es Parameter gäbe, würden sie innerhalb der Klammern <code>()</code>
stehen.</p>
<p>Der Funktionsrumpf in geschweifte Klammern <code>{}</code> eingehüllt. Rust erfordert
diese um alle Funktionsrümpfe. Es ist guter Stil, die öffnende geschweifte
Klammer in dieselbe Zeile wie die Funktionsdeklaration zu platzieren und
dazwischen ein Leerzeichen einzufügen.</p>
<blockquote>
<p>Hinweis: Wenn du einen Standardstil für alle Rust-Projekte verwenden
möchtest, kannst du ein automatisches Formatierungswerkzeug namens <code>rustfmt</code>
verwenden, um deinen Code in einem bestimmten Stil zu formatieren (mehr über
<code>rustfmt</code> im <a href="appendix-04-useful-development-tools.html">Anhang D</a>). Das Rust-Team hat dieses Tool wie <code>rustc</code>
in die Standard-Rust-Distribution aufgenommen, es sollte also bereits auf
deinem Computer installiert sein!</p>
</blockquote>
<p>Innerhalb der Funktion <code>main</code> befindet sich der folgende Code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hallo Welt!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Diese Zeile erledigt die ganze Arbeit in diesem kleinen Programm: Sie gibt Text
auf dem Bildschirm aus. Hier gibt es vier wichtige Details zu beachten.</p>
<p>Erstens wird im Rust-Stil mit vier Leerzeichen eingerückt, nicht mit einem
Tabulator.</p>
<p>Zweitens ruft <code>println!</code> ein Rust-Makro auf. Wenn es stattdessen eine Funktion
aufrufte, würde diese als <code>println</code> (ohne <code>!</code>) angegeben werden. Wir werden die
Rust-Makros in Kapitel 19 ausführlicher besprechen. Im Moment musst du nur
wissen, dass die Verwendung eines <code>!</code> bedeutet, dass du ein Makro anstelle
einer normalen Funktion aufrufst und dass Makros nicht immer denselben Regeln
folgen wie Funktionen.</p>
<p>Drittens siehst du die Zeichenkette <code>&quot;Hallo Welt!&quot;</code>. Wir übergeben diese
Zeichenkette als Argument an <code>println!</code>, und die Zeichenkette wird auf dem
Bildschirm ausgegeben.</p>
<p>Viertens beenden wir die Zeile mit einem Semikolon (<code>;</code>), was anzeigt, dass
dieser Ausdruck beendet ist und der nächste beginnen kann. Die meisten Zeilen
eines Rust-Codes enden mit einem Semikolon.</p>
<h3 id="kompilieren-und-ausführen-sind-getrennte-schritte"><a class="header" href="#kompilieren-und-ausführen-sind-getrennte-schritte">Kompilieren und Ausführen sind getrennte Schritte</a></h3>
<p>Du hast gerade ein neu erstelltes Programm ausgeführt, also lass uns jeden
Schritt in diesem Prozess untersuchen.</p>
<p>Bevor du ein Rust-Programm ausführst, musst du es mit dem Rust-Compiler
kompilieren, indem du den Befehl <code>rustc</code> eingibst und ihm den Namen deiner
Quelldatei übergibst, so wie hier:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>Wenn du einen C- oder C++-Hintergrund hast, wirst du feststellen, dass dies
ähnlich wie <code>gcc</code> oder <code>clang</code> ist. Nach erfolgreicher Kompilierung gibt Rust
eine ausführbare Binärdatei aus.</p>
<p>Unter Linux, MacOS und PowerShell unter Windows kannst du die ausführbare Datei
sehen, indem du den Befehl <code>ls</code> in deiner Konsole eingibst:</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>Unter Linux und MacOS siehst du zwei Dateien. Mit PowerShell unter Windows
siehst du die gleichen drei Dateien, die du mit CMD sehen würdest. Bei CMD
unter Windows würdest du folgendes eingeben:</p>
<pre><code class="language-cmd">&gt; dir /B %= die Option /B bewirkt, dass nur die Dateinamen angezeigt werden =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Dies zeigt die Quellcodedatei mit der Erweiterung <em>.rs</em>, die ausführbare Datei
(<em>main.exe</em> unter Windows, aber <em>main</em> auf allen anderen Plattformen) und, bei
Verwendung von Windows, eine Datei mit Debugging-Informationen mit der
Erweiterung <em>.pdb</em>. Von hier aus führst du die Datei <em>main</em> oder <em>main.exe</em>
aus, so wie hier:</p>
<pre><code class="language-console">$ ./main # oder .\main.exe unter Windows
</code></pre>
<p>Wenn <em>main.rs</em> dein „Hallo Welt!“-Programm wäre, würde diese Zeile „Hallo
Welt!“ in deiner Konsole ausgeben.</p>
<p>Wenn du mit einer dynamischen Sprache wie Ruby, Python oder JavaScript besser
vertraut bist, bist du es möglicherweise nicht gewohnt, ein Programm in
getrennten Schritten zu kompilieren und auszuführen. Rust ist eine <em>vorab
kompilierte</em> (ahead-of-time compiled) Sprache, d.h. du kannst ein Programm
kompilieren und die ausführbare Datei an jemand anderen weitergeben, und dieser
kann das Programm auch ohne Installation von Rust ausführen. Wenn du jemandem
eine <em>.rb</em>-, <em>.py</em>- oder <em>.js</em>-Datei gibst, muss er eine Ruby-, Python- bzw.
JavaScript-Implementierung installiert haben. Aber in diesen Sprachen benötigst
du nur einen Befehl, um dein Programm zu kompilieren und auszuführen. Beim
Sprachdesign ist alles ein Kompromiss.</p>
<p>Einfach mit <code>rustc</code> zu kompilieren ist für einfache Programme in Ordnung, aber
wenn dein Projekt wächst, wirst du alle Optionen verwalten und es einfach
machen wollen, deinen Code weiterzugeben. Als Nächstes stellen wir dir das
Cargo-Tool vor, das dir beim Schreiben von Rust-Programmen aus der realen Welt
helfen wird.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hallo-cargo"><a class="header" href="#hallo-cargo">Hallo Cargo</a></h2>
<p>Cargo ist das Bau-System (build system) und der Paketmanager von Rust. Die
meisten Rust-Entwickler verwenden dieses Werkzeug, um ihre Rust-Projekte zu
verwalten, weil Cargo viele Aufgaben für dich erledigt, z.B. Bauen deines
Codes, Herunterladen der Bibliotheken, von denen dein Code abhängt, und das
Bauen dieser Bibliotheken. (Wir nennen Bibliotheken, die dein Code benötigt,
<em>Abhängigkeiten</em> (dependencies).)</p>
<p>Die einfachsten Rust-Programme, wie das, das wir bisher geschrieben haben,
haben keine Abhängigkeiten. Wenn wir also das „Hallo Welt!“-Projekt mit Cargo
gebaut hätten, würde es nur den Teil von Cargo verwenden, der für das Bauen
deines Codes zuständig ist. Wenn du komplexere Rust-Programme schreibst, wirst
du Abhängigkeiten hinzufügen, und wenn du ein Projekt mit Cargo beginnst, wird
das Hinzufügen von Abhängigkeiten viel einfacher sein.</p>
<p>Da die überwiegende Mehrheit der Rust-Projekte Cargo verwendet, geht der Rest
dieses Buches davon aus, dass auch du Cargo verwendest. Cargo wird mit Rust
installiert, wenn du die offiziellen Installationsprogramme verwendet hast, die
im Abschnitt <a href="ch01-01-installation.html">„Installation“</a> besprochen werden. Wenn du Rust auf
eine andere Weise installiert hast, prüfe, ob Cargo installiert ist, indem du
Folgendes in dein Terminal eingibst:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>Wenn du eine Versionsnummer siehst, hast du es! Wenn du einen Fehler siehst,
z.B. <code>command not found</code>, schaue in der Dokumentation zu deiner
Installationsmethode nach, um festzustellen, wie du Cargo separat installieren
kannst.</p>
<h3 id="projekt-mit-cargo-erstellen"><a class="header" href="#projekt-mit-cargo-erstellen">Projekt mit Cargo erstellen</a></h3>
<p>Lass uns mit Cargo ein neues Projekt erstellen und uns ansehen, wie es sich von
unserem ursprünglichen „Hallo Welt!“-Projekt unterscheidet. Navigiere zurück zu
deinem <em>projects</em>-Verzeichnis (oder wo auch immer du dich entschieden hast,
deinen Code zu speichern). Führe dann auf einem beliebigen Betriebssystem die
folgenden Schritte aus:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>Der erste Befehl erstellt ein neues Verzeichnis und ein Projekt namens
<em>hello_cargo</em>. Wir haben unser Projekt <em>hello_cargo</em> genannt und Cargo
erstellt seine Dateien in einem Verzeichnis mit demselben Namen.</p>
<p>Gehe in das Verzeichnis <em>hello_cargo</em> und liste die Dateien auf. Du wirst
sehen, dass Cargo zwei Dateien und ein Verzeichnis für uns generiert hat: Eine
Datei <em>Cargo.toml</em> und ein Verzeichnis <em>src</em> mit einer Datei <em>main.rs</em> darin.</p>
<p>Es hat auch ein neues Git-Repository zusammen mit einer Datei <em>.gitignore</em>
initialisiert. Git-Dateien werden nicht erzeugt, wenn du <code>cargo new</code> innerhalb
eines existierenden Git-Repositories ausführst; du kannst dieses Verhalten
überschreiben, indem du <code>cargo new --vcs=git</code> verwendest. </p>
<blockquote>
<p>Hinweis: Git ist ein gebräuchliches Versionskontrollsystem. Du kannst <code>cargo new</code> anpassen, um ein anderes Versionskontrollsystem oder kein
Versionskontrollsystem zu verwenden, indem du das Flag <code>--vcs</code> verwendest.
Führe <code>cargo new --help</code> aus, um die verfügbaren Optionen zu sehen.</p>
</blockquote>
<p>Öffne <em>Cargo.toml</em> in einem Texteditor deiner Wahl. Es sollte ähnlich wie der
Code in Codeblock 1-2 aussehen.</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# Weitere Schlüssel und ihre Definitionen findest du unter
# https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p><span class="caption">Codeblock 1-2: Inhalt von <em>Cargo.toml</em> erzeugt durch
<code>cargo new</code></span></p>
<p>Diese Datei liegt im Format <a href="https://toml.io"><em>TOML</em></a> (<em>Tom's Obvious, Minimal
Language</em>) vor, welches das Konfigurationsformat von Cargo ist.</p>
<p>Die erste Zeile <code>[package]</code> ist eine Abschnittsüberschrift, die anzeigt, dass
die folgenden Anweisungen ein Paket konfigurieren. Wenn wir weitere
Informationen zu dieser Datei hinzufügen, werden wir weitere Abschnitte
hinzufügen.</p>
<p>Die nächsten drei Zeilen legen die Konfigurationsinformationen fest, die Cargo
benötigt, um dein Programm zu kompilieren: Den Namen, die Version und die zu 
verwendende Rust-Ausgabe. Über den Schlüssel <code>edition</code> sprechen wir in <a href="appendix-05-editions.html">Anhang
E</a>.</p>
<p>Die letzte Zeile <code>[dependencies]</code> ist der Anfang eines Abschnitts, in dem du
alle Abhängigkeiten deines Projekts auflisten kannst. In Rust werden
Code-Pakete als <em>Kisten</em> (crates) bezeichnet. Wir werden keine anderen Kisten
für dieses Projekt benötigen, aber wir werden es im ersten Projekt in Kapitel 2
tun, also werden wir dann diesen Abhängigkeits-Abschnitt verwenden.</p>
<p>Öffne nun <em>src/main.rs</em> und wirf einen Blick darauf:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p>Cargo hat für dich ein „Hello, world!“-Programm generiert, genau wie das, das
wir in Codeblock 1-1 geschrieben haben! Die Unterschiede zwischen unserem
Projekt und dem Projekt, das Cargo generiert hat, bestehen bisher darin, dass
Cargo den Code im Verzeichnis <em>src</em> abgelegt hat, und wir haben eine
Konfigurationsdatei <em>Cargo.toml</em> im obersten Verzeichnis.</p>
<p>Cargo erwartet, dass deine Quelldateien innerhalb des <em>src</em>-Verzeichnisses
liegen. Das Projektverzeichnis der obersten Ebene ist nur für README-Dateien,
Lizenzinformationen, Konfigurationsdateien und alles andere, was nicht mit
deinem Code zusammenhängt. Das Verwenden von Cargo hilft dir, deine Projekte zu
organisieren. Es gibt einen Platz für alles und alles ist an seinem Platz.</p>
<p>Wenn du ein Projekt begonnen hast, das Cargo nicht verwendet, wie wir es mit
dem Projekt „Hallo Welt!“ getan haben, kannst du es in ein Projekt umwandeln,
das Cargo verwendet. Verschiebe den Projektcode in das Verzeichnis <em>src</em> und
erstelle eine entsprechende <em>Cargo.toml</em>-Datei.</p>
<h3 id="bauen-und-ausführen-eines-cargo-projekts"><a class="header" href="#bauen-und-ausführen-eines-cargo-projekts">Bauen und Ausführen eines Cargo-Projekts</a></h3>
<p>Schauen wir uns nun an, was anders ist, wenn wir das „Hello, world!“-Programm
mit Cargo bauen und ausführen. Von deinem <em>hello_cargo</em>-Verzeichnis aus baust
du dein Projekt, indem du den folgenden Befehl eingibst:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Dieser Befehl erzeugt eine ausführbare Datei in <em>target/debug/hello_cargo</em>
(oder <em>target\debug\hello_cargo.exe</em> unter Windows) und nicht in deinem
aktuellen Verzeichnis. Da standardmäßig für den Debug-Modus gebaut wird, legt
Cargo die Binärdatei in einem Verzeichnis namens <em>debug</em> ab. Mit diesem Befehl
kannst du die ausführbare Datei ausführen:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # oder .\target\debug\hello_cargo.exe unter Windows
Hello, world!
</code></pre>
<p>Wenn alles gut geht, sollte <code>Hello, world!</code> im Terminal ausgegeben werden. Wenn
<code>cargo build</code> zum ersten Mal ausgeführt wird, erzeugt Cargo auch eine neue
Datei auf der obersten Ebene: <em>Cargo.lock</em>. Diese Datei verfolgt die genauen
Versionen der Abhängigkeiten in deinem Projekt. Dieses Projekt hat keine
Abhängigkeiten, daher ist die Datei etwas spärlich. Du musst diese Datei
niemals manuell ändern; Cargo verwaltet ihren Inhalt für dich.</p>
<p>Wir haben gerade ein Projekt mit <code>cargo build</code> gebaut und es mit
<code>./target/debug/hello_cargo</code> ausgeführt, aber wir können auch <code>cargo run</code>
verwenden, um den Code zu kompilieren und dann die resultierende ausführbare
Datei mit einem einzigen Befehl auszuführen:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Das Verwenden von <code>cargo run</code> ist bequemer, als sich daran erinnern zu müssen,
<code>cargo build</code> auszuführen und dann den gesamten Pfad zur Binärdatei zu
verwenden, daher verwenden die meisten Entwickler <code>cargo run</code>.</p>
<p>Beachte, dass wir diesmal keine Ausgabe gesehen haben, die darauf hinweist,
dass Cargo <code>hello_cargo</code> kompiliert hat. Cargo fand heraus, dass sich die
Dateien nicht geändert hatten, also hat es nicht neu gebaut, sondern ließ
einfach die Binärdatei laufen. Wenn du deinen Quellcode geändert hättest, hätte
Cargo das Projekt vor der Ausführung neu kompiliert, und du hättest diese
Ausgabe gesehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo bietet auch einen Befehl namens <code>cargo check</code>. Dieser Befehl überprüft
schnell deinen Code, um sicherzustellen, dass er kompiliert, erzeugt aber keine
ausführbare Datei:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>Warum willst du keine ausführbare Datei? Häufig ist <code>cargo check</code> viel
schneller als <code>cargo build</code>, weil es den Schritt der Erstellung einer
ausführbaren Datei überspringt. Wenn du deine Arbeit während des Schreibens des
Codes ständig überprüfst, wird das Verwenden von <code>cargo check</code> den Prozess
beschleunigen! Daher führen viele Rust-Entwickler während des Schreibens ihres
Programms regelmäßig <code>cargo check</code> aus, um sicherzustellen, dass das Programm
kompiliert. Dann lassen sie <code>cargo build</code> laufen, wenn sie bereit sind, die
ausführbare Datei zu benutzen.</p>
<p>Lasse uns zusammenfassen, was wir bisher über Cargo gelernt haben:</p>
<ul>
<li>Wir können ein Projekt mit <code>cargo new</code> erstellen.</li>
<li>Wir können ein Projekt mit <code>cargo build</code> bauen.</li>
<li>Wir können ein Projekt mit <code>cargo run</code> in einem Schritt bauen und ausführen.</li>
<li>Wir können ein Projekt mit <code>cargo check</code> bauen, ohne eine Binärdatei zu
erzeugen, um auf Fehler zu prüfen.</li>
<li>Anstatt das Ergebnis des Bauvorgangs im selben Verzeichnis wie unser Code
abzulegen, legt Cargo es im Verzeichnis <em>target/debug</em> ab.</li>
</ul>
<p>Ein zusätzlicher Vorteil der Verwendung von Cargo ist, dass die Befehle
unabhängig vom Betriebssystem sind, mit dem du arbeitest. Daher werden wir an
dieser Stelle keine spezifischen Anweisungen für Linux und macOS gegenüber
Windows mehr geben.</p>
<h3 id="bauen-einer-freigabe-release"><a class="header" href="#bauen-einer-freigabe-release">Bauen einer Freigabe (release)</a></h3>
<p>Wenn dein Projekt schließlich zur Freigabe bereit ist, kannst du <code>cargo build --release</code> verwenden, um es mit Optimierungen zu kompilieren. Dieser Befehl
erzeugt eine ausführbare Datei in <em>target/release</em> anstelle von <em>target/debug</em>.
Durch die Optimierungen läuft dein Rust-Code schneller, aber wenn du sie
einschaltest, verlängert sich die Zeit, die dein Programm zum Kompilieren
benötigt. Aus diesem Grund gibt es zwei verschiedene Profile: Eines für die
Entwicklung, wenn du schnell und oft neu bauen willst, und ein anderes für das
Erstellen des endgültigen Programms, das du einem Benutzer gibst, das nicht
wiederholt neu gebaut wird und das so schnell wie möglich läuft. Wenn du einen
Laufzeit-Benchmark deines Codes durchführst, stelle sicher, dass du <code>cargo build --release</code> ausführst und den Benchmark mit der ausführbaren Datei in
<em>target/release</em> durchführst.</p>
<h3 id="cargo-als-konvention"><a class="header" href="#cargo-als-konvention">Cargo als Konvention</a></h3>
<p>Bei einfachen Projekten bietet Cargo nicht viel mehr Wert als das bloße
Verwenden von <code>rustc</code>, aber es wird sich in dem Maße bewähren, wie deine
Programme immer komplizierter werden. Sobald Programme auf mehrere Dateien
anwachsen oder eine Abhängigkeit benötigen, ist es viel einfacher, Cargo den
Bauvorgang koordinieren zu lassen.</p>
<p>Auch wenn das Projekt <code>hello_cargo</code> einfach ist, so verwendet es jetzt einen
Großteil der realen Werkzeuge, die du im Rest deiner Rust-Karriere verwenden
wirst. Tatsächlich kannst du, um an bestehenden Projekten zu arbeiten, die
folgenden Befehle verwenden, um den Code mit Git auszuchecken, in das
Verzeichnis dieses Projekts zu wechseln und zu bauen:</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Weitere Informationen über Cargo findest du unter seiner
<a href="https://doc.rust-lang.org/cargo/">Dokumentation</a>.</p>
<h2 id="zusammenfassung"><a class="header" href="#zusammenfassung">Zusammenfassung</a></h2>
<p>Du hast deine Rust-Reise bereits gut begonnen! In diesem Kapitel hast du
gelernt, wie es geht:</p>
<ul>
<li>Installiere die neueste stabile Version von Rust mit <code>rustup</code>.</li>
<li>Aktualisiere auf eine neuere Rust-Version.</li>
<li>Öffne die lokal installierte Dokumentation.</li>
<li>Schreibe und führe ein „Hallo Welt!“-Programm aus, direkt mittels <code>rustc</code>.</li>
<li>Schreibe und führe ein neues Projekt aus mittels Cargo-Konventionen.</li>
</ul>
<p>Dies ist ein guter Zeitpunkt, ein umfangreicheres Programm zu erstellen, um
sich an das Lesen und Schreiben von Rust-Code zu gewöhnen. In Kapitel 2 werden
wir also ein Ratespielprogramm erstellen. Wenn du lieber damit beginnen
möchtest, zu lernen, wie gängige Programmierkonzepte in Rust funktionieren,
lies Kapitel 3 und kehre dann zu Kapitel 2 zurück.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ein-ratespiel-programmieren"><a class="header" href="#ein-ratespiel-programmieren">Ein Ratespiel programmieren</a></h1>
<p>Lass uns den Sprung in Rust wagen, indem wir gemeinsam ein praktisches Projekt
durcharbeiten! Dieses Kapitel führt dich in einige gängige Rust-Konzepte ein,
indem es dir zeigt, wie du diese in einem realen Programm verwenden kannst. Du
lernst <code>let</code>, <code>match</code>, Methoden, assoziierte Funktionen, externe Kisten
(crates) und mehr kennen! In den folgenden Kapiteln werden wir diese Ideen
ausführlicher behandeln. In diesem Kapitel wirst du nur die Grundlagen üben.</p>
<p>Wir werden ein klassisches Programmierproblem für Anfänger implementieren: Ein
Ratespiel. Und so funktioniert es: Das Programm erzeugt eine zufällige ganze
Zahl zwischen 1 und 100. Dann wird es den Spieler auffordern, eine Schätzung
einzugeben. Nachdem eine Schätzung eingegeben wurde, zeigt das Programm an, ob
die Schätzung zu niedrig oder zu hoch ist. Wenn die Schätzung korrekt ist, gibt
das Spiel eine Glückwunschnachricht aus und beendet sich.</p>
<h2 id="aufsetzen-eines-neuen-projekts"><a class="header" href="#aufsetzen-eines-neuen-projekts">Aufsetzen eines neuen Projekts</a></h2>
<p>Um ein neues Projekt aufzusetzen, gehe in das Verzeichnis <em>projects</em>, das du in
Kapitel 1 erstellt hast, und erstelle ein neues Projekt mit Cargo, wie folgt:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>Der erste Befehl <code>cargo new</code> nimmt den Namen des Projekts (<code>guessing_game</code>) als
erstes Argument. Der zweite Befehl wechselt in das Verzeichnis des neuen
Projekts.</p>
<p>Schaue dir die generierte Datei <em>Cargo.toml</em> an:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>Wie du in Kapitel 1 gesehen hast, generiert <code>cargo new</code> ein „Hello,
world!“-Programm für dich. Sieh dir die Datei <em>src/main.rs</em> an:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p>Kompilieren wir nun dieses „Hello, world!“-Programm und führen es im gleichen
Schritt aus mit dem Befehl <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Der Befehl <code>run</code> ist praktisch, wenn du ein Projekt schnell iterieren musst,
wie wir es in diesem Spiel tun werden, indem du jede Iteration schnell testest,
bevor du zur nächsten übergehst.</p>
<p>Öffne die Datei <em>src/main.rs</em> erneut. Du wirst den gesamten Code in diese Datei
schreiben.</p>
<h2 id="verarbeiten-einer-schätzung"><a class="header" href="#verarbeiten-einer-schätzung">Verarbeiten einer Schätzung</a></h2>
<p>Der erste Teil des Ratespielprogramms fragt nach einer Benutzereingabe,
verarbeitet diese Eingabe und überprüft, ob die Eingabe in der erwarteten Form
vorliegt. Zu Beginn erlauben wir dem Spieler, eine Schätzung einzugeben. Gib
den Code aus Codeblock 2-1 in <em>src/main.rs</em> ein.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    println!(&quot;Bitte gib deine Schätzung ein.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    println!(&quot;Du hast geschätzt: {guess}&quot;);
}</code></pre>
<p><span class="caption">Codeblock 2-1: Code, der eine Schätzung vom Benutzer
erhält und ausgibt</span></p>
<p>Dieser Code enthält eine Menge Informationen, also gehen wir ihn Zeile für
Zeile durch. Um eine Benutzereingabe zu erhalten und das Ergebnis dann als
Ausgabe auszugeben, müssen wir die Bibliothek <code>io</code> (input/output) in den
Gültigkeitsbereich bringen. Die <code>io</code>-Bibliothek stammt aus der
Standardbibliothek, bekannt als <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geschätzt: {guess}&quot;);
</span><span class="boring">}</span></code></pre>
<p>Standardmäßig hat Rust einige Elemente in der Standardbibliothek definiert,
die es in den Gültigkeitsbereich jedes Programms bringt. Diese Menge wird
<em>Präludium</em> genannt, und du kannst deren Inhalt <a href="https://doc.rust-lang.org/std/prelude/index.html">in der Dokumentation der
Standardbibliothek</a> sehen.</p>
<p>Wenn ein Typ, den du verwenden willst, nicht im Präludium enthalten ist, musst
du diesen Typ explizit mit einer <code>use</code>-Anweisung in den Gültigkeitsbereich
bringen. Das Verwenden der Bibliothek <code>std::io</code> bietet dir eine Reihe von
nützlichen Funktionalitäten, einschließlich der Möglichkeit, Benutzereingaben
entgegenzunehmen.</p>
<p>Wie du in Kapitel 1 gesehen hast, ist die Funktion <code>main</code> der Einstiegspunkt in
das Programm:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geschätzt: {guess}&quot;);
</span><span class="boring">}</span></code></pre>
<p>Die Syntax <code>fn</code> deklariert eine neue Funktion; die Klammern <code>()</code> zeigen an,
dass es keine Parameter gibt; und die geschweifte Klammer <code>{</code> beginnt den Rumpf
der Funktion.</p>
<p>Wie du auch in Kapitel 1 gelernt hast, ist <code>println!</code> ein Makro, das eine
Zeichenkette auf dem Bildschirm ausgibt:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Rate die Zahl!&quot;);

    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geschätzt: {guess}&quot;);
</span><span class="boring">}</span></code></pre>
<p>Dieser Code gibt eine Eingabeaufforderung aus, die angibt, um was für ein Spiel
es sich handelt, und den Benutzer zur Eingabe auffordert.</p>
<h3 id="speichern-von-werten-mit-variablen"><a class="header" href="#speichern-von-werten-mit-variablen">Speichern von Werten mit Variablen</a></h3>
<p>Als Nächstes erstellen wir eine <em>Variable</em>, um die Benutzereingabe zu
speichern, wie hier:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geschätzt: {guess}&quot;);
</span><span class="boring">}</span></code></pre>
<p>Jetzt wird das Programm interessant! Es ist viel los in dieser kleinen Zeile.
Wir verwenden eine <code>let</code>-Anweisung, um eine Variable zu erzeugen. Hier ist ein
weiteres Beispiel:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>Diese Zeile erzeugt eine neue Variable namens <code>apples</code> und bindet sie an den
Wert 5. In Rust sind Variablen standardmäßig unveränderbar (immutable), das
heißt, sobald wir der Variablen einen Wert gegeben haben, wird sich der Wert
nicht mehr ändern. Wir werden dieses Konzept im Abschnitt <a href="ch03-01-variables-and-mutability.html">„Variablen und
Veränderbarkeit“</a> in Kapitel 3 ausführlich
besprechen. Um eine Variable veränderbar zu machen, ergänzen wir <code>mut</code> vor dem
Variablennamen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let apples = 5; // unveränderbar
let mut bananas = 5; // veränderbar
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Anmerkung: Die Syntax <code>//</code> beginnt einen Kommentar, der bis zum Ende der
Zeile weitergeht. Rust ignoriert alles in Kommentaren. Diese werden in
Kapitel 3 ausführlicher besprochen.</p>
</blockquote>
<p>Zurück zum Programm des Ratespiels. Du weißt jetzt, dass <code>let mut guess</code> eine veränderbare Variable namens <code>guess</code> einführt. Das
Gleichheitszeichen (<code>=</code>) sagt Rust, dass wir jetzt etwas an die Variable binden
wollen. Auf der rechten Seite des Gleichheitszeichens steht der Wert, an den
<code>guess</code> gebunden ist, was das Ergebnis des Aufrufs von <code>String::new</code> ist, einer
Funktion, die eine neue Instanz eines <code>String</code> zurückgibt. <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>
ist ein von der Standardbibliothek bereitgestellter Zeichenketten-Typ, der ein
wachstumsfähiges, UTF-8-kodiertes Stück Text ist.</p>
<p>Die Syntax <code>::</code> in der Zeile <code>::new</code> zeigt an, dass <code>new</code> eine assoziierte
Funktion (associated function) vom Typ <code>String</code> ist. Eine <em>assoziierte
Funktion</em> ist eine Funktion, die auf einem Typ, in diesem Fall <code>String</code>,
implementiert ist. Diese Funktion <code>new</code> erzeugt eine neue, leere Zeichenkette.
Du wirst eine Funktion <code>new</code> bei vielen Typen finden, weil es ein
gebräuchlicher Name für eine Funktion ist, die einen neuen Wert irgendeiner Art
erzeugt.</p>
<p>Insgesamt hat die Zeile <code>let mut guess = String::new();</code> eine veränderbare
Variable erzeugt, die derzeit an eine neue, leere Instanz eines <code>String</code>
gebunden ist. Uff!</p>
<h3 id="empfangen-von-benutzereingaben"><a class="header" href="#empfangen-von-benutzereingaben">Empfangen von Benutzereingaben</a></h3>
<p>Erinnere dich, dass wir die Ein-/Ausgabefunktionalität aus der
Standardbibliothek mit <code>use std::io;</code> in der ersten Zeile des Programms
eingebunden haben. Jetzt rufen wir die Funktion <code>stdin</code> aus dem Modul <code>io</code> auf,
die es uns ermöglichen wird, Benutzereingaben zu verarbeiten.</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geschätzt: {guess}&quot;);
</span><span class="boring">}</span></code></pre>
<p>Hätten wir die Bibliothek <code>io</code> nicht am Anfang des Programms mit <code>use std::io;</code>
importiert, könnten wir die Funktion trotzdem verwenden, indem wir den
Funktionsaufruf als <code>std::io::stdin</code> schreiben. Die Funktion <code>stdin</code> gibt eine
Instanz von <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a> zurück, was ein Typ ist, der eine
Standardeingaberessource (handle to the standard input) für dein Terminal
darstellt.</p>
<p>Die nächste Zeile <code>.read_line(&amp;mut guess)</code> ruft die Methode
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a> der Standardeingaberessource auf, um eine Eingabe vom
Benutzer zu erhalten. Wir übergeben auch das Argument <code>&amp;mut guess</code> an
<code>read_line</code>, um ihm mitzuteilen, in welche Zeichenfolge es die Benutzereingabe
speichern soll. Die Aufgabe von <code>read_line</code> ist es, alles, was der Benutzer in
die Standardeingabe eingibt, an eine Zeichenkette anzuhängen (ohne deren Inhalt
zu überschreiben), daher übergeben wir diese Zeichenkette als Argument. Das
Zeichenketten-Argument muss veränderbar sein, damit die Methode den Inhalt der
Zeichenkette ändern kann.</p>
<p>Das <code>&amp;</code> zeigt an, dass es sich bei diesem Argument um eine <em>Referenz</em> handelt,
die dir eine Möglichkeit bietet, mehrere Teile deines Codes auf einen Datenteil
zugreifen zu lassen, ohne dass du diese Daten mehrfach in den Speicher kopieren
musst. Referenzen sind eine komplexe Funktionalität, und einer der
Hauptvorteile von Rust ist, wie sicher und einfach es ist, Referenzen zu
verwenden. Du musst nicht viele dieser Details kennen, um dieses Programm
fertigzustellen. Im Moment musst du nur wissen, dass Referenzen wie Variablen
standardmäßig unveränderbar sind. Daher musst du <code>&amp;mut guess</code> anstatt <code>&amp;guess</code>
schreiben, um sie veränderbar zu machen. (In Kapitel 4 werden Referenzen
ausführlicher erklärt.)</p>
<h3 id="behandeln-potentieller-fehler-mit-result"><a class="header" href="#behandeln-potentieller-fehler-mit-result">Behandeln potentieller Fehler mit <code>Result</code></a></h3>
<p>Wir arbeiten noch immer an dieser Codezeile. Wir besprechen jetzt eine dritte
Textzeile, aber beachte, dass sie immer noch Teil einer einzigen logischen
Codezeile ist. Der nächste Teil ist diese Methode:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;Du hast geschätzt: {guess}&quot;);
</span><span class="boring">}</span></code></pre>
<p>Wir hätten diesen Code auch so schreiben können:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Fehler beim Lesen der Zeile&quot;);</code></pre>
<p>Eine lange Zeile ist jedoch schwer zu lesen, daher ist es am besten, sie
aufzuteilen. Es ist oft ratsam, einen Zeilenumbruch und andere Leerzeichen
einzufügen, um lange Zeilen aufzubrechen, wenn du eine Methode mit der
Syntax <code>.method_name()</code> aufrufst. Lass uns nun besprechen, was diese Zeile
bewirkt. </p>
<p>Wie bereits erwähnt, schreibt <code>read_line</code> die Benutzereingabe in die übergebene 
String-Variable, gibt aber darüber hinaus auch einen <code>Result</code>-Wert
zurück.
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> ist eine <a href="ch06-00-enums.html"><em>Aufzählung</em></a> (enumeration, oder
kurz enum), die einen Datentyp darstellt, der einem von mehreren möglichen
Zuständen annehmen kann.
Wir nennen jeden möglichen Zustand eine <em>Variante</em>.</p>
<p>In Kapitel 6 werden <a href="ch06-00-enums.html">Aufzählungen</a> ausführlicher behandelt. Der Zweck
dieser <code>Result</code>-Typen ist es, Informationen zur Fehlerbehandlung zu kodieren.</p>
<p>Die Varianten von  <code>Result</code> sind <code>Ok</code> und <code>Err</code>. Die Variante <code>Ok</code> gibt an, dass
die Operation erfolgreich war, und der erfolgreich
generierte Wert innerhalb von <code>Ok</code> steht. 
Die Variante <code>Err</code> bedeutet, dass die Operation fehlgeschlagen
ist, und <code>Err</code> enthält Informationen darüber, wie oder warum die Operation
fehlgeschlagen ist.</p>
<p>Für Werte vom Typ <code>Result</code> sind, wie für Werte jedes Typs, Methoden definiert.
Eine Instanz von <code>Result</code> hat eine <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">Methode <code>expect</code></a>, die du
aufrufen kannst. Wenn diese <code>io::Result</code>-Instanz ein <code>Err</code>-Wert ist, wird
<code>expect</code> das Programm zum Absturz bringen und die Meldung anzeigen, die du als
Argument an <code>expect</code> übergeben hast. Wenn die Methode <code>read_line</code> ein <code>Err</code>
zurückgibt, ist dies wahrscheinlich das Ergebnis eines Fehlers, der vom
zugrundeliegenden Betriebssystem herrührt. Wenn diese <code>io::Result</code>-Instanz ein
<code>Ok</code>-Wert ist, wird <code>expect</code> den Wert, den <code>Ok</code> hält, als Rückgabewert
verwenden, damit du ihn verwenden kannst. In diesem Fall ist dieser Wert die
Anzahl der Bytes, die der Benutzer in die Standardeingabe eingegeben hat.</p>
<p>Wenn du nicht <code>expect</code> aufrufst, wird das Programm kompiliert, aber du erhältst
eine Warnung:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning

    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust warnt, dass du den von <code>read_line</code> zurückgegebenen <code>Result</code>-Wert nicht
verwendet hast, was darauf hinweist, dass das Programm einen möglichen Fehler
nicht behandelt hat.</p>
<p>Der richtige Weg, die Warnung zu unterdrücken, ist eine Fehlerbehandlung zu
schreiben, aber da wir dieses Programm einfach nur abstürzen lassen wollen,
wenn ein Problem auftritt, können wir <code>expect</code> verwenden. In <a href="ch09-02-recoverable-errors-with-result.html">Kapitel
9</a> erfährst du, wie man sich von Fehlern erholt.</p>
<h3 id="ausgeben-von-werten-mit-println-platzhaltern"><a class="header" href="#ausgeben-von-werten-mit-println-platzhaltern">Ausgeben von Werten mit <code>println!</code>-Platzhaltern</a></h3>
<p>Abgesehen von der schließenden geschweiften Klammer gibt es in dem bisher
hinzugefügten Code nur noch eine weitere Zeile zu besprechen: </p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span>    println!(&quot;Du hast geschätzt: {guess}&quot;);
<span class="boring">}</span></code></pre>
<p>Diese Zeile gibt die Zeichenkette aus, die jetzt die Eingabe des Benutzers
enthält. Der Satz geschweifte Klammern <code>{}</code> ist ein Platzhalter:
Stelle dir <code>{}</code> wie kleine Krebszangen vor, die einen Wert an Ort und Stelle
halten. Wenn du den Wert einer Variablen ausgibst, kann der Variablenname
innerhalb der geschweiften Klammern stehen. Wenn du das Ergebnis der Auswertung
eines Ausdrucks ausgeben willst, füge leere geschweifte Klammern in die
Formatierungszeichenkette ein und gib dann nach der Formatierungszeichenkette
eine durch Komma getrennte Liste von Ausdrücken ein, die in jedem leeren
geschweiften Klammerplatzhalter in derselben Reihenfolge ausgegeben werden
sollen. Das Ausgeben einer Variablen und des Ergebnisses eines Ausdrucks in
einem Aufruf von <code>println!</code> würde wie folgt aussehen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {x} und y + 2 = {}&quot;, y + 2);
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code würde <code>x = 5 und y + 2 = 12</code> ausgeben.</p>
<h3 id="testen-des-ersten-teils"><a class="header" href="#testen-des-ersten-teils">Testen des ersten Teils</a></h3>
<p>Testen wir den ersten Teil des Ratespiels. Führe ihn mit <code>cargo run</code> aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Rate die Zahl!
Bitte gib deine Schätzung ein.
6
Du hast geschätzt: 6
</code></pre>
<p>An diesem Punkt ist der erste Teil des Spiels abgeschlossen: Wir erhalten
eine Eingabe über die Tastatur und geben sie dann aus.</p>
<h2 id="generieren-einer-geheimzahl"><a class="header" href="#generieren-einer-geheimzahl">Generieren einer Geheimzahl</a></h2>
<p>Als Nächstes müssen wir eine Geheimzahl generieren, die der Benutzer versucht 
zu erraten. Die Geheimzahl sollte jedes Mal anders sein, damit das Spiel mehr als
einmal Spaß macht. Wir werden eine Zufallszahl zwischen 1 und 100 verwenden,
damit das Spiel nicht zu schwierig wird. Rust enthält noch keine
Zufallszahl-Funktionalität in seiner Standardbibliothek. Das Rust-Team stellt
jedoch eine <a href="https://crates.io/crates/rand">Kiste <code>rand</code></a> mit besagter Funktionalität zur
Verfügung.</p>
<h3 id="verwenden-einer-kiste-um-mehr-funktionalität-zu-erhalten"><a class="header" href="#verwenden-einer-kiste-um-mehr-funktionalität-zu-erhalten">Verwenden einer Kiste, um mehr Funktionalität zu erhalten</a></h3>
<p>Denke daran, dass eine Kiste eine Sammlung von Rust-Quellcode-Dateien ist. Unser
Projekt &quot;Ratespiel&quot; ist eine <em>binäre Kiste</em> (binary crate), die eine
ausführbare Datei ist. Die Kiste <code>rand</code> ist eine <em>Bibliotheks-Kiste</em> (library
crate), die Code enthält, der in anderen Programmen verwendet werden soll.</p>
<p>Das Koordinieren von externen Kisten ist der Bereich, in dem Cargo glänzt.
Bevor wir Code schreiben können, der <code>rand</code> benutzt, müssen wir die Datei
<em>Cargo.toml</em> so modifizieren, dass die Kiste <code>rand</code> als Abhängigkeit
eingebunden wird. Öffne jetzt diese Datei und füge die folgende Zeile unten
unter der Überschrift des Abschnitts <code>[dependencies]</code> hinzu, den Cargo für dich
erstellt hat. Stelle sicher, dass du <code>rand</code> genau so angibst, wie wir es hier
getan haben, andernfalls funktionieren die Codebeispiele in dieser Anleitung
möglicherweise nicht.</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.5&quot;
</code></pre>
<p>In der Datei <em>Cargo.toml</em> ist alles, was nach einer Überschrift folgt, Teil
dieses Abschnitts, der so lange andauert, bis ein anderer Abschnitt beginnt. Im
Abschnitt <code>[dependencies]</code> teilst du Cargo mit, von welchen externen Kisten
dein Projekt abhängt und welche Versionen dieser Kisten du benötigst. In diesem
Fall spezifizieren wir die Kiste <code>rand</code> mit dem semantischen
Versionsspezifikator <code>0.8.5</code>. Cargo versteht <a href="https://semver.org/lang/de/">semantische
Versionierung</a> (manchmal auch <em>SemVer</em> genannt), was ein Standard zum
Schreiben von Versionsnummern ist. Die Angabe <code>0.8.5</code> ist eigentlich die
Abkürzung für <code>^0.8.5</code>, was für alle Versionen ab <code>0.8.5</code> und kleiner als
<code>0.9.0</code> steht.</p>
<p>Cargo geht davon aus, dass die öffentliche API dieser Versionen kompatibel zur
Version 0.8.5 ist und diese Angabe stellt sicher, dass du die neueste
Patch-Version erhältst, die noch mit dem Code in diesem Kapitel kompiliert
werden kann. Ab Version <code>0.9.0</code> ist nicht garantiert, dass die API mit der in
den folgenden Beispielen verwendeten übereinstimmt.</p>
<p>Lass uns nun, ohne den Code zu ändern, das Projekt bauen, wie in Codeblock 2-2
gezeigt.</p>
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Codeblock 2-2: Die Ausgabe beim Ausführen von <code>cargo build</code> nach dem Hinzufügen der Kiste rand als Abhängigkeit</span></p>
<p>Möglicherweise siehst du unterschiedliche Versionsnummern (aber dank SemVer
sind sie alle mit dem Code kompatibel!) und unterschiedliche Zeilen (je nach
Betriebssystem), und die Zeilen können in einer anderen Reihenfolge erscheinen.</p>
<p>Wenn wir eine externe Abhängigkeit einfügen, holt Cargo die neuesten
Versionen von allem was die Abhängigkeit aus der <em>Registry</em> benötigt, was eine
Kopie der Daten von <a href="https://crates.io/">Crates.io</a> ist. Crates.io ist der Ort, an dem
die Menschen im Rust-Ökosystem ihre Open-Source-Rustprojekte für andere zur
Nutzung bereitstellen.</p>
<p>Nach dem Aktualisieren der Registry überprüft Cargo den Abschnitt
<code>[dependencies]</code> und lädt alle aufgelisteten Kisten herunter, die noch nicht
heruntergeladen wurden. Obwohl wir nur <code>rand</code> als Abhängigkeit aufgelistet
haben, hat sich Cargo in diesem Fall auch andere Kisten geschnappt, von denen
<code>rand</code> abhängig ist, um zu funktionieren. Nachdem die Kisten heruntergeladen
wurden, kompiliert Rust sie und kompiliert dann das Projekt mit den verfügbaren
Abhängigkeiten.</p>
<p>Wenn du gleich wieder <code>cargo build</code> ausführst, ohne irgendwelche Änderungen
vorzunehmen, erhältst du keine Ausgabe außer der Zeile <code>Finished</code>. Cargo weiß,
dass es die Abhängigkeiten bereits heruntergeladen und kompiliert hat, und du
hast in deiner Datei <em>Cargo.toml</em> nichts daran geändert. Cargo weiß auch, dass
du nichts an deinem Code geändert hast, also wird dieser auch nicht neu
kompiliert. Ohne etwas zu tun zu haben, wird es einfach beendet.</p>
<p>Wenn du die Datei <em>src/main.rs</em> öffnest, eine triviale Änderung vornimmst und
sie dann speicherst und neu baust, siehst du nur zwei Zeilen Ausgabe:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Diese Zeilen zeigen, dass Cargo nur den Build mit deiner winzigen Änderung an
der Datei <em>src/main.rs</em> aktualisiert. Deine Abhängigkeiten haben sich nicht
geändert, sodass Cargo weiß, dass es wiederverwenden kann, was es bereits
heruntergeladen und kompiliert hat.</p>
<h4 id="sicherstellen-reproduzierbarer-builds-mit-der-datei-cargolock"><a class="header" href="#sicherstellen-reproduzierbarer-builds-mit-der-datei-cargolock">Sicherstellen reproduzierbarer Builds mit der Datei <em>Cargo.lock</em></a></h4>
<p>Cargo verfügt über einen Mechanismus, der sicherstellt, dass du jedes Mal, wenn
du oder jemand anderes deinen Code baut, dasselbe Artefakt neu erstellen
kannst: Cargo wird nur die Versionen der von dir angegebenen Abhängigkeiten
verwenden, bis du etwas anderes angibst. Nehmen wir beispielsweise an, dass
nächste Woche Version 0.8.6 der Kiste <code>rand</code> herauskommt und eine wichtige
Fehlerkorrektur enthält, aber auch eine Regression, die deinen Code bricht. Um
dies zu handhaben, erstellt Rust die Datei <em>Cargo.lock</em> beim ersten Mal, wenn
du <code>cargo build</code> ausführst, die nun im <em>guessing_game</em>-Verzeichnis liegt.</p>
<p>Wenn du ein Projekt zum ersten Mal baust, ermittelt Cargo alle Versionen der
Abhängigkeiten, die den Kriterien entsprechen, und schreibt sie dann in die
Datei <em>Cargo.lock</em>. Wenn du dein Projekt in der Zukunft baust, wird Cargo
sehen, dass die Datei <em>Cargo.lock</em> existiert und die dort angegebenen Versionen
verwenden, anstatt die ganze Arbeit der Versionsfindung erneut zu machen. Auf
diese Weise erhältst du automatisch einen reproduzierbaren Build. Mit anderen
Worten, dein Projekt bleibt dank der Datei <em>Cargo.lock</em> auf 0.8.5, bis du
explizit die Versionsnummer erhöhst. Da die Datei <em>Cargo.lock</em> für das
reproduzierbare Bauen wichtig ist, wird sie oft zusammen mit dem restlichen
Code deines Projekts in die Versionskontrolle eingecheckt.</p>
<h4 id="aktualisieren-einer-kiste-um-eine-neue-version-zu-erhalten"><a class="header" href="#aktualisieren-einer-kiste-um-eine-neue-version-zu-erhalten">Aktualisieren einer Kiste, um eine neue Version zu erhalten</a></h4>
<p>Wenn du eine Kiste aktualisieren <em>willst</em>, bietet Cargo den Befehl <code>update</code> an,
der die Datei <em>Cargo.lock</em> ignoriert und alle neuesten Versionen, die deinen
Spezifikationen entsprechen, in <em>Cargo.toml</em> herausfindet. Cargo schreibt diese
Versionen dann in die Datei <em>Cargo.lock</em>. Andernfalls wird Cargo standardmäßig
nur nach Versionen größer als 0.8.5 und kleiner als 0.9.0 suchen. Wenn die
Kiste <code>rand</code> zwei neue Versionen 0.8.6 und 0.9.0 veröffentlicht hat, würdest du
folgendes sehen, wenn du <code>cargo update</code> ausführst:</p>
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo ignoriert die Version 0.9.0. An diesem Punkt würdest du auch eine
Änderung in deiner Datei <em>Cargo.lock</em> bemerken, die feststellt, dass die
Version der Kiste <code>rand</code>, die du jetzt benutzt, 0.8.6 ist. Um die
<code>rand</code>-Version 0.9.0 oder irgendeine Version aus der 0.9.<em>x</em>-Serie zu
verwenden, müsstest du stattdessen die Datei <em>Cargo.toml</em> anpassen, damit sie
wie folgt aussieht:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<p>Wenn du das nächste Mal <code>cargo build</code> ausführst, wird Cargo die Registry der
verfügbaren Kisten aktualisieren und deine <code>rand</code>-Anforderungen entsprechend
der von dir angegebenen neuen Version neu bewerten.</p>
<p>Es gibt noch viel mehr über <a href="http://doc.crates.io">Cargo</a> und <a href="http://doc.crates.io/crates-io.html">seinem
Ökosystem</a> zu sagen, das wir in Kapitel 14 besprechen werden, aber
für den Moment ist das alles, was du wissen musst. Cargo macht es sehr einfach,
Bibliotheken wiederzuverwenden, sodass die Rust-Entwickler in der Lage sind,
kleinere Projekte zu schreiben, die aus einer Reihe von Paketen
zusammengestellt werden.</p>
<h3 id="generieren-einer-zufallszahl"><a class="header" href="#generieren-einer-zufallszahl">Generieren einer Zufallszahl</a></h3>
<p>Beginnen wir mit <code>rand</code>, um eine Zahl zum Raten zu erzeugen. Der nächste
Schritt ist <em>src/main.rs</em> zu ändern, wie in Codeblock 2-3 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!(&quot;Die Geheimzahl ist: {secret_number}&quot;);

    println!(&quot;Bitte gib deine Schätzung ein.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    println!(&quot;Du hast geschätzt: {guess}&quot;);
}</code></pre>
<p><span class="caption">Codeblock 2-3: Hinzufügen von Code zum Generieren einer
Zufallszahl</span></p>
<p>Zuerst fügen wir die Zeile <code>use rand::Rng;</code> hinzu. Das Merkmal (trait)
<code>Rng</code> definiert Methoden, die Zufallszahlengeneratoren implementieren, und
dieses Merkmal muss im Gültigkeitsbereich sein, damit wir diese Methoden
verwenden können. In Kapitel 10 werden Merkmale im Detail behandelt.</p>
<p>Als nächstes fügen wir zwei Zeilen in der Mitte hinzu. In der ersten Zeile
rufen wir die Funktion <code>rand::thread_rng</code> auf, die uns den speziellen
Zufallszahlengenerator zurückgibt, den wir verwenden werden: Einen, der lokal
zum aktuellen Ausführungsstrang (thread) ist und vom Betriebssystem
initialisiert (seeded) wird. Dann rufen wir die Methode <code>gen_range</code> des
Zufallszahlengenerators auf. Diese Methode wird durch das Merkmal <code>Rng</code>
definiert, das wir mit der Anweisung <code>use rand::Rng;</code> in den Gültigkeitsbereich
gebracht haben. Die Methode <code>gen_range</code> nimmt einen Bereichsausdruck als
Argument und generiert eine Zufallszahl in diesem Bereich. Ein Bereichsausdruck
hat die Form <code>start..=end</code> und er beinhaltet die Untergrenze und die
Obergrenze, sodass wir <code>1..=100</code> angeben müssen, um eine Zahl zwischen 1 und 100
zu erhalten.</p>
<blockquote>
<p>Hinweis: Du wirst nicht immer wissen, welche Merkmale du verwenden sollst und
welche Methoden und Funktionen einer Kiste du aufrufen musst, daher hat jede
Kiste eine Dokumentation mit einer Anleitungen zur Verwendung der Kiste.
Eine weitere nette Funktionalität von Cargo ist, dass das Ausführen des
Kommandos <code>cargo doc --open</code> die von all deinen Abhängigkeiten
bereitgestellte Dokumentation lokal zusammenstellt und in deinem Browser
öffnet. Wenn du an anderen Funktionen der Kiste <code>rand</code> interessiert bist,
führe zum Beispiel <code>cargo doc --open</code> aus und klicke auf <code>rand</code> in der
Seitenleiste links.</p>
</blockquote>
<p>Die zweite neue Zeile gibt die Geheimzahl aus. Das ist hilfreich während wir
das Programm entwickeln, um es testen zu können, aber wir werden es aus der
finalen Version entfernen. Es ist kein echtes Spiel, wenn das Programm die
Antwort ausgibt, sobald es startet!</p>
<p>Versuche, das Programm einige Male auszuführen:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 7
Bitte gib deine Schätzung ein.
4
Du hast geschätzt: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 83
Bitte gib deine Schätzung ein.
5
Du hast geschätzt: 5
</code></pre>
<p>Du solltest verschiedene Zufallszahlen erhalten und sie sollten alle zwischen 1
und 100 sein. Großartige Arbeit!</p>
<h2 id="vergleichen-der-schätzung-mit-der-geheimzahl"><a class="header" href="#vergleichen-der-schätzung-mit-der-geheimzahl">Vergleichen der Schätzung mit der Geheimzahl</a></h2>
<p>Jetzt, da wir eine Benutzereingabe und eine Zufallszahl haben, können wir sie
vergleichen. Dieser Schritt ist in Codeblock 2-4 dargestellt. Beachte, dass
sich dieser Code noch nicht ganz kompilieren lässt, wie wir erklären werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --abschneiden--
<span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Geheimzahl ist: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span>
    println!(&quot;Du hast geschätzt: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
        Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
        Ordering::Equal =&gt; println!(&quot;Du hast gewonnen!&quot;),
    }
}</code></pre>
<p><span class="caption">Codeblock 2-4: Behandeln der möglichen Rückgabewerte beim
Vergleich zweier Zahlen</span></p>
<p>Zuerst fügen wir eine weitere <code>use</code>-Anweisung hinzu, die einen Typ namens
<code>std::cmp::Ordering</code> aus der Standardbibliothek in den Gültigkeitsbereich
bringt. Der Typ <code>Ordering</code> ist eine weitere Aufzählung und hat die Varianten
<code>Less</code>, <code>Greater</code> und <code>Equal</code>. Dies sind die drei Ergebnisse, die möglich sind,
wenn man zwei Werte vergleicht.</p>
<p>Dann fügen wir unten fünf neue Zeilen hinzu, die den Typ <code>Ordering</code> verwenden.
Die <code>cmp</code>-Methode vergleicht zwei Werte und kann auf alles, was verglichen
werden kann, angewendet werden. Sie braucht eine Referenz auf das, was du
vergleichen willst: Hier wird <code>guess</code> mit <code>secret_number</code> verglichen. Dann gibt
sie eine Variante der <code>Ordering</code>-Aufzählung zurück, die wir mit der
<code>use</code>-Anweisung in den Gültigkeitsbereich gebracht haben. Wir verwenden einen
<a href="ch06-02-match.html"><code>match</code></a>-Ausdruck, um zu entscheiden, was als nächstes zu tun ist,
basierend darauf, welche <code>Ordering</code>-Variante vom Aufruf von <code>cmp</code> mit den
Werten in <code>guess</code> und <code>secret_number</code> zurückgegeben wurde.</p>
<p>Ein <code>match</code>-Ausdruck besteht aus <em>Zweigen</em> (arms). Ein Zweig besteht aus einem
<em>Muster</em> (pattern) und dem Code, der ausgeführt werden soll, wenn der Wert, der
am Anfang des <code>match</code>-Ausdrucks steht, zum Muster dieses Zweigs passt. Rust
nimmt den Wert, der bei <code>match</code> angegeben wurde, und schaut nacheinander durch
das Muster jedes Zweigs. Das <code>match</code>-Konstrukt und die Muster sind mächtige
Funktionalitäten in Rust, mit denen du eine Vielzahl von Situationen ausdrücken
kannst, auf die dein Code stoßen könnte, und die sicherstellen, dass du sie
alle behandelst. Diese Funktionalitäten werden ausführlich in Kapitel 6 bzw.
Kapitel 18 behandelt.</p>
<p>Gehen wir ein Beispiel dafür durch, was mit dem hier verwendeten
<code>match</code>-Ausdruck geschehen würde. Angenommen, der Benutzer hat 50 geschätzt und
die zufällig generierte Geheimzahl ist diesmal 38.</p>
<p>Wenn der Code 50 mit 38 vergleicht, gibt die <code>cmp</code>-Methode <code>Ordering::Greater</code>
zurück, weil 50 größer als 38 ist. Der <code>match</code>-Ausdruck erhält den Wert
<code>Ordering::Greater</code> und beginnt mit der Überprüfung des Musters jedes Zweigs.
Er schaut auf das Muster <code>Ordering::Less</code> des ersten Zweigs und sieht, dass der
Wert <code>Ordering::Greater</code> nicht mit <code>Ordering::Less</code> übereinstimmt, also
ignoriert er den Code in diesem Zweig und geht zum nächsten Zweig über. Das
Muster <code>Ordering::Greater</code> des nächsten Zweigs <em>passt</em> zu <code>Ordering::Greater</code>!
Der dazugehörige Code in diesem Zweig wird ausgeführt und <code>Zu groß!</code> auf den
Bildschirm ausgegeben. Der <code>match</code>-Ausdruck endet nach der ersten erfolgreichen
Übereinstimmung, sodass der letzte Zweig in diesem Szenario nicht
berücksichtigt wird.</p>
<p>Der Code in Codeblock 2-4 lässt sich jedoch noch nicht kompilieren. Lass es uns
versuchen:</p>
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.51
   Compiling rand_core v0.4.0
   Compiling rand_core v0.3.1
   Compiling rand v0.5.6
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` due to previous error
</code></pre>
<p>Der Kernbotschaft besagt, dass es <em>nicht übereinstimmende Typen</em> (mismatched
types) gibt. Rust hat ein starkes, statisches Typsystem. Es hat jedoch auch
eine Typ-Inferenz. Als wir <code>let mut guess = String::new()</code> schrieben, konnte
Rust daraus schließen, dass <code>guess</code> ein <code>String</code> sein sollte, und zwang uns
nicht, den Typ anzugeben. Die <code>secret_number</code> hingegen ist ein Zahlentyp.
Einige Zahlentypen können einen Wert zwischen 1 und 100 haben: <code>i32</code>, eine
32-Bit-Zahl; <code>u32</code>, eine 32-Bit-Zahl ohne Vorzeichen; <code>i64</code>, eine 64-Bit-Zahl;
sowie andere. Solange nicht anders angegeben, verwendet Rust standardmäßig
<code>i32</code>, was der Typ von <code>secret_number</code> ist, es sei denn, du fügst an anderer
Stelle Typinformationen hinzu, die Rust veranlassen würden, auf einen anderen
numerischen Typ zu schließen. Der Grund für den Fehler liegt darin, dass Rust
eine Zeichenkette und einen Zahlentyp nicht vergleichen kann.</p>
<p>Letztendlich wollen wir den <code>String</code>, den das Programm als Eingabe liest, in
einen echten Zahlentyp umwandeln, damit wir ihn numerisch mit der Geheimzahl
vergleichen können. Das tun wir, indem wir folgendes zum <code>main</code>-Funktionsrumpf
hinzufügen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Geheimzahl ist: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span>    // --abschneiden--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Bitte gib eine Zahl ein!&quot;);

    println!(&quot;Du hast geschätzt: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
        Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
        Ordering::Equal =&gt; println!(&quot;Du hast gewonnen!&quot;),
    }
}</code></pre>
<p>Die Zeile lautet:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Bitte gib eine Zahl ein!&quot;);</code></pre>
<p>Wir erstellen eine Variable mit dem Namen <code>guess</code>. Aber warte, hat das Programm
nicht bereits eine Variable namens <code>guess</code>? Ja, aber Rust erlaubt uns, den
vorherigen Wert von <code>guess</code> mit einem neuen Wert zu verschatten (shadow). Durch
das <em>Verschatten</em> können wir den Variablennamen <code>guess</code> wiederverwenden, anstatt
uns zu zwingen, zwei eindeutige Variablen zu erstellen, z.B. <code>guess_str</code> und
<code>guess</code>. Wir werden dies in <a href="ch03-01-variables-and-mutability.html#verschatten-shadowing">Kapitel 3</a> ausführlicher behandeln,
aber für den Moment solltst du wissen, dass diese Funktionalität oft verwendet
wird, wenn du einen Wert von einem Typ in einen anderen Typ konvertieren
willst.</p>
<p>Wir binden <code>guess</code> an den Ausdruck <code>guess.trim().parse()</code>. Das <code>guess</code> im
Ausdruck bezieht sich auf das ursprüngliche <code>guess</code>, das ein <code>String</code> mit der
Eingabe darin war. Die <code>trim</code>-Methode der <code>String</code>-Instanz wird alle
Leerzeichen am Anfang und am Ende entfernen. Obwohl <code>u32</code> nur numerische
Zeichen enthalten kann, muss der Benutzer die <span
class="keystroke">Eingabetaste</span> drücken, um <code>read_line</code>
zufriedenzustellen. Wenn der Benutzer die <span
class="keystroke">Eingabetaste</span> drückt, wird der Zeichenkette ein
Zeilenumbruchszeichen (newline character) hinzugefügt. Wenn der Benutzer z.B.
<span class="keystroke">5</span> eingibt und die <span
class="keystroke">Eingabetaste</span> drückt, sieht <code>guess</code> wie folgt aus:
<code>5\n</code>. Das <code>\n</code> steht für „Zeilenumbruch“ (newline), das Ergebnis des Drückens
der <span class="keystroke">Eingabetaste</span>. (Unter Windows ergibt das
Drücken der <span class="keystroke">Eingabetaste</span> einen Wagenrücklauf
(carriage return) und einen Zeilenumbruch (newline): <code>\r\n</code>) Die <code>trim</code>-Methode
entfernt <code>\n</code> und <code>\r\n</code>, was nur <code>5</code> ergibt.</p>
<p>Die <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code>-Methode für Zeichenketten</a> konvertiert eine Zeichenkette in
einen anderen Typ. Hier verwenden wir sie, um eine Zeichenkette in eine Zahl
umzuwandeln. Wir müssen Rust den genauen Zahlentyp mitteilen, den wir wollen,
indem wir <code>let guess: u32</code> verwenden. Der Doppelpunkt (<code>:</code>) nach <code>guess</code> sagt
Rust, dass wir den Typ der Variablen annotieren werden. Rust hat ein paar
eingebaute Zahlentypen; <code>u32</code>, das du hier siehst, ist eine vorzeichenlose
32-Bit-Ganzzahl. Es ist eine gute Standardwahl für eine kleine positive Zahl.
Über andere Zahlentypen erfährst du in <a href="ch03-02-data-types.html#ganzzahl-typen">Kapitel 3</a>.</p>
<p>Zusätzlich bedeuten die Annotation <code>u32</code> in diesem Beispielprogramm und der
Vergleich mit <code>secret_number</code>, dass Rust daraus ableiten wird, dass
<code>secret_number</code> ebenfalls ein <code>u32</code> sein sollte. Nun wird also der Vergleich
zwischen zwei Werten desselben Typs durchgeführt!</p>
<p>Die Methode <code>parse</code> funktioniert nur bei Zeichen, die logisch in Zahlen
umgewandelt werden können und kann daher leicht Fehler verursachen. Wenn die
Zeichenkette zum Beispiel <code>A👍%</code> enthielte, gäbe es keine Möglichkeit, dies in
eine Zahl umzuwandeln. Da dies fehlschlagen könnte, gibt die <code>parse</code>-Methode
einen <code>Result</code>-Typ zurück, ähnlich wie die <code>read_line</code>-Methode (weiter oben in
<a href="ch02-00-guessing-game-tutorial.html#behandeln-potentieller-fehler-mit-result">„Behandeln potentieller Fehler mit
<code>Result</code>“</a>). Wir werden dieses
<code>Result</code> auf die gleiche Weise behandeln, indem wir erneut <code>expect</code> verwenden.
Wenn <code>parse</code> eine <code>Err</code>-Variante von <code>Result</code> zurückgibt, weil es keine Zahl
aus der Zeichenkette erzeugen konnte, wird der <code>expect</code>-Aufruf das Spiel zum
Absturz bringen und die Nachricht ausgeben, die wir ihm geben. Wenn <code>parse</code> die
Zeichenkette erfolgreich in eine Zahl umwandeln kann, gibt es die <code>Ok</code>-Variante
von <code>Result</code> zurück, und <code>expect</code> gibt die Zahl zurück, die wir vom <code>Ok</code>-Wert
erwarten.</p>
<p>Lassen wir das Programm jetzt laufen:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 58
Bitte gib deine Schätzung ein.
  76
Du hast geschätzt: 76
Zu groß!
</code></pre>
<p>Schön! Auch wenn vor der Schätzung Leerzeichen eingegeben wurden, fand das
Programm dennoch heraus, dass der Benutzer 76 geschätzt hat. Führe das Programm
einige Male aus, um das unterschiedliche Verhalten bei verschiedenen
Eingabearten zu überprüfen: Schätze die Zahl richtig, schätze eine zu große Zahl
und schätze eine zu kleine Zahl.</p>
<p>Der Großteil des Spiels funktioniert jetzt, aber der Benutzer kann nur <em>eine</em>
Schätzung anstellen. Ändern wir das, indem wir eine Schleife hinzufügen!</p>
<h2 id="zulassen-mehrerer-schätzungen-mittels-schleife"><a class="header" href="#zulassen-mehrerer-schätzungen-mittels-schleife">Zulassen mehrerer Schätzungen mittels Schleife</a></h2>
<p>Das Schlüsselwort <code>loop</code> erzeugt eine Endlosschleife. Wir fügen jetzt eine
Schleife hinzu, um den Benutzern mehr Chancen zu geben, die Zahl zu erraten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --abschneiden--

    println!(&quot;Die Geheimzahl ist: {secret_number}&quot;);

    loop {
        println!(&quot;Bitte gib deine Schätzung ein.&quot;);

        // --abschneiden--

<span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Bitte gib eine Zahl ein!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Du hast geschätzt: {guess}&quot;);
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal =&gt; println!(&quot;Du hast gewonnen!&quot;),
        }
    }
}</code></pre>
<p>Wie du sehen kannst, haben wir alles ab der Eingabeaufforderung für die
Schätzung in eine Schleife verschoben. Achte darauf, die Zeilen innerhalb der
Schleife jeweils um weitere vier Leerzeichen einzurücken und das Programm
erneut auszuführen. Beachte, dass es ein neues Problem gibt, weil das Programm
genau das tut, was wir ihm gesagt haben: Frage für immer nach einer weiteren
Schätzung! Es sieht nicht so aus, als könne der Benutzer das Programm beenden!</p>
<p>Der Benutzer könnte das Programm jederzeit mit dem Tastaturkürzel <span
class="keystroke">Strg+c</span> unterbrechen. Aber es gibt noch eine andere
Möglichkeit, diesem unersättlichen Monster zu entkommen, wie in der
<code>parse</code>-Diskussion in <a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">„Vergleichen der Schätzung mit der
Geheimzahl“</a> erwähnt: Wenn der
Benutzer eine Antwort ohne Zahl eingibt, stürzt das Programm ab. Wir können das
ausnutzen, um dem Benutzer zu erlauben das Programm zu beenden, wie hier
gezeigt:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 59
Bitte gib deine Schätzung ein.
45
Du hast geschätzt: 45
Zu klein!
Bitte gib deine Schätzung ein.
60
Du hast geschätzt: 60
Zu groß!
Bitte gib deine Schätzung ein.
59
Du hast geschätzt: 59
Du hast gewonnen!
Bitte gib deine Schätzung ein.
quit
thread 'main' panicked at 'Bitte gib eine Zahl ein!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:999:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Mit der Eingabe von <code>quit</code> wird das Spiel beendet, aber das gilt
auch für alle anderen Eingaben, die keine Zahlen sind. Dies ist jedoch, gelinde
gesagt, suboptimal. Wir wollen, dass das Spiel automatisch beendet wird, wenn
die richtige Zahl erraten wird.</p>
<h3 id="beenden-nach-einer-korrekten-schätzung"><a class="header" href="#beenden-nach-einer-korrekten-schätzung">Beenden nach einer korrekten Schätzung</a></h3>
<p>Programmieren wir das Spiel so, dass es beendet wird, wenn der Benutzer
gewinnt, indem wir eine <code>break</code>-Anweisung hinzufügen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Geheimzahl ist: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Bitte gib eine Zahl ein!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Du hast geschätzt: {guess}&quot;);
</span><span class="boring">
</span>        // --abschneiden--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Du hast gewonnen!&quot;);
                break;
            }
        }
    }
}</code></pre>
<p>Das Hinzufügen der <code>break</code>-Zeile nach <code>Du hast gewonnen!</code> bewirkt, dass das
Programm die Schleife verlässt, wenn der Benutzer die Geheimzahl richtig errät.
Die Schleife zu verlassen bedeutet auch, das Programm zu beenden, da die
Schleife der letzte Teil von <code>main</code> ist.</p>
<h3 id="behandeln-ungültiger-eingaben"><a class="header" href="#behandeln-ungültiger-eingaben">Behandeln ungültiger Eingaben</a></h3>
<p>Um das Verhalten des Spiels weiter zu verfeinern, sollten wir das Programm
nicht abstürzen lassen, wenn der Benutzer keine gültige Zahl eingibt, sondern
dafür sorgen, dass das Spiel ungültige Zahlen ignoriert, damit der Benutzer
weiter raten kann. Das können wir erreichen, indem wir die Zeile ändern, in der
<code>guess</code> von <code>String</code> in <code>u32</code> umgewandelt wird, wie in Codeblock 2-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Geheimzahl ist: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --abschneiden--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Du hast geschätzt: {guess}&quot;);

        // --abschneiden--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Du hast gewonnen!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 2-5: Ignorieren einer ungültigen Zahl und
Auffordern zu einer weiteren Schätzung, anstatt das Programm zum Absturz zu
bringen</span></p>
<p>Das Umstellen von einem <code>expect</code>-Aufruf zu einem <code>match</code>-Ausdruck ist eine
Möglichkeit für den Übergang vom Absturz bei einem Fehler zur Behandlung des
Fehlers. Denke daran, dass <code>parse</code> einen <code>Result</code>-Typ zurückgibt und <code>Result</code>
eine Aufzählung ist, die die Varianten <code>Ok</code> und <code>Err</code> hat. Wir benutzen hier
einen <code>match</code>-Ausdruck, wie wir es mit dem <code>Ordering</code>-Ergebnis der
<code>cmp</code>-Methode getan haben.</p>
<p>Wenn <code>parse</code> in der Lage ist, die Zeichenkette erfolgreich in eine Zahl
umzuwandeln, gibt es einen <code>Ok</code>-Wert zurück, der die resultierende Zahl
enthält. Dieser <code>Ok</code>-Wert wird mit dem Muster des ersten Zweigs übereinstimmen
und der <code>match</code>-Ausdruck wird nur den <code>num</code>-Wert zurückgeben, der durch <code>parse</code>
erzeugt und in den <code>Ok</code>-Wert eingefügt wurde. Diese Zahl wird in der neuen
<code>guess</code>-Variable, die wir erzeugen, genau dort landen, wo wir sie haben wollen.</p>
<p>Wenn <code>parse</code> <em>nicht</em> in der Lage ist, die Zeichenkette in eine Zahl
umzuwandeln, gibt es einen <code>Err</code>-Wert zurück, der mehr Informationen über den
Fehler enthält. Der <code>Err</code>-Wert stimmt nicht mit dem <code>Ok(num)</code>-Muster im ersten
<code>match</code>-Zweig überein, aber er stimmt mit dem <code>Err(_)</code>-Muster im zweiten Zweig
überein. Der Unterstrich <code>_</code> ist ein Sammelbehälter; in diesem Beispiel sagen
wir, dass alle <code>Err</code>-Werte übereinstimmen sollen, egal welche Informationen sie
enthalten. Das Programm wird also den Code <code>continue</code> des zweiten Zweigs
ausführen, der das Programm anweist, zur nächsten <code>loop</code>-Iteration zu gehen und
nach einer weiteren Schätzung zu fragen. Effektiv ignoriert das Programm also
alle Fehler, die bei <code>parse</code> auftreten könnten!</p>
<p>Jetzt sollte alles im Programm wie erwartet funktionieren. Lass es uns
versuchen:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 61
Bitte gib deine Schätzung ein.
10
Du hast geschätzt: 10
Zu klein!
Bitte gib deine Schätzung ein.
99
Du hast geschätzt: 99
Zu groß!
Bitte gib deine Schätzung ein.
foo
Bitte gib deine Schätzung ein.
61
Du hast geschätzt: 61
Du hast gewonnen!
</code></pre>
<p>Fantastisch! Mit einem winzigen letzten Feinschliff beenden wir das Ratespiel.
Denke daran, dass das Programm immer noch die Geheimzahl ausgibt. Das hat beim
Testen gut funktioniert, aber es ruiniert das Spiel. Löschen wir das
<code>println!</code>, das die Geheimzahl ausgibt. Codeblock 2-6 zeigt den finalen Code.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(&quot;Bitte gib deine Schätzung ein.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Du hast geschätzt: {guess}&quot;);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Du hast gewonnen!&quot;);
                break;
            }
        }
    }
}</code></pre>
<p><span class="caption">Codeblock 2-6: Vollständiger Code des
Ratespiels</span></p>
<p>An diesem Punkt hast du das Ratespiel erfolgreich aufgebaut. Herzlichen
Glückwunsch!</p>
<h2 id="zusammenfassung-1"><a class="header" href="#zusammenfassung-1">Zusammenfassung</a></h2>
<p>Dieses Projekt war eine praktische Möglichkeit, dich mit vielen neuen
Rust-Konzepten vertraut zu machen: <code>let</code>, <code>match</code>, Funktionen, das Verwenden
von externen Kisten und mehr. In den nächsten Kapiteln erfährst du mehr über
diese Konzepte. Kapitel 3 behandelt Konzepte, über die die meisten
Programmiersprachen verfügen, z.B. Variablen, Datentypen und Funktionen, und
zeigt, wie man sie in Rust verwendet. Kapitel 4 untersucht die
Eigentümerschaft, eine Funktionalität, die Rust von anderen Sprachen
unterscheidet. In Kapitel 5 werden Strukturen (structs) und die Methodensyntax
besprochen und in Kapitel 6 wird die Funktionsweise von Aufzählungen erläutert.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allgemeine-programmierkonzepte"><a class="header" href="#allgemeine-programmierkonzepte">Allgemeine Programmierkonzepte</a></h1>
<p>Dieses Kapitel behandelt Konzepte, die in fast jeder Programmiersprache
vorkommen, und wie sie in Rust funktionieren. Viele Programmiersprachen haben
in ihrem Kern viel gemeinsam. Keines der in diesem Kapitel vorgestellten
Konzepte ist einzigartig für Rust, aber wir werden sie im Kontext von Rust
besprechen und die Konventionen beim Verwenden dieser Konzepte erklären.</p>
<p>Insbesondere lernst du etwas über Variablen, Basistypen (basic types),
Funktionen, Kommentare und Kontrollfluss (control flow). Diese Grundlagen
werden in jedem Rust-Programm vorhanden sein, und wenn du sie früh lernst,
erhältst du eine starke Basis, auf der du aufbauen kannst.</p>
<blockquote>
<h4 id="schlüsselwörter"><a class="header" href="#schlüsselwörter">Schlüsselwörter</a></h4>
<p>Die Sprache Rust hat eine Reihe von <em>Schlüsselwörtern</em> (keywords), die wie in
anderen Sprachen nur der Sprache selbst vorbehalten sind. Denke daran, dass
du diese Wörter nicht als Namen von Variablen oder Funktionen verwenden
kannst. Die meisten der Schlüsselwörter haben spezielle Bedeutungen und du
wirst sie für verschiedene Aufgaben in deinen Rust-Programmen verwenden;
einige wenige haben aktuell noch keine Funktionalität, die mit ihnen
verbunden ist, sondern wurden für Funktionalität reserviert, die in Zukunft
zu Rust hinzugefügt werden könnte. Eine Liste der Schlüsselwörter findest du
in <a href="appendix-01-keywords.html">Anhang A</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="variablen-und-veränderbarkeit"><a class="header" href="#variablen-und-veränderbarkeit">Variablen und Veränderbarkeit</a></h2>
<p>Wie im Abschnitt <a href="ch02-00-guessing-game-tutorial.html#speichern-von-werten-mit-variablen">„Speichern von Werten mit
Variablen“</a> erwähnt, sind Variablen
standardmäßig unveränderbar. Dies ist einer der vielen Stupser, die Rust dir
gibt, um deinen Code so zu schreiben, dass du die Vorteile von Sicherheit
(safety) und einfacher Nebenläufigkeit (easy concurrency) nutzt, die Rust
bietet. Du hast jedoch immer noch die Möglichkeit, deine Variablen veränderbar
(mutable) zu machen. Lass uns untersuchen, wie und warum Rust dich dazu
ermutigt, die Unveränderbarkeit (immutability) zu bevorzugen, und warum du
manchmal vielleicht davon abweichen möchtest.</p>
<p>Wenn eine Variable unveränderbar ist, kannst du deren Wert nicht mehr ändern,
sobald ein Wert gebunden ist. Um dies zu veranschaulichen, lege ein neues
Projekt namens <em>variables</em> in deinem <em>projects</em>-Verzeichnis an, indem du
<code>cargo new variables</code> aufrufst.</p>
<p>Öffne dann in deinem neuen Verzeichnis <em>variables</em> die Datei <em>src/main.rs</em> und
ersetze dessen Code durch folgenden Code, der sich sich noch nicht kompilieren
lässt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = 5;
    println!(&quot;Der Wert von x ist: {x}&quot;);
    x = 6;
    println!(&quot;Der Wert von x ist: {x}&quot;);
}</code></pre></pre>
<p>Speichere und starte das Programm mit <code>cargo run</code>. Du solltest eine
Fehlermeldung über einen Unveränderbarkeitsfehler erhalten, wie in dieser
Ausgabe gezeigt:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;Der Wert von x ist: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
</code></pre>
<p>Dieses Beispiel zeigt, wie der Compiler dir hilft, Fehler in deinen Programmen
zu finden. Kompilierfehler können frustrierend sein, aber eigentlich bedeuten
sie nur, dass dein Programm noch nicht sicher das tut, was du willst; sie
bedeuten <em>nicht</em>, dass du kein guter Programmierer bist! Erfahrene
Rust-Entwickler bekommen ebenfalls noch Kompilierfehler.</p>
<p>Du hast die Fehlermeldung <code>cannot assign twice to immutable variable x</code>
erhalten, weil du versucht hast, der unveränderbaren Variablen <code>x</code> einen
zweiten Wert zuzuweisen.</p>
<p>Es ist wichtig, dass wir Kompilierzeitfehler erhalten, wenn wir versuchen,
einen Wert zu ändern, der als unveränderbar gekennzeichnet ist, denn genau
diese Situation kann zu Fehlern führen. Wenn ein Teil unseres Codes von der
Annahme ausgeht, dass sich ein Wert niemals ändern wird, und ein anderer Teil
unseres Codes diesen Wert ändert, ist es möglich, dass der erste Teil des Codes
nicht das tut, wozu er entwickelt wurde. Die Ursache für diese Art von Fehler
kann im Nachhinein schwer aufzuspüren sein, besonders wenn das zweite Stück
Code den Wert nur <em>gelegentlich</em> ändert. In Rust garantiert der Compiler, dass
sich ein Wert tatsächlich nicht ändert, wenn du angibst, dass er sich nicht
ändern darf, du musst also nicht selbst darauf achten. Dein Code ist somit
leichter zu durchschauen.</p>
<p>Veränderbarkeit kann jedoch sehr nützlich sein und das Erstellen von Code
erleichtern. Obwohl Variablen standardmäßig unveränderbar sind, kannst du sie
veränderbar machen, indem du vor den Variablennamen <code>mut</code> angibst, wie du es
in <a href="ch02-00-guessing-game-tutorial.html#speichern-von-werten-mit-variablen">Kapitel 2</a> getan hast. Das Hinzufügen von
<code>mut</code> vermittelt den zukünftigen Lesern des Codes die Absicht, dass andere
Teile des Codes den Wert dieser Variablen ändern werden.</p>
<p>Lass uns zum Beispiel <em>src/main.rs</em> wie folgt ändern:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;Der Wert von x ist: {x}&quot;);
    x = 6;
    println!(&quot;Der Wert von x ist: {x}&quot;);
}</code></pre></pre>
<p>Wenn wir das Programm jetzt ausführen, bekommen wir dies:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
Der Wert von x ist: 5
Der Wert von x ist: 6
</code></pre>
<p>Wir dürfen den Wert, an den sich <code>x</code> bindet, von <code>5</code> auf <code>6</code> ändern, wenn <code>mut</code>
verwendet wird. Letztendlich ist es deine Entscheidung, ob du Veränderbarkeit
einsetzen willst oder nicht, und es hängt davon ab, was du in der jeweiligen
Situation für am sinnvollsten hältst.</p>
<h3 id="konstanten"><a class="header" href="#konstanten">Konstanten</a></h3>
<p>Wie unveränderbare Variablen sind <em>Konstanten</em> Werte, die an einen Namen
gebunden sind und sich nicht ändern dürfen, aber es gibt einige Unterschiede
zwischen Konstanten und Variablen.</p>
<p>Erstens ist es dir nicht erlaubt, <code>mut</code> mit Konstanten zu verwenden. Konstanten
sind nicht nur von vornherein unveränderbar – sie sind immer
unveränderbar. Du deklarierst Konstanten mit dem Schlüsselwort <code>const</code>
anstelle des Schlüsselworts <code>let</code> und der Typ des Wertes <em>muss</em> annotiert
werden. Wir sind dabei, Typen und Typ-Annotationen im nächsten Abschnitt
<a href="ch03-02-data-types.html">„Datentypen“</a> zu behandeln, also mach dir jetzt keine Gedanken
über die Details. Du musst nur wissen, dass du den Typ immer annotieren musst.</p>
<p>Konstanten können in jedem Gültigkeitsbereich deklariert werden, auch im
globalen Gültigkeitsbereich, was sie für Werte nützlich macht, über die viele
Teile des Codes Bescheid wissen müssen.</p>
<p>Der letzte Unterschied besteht darin, dass Konstanten nur auf einen konstanten
Ausdruck gesetzt werden dürfen, nicht auf einen Wert, der nur zur Laufzeit
berechnet werden könnte.</p>
<p>Hier ist ein Beispiel für eine Konstantendeklaration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>Der Name der Konstante lautet <code>THREE_HOURS_IN_SECONDS</code> und ihr Wert wird auf
das Ergebnis der Multiplikation von 60 (die Anzahl der Sekunden in einer
Minute) mal 60 (die Anzahl der Minuten in einer Stunde) mal 3 (die Anzahl der
Stunden, die wir in diesem Programm zählen wollen). Die Namenskonvention von
Rust für Konstanten ist die Verwendung von Großbuchstaben mit Unterstrichen
zwischen den Wörtern. Der Compiler ist in der Lage, eine begrenzte Anzahl von
Operationen zur Kompilierzeit auswerten, was uns die Möglichkeit gibt, diesen
Wert so zu schreiben, dass er leichter zu verstehen und zu überprüfen ist, als
wenn diese Konstante auf den Wert 10.800 gesetzt wäre. Siehe die
<a href="https://doc.rust-lang.org/reference/const_eval.html">Rust-Referenz, Abschnitt über die Auswertung von Konstanten</a> für
weitere Informationen darüber, welche Operationen bei der Deklaration von
Konstanten verwendet werden können.</p>
<p>Konstanten sind für die gesamte Laufzeit eines Programms in dem
Gültigkeitsbereich gültig, in dem sie deklariert wurden. Damit sind sie eine
nützliche Wahl für Werte in deiner Anwendungsdomäne, über die mehrere Teile des
Programms Bescheid wissen müssen, z.B. die maximale Punktzahl, die jeder
Spieler eines Spiels erhalten darf, oder die Lichtgeschwindigkeit.</p>
<p>Das Benennen von hartkodierten Werten, die im gesamten Programm als Konstanten
verwendet werden, ist nützlich, um die Bedeutung dieses Wertes zukünftigen
Code-Betreuern zu vermitteln. Es ist auch hilfreich, nur eine Stelle in deinem
Code zu haben, die du ändern musst, wenn der hartkodierte Wert in Zukunft
aktualisiert werden müsste.</p>
<h3 id="verschatten-shadowing"><a class="header" href="#verschatten-shadowing">Verschatten (shadowing)</a></h3>
<p>Wie du in der Anleitung zum Ratespiel in <a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">Kapitel
2</a> gesehen hast, kannst du eine neue
Variable mit dem gleichen Namen wie eine vorherige Variable deklarieren. Die
Rust-Entwickler sagen, dass die erste Variable von der zweiten <em>verschattet</em>
(shadowed) wird, was bedeutet, dass die zweite Variable das ist, was der
Compiler sieht, wenn du den Namen der Variable verwendest. Die zweite Variable
verschattet die erste und nimmt alle Verwendungen des Variablennamens auf sich,
bis sie entweder selbst verschattet wird oder der Gültigkeitsbereich endet. Wir
können eine Variable verschatten, indem wir denselben Variablenamen verwenden
und das Schlüsselwort <code>let</code> wie folgt wiederholen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;Der Wert von x im inneren Gültigkeitsbereich ist: {x}&quot;);
    }

    println!(&quot;Der Wert von x ist: {x}&quot;);
}</code></pre></pre>
<p>Dieses Programm bindet zunächst <code>x</code> an den Wert <code>5</code>. Dann wird eine neue
Variable <code>x</code> erzeugt, indem <code>let x =</code> wiederholt wird, wobei der ursprüngliche
Wert genommen und <code>1</code> hinzugefügt wird, sodass der Wert von <code>x</code> dann <code>6</code> ist.
Innerhalb eines inneren Gültigkeitsbereichs, der durch die geschweiften
Klammern geschaffen wird, verschattet die dritte <code>let</code>-Anweisung dann ebenfalls
<code>x</code> und erzeugt eine neue Variable, wobei der vorherige Wert mit <code>2</code>
multipliziert wird, um <code>x</code> einen Wert von <code>12</code> zu geben. Wenn dieser
Gültigkeitsbereich zu Ende ist, endet die innere Verschattung und <code>x</code> wird
wieder zu <code>6</code>. Wenn wir dieses Programm ausführen, wird es folgendes ausgeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
Der Wert von x im inneren Gültigkeitsbereich ist: 12
Der Wert von x ist: 6
</code></pre>
<p>Verschatten unterscheidet sich vom Markieren einer Variable mit <code>mut</code>, weil wir
einen Kompilierfehler erhalten, wenn wir versehentlich versuchen, diese
Variable neu zuzuweisen, ohne das Schlüsselwort <code>let</code> zu verwenden. Durch das
Verwenden von <code>let</code> können wir einige wenige Transformationen an einem Wert
durchführen, aber die Variable ist unveränderbar, nachdem diese
Transformationen abgeschlossen sind.</p>
<p>Der andere Unterschied zwischen <code>mut</code> und Verschatten besteht darin, dass wir,
weil wir effektiv eine neue Variable erstellen, wenn wir das Schlüsselwort
<code>let</code> erneut verwenden, den Typ des Wertes ändern können, aber denselben Namen
wiederverwenden. Nehmen wir zum Beispiel an, unser Programm bittet einen
Benutzer, durch Eingeben von Leerzeichen zu zeigen, wie viele Leerzeichen er
zwischen irgendeinem Text haben möchte, und wir möchten diese Eingabe als Zahl
speichern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spaces = &quot;   &quot;;
let spaces = spaces.len();
<span class="boring">}</span></code></pre></pre>
<p>Die erste Variable <code>spaces</code> ist ein String-Typ und die zweite Variable <code>spaces</code>
ist ein Zahlentyp Integer. Das Verschatten erspart es uns also, uns verschiedene
Namen auszudenken, z.B. <code>spaces_str</code> und <code>spaces_num</code>; stattdessen können wir
den einfacheren Namen <code>spaces</code> wiederverwenden. Wenn wir jedoch versuchen,
dafür <code>mut</code> zu verwenden, wie hier gezeigt, erhalten wir einen Kompilierfehler:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut spaces = &quot;   &quot;;
spaces = spaces.len();

<span class="boring">}</span></code></pre></pre>
<p>Der Fehler besagt, dass es uns nicht erlaubt ist, den Typ einer Variable zu
mutieren:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = &quot;   &quot;;
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
</code></pre>
<p>Nachdem wir nun untersucht haben, wie Variablen funktionieren, wollen wir uns
weitere Datentypen ansehen, die sie haben können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="datentypen"><a class="header" href="#datentypen">Datentypen</a></h2>
<p>Jeder Wert in Rust ist von einem bestimmten <em>Datentyp</em>, der Rust mitteilt,
welche Art von Daten angegeben wird, damit es weiß, wie es mit diesen Daten
arbeiten soll. Wir werden uns zwei Datentyp-Untermengen ansehen: Skalar (scalar) und
Verbund (compound).</p>
<p>Denk daran, dass Rust eine <em>statisch typisierte</em> Sprache ist, was bedeutet,
dass es die Typen von allen Variablen zur Kompilierzeit kennen muss. Der
Compiler kann normalerweise auf der Grundlage des Wertes und wie wir ihn
verwenden ableiten, welchen Typ wir verwenden wollen. Wenn mehrere Typen
möglich sind, wie zum Beispiel als wir im Abschnitt <a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">„Vergleichen der Schätzung
mit der Geheimzahl“</a> eine
Zeichenkette (<code>String</code>) mittels <code>parse</code> zu einem numerischen Typ umwandelten,
müssen wir eine Typ-Annotation ergänzen, wie hier:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Keine Zahl!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Wenn wir diese Typ-Annotation nicht angeben, zeigt Rust den folgenden Fehler
an, was bedeutet, dass der Compiler mehr Informationen von uns benötigt, um
zu wissen welchen Typ wir verwenden wollen:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Keine Zahl!&quot;);
  |         ^^^^^ consider giving `guess` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<p>Für andere Datentypen wirst du andere Typ-Annotationen sehen.</p>
<h3 id="skalare-typen"><a class="header" href="#skalare-typen">Skalare Typen</a></h3>
<p>Ein <em>skalarer</em> Typ stellt einen einzelnen Wert dar. Rust hat vier primäre
skalare Typen: Ganze Zahlen, Fließkommazahlen, boolesche Werte (Wahrheitswerte)
und Zeichen. Du erkennst diese vielleicht aus anderen Programmiersprachen. Lass
uns darüber sprechen, wie sie in Rust funktionieren.</p>
<h4 id="ganzzahl-typen"><a class="header" href="#ganzzahl-typen">Ganzzahl-Typen</a></h4>
<p>Eine <em>ganze Zahl</em> ist eine Zahl ohne Bruchteilkomponente. Wir verwendeten eine
ganze Zahl in Kapitel 2, den Typ <code>u32</code>. Diese Typdeklaration gibt an, dass der
Wert, dem sie zugeordnet ist, eine 32 Bit große ganze Zahl ohne Vorzeichen ist
(vorzeichenbehaftete Ganzzahl-Typen beginnen mit <code>i</code> anstatt <code>u</code>). Tabelle 3-1
zeigt die in Rust eingebauten Ganzzahl-Typen. Wir können jede dieser Varianten
verwenden, um den den Typ eines ganzzahligen Wertes zu deklarieren.</p>
<p><span class="caption">Tabelle 3-1: Ganzzahlige Typen in Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Länge</th><th>Vorzeichenbehaftet</th><th>Vorzeichenlos</th></tr></thead><tbody>
<tr><td style="text-align: right">8 Bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td style="text-align: right">16 Bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td style="text-align: right">32 Bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td style="text-align: right">64 Bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td style="text-align: right">128 Bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td style="text-align: right">arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Jede Variante kann entweder vorzeichenbehaftet oder vorzeichenlos sein und hat
eine explizite Größe. <em>Vorzeichenbehaftet</em> (signed) und <em>vorzeichenlos</em>
(unsigned) beziehen sich darauf, ob es möglich ist, dass die Zahl negativ ist
– in anderen Worten, ob die Zahl ein Vorzeichen haben muss
(vorzeichenbehaftet) oder ob sie immer nur positiv sein wird und daher ohne
Vorzeichen dargestellt werden kann (vorzeichenlos). Es ist wie das Schreiben
von Zahlen auf Papier: Wenn das Vorzeichen eine Rolle spielt, wird die Zahl mit
einem Plus- oder Minuszeichen geschrieben; wenn man jedoch davon ausgehen kann,
dass die Zahl positiv ist, wird sie ohne Vorzeichen geschrieben.
Vorzeichenbehaftete Zahlen werden unter Verwendung der
<a href="https://de.wikipedia.org/wiki/Zweierkomplement">Zweierkomplementdarstellung</a> gespeichert.</p>
<p>Jede vorzeichenbehaftete Variante kann Zahlen von -(2<sup>n - 1</sup>) bis
einschließlich 2<sup>n - 1</sup> - 1 speichern, wobei <em>n</em> die Anzahl an Bits
ist, die diese Variante benutzt. Ein <code>i8</code> kann also Zahlen von -(2<sup>7</sup>)
bis 2<sup>7</sup> - 1 speichern, was -128 bis 127 entspricht. Vorzeichenlose
Varianten können Zahlen von 0 bis 2<sup>n</sup> - 1 speichern, also kann ein
<code>u8</code> Zahlen von 0 bis 2<sup>8</sup> - 1 speichern, was 0 bis 255 entspricht.</p>
<p>Zusätzlich hängen die Typen <code>isize</code> und <code>usize</code> von der Architektur des
Computers ab, auf dem dein Programm läuft, die in der Tabelle als „arch“
bezeichnet wird: 64 Bit wenn du dich auf einer 64-Bit-Architektur befindest und
32 Bit auf einer 32-Bit-Architektur.</p>
<p>Du kannst ganzzahlige Literale in jeder der in Tabelle 3-2 gezeigten Formen
schreiben. Beachte, dass Zahlenliterale, die mehrere numerische Typen sein
können, ein Typ-Suffix wie <code>57u8</code> zur Bezeichnung des Typs erlauben.
Zahlenliterale können auch <code>_</code> als visuelles Trennzeichen verwenden, um die
Zahl leichter lesbar zu machen, z.B. <code>1_000</code>, das den gleichen Wert hat, wie
wenn du <code>1000</code> angegeben hättest.</p>
<p><span class="caption">Tabelle 3-2: Ganzzahl-Literale in Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Ganzahl-Literal</th><th>Beispiel</th></tr></thead><tbody>
<tr><td>Dezimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Oktal</td><td><code>0o77</code></td></tr>
<tr><td>Binär</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (nur <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Woher weist du also, welcher Ganzzahltyp zu verwenden ist? Wenn du dir unsicher
bist, sind Rusts Standards im Allgemeinen ein guter Ausgangspunkt: Ganzzahlige
Typen sind standardmäßig <code>i32</code>. Die primäre Situation, in der du <code>isize</code> oder
<code>usize</code> verwendest, ist beim Indizieren einer Art Sammlung.</p>
<blockquote>
<h5 id="ganzzahlüberlauf"><a class="header" href="#ganzzahlüberlauf">Ganzzahlüberlauf</a></h5>
<p>Nehmen wir an, du hast eine Variable vom Typ <code>u8</code>, die Werte zwischen 0 und
255 annehmen kann. Wenn du versuchst, die Variable auf einen Wert außerhalb
dieses Bereiches zu ändern, z.B. auf 256, tritt ein Ganzzahlüberlauf auf, was
zu einem von zwei Verhaltensweisen führen kann. Wenn du im Fehlersuchmodus
(debug mode) kompilierst, fügt Rust Prüfungen auf Ganzzahlüberläufe ein, was
dazu führt, dass dein Programm zur Laufzeit <em>abbricht</em> (panic), falls dieses
Verhalten auftritt. Rust verwendet den Begriff „panic“, wenn ein Programm
durch einen Fehler abgebrochen wird; wir werden Programmabbrüche im Abschnitt
<a href="ch09-01-unrecoverable-errors-with-panic.html">„Nicht behebbare Fehler mit <code>panic!</code>“</a> in
Kapitel 9 näher betrachten.</p>
<p>Wenn du mit dem Schalter <code>--release</code> im Freigabemodus (release mode)
kompilierst, fügt Rust <em>keine</em> Prüfungen auf Ganzzahlüberläufe, die das
Programm abbrechen, ein. Wenn ein Überlauf auftritt, führt Rust stattdessen
einen <em>Zweier-Komplement-Umbruch</em> durch. Kurz gesagt, Werte die größer als
der Maximalwert den der Typ enthalten kann sind, werden umgebrochen zum
kleinsten Wert den der Typ enthalten kann. Im Falle eines <code>u8</code> wird der Wert
256 zu 0, der Wert 257 zu 1 und so weiter. Das Programm wird nicht abbrechen,
aber die Variable wird wahrscheinlich einen anderen Wert annehmen, als du
erwartest. Sich auf das Verhalten von Ganzzahlüberläufen zu verlassen wird
als Fehler angesehen.</p>
<p>Um die Möglichkeit eines Überlaufs explizit zu behandeln, kannst du diese
Methodenfamilien verwenden, die die Standardbibliothek für primitive
numerische Typen bereitstellt:</p>
<ul>
<li>Verpacken (wrap) aller Fälle mit den Methoden <code>wrapping_*</code>, z.B.
<code>wrapping_add</code></li>
<li>Zurückgeben des Wertes <code>None</code>, wenn es einen Überlauf mit einer
<code>checked_*</code>-Methode gibt.</li>
<li>Zurückgeben des Wertes und eines booleschen Wertes, der angibt, ob ein
Überlauf mit einer <code>overflowing_*</code>-Methode stattgefunden hat.</li>
<li>Gewährleisten der Minimal- oder Maximalwerte des Wertes mit den
<code>saturating_*</code>-Methoden.</li>
</ul>
</blockquote>
<h4 id="fließkomma-typen"><a class="header" href="#fließkomma-typen">Fließkomma-Typen</a></h4>
<p>Rust hat auch zwei primitive Typen für <em>Fließkommazahlen</em>, das sind Zahlen mit
Dezimalkomma. Die Fließkomma-Typen in Rust sind <code>f32</code> und <code>f64</code>, die 32 Bit
bzw. 64 Bit groß sind. Der Standardtyp ist <code>f64</code>, da er auf modernen CPUs
ungefähr die gleiche Geschwindigkeit wie <code>f32</code> hat, aber eine höhere Präzision
ermöglicht. Alle Fließkomma-Typen sind vorzeichenbehaftet.</p>
<p>Hier ist ein Beispiel, das Fließkommazahlen in Aktion zeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>Fließkommazahlen werden nach dem IEEE-754-Standard dargestellt. Der Typ <code>f32</code>
ist eine Fließkommazahl mit einfacher Genauigkeit und <code>f64</code> mit doppelter
Genauigkeit.</p>
<h4 id="numerische-operationen"><a class="header" href="#numerische-operationen">Numerische Operationen</a></h4>
<p>Rust unterstützt grundlegende mathematische Operationen, die man bei allen
Zahlentypen erwartet: Addition, Subtraktion, Multiplikation, Division und
Restberechnung. Die Ganzzahldivision rundet auf die nächste Ganzzahl ab. Der
folgende Code zeigt, wie du die einzelnen Typen in einer <code>let</code>-Anweisung
verwenden würdest:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Addition
    let sum = 5 + 10;

    // Subtraktion
    let difference = 95.5 - 4.3;

    // Multiplikation
    let product = 4 * 30;

    // Division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Ergibt 0

    // Restberechnung
    let remainder = 43 % 5;
}</code></pre></pre>
<p>Jeder Ausdruck in diesen Anweisungen verwendet einen mathematischen Operator
und wird zu einem einzelnen Wert ausgewertet, der dann an eine Variable
gebunden wird. <a href="appendix-02-operators.html">Anhang B</a> enthält eine Liste aller Operatoren, die
Rust anbietet.</p>
<h4 id="der-boolesche-typ"><a class="header" href="#der-boolesche-typ">Der boolesche Typ</a></h4>
<p>Wie in den meisten anderen Programmiersprachen hat ein boolescher Typ in Rust
zwei mögliche Werte: <code>true</code> (wahr) und <code>false</code> (falsch). Boolesche Werte sind
ein Byte groß. In Rust wird der boolesche Typ mit <code>bool</code> spezifiziert. Zum
Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // mit expliziter Typ-Annotation
}</code></pre></pre>
<p>Hauptsächlich werden boolesche Werte in Bedingungen verwendet, z.B. im
<code>if</code>-Ausdruck. Wie <code>if</code>-Ausdrücke in Rust funktionieren werden wir im Abschnitt
<a href="ch03-05-control-flow.html">„Kontrollfluss“</a> erläutern.</p>
<h4 id="der-zeichen-typ"><a class="header" href="#der-zeichen-typ">Der Zeichen-Typ</a></h4>
<p>Rusts Typ <code>char</code> ist der primitivste alphabetische Typ der Sprache. Hier sind
einige Beispiele für die Deklaration von <code>char</code>-Werten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // mit expliziter Typannotation
    let heart_eyed_cat = '😻';
}</code></pre></pre>
<p>Beachte, dass wir <code>char</code>-Literale mit einfachen Anführungszeichen angeben, im
Gegensatz zu Zeichenketten-Literalen, die doppelte Anführungszeichen verwenden.
Der Typ <code>char</code> von Rust ist vier Bytes groß und stellt einen Unicode-Skalarwert
dar, was bedeutet, dass er viel mehr als nur ASCII darstellen kann.
Akzentuierte Buchstaben, chinesische, japanische und koreanische Zeichen, Emoji
und Leerzeichen mit Null-Breite sind gültige <code>char</code>-Werte in Rust.
Unicode-Skalarwerte reichen von <code>U+0000</code> bis <code>U+D7FF</code> und von <code>U+E000</code> bis
einschließlich <code>U+10FFFF</code>. Ein „Zeichen“ ist jedoch nicht wirklich ein Konzept
in Unicode, deine menschliche Intuition dafür, was ein „Zeichen“ ist, stimmt
möglicherweise nicht mit dem überein, was ein <code>char</code> in Rust ist. Wir werden
dieses Thema in <a href="ch08-02-strings.html">„UTF-8-kodierten Text in Zeichenketten (strings)
ablegen“</a> in Kapitel 8 im Detail besprechen.</p>
<h3 id="verbund-typen"><a class="header" href="#verbund-typen">Verbund-Typen</a></h3>
<p><em>Verbund-Typen</em> (compound types) können mehrere Werte zu einem Typ gruppieren.
Rust hat zwei primitive Verbund-Typen: Tupel (tuples) und Arrays (arrays).</p>
<h4 id="der-tupel-typ"><a class="header" href="#der-tupel-typ">Der Tupel-Typ</a></h4>
<p>Ein <em>Tupel</em> ist eine allgemeine Möglichkeit, eine Reihe von Werten mit einer
Vielzahl von Typen zu einem Verbund-Typ zusammenzufassen. Tupel haben eine
feste Länge: Einmal deklariert, können sie weder wachsen noch schrumpfen.</p>
<p>Wir erzeugen ein Tupel, indem wir eine durch Kommata getrennte Liste von Werten
innerhalb von Klammern schreiben. Jede Position im Tupel hat einen Typ und die
Typen der verschiedenen Werte im Tupel müssen nicht gleich sein. In diesem
Beispiel haben wir optionale Typ-Annotationen angegeben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>Die Variable <code>tup</code> bindet das gesamte Tupel, da ein Tupel als ein einziges
Verbundelement betrachtet wird. Um die einzelnen Werte aus einem Tupel
herauszubekommen, können wir den Musterabgleich verwenden, um einen Tupelwert
zu destrukturieren, etwa so:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;Der Wert von y ist: {y}&quot;);
}</code></pre></pre>
<p>Dieses Programm erzeugt zunächst ein Tupel und bindet es an die Variable <code>tup</code>.
Dann benutzt es ein Muster mit <code>let</code>, um <code>tup</code> zu nehmen und in drei separate
Variablen <code>x</code>, <code>y</code> und <code>z</code> umzuwandeln. Dies nennt man <em>destrukturieren</em>
(destructuring), weil es das einzelne Tupel in drei Teile zerlegt. Schließlich
gibt das Programm den Wert von <code>y</code> aus, der <code>6.4</code> ist.</p>
<p>Wir können direkt auf ein Tupelelement zugreifen, indem wir einen Punkt (<code>.</code>)
gefolgt vom Index des Wertes, auf den wir zugreifen wollen, verwenden. Zum
Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>Dieses Programm erstellt das Tupel <code>x</code> und greift dann auf jedes Element des
Tupels über die jeweiligen Indizes zu. Wie bei den meisten Programmiersprachen
ist der erste Index in einem Tupel 0.</p>
<p>Das Tupel ohne Werte hat einen speziellen Namen: <em>Einheitswert</em> (unit value).
Dieser Wert und der zugehörige Typ (<em>Einheitstyp</em> (unit type)) werden beide mit
<code>()</code> geschrieben und stellen einen leeren Wert oder einen leeren Rückgabetyp
dar. Ausdrücke geben implizit den Einheitswert zurück, wenn sie keinen anderen
Wert zurückgeben.</p>
<h4 id="der-array-typ"><a class="header" href="#der-array-typ">Der Array-Typ</a></h4>
<p>Eine andere Möglichkeit, eine Kollektion mit mehreren Werten zu haben, ist mit
einem <em>Array</em>. Im Gegensatz zu einem Tupel muss jedes Element eines Arrays den
gleichen Typ haben. Anders als Arrays in einigen anderen Sprachen haben Arrays
in Rust eine feste Länge.</p>
<p>Wir schreiben die Werte in einem Array als kommagetrennte Liste in eckigen
Klammern:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>Arrays sind nützlich, wenn du deine Daten eher auf dem Stapelspeicher als im
Haldenspeicher abgelegt haben möchtest (auf den Stapelspeicher und den
Haldenspeicher gehen wir in <a href="ch04-01-what-is-ownership.html#stapelspeicher-stack-und-haldenspeicher-heap">Kapitel 4</a> näher ein) oder wenn du
sicherstellen willst, dass du immer eine feste Anzahl von Elementen hast. Ein
Array ist jedoch nicht so flexibel wie der Vektortyp. Ein <em>Vektor</em> ist ein
ähnlicher Kollektionstyp, der von der Standardbibliothek zur Verfügung gestellt
wird und der in seiner Größe wachsen oder schrumpfen kann. Wenn du dir nicht
sicher bist, ob du ein Array oder einen Vektor verwenden sollst, ist es
wahrscheinlich, dass du einen Vektor verwenden solltest. In <a href="ch08-01-vectors.html">Kapitel
8</a> werden Vektoren ausführlicher besprochen.</p>
<p>Arrays sind jedoch hilfreicher, wenn du weißt, dass sich die Anzahl der
Elemente nicht ändern wird. Wenn du z.B. die Monatsnamen in einem Programm
verwendest, würdest du wahrscheinlich eher ein Array als einen Vektor
verwenden, weil du weißt, dass es immer 12 Elemente enthalten wird:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;Januar&quot;, &quot;Februar&quot;, &quot;März&quot;, &quot;April&quot;, &quot;Mai&quot;, &quot;Juni&quot;, &quot;Juli&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;Oktober&quot;, &quot;November&quot;, &quot;Dezember&quot;];
<span class="boring">}</span></code></pre></pre>
<p>Der Typ eines Arrays wird in eckigen Klammern mit dem Typ der einzelnen
Elemente angegeben, ein Semikolon und dann die Anzahl der Elemente im Array,
etwa so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Hier ist <code>i32</code> der Typ aller Elemente. Nach dem Semikolon gibt die Zahl <code>5</code> an,
dass das Array fünf Elemente enthält.</p>
<p>Du kannst ein Array auch so initialisieren, dass es für jedes Element denselben
Wert enthält, indem du den Anfangswert, gefolgt von einem Semikolon, und dann
die Länge des Arrays in eckigen Klammern angibst, wie hier gezeigt:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p>Das Array mit dem Namen <code>a</code> wird <code>5</code> Elemente enthalten, die alle anfänglich
auf den Wert <code>3</code> gesetzt werden. Dies ist dasselbe wie das Schreiben von
<code>let a = [3, 3, 3, 3, 3];</code>, aber in einer prägnanteren Weise.</p>
<h5 id="zugriff-auf-array-elemente"><a class="header" href="#zugriff-auf-array-elemente">Zugriff auf Array-Elemente</a></h5>
<p>Ein Array ist ein einzelner Speicherbereich mit einer bekannten, festen Größe,
der auf den Stapelspeicher gelegt wird. Du kannst auf Elemente eines Arrays mit
Hilfe der Indizierung wie folgt zugreifen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>In diesem Beispiel erhält die Variable mit dem Namen <code>first</code> den Wert <code>1</code>, weil
das der Wert am Index <code>[0]</code> im Array ist. Die Variable mit dem Namen <code>second</code>
wird den Wert <code>2</code> vom Index <code>[1]</code> im Array erhalten.</p>
<h5 id="ungültiger-array-element-zugriff"><a class="header" href="#ungültiger-array-element-zugriff">Ungültiger Array-Element-Zugriff</a></h5>
<p>Sehen wir uns an was passiert, wenn du versuchst, auf ein Element eines Arrays
zuzugreifen, das sich hinter dem Ende des Arrays befindet. Angenommen, du
führst diesen Code aus, ähnlich zum Ratespiel in Kapitel 2, um einen
Array-Index vom Benutzer zu erhalten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Bitte gib einen Array-Index ein.&quot;);

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Eingegebener Index war keine Zahl&quot;);

    let element = a[index];

    println!(
        &quot;Der Wert von element beim Index {index} ist: {element}&quot;);
}</code></pre></pre>
<p>Dieser Code kompiliert erfolgreich. Wenn du diesen Code mit <code>cargo run</code>
ausführst und <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> oder <code>4</code> eingibst, wird das Programm den
entsprechenden Wert an diesem Index im Array ausgeben. Wenn du stattdessen eine
Zahl hinter dem Ende des Arrays eingibst, z.B. <code>10</code>, erhältst du eine Ausgabe
wie diese:</p>
<pre><code class="language-text">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Das Programm führte zu einem <em>Laufzeitfehler</em> an der Stelle, an der ein
ungültiger Wert in der Index-Operation verwendet wurde. Das Programm wurde mit
einer Fehlermeldung beendet und hat die abschließende <code>println!</code>-Anweisung
nicht ausgeführt. Wenn du versuchst, mit Hilfe der Indizierung auf ein Element
zuzugreifen, prüft Rust, ob der angegebene Index kleiner als die Array-Länge
ist. Wenn der Index größer oder gleich der Länge ist, wird Rust das Programm
abbrechen. Diese Prüfung muss zur Laufzeit erfolgen, insbesondere in diesem
Fall, weil der Compiler unmöglich wissen kann, welchen Wert ein Benutzer später
eingeben wird, wenn er den Code ausführt.</p>
<p>Dies ist ein Beispiel für die Umsetzung der Speichersicherheitsprinzipien von
Rust. In vielen Low-Level-Sprachen wird diese Art der Überprüfung nicht
durchgeführt und wenn du einen falschen Index angibst, kann auf ungültigen
Speicher zugegriffen werden. Rust schützt dich vor dieser Art von Fehlern,
indem es das Programm sofort beendet, anstatt den Speicherzugriff zuzulassen
und fortzusetzen. Kapitel 9 behandelt die Fehlerbehandlung in Rust und wie du
lesbaren, sicheren Code schreiben kannst, der weder abstürzt noch ungültige
Speicherzugriffe zulässt.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="funktionen"><a class="header" href="#funktionen">Funktionen</a></h2>
<p>Funktionen sind im Rust-Code weit verbreitet. Du hast bereits eine der
wichtigsten Funktionen in der Sprache gesehen: Die Funktion <code>main</code>, die der
Einstiegspunkt vieler Programme ist. Du hast auch das Schlüsselwort <code>fn</code>
gesehen, mit dem du neue Funktionen deklarieren kannst.</p>
<p>Rust-Code verwendet die <em>Schlangenschrift</em>-Stil-Konvention (snake case) für
Funktions- und Variablennamen, bei der alle Buchstaben klein geschrieben sind
und Unterstriche Wörter separieren. Hier ist ein Programm, das eine
Beispiel-Funktionsdefinition enthält:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hallo Welt!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Eine andere Funktion.&quot;);
}</code></pre></pre>
<p>Wir definieren eine Funktion in Rust durch die Eingabe von <code>fn</code>, gefolgt von
einem Funktionsnamen und einem Satz Klammern. Die geschweiften Klammern teilen
dem Compiler mit, wo der Funktionsrumpf beginnt und endet.</p>
<p>Wir können jede Funktion, die wir definiert haben, aufrufen, indem wir ihren
Namen gefolgt von einem Satz Klammern eingeben. Da <code>another_function</code> im
Programm definiert ist, kann sie von innerhalb der <code>main</code>-Funktion aufgerufen
werden. Beachte, dass wir <code>another_function</code> <em>nach</em> der <code>main</code>-Funktion im
Quellcode definiert haben; wir hätten sie auch vorher definieren können. Rust
interessiert es nicht, wo du deine Funktionen definierst, nur dass sie irgendwo
definiert sind.</p>
<p>Lass uns ein neues Binärprojekt namens „functions“ anfangen, um Funktionen
weiter zu erforschen. Platziere das Beispiel <code>another_function</code> in
<em>src/main.rs</em> und lass es laufen. Du solltest die folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hallo Welt!
Eine andere Funktion.
</code></pre>
<p>Die Zeilen werden in der Reihenfolge ausgeführt, in der sie in der
<code>main</code>-Funktion erscheinen. Zuerst wird die Nachricht „Hallo Welt!“ ausgegeben
und dann wird <code>another_function</code> aufgerufen und ihre Nachricht ausgegeben.</p>
<h3 id="parameter"><a class="header" href="#parameter">Parameter</a></h3>
<p>Wir können Funktionen auch so definieren, dass sie <em>Parameter</em> haben, das
sind spezielle Variablen, die Teil der Funktionssignatur sind. Wenn eine
Funktion Parameter hat, kannst du sie mit konkreten Werten für diese Parameter
versehen. Technisch gesehen werden die konkreten Werte <em>Argumente</em> genannt,
aber in lockeren Gesprächen neigen Leute dazu, die Worte <em>Parameter</em> und
<em>Argument</em> entweder für die Variablen in der Definition einer Funktion oder für
die konkreten Werte, die beim Aufruf einer Funktion übergeben werden,
synonym zu verwenden.</p>
<p>In dieser Version von <code>another_function</code> fügen wir einen Parameter hinzu:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;Der Wert von x ist: {x}&quot;);
}</code></pre></pre>
<p>Versuche, dieses Programm auszuführen; du solltest die folgende Ausgabe
erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
Der Wert von x ist: 5
</code></pre>
<p>Die Deklaration <code>another_function</code> hat einen Parameter namens <code>x</code>. Der Typ von
<code>x</code> wird als <code>i32</code> angegeben. Wenn wir <code>5</code> an <code>another_function</code> übergeben,
setzt das Makro <code>println!</code> den Wert <code>5</code> an die Stelle, an der sich das Paar
geschweifter Klammern mit dem <code>x</code> darin in der Formatierungszeichenkette
befand.</p>
<p>In Funktionssignaturen <em>musst</em> du den Typ jedes Parameters deklarieren. Dies
ist eine bewusste Designentscheidung von Rust: Das Erfordernis von
Typ-Annotationen in Funktionsdefinitionen bedeutet, dass der Compiler sie
fast nie an anderer Stelle im Code benötigt, um herauszufinden, welchen Typ du
meinst. Der Compiler ist auch in der Lage, hilfreichere Fehlermeldungen zu
geben, wenn er weiß, welche Typen die Funktion erwartet.</p>
<p>Wenn wir mehrere Parameter definieren, trennen wir die Parameterdeklarationen
mit Kommas, so wie hier:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!(&quot;Das Maß ist: {value}{unit_label}&quot;);
}</code></pre></pre>
<p>Dieses Beispiel erzeugt eine Funktion namens <code>print_labeled_measurement</code> mit
zwei Parametern. Der erste Parameter heißt <code>value</code> und ist ein <code>i32</code>. Der
zweite heißt <code>unit_label</code> und ist vom Typ <code>char</code>. Die Funktion gibt dann einen
Text aus, der sowohl <code>value</code> als auch <code>unit_label</code> enthält.</p>
<p>Lass uns versuchen, diesen Code auszuführen. Ersetze das Programm, das sich
derzeit in der Datei <em>src/main.rs</em> deines „functions“-Projekts befindet, durch
das vorhergehende Beispiel und führe es mit <code>cargo run</code> aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
Das Maß ist: 5h
</code></pre>
<p>Da wir die Funktion mit <code>5</code> als Wert für <code>value</code> und <code>'h'</code> als Wert für
<code>unit_label</code> aufgerufen haben, enthält die Programmausgabe diese Werte.</p>
<h4 id="anweisungen-und-ausdrücke"><a class="header" href="#anweisungen-und-ausdrücke">Anweisungen und Ausdrücke</a></h4>
<p>Funktionsrümpfe bestehen aus einer Reihe von Anweisungen, die optional mit
einem Ausdruck enden können. Bisher haben wir nur Funktionen ohne einen
endenden Ausdruck behandelt, aber du hast einen Ausdruck als Teil einer
Anweisung gesehen. Da Rust eine auf Ausdrücken basierende Sprache ist, ist dies
eine wichtige Unterscheidung, die es zu verstehen gilt. Andere Sprachen haben
nicht dieselben Unterscheidungen, deshalb wollen wir uns ansehen, was
Anweisungen und Ausdrücke sind und wie sich ihre Unterschiede auf die
Funktionsrümpfe auswirken.</p>
<ul>
<li><strong>Anweisungen</strong> (statements) sind Instruktionen, die eine Aktion ausführen
und keinen Wert zurückgeben.</li>
<li><strong>Ausdrücke</strong> (expressions) werden zu einem Ergebniswert ausgewertet.
Schauen wir uns einige Beispiele an.</li>
</ul>
<p>Eine Variable zu erstellen und ihr mit dem Schlüsselwort <code>let</code> einen Wert
zuzuweisen, ist eine Anweisung. In Codeblock 3-1 ist <code>let y = 6;</code> eine
Anweisung.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}</code></pre></pre>
<p><span class="caption">Codeblock 3-1: Eine Funktionsdeklaration <code>main</code>, die eine
Anweisung enthält</span></p>
<p>Auch Funktionsdefinitionen sind Anweisungen; das gesamte vorhergehende Beispiel
ist eine Anweisung für sich.</p>
<p>Anweisungen geben keine Werte zurück. Daher kannst du keine <code>let</code>-Anweisung
einer anderen Variablen zuweisen, wie es der folgende Code versucht; du wirst
einen Fehler erhalten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre></pre>
<p>Wenn du dieses Programm ausführst, wirst du in etwa folgenden Fehler erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling playground v0.0.1 (/playground)
error[E0658]: `let` expressions in this position are experimental
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information
  = help: you can write `matches!(&lt;expr&gt;, &lt;pattern&gt;)` instead of `let &lt;pattern&gt; = &lt;expr&gt;`

error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^^^^^^^^^^^ help: remove these parentheses
  |
  = note: `#[warn(unused_parens)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0658`.
error: could not compile `playground`

To learn more, run the command again with --verbose.
</code></pre>
<p>Die Anweisung <code>let y = 6</code> gibt keinen Wert zurück, also gibt es für <code>x</code> nichts,
woran <code>x</code> gebunden werden kann. Dies unterscheidet sich von dem, was in anderen
Sprachen wie C und Ruby geschieht, wo die Zuweisung den Wert der Zuweisung
zurückgibt. In diesen Sprachen kannst du <code>x = y = 6</code> schreiben und sowohl <code>x</code>
als auch <code>y</code> haben den Wert <code>6</code>; das ist in Rust nicht der Fall.</p>
<p>Ausdrücke werten zu einem Wert aus und machen den größten Teil des restlichen
Codes aus, den du in Rust schreiben wirst. Betrachte eine mathematische
Operation, z.B. <code>5 + 6</code>, die ein Ausdruck ist, der zum Wert <code>11</code> ausgewertet
wird. Ausdrücke können Teil von Anweisungen sein: In Codeblock 3-1 ist die <code>6</code>
in der Anweisung <code>let y = 6;</code> ein Ausdruck, der den Wert <code>6</code> ergibt. Der Aufruf
einer Funktion ist ein Ausdruck. Der Aufruf eines Makros ist ein Ausdruck. Ein
neuer Gültigkeitsbereichsblock, der mit geschweiften Klammern erstellt wird,
ist ein Ausdruck, zum Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;Der Wert von y ist: {y}&quot;);
}</code></pre></pre>
<p>Der Ausdruck</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>ist ein Block, der in diesem Fall zu <code>4</code> ausgewertet wird. Dieser Wert wird als
Teil der <code>let</code>-Anweisung an <code>y</code> gebunden. Beachte, dass die Zeile <code>x + 1</code> am
Ende kein Semikolon hat, was sich von den meisten Zeilen, die du bisher gesehen
hast, unterscheidet. Ausdrücke enthalten keine abschließenden Semikolons. Wenn
du ein Semikolon an das Ende eines Ausdrucks anfügst, machst du daraus eine
Anweisung, und sie gibt keinen Wert zurück.  Behalte dies im Hinterkopf, wenn
du als nächstes die Rückgabewerte von Funktionen und Ausdrücken untersuchst.</p>
<h3 id="funktionen-mit-rückgabewerten"><a class="header" href="#funktionen-mit-rückgabewerten">Funktionen mit Rückgabewerten</a></h3>
<p>Funktionen können Werte an den Code zurückgeben, der sie aufruft. Wir benennen
keine Rückgabewerte, aber wir müssen ihren Typ nach einem Pfeil (<code>-&gt;</code>)
deklarieren. In Rust ist der Rückgabewert der Funktion gleichbedeutend mit dem
Wert des letzten Ausdrucks im Block des Funktionsrumpfs. Du kannst frühzeitig
von einer Funktion zurückkehren, indem du das Schlüsselwort <code>return</code> verwendest
und einen Wert angibst, aber die meisten Funktionen geben den letzten Ausdruck
implizit zurück. Hier ist ein Beispiel für eine Funktion, die einen Wert
zurückgibt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;Der Wert von x ist: {x}&quot;);
}</code></pre></pre>
<p>Es gibt keine Funktionsaufrufe, Makros oder gar <code>let</code>-Anweisungen in der
<code>five</code>-Funktion – nur die Zahl <code>5</code> selbst. Das ist eine vollkommen
gültige Funktion in Rust. Beachte, dass der Rückgabetyp der Funktion ebenfalls
angegeben ist, mit <code>-&gt; i32</code>. Versuche diesen Code auszuführen; die Ausgabe
sollte wie folgt aussehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
Der Wert von x ist: 5
</code></pre>
<p>Die <code>5</code> in <code>five</code> ist der Rückgabewert der Funktion, weshalb der Rückgabetyp
<code>i32</code> ist. Lass uns dies genauer untersuchen. Es gibt zwei wichtige Teile:
Erstens zeigt die Zeile <code>let x = five();</code>, dass wir den Rückgabewert einer
Funktion verwenden, um eine Variable zu initialisieren. Da die Funktion <code>five</code>
den Wert <code>5</code> zurückgibt, ist diese Zeile die gleiche wie die folgende:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Zweitens hat die Funktion <code>five</code> keine Parameter und definiert den Typ des
Rückgabewertes, aber der Funktionsrumpf ist eine einsame <code>5</code> ohne Semikolon,
weil es ein Ausdruck ist, dessen Wert wir zurückgeben wollen.</p>
<p>Sehen wir uns ein weiteres Beispiel an:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;Der Wert von x ist: {x}&quot;);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre></pre>
<p>Beim Ausführen dieses Codes wird <code>Der Wert von x ist: 6</code> ausgegeben. Wenn wir
aber ein Semikolon an das Ende der Zeile mit <code>x + 1</code> setzen und es von einem
Ausdruck in eine Anweisung ändern, erhalten wir einen Fehler:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = plus_one(5);

    println!(&quot;Der Wert von x ist: {x}&quot;);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}</code></pre></pre>
<p>Das Kompilieren dieses Codes führt zum folgenden Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
warning: `functions` (bin &quot;functions&quot;) generated 1 warning
error: could not compile `functions` due to 2 previous errors; 1 warning emitted
</code></pre>
<p>Die Hauptfehlermeldung <code>mismatched types</code> offenbart das Kernproblem dieses
Codes. Die Definition der Funktion <code>plus_one</code> besagt, dass sie ein <code>i32</code>
zurückgibt, aber Anweisungen werden nicht zu einem Wert ausgewertet, was durch
den Einheitstyp <code>()</code> ausgedrückt wird. Daher wird nichts zurückgegeben, was der
Funktionsdefinition widerspricht und zu einem Fehler führt. In dieser Ausgabe
gibt Rust eine Meldung aus, die möglicherweise helfen kann, dieses Problem zu
beheben: Es wird vorgeschlagen, das Semikolon zu entfernen, was den Fehler
beheben würde.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kommentare"><a class="header" href="#kommentare">Kommentare</a></h2>
<p>Alle Programmierer bemühen sich, ihren Code leicht verständlich zu machen, aber
manchmal sind zusätzliche Erklärungen angebracht. In solchen Fällen versehen
Entwickler den Quellcode mit <em>Kommentaren</em>, welche der Compiler ignoriert
und für andere Entwickler nützlich sein können.</p>
<p>Dies ist ein einfacher Kommentar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hallo Welt
<span class="boring">}</span></code></pre></pre>
<p>In Rust beginnt ein gewöhnlicher Kommentar mit zwei Schrägstrichen; der
Kommentar reicht dann bis zum Ende der Zeile. Für Kommentare, die über eine
einzelne Zeile hinausgehen, musst du bei jedem Zeilenanfang <code>//</code> angeben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hier passiert etwas kompliziertes, so komplex dass wir
// mehrere Kommentarzeilen brauchen! Puh! Hoffentlich erklärt
// dieser Kommentar, was hier passiert.
<span class="boring">}</span></code></pre></pre>
<p>Kommentare können auch am Ende einer Codezeile stehen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lucky_number = 7; // Heute habe ich Glück
}</code></pre></pre>
<p>Gängiger ist jedoch die Schreibweise mit dem Kommentar über der Codezeile, die
er beschreibt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Heute habe ich Glück
    let lucky_number = 7;
}</code></pre></pre>
<p>Rust kennt noch eine weitere Kommentarart, nämlich Dokumentationskommentare,
die wir im Abschnitt <a href="ch14-02-publishing-to-crates-io.html">„Kisten (crate) auf crates.io
veröffentlichen“</a> in Kapitel 14 besprechen werden.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kontrollfluss"><a class="header" href="#kontrollfluss">Kontrollfluss</a></h2>
<p>Die Fähigkeit, Code auszuführen, der davon abhängt, ob eine Bedingung <code>true</code>
ist, oder Code wiederholt auszuführen, während eine Bedingung <code>true</code> ist, sind
grundlegende Bausteine der meisten Programmiersprachen. Die gebräuchlichsten
Konstrukte, mit denen du den Kontrollfluss von Rust-Code kontrollieren kannst,
sind <code>if</code>-Ausdrücke und Schleifen.</p>
<h3 id="if-ausdrücke"><a class="header" href="#if-ausdrücke"><code>if</code>-Ausdrücke</a></h3>
<p>Ein <code>if</code>-Ausdruck erlaubt es dir, deinen Code abhängig von Bedingungen zu
verzweigen. Du gibst eine Bedingung an und legst dann fest: „Wenn diese
Bedingung erfüllt ist, führe diesen Codeblock aus. Wenn die Bedingung nicht
erfüllt ist, darf dieser Codeblock nicht ausgeführt werden.“</p>
<p>Erstelle in deinem <em>projects</em>-Verzeichnis ein neues Projekt namens <em>branches</em>,
um den <code>if</code>-Ausdruck zu erforschen. Gibt in der Datei <em>src/main.rs</em> folgendes
ein:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;Bedingung war wahr&quot;);
    } else {
        println!(&quot;Bedingung war falsch&quot;);
    }
}</code></pre></pre>
<p>Alle <code>if</code>-Ausdrücke beginnen mit dem Schlüsselwort <code>if</code>, gefolgt von einer
Bedingung. In diesem Fall prüft die Bedingung, ob die Variable <code>number</code> einen
Wert kleiner als 5 hat oder nicht. Der Codeblock, den wir ausführen wollen,
wenn die Bedingung <code>true</code> ist, wird unmittelbar nach der Bedingung in
geschweifte Klammern gesetzt. Codeblöcke, die mit den Bedingungen in
<code>if</code>-Ausdrücken verbunden sind, werden manchmal auch als <em>Zweige</em> (arms)
bezeichnet, genau wie die Zweige in <code>match</code>-Ausdrücken, die wir im Abschnitt
<a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">„Vergleichen der Schätzung mit der
Geheimzahl“</a> in Kapitel 2 besprochen
haben.</p>
<p>Optional können wir auch einen <code>else</code>-Ausdruck angeben, was wir hier gemacht
haben, um dem Programm einen alternativen Codeblock zur Ausführung zu geben,
falls die Bedingung zu <code>false</code> ausgewertet wird. Wenn du keinen <code>else</code>-Ausdruck
angibst und die Bedingung <code>false</code> ist, überspringt das Programm einfach den
<code>if</code>-Block und geht zum nächsten Codeteil über.</p>
<p>Versuche, diesen Code auszuführen; du solltest die folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Bedingung war wahr
</code></pre>
<p>Lass uns versuchen, den Wert von <code>number</code> in einen Wert zu ändern, der die
Bedingung <code>falsch</code> macht, um zu sehen, was passiert:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!(&quot;Bedingung war wahr&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;Bedingung war falsch&quot;);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>Führe das Programm erneut aus und sieh dir die Ausgabe an:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Bedingung war falsch
</code></pre>
<p>Es ist auch erwähnenswert, dass die Bedingung in diesem Code ein <code>bool</code> sein
<em>muss</em>. Wenn die Bedingung kein <code>bool</code> ist, erhalten wir einen Fehler. Versuche
zum Beispiel, den folgenden Code auszuführen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let number = 3;

    if number {
        println!(&quot;Zahl war drei&quot;);
    }
}</code></pre></pre>
<p>Die <code>if</code>-Bedingung wird diesmal zum Wert <code>3</code> ausgewertet und Rust wirft einen
Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p>Der Fehler gibt an, dass Rust ein <code>bool</code> erwartet, aber eine ganze Zahl
erhalten hat. Im Gegensatz zu Sprachen wie Ruby und JavaScript wird Rust nicht
automatisch versuchen, nicht-boolsche Typen in ein Boolean zu konvertieren. Du
musst explizit sein und immer <code>if</code> mit einer Booleschen Bedingung versehen.
Wenn wir beispielsweise wollen, dass der <code>if</code>-Codeblock nur ausgeführt wird,
wenn eine Zahl ungleich <code>0</code> ist, können wir den <code>if</code>-Ausdruck wie folgt ändern:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;Zahl war etwas anderes als Null&quot;);
    }
}</code></pre></pre>
<p>Wenn du diesen Code ausführst, wird <code>Zahl war etwas anderes als Null</code>
ausgegeben.</p>
<h4 id="behandeln-mehrerer-bedingungen-mit-else-if"><a class="header" href="#behandeln-mehrerer-bedingungen-mit-else-if">Behandeln mehrerer Bedingungen mit <code>else if</code></a></h4>
<p>Du kannst mehrere Bedingungen verwenden, indem du <code>if</code> und <code>else</code> in einem
<code>else if</code>-Ausdruck kombinierst. Zum Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;Zahl ist durch 4 teilbar&quot;);
    } else if number % 3 == 0 {
        println!(&quot;Zahl ist durch 3 teilbar&quot;);
    } else if number % 2 == 0 {
        println!(&quot;Zahl ist durch 2 teilbar&quot;);
    } else {
        println!(&quot;Zahl ist nicht durch 4, 3 oder 2 teilbar&quot;);
    }
}</code></pre></pre>
<p>Dieses Programm hat vier mögliche Wege, die es nehmen kann. Nachdem du es
ausgeführt hast, solltest du folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Zahl ist durch 3 teilbar
</code></pre>
<p>Wenn dieses Programm ausgeführt wird, prüft es der Reihe nach jeden
<code>if</code>-Ausdruck und führt den ersten Block aus, für den die Bedingung zu <code>true</code>
ausgewertet wird. Beachte, dass, obwohl 6 durch 2 teilbar ist, wir weder die
Ausgabe <code>Zahl ist durch 2 teilbar</code> sehen, noch sehen wir den Text <code>Zahl ist nicht durch 4, 3 oder 2 teilbar</code> aus dem <code>else</code>-Block. Das liegt daran, dass
Rust den Block nur für die erste <code>true</code>-Bedingung ausführt, und wenn es eine
findet, prüft es den Rest nicht mehr.</p>
<p>Das Verwenden von zu vielen <code>else if</code>-Ausdrücken kann deinen Code
unübersichtlich machen. Wenn du also mehr als einen Ausdruck hast, solltest du
deinen Code vielleicht überarbeiten. Kapitel 6 beschreibt ein leistungsfähiges
Rust-Verzweigungskonstrukt namens <code>match</code> für solche Fälle.</p>
<h4 id="verwenden-von-if-in-einer-let-anweisung"><a class="header" href="#verwenden-von-if-in-einer-let-anweisung">Verwenden von <code>if</code> in einer <code>let</code>-Anweisung</a></h4>
<p>Weil <code>if</code> ein Ausdruck ist, können wir ihn auf der rechten Seite einer
<code>let</code>-Anweisung verwenden, um das Ergebnis einer Variablen zuzuordnen, wie in
Codeblock 3-2.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;Der Wert der Zahl ist: {number}&quot;);
}</code></pre></pre>
<p><span class="caption">Codeblock 3-2: Zuweisen des Ergebnisses eines
<code>if</code>-Ausdrucks an eine Variable</span></p>
<p>Die Variable <code>number</code> wird an einen Wert gebunden, der auf dem Ergebnis des
<code>if</code>-Ausdrucks basiert. Führe diesen Code aus, um zu sehen, was passiert:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
Der Wert der Zahl ist: 5
</code></pre>
<p>Denke daran, dass Codeblöcke bis zum letzten Ausdruck in ihnen ausgewertet
werden, und auch Zahlen an sich sind Ausdrücke. In diesem Fall hängt der Wert
des gesamten <code>if</code>-Ausdrucks davon ab, welcher Codeblock ausgeführt wird. Dies
bedeutet, dass die Werte, die potentielle Ergebnisse eines <code>if</code>-Zweigs sein
können, vom gleichen Typ sein müssen; in Codeblock 3-2 waren die Ergebnisse
sowohl des <code>if</code>-Zweigs als auch des <code>else</code>-Zweigs <code>i32</code>-Ganzzahlen. Wenn die
Typen nicht übereinstimmen, wie im folgenden Beispiel, erhalten wir einen
Fehler:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { &quot;sechs&quot; };

    println!(&quot;Der Wert der Zahl ist: {number}&quot;);
}</code></pre></pre>
<p>Wenn wir versuchen, diesen Code zu kompilieren, erhalten wir einen Fehler. Die
<code>if</code>- und <code>else</code>-Zweige haben Werttypen, die inkompatibel sind, und Rust zeigt
genau an, wo das Problem im Programm zu finden ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { &quot;sechs&quot; };
  |                                 -          ^^^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p>Der Ausdruck im <code>if</code>-Block wird zu einer ganzen Zahl und der Ausdruck im
<code>else</code>-Block zu einer Zeichenkette ausgewertet. Dies wird nicht funktionieren,
da Variablen einen einzigen Typ haben müssen. Rust muss zur Kompilierzeit
definitiv wissen, welchen Typ die Variable <code>number</code> hat, damit es zur
Kompilierzeit überprüfen kann, ob ihr Typ überall gültig ist, wo wir <code>number</code>
verwenden. Rust wäre dazu nicht in der Lage, wenn der Typ von <code>number</code> erst zur
Laufzeit bestimmt würde; der Compiler wäre komplexer und würde weniger
Garantien über den Code geben, wenn er mehrere hypothetische Typen für jede
Variable verfolgen müsste.</p>
<h3 id="wiederholung-mit-schleifen"><a class="header" href="#wiederholung-mit-schleifen">Wiederholung mit Schleifen</a></h3>
<p>Es ist oft hilfreich, einen Codeblock mehr als einmal auszuführen. Für diese
Aufgabe stellt Rust mehrere <em>Schleifen</em> (loops) zur Verfügung, die den Code
innerhalb des Schleifenrumpfs bis zum Ende durchläuft und dann sofort wieder am
Anfang beginnt. Um mit Schleifen zu experimentieren, machen wir ein neues
Projekt namens <em>loops</em>.</p>
<p>Rust hat drei Arten von Schleifen: <code>loop</code>, <code>while</code> und <code>for</code>. Probieren wir
jede einzelne aus.</p>
<h4 id="wiederholen-von-code-mit-loop"><a class="header" href="#wiederholen-von-code-mit-loop">Wiederholen von Code mit <code>loop</code></a></h4>
<p>Das Schlüsselwort <code>loop</code> weist Rust an, einen Codeblock immer und immer wieder
auszuführen, und zwar für immer oder bis du ihm explizit sagst, dass er
aufhören soll.</p>
<p>Als Beispiel änderst du die Datei <em>src/main.rs</em> in deinem <em>loops</em>-Verzeichnis
so, dass sie wie folgt aussieht:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;nochmal!&quot;);
    }
}</code></pre>
<p>Wenn wir dieses Programm ausführen, werden wir sehen, dass es immer und immer
wieder <code>nochmal!</code> ausgibt, bis wir das Programm manuell stoppen. Die meisten
Terminals unterstützen das Tastaturkürzel <span
class="keystroke">Strg+c</span>, um ein Programm zu unterbrechen, das in einer
Endlosschleife feststeckt. Probiere es aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
nochmal!
nochmal!
nochmal!
nochmal!
^Cnochmal!
</code></pre>
<p>Das Symbol <code>^C</code> steht für die Stelle, an der du <span
class="keystroke">Strg+c</span> gedrückt hast. Je nachdem, wo sich der Code in
der Schleife befand, als er das Unterbrechungssignal empfing, siehst du nach
dem <code>^C</code> das Wort <code>nochmal!</code> oder nicht.</p>
<p>Glücklicherweise bietet Rust auch eine Möglichkeit, aus einer Schleife
mittels Code auszubrechen. Du kannst das Schlüsselwort <code>break</code> innerhalb der
Schleife platzieren, um dem Programm mitzuteilen, wann es die Ausführung der
Schleife beenden soll. Erinnere dich, dass wir dies im Ratespiel im Abschnitt
<a href="ch02-00-guessing-game-tutorial.html#beenden-nach-einer-korrekten-sch%C3%A4tzung">„Beenden nach einer korrekten Schätzung“</a> in
Kapitel 2 getan haben, um das Programm zu beenden, wenn der Benutzer das Spiel
durch Erraten der richtigen Zahl gewonnen hat.</p>
<p>Wir haben im Ratespiel auch <code>continue</code> verwendet, das innerhalb einer Schleife
das Programm anweist, jeden restlichen Code in dieser Iteration der Schleife zu
überspringen und mit der nächsten Iteration fortzufahren.</p>
<h4 id="rückgabe-von-werten-aus-schleifen"><a class="header" href="#rückgabe-von-werten-aus-schleifen">Rückgabe von Werten aus Schleifen</a></h4>
<p>Eine der Verwendungen von <code>loop</code> besteht darin, eine Operation, von der du
weißt, dass sie fehlschlagen könnte, erneut zu versuchen, z.B. um zu prüfen, ob
ein Strang (thread) seine Arbeit abgeschlossen hat. Möglicherweise musst du
jedoch das Ergebnis dieser Operation aus der Schleife heraus an den Rest deines
Codes weitergeben. Dazu kannst du den Wert, der zurückgegeben werden soll,
hinter dem <code>break</code>-Ausdruck angeben, den du zum Beenden der Schleife
verwendest; dieser Wert wird aus der Schleife zurückgegeben, sodass du ihn
verwenden kannst, wie hier gezeigt:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;Das Ergebnis ist {result}&quot;);
}</code></pre></pre>
<p>Vor der Schleife deklarieren wir eine Variable namens <code>counter</code> und
initialisieren sie mit <code>0</code>. Dann deklarieren wir eine Variable namens <code>result</code>,
die den von der Schleife zurückgegebenen Wert enthält. Bei jeder Iteration der
Schleife addieren wir <code>1</code> zur Variable <code>counter</code> und prüfen dann, ob der Zähler
in <code>counter</code> gleich <code>10</code> ist. Wenn dies der Fall ist, verwenden wir das
Schlüsselwort <code>break</code> mit dem Wert <code>counter * 2</code>. Nach der Schleife verwenden
wir ein Semikolon, um die Anweisung zu beenden, die <code>result</code> den Wert zuweist.
Schließlich geben wir den Wert in <code>result</code> aus, der in diesem Fall <code>20</code>
beträgt.</p>
<h4 id="schleifenlabel-zur-eindeutigen-unterscheidung-mehrerer-schleifen"><a class="header" href="#schleifenlabel-zur-eindeutigen-unterscheidung-mehrerer-schleifen">Schleifenlabel zur eindeutigen Unterscheidung mehrerer Schleifen</a></h4>
<p>Wenn du Schleifen innerhalb von Schleifen hast, gelten <code>break</code> und <code>continue</code>
für die innerste Schleife an diesem Punkt. Du kannst optional ein
<em>Schleifenlabel</em> (loop label) für eine Schleife angeben, das wir dann mit
<code>break</code> oder <code>continue</code> verwenden können, um festzulegen, dass diese
Schlüsselwörter für die gekennzeichnete Schleife gelten und nicht für die
innerste Schleife. Schleifenlabel müssen mit einem einfachen Anführungszeichen
beginnen. Hier ist ein Beispiel mit zwei verschachtelten Schleifen:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;Zähler = {count}&quot;);
        let mut remaining = 10;

        loop {
            println!(&quot;Restliche = {remaining}&quot;);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;Zähler-Endstand = {count}&quot;);
}</code></pre></pre>
<p>Die äußere Schleife hat das Label <code>'counting_up</code> und zählt von 0 bis 2
aufwärts. Die innere Schleife ohne Label zählt von 10 bis 9 herunter. Das erste
<code>break</code>, das kein Label angibt, beendet nur die innere Schleife. Mit der
Anweisung <code>break 'counting_up;</code> wird die äußere Schleife verlassen. Dieser Code
gibt folgendes aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
Zähler = 0
Restliche = 10
Restliche = 9
Zähler = 1
Restliche = 10
Restliche = 9
Zähler = 2
Restliche = 10
Zähler-Endstand = 2
</code></pre>
<h4 id="bedingte-schleifen-mit-while"><a class="header" href="#bedingte-schleifen-mit-while">Bedingte Schleifen mit <code>while</code></a></h4>
<p>Ein Programm wird oft eine Bedingung innerhalb einer Schleife auszuwerten
haben. Solange die Bedingung <code>true</code> ist, wird die Schleife durchlaufen. Wenn
die Bedingung nicht mehr <code>true</code> ist, ruft das Programm <code>break</code> auf und stoppt
die Schleife. Es ist möglich, derartiges Verhalten mittels einer Kombination
von <code>loop</code>, <code>if</code>, <code>else</code> und <code>break</code> zu implementieren; du kannst das jetzt in
einem Programm versuchen, wenn du möchtest. Dieses Muster ist jedoch so weit
verbreitet, dass Rust ein eingebautes Sprachkonstrukt dafür hat, die sogenannte
<code>while</code>-Schleife. In Codeblock 3-3 wird <code>while</code> verwendet: Das Programm
durchläuft dreimal eine Schleife, in der es jedes Mal abwärts zählt, und dann
nach dem Ende der Schleife eine weitere Nachricht ausgibt und sich beendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{number}!&quot;);

        number -= 1;
    }

    println!(&quot;ABHEBEN!!!&quot;);
}</code></pre></pre>
<p><span class="caption">Codeblock 3-3: Verwenden einer <code>while</code>-Schleife, um Code
auszuführen, solange eine Bedingung wahr ist</span></p>
<p>Dieses Konstrukt eliminiert eine Menge von Verschachtelungen, die notwendig
wären, wenn du <code>loop</code>, <code>if</code>, <code>else</code> und <code>break</code> verwenden würdest, und es ist
klarer. Solange eine Bedingung zu <code>true</code> auswertet, läuft der Code ab;
andernfalls wird die Schleife verlassen.</p>
<h4 id="wiederholen-anhand-einer-kollektion-mit-for"><a class="header" href="#wiederholen-anhand-einer-kollektion-mit-for">Wiederholen anhand einer Kollektion mit <code>for</code></a></h4>
<p>Du kannst das <code>while</code>-Konstrukt verwenden, um die Elemente einer Kollektion,
z.B. ein Array, in einer Schleife zu durchlaufen. Die Schleife in Codeblock 3-4
gibt zum Beispiel jedes Element im Array <code>a</code> aus.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;Der Wert ist: {}&quot;, a[index]);

        index += 1;
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 3-4: Wiederholen anhand aller Elemente einer
Kollektion unter Verwendung einer <code>while</code>-Schleife</span></p>
<p>Hier zählt der Code die Elemente im Array aufwärts. Er beginnt bei Index <code>0</code>
und wiederholt bis er den letzten Index im Array erreicht (d.h. wenn
<code>index &lt; 5</code> nicht mehr <code>true</code> ist). Wenn du diesen Code ausführst, wird jedes
Element im Array ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
Der Wert ist: 10
Der Wert ist: 20
Der Wert ist: 30
Der Wert ist: 40
Der Wert ist: 50
</code></pre>
<p>Alle fünf Array-Werte erscheinen erwartungsgemäß im Terminal. Wenn <code>index</code> den
Wert <code>5</code> erreicht hat, stoppt die Schleife ihre Ausführung, bevor sie versucht,
einen sechsten Wert aus dem Array zu holen.</p>
<p>Aber dieser Ansatz ist fehleranfällig; wir könnten das Programm zum Abstürzen
bringen, wenn der Indexwert oder die Testbedingung falsch ist. Wenn du zum
Beispiel die Definition des Arrays <code>a</code> so änderst, dass es vier Elemente hat,
aber vergisst, die Bedingung <code>while index &lt; 4</code> zu aktualisieren, würde der Code
abstürzen. Er ist zudem langsam, weil der Compiler Laufzeitcode erzeugt, der
die Bedingungsprüfung, ob der Index innerhalb der Arraygrenzen liegt, bei jeder
Schleifeniteration durchführt.</p>
<p>Als prägnantere Alternative kannst du eine <code>for</code>-Schleife verwenden und für
jedes Element einer Kollektion etwas Code ausführen. Eine <code>for</code>-Schleife sieht
wie der Code in Codeblock 3-5 aus.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;Der Wert ist: {element}&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 3-5: Wiederholen anhand aller Elemente einer
Kollektion unter Verwendung einer <code>for</code>-Schleife</span></p>
<p>Wenn wir diesen Code ausführen, werden wir die gleiche Ausgabe wie in Codeblock
3-4 sehen. Noch wichtiger ist, dass wir jetzt die Sicherheit des Codes erhöht
und die Möglichkeit von Fehlern eliminiert haben, die dadurch entstehen
könnten, dass wir über das Ende des Arrays hinausgehen oder nicht weit genug
gehen und einige Elemente übersehen.</p>
<p>Wenn du die <code>for</code>-Schleife verwendest, brauchst du nicht daran zu denken,
irgendeinen anderen Code zu ändern, wenn du die Anzahl der Werte im Array
änderst, wie bei der Methode in Codeblock 3-4 verwendet.</p>
<p>Die Sicherheit und Prägnanz der <code>for</code>-Schleifen machen sie zum am häufigsten
verwendeten Schleifenkonstrukt in Rust. Sogar in Situationen, in denen du einen
Code bestimmt oft laufen lassen willst, wie im Countdown-Beispiel, das in
Codeblock 3-3 eine <code>while</code>-Schleife verwendet hat, würden die meisten
Rust-Entwickler eine <code>for</code>-Schleife verwenden. Der Weg, dies zu erreichen, wäre
das Verwenden eines <code>Range</code>, der von der Standardbibliothek zur Verfügung
gestellt wird und alle Zahlen in Folge generiert, beginnend mit einer Zahl und
endend vor einer anderen Zahl.</p>
<p>So würde der Countdown aussehen, wenn man eine <code>for</code>-Schleife und die Methode
<code>rev</code>, über die wir noch nicht gesprochen haben und die den <code>Range</code> umkehrt,
verwenden würde:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{number}!&quot;);
    }
    println!(&quot;ABHEBEN!!!&quot;);
}</code></pre></pre>
<p>Dieser Code ist ein bisschen schöner, nicht wahr?</p>
<h2 id="zusammenfassung-2"><a class="header" href="#zusammenfassung-2">Zusammenfassung</a></h2>
<p>Du hast es geschafft! Das war ein beachtliches Kapitel: Du lerntest etwas über
Variablen, Skalare und zusammengesetzte Datentypen, Funktionen, Kommentare,
<code>if</code>-Ausdrücke und Schleifen! Um mit den in diesem Kapitel besprochenen
Konzepten zu üben, versuche, Programme zu bauen, um Folgendes zu tun:</p>
<ul>
<li>Temperaturen zwischen Fahrenheit und Celsius umrechnen.</li>
<li>Die <em>n</em>-te Fibonacci-Zahl berechnen.</li>
<li>Den Text des Weihnachtsliedes „Die Zwölf Weihnachtstage“ (The Twelve Days of
Christmas) ausgeben und dabei die Wiederholung im Lied nutzen.</li>
</ul>
<p>Wenn du bereit bist, weiterzumachen, werden wir in Rust über ein Konzept
sprechen, das es in anderen Programmiersprachen üblicherweise <em>nicht</em> gibt:
Eigentümerschaft (ownership).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eigentümerschaft-ownership-verstehen"><a class="header" href="#eigentümerschaft-ownership-verstehen">Eigentümerschaft (ownership) verstehen</a></h1>
<p>Eigentümerschaft (ownership) ist das wichtigste Alleinstellungsmerkmal von
Rust und hat tiefgreifende Auswirkungen auf den Rest der Sprache. Sie
ermöglicht es Rust, Speichersicherheitsgarantien ohne Einsatz
einer automatischen Speicherbereinigung (garbage collector) zu geben, deshalb
ist es wichtig zu verstehen, wie Eigentümerschaft in Rust funktioniert. In
diesem Kapitel werden wir uns neben der Eigentümerschaft weitere diesbezügliche
Funktionalitäten ansehen: Ausleihen (borrowing), Anteilstypen (slices) und wie
Rust Daten im Speicher anordnet.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="was-ist-eigentümerschaft-ownership"><a class="header" href="#was-ist-eigentümerschaft-ownership">Was ist Eigentümerschaft (ownership)?</a></h2>
<p><em>Eigentümerschaft</em> ist eine Reihe von Regeln, die bestimmen, wie ein
Rust-Programm den Speicher verwaltet.</p>
<p>Alle Programme müssen den Arbeitsspeicher eines Rechners verwalten, während sie
ausgeführt werden. Einige Sprachen verfügen über eine automatische
Speicherbereinigung, die während der Programmausführung ständig nach nicht mehr
genutztem Speicher sucht. Bei anderen Sprachen muss der Programmierer selbst
den Speicher explizit reservieren und freigeben. Rust verwendet einen dritten
Ansatz: Der Speicher wird durch ein System aus Eigentümerschaft und einer Reihe
von Regeln verwaltet, die der Compiler überprüft. Wenn eine der Regeln verletzt
wird, lässt sich das Programm nicht kompilieren. Keine der
Eigentümerschaftsfunktionalitäten verlangsamt dein Programm, während es
läuft.</p>
<p>Da die Eigentümerschaft für viele Programmierer ein neues Konzept ist, braucht
es etwas Zeit, sich daran zu gewöhnen. Die gute Nachricht ist, je mehr
Erfahrung du mit Rust und den Regeln der Eigentümerschaft gesammelt hast, desto
einfacher findest du es, auf natürliche Weise Code zu entwickeln, der sicher und
effizient ist. Bleib dran!</p>
<p>Wenn du Eigentümerschaft verstehst, hast du eine solide Grundlage, um die
Funktionalitäten zu verstehen, die Rust einzigartig machen. In diesem Kapitel
lernst du Eigentümerschaft kennen, indem du einige Beispiele durcharbeitest,
die sich auf eine sehr verbreitete Datenstruktur konzentrieren: Zeichenketten
(strings).</p>
<blockquote>
<h3 id="stapelspeicher-stack-und-haldenspeicher-heap"><a class="header" href="#stapelspeicher-stack-und-haldenspeicher-heap">Stapelspeicher (stack) und Haldenspeicher (heap)</a></h3>
<p>Viele Programmiersprachen erfordern nicht, dass du sehr oft über
Stapelspeicher und Haldenspeicher nachdenken musst. Aber in einer
Systemprogrammiersprache wie Rust hat die Frage, ob ein Wert auf dem
Stapelspeicher oder im Haldenspeicher liegt, einen größeren Einfluss darauf,
wie sich die Sprache verhält und warum du bestimmte Entscheidungen treffen
musst. Teile der Eigentümerschaft werden später in diesem Kapitel in Bezug
auf den Stapelspeicher und den Haldenspeicher beschrieben, daher hier eine
kurze Erklärung zur Vorbereitung.</p>
<p>Sowohl Stapelspeicher als auch Haldenspeicher sind Teile des
Arbeitsspeichers, die deinem Code zur Laufzeit zur Verfügung stehen, aber sie
sind unterschiedlich strukturiert. Der Stapelspeicher speichert Werte in der
Reihenfolge, in der er sie erhält, und entfernt die Werte in umgekehrter
Reihenfolge. Dies wird als <em>zuletzt herein, zuerst hinaus</em> (last in, first
out) bezeichnet. Denke an einen Stapel Teller: Wenn du weitere Teller
hinzufügst, legst du sie auf den Stapel, und wenn du einen Teller benötigst,
nimmst du einen von oben. Das Hinzufügen oder Entfernen von Tellern aus der
Mitte oder von unten würde nicht so gut funktionieren! Das Hinzufügen von
Daten nennt man <em>auf den Stapel legen</em>, und das Entfernen von Daten nennt man
<em>vom Stapel nehmen</em>. Alle im Stapelspeicher gespeicherten Daten müssen eine
bekannte, feste Größe haben. Daten mit einer zur Kompilierzeit unbekannten
Größe oder einer Größe, die sich ändern könnte, müssen stattdessen im
Haldenspeicher gespeichert werden.</p>
<p>Der Haldenspeicher ist weniger organisiert: Wenn du
Daten in den Haldenspeicher legst, forderst du eine bestimmte Menge an
Speicherplatz an. Der Speicher-Allokator (memory allocator) sucht eine leere
Stelle im Haldenspeicher, die groß genug ist, markiert sie als in
Benutzung und gibt einen <em>Zeiger</em> (pointer) zurück, der die Adresse dieser
Stelle ist. Dieser Vorgang wird als <em>Allokieren im Haldenspeicher</em>
bezeichnet und manchmal mit <em>Allokieren</em> abgekürzt (Das Legen von Werten auf
den Stapelspeicher gilt nicht als Allokieren). Da es sich beim Zeiger um eine
bekannte, feste Größe handelt, kannst du den Zeiger auf den Stapelspeicher
legen, aber wenn du die eigentlichen Daten benötigst, musst du dem Zeiger
folgen. Stell dir vor, du sitzt in einem Restaurant. Wenn du hineingehst,
gibst du die Anzahl der Personen deiner Gruppe an, und das Personal findet
einen leeren Tisch, der groß genug ist, und führt euch dorthin. Wenn jemand
aus deiner Gruppe zu spät kommt, kann er fragen, wo ihr Platz genommen habt,
um euch zu finden.</p>
<p>Das Legen auf den Stapelspeicher ist schneller als das Allokieren im
Haldenspeicher, da der Speicher-Allokator nie nach Platz zum Speichern
neuer Daten suchen muss; dieser Ort ist immer ganz oben auf dem Stapel. Im
Vergleich dazu erfordert das Allokieren von Speicherplatz im dynamischen
Speicher mehr Arbeit, da der Speicher-Allokator zunächst einen ausreichend
großen Platz für die Daten finden und dann Buch führen muss, um die nächste
Allokation vorzubereiten.</p>
<p>Der Zugriff auf Daten im Haldenspeicher ist langsamer als der Zugriff
auf Daten auf dem Stapelspeicher, da du einem Zeiger folgen musst, um dorthin
zu gelangen. Heutige Prozessoren sind schneller, wenn sie weniger im Speicher
herumspringen. Um die Analogie fortzusetzen, betrachte einen Kellner in einem
Restaurant, der an vielen Tischen Bestellungen aufnimmt. Es ist am
effizientesten, alle Bestellungen an einem Tisch aufzunehmen, bevor man zum
nächsten Tisch weitergeht. Eine Bestellung von Tisch A, dann eine Bestellung
von Tisch B, dann wieder eine von A und dann wieder eine von B aufzunehmen,
wäre ein viel langsamerer Vorgang. Umgekehrt kann ein Prozessor seine Arbeit
besser erledigen, wenn er mit Daten arbeitet, die nahe beieinander liegen
(wie sie auf dem Stapelspeicher liegen) und nicht weiter voneinander entfernt
(wie sie im Haldenspeicher liegen können). Das Allokieren einer großen
Menge an Platz im Haldenspeicher kann ebenfalls Zeit in Anspruch
nehmen.</p>
<p>Wenn dein Code eine Funktion aufruft, werden die an die Funktion übergebenen
Werte (einschließlich potentieller Zeiger auf Daten im Haldenspeicher)
und die lokalen Variablen der Funktion auf den Stapelspeicher gelegt. Wenn
die Funktion beendet ist, werden diese Werte vom Stapelspeicher genommen.</p>
<p>Das Nachverfolgen, welche Codeteile welche Daten im Haldenspeicher
verwenden, das Minimieren der Menge an doppelten Daten im Haldenspeicher
und das Aufräumen ungenutzter Daten im Haldenspeicher, damit
dir der Speicherplatz nicht ausgeht, sind alles Probleme, die durch
Eigentümerschaft gelöst werden. Wenn du Eigentümerschaft einmal verstanden
hast, brauchst du nicht mehr so oft über Stapelspeicher und Haldenspeicher 
nachzudenken. Aber zu wissen, dass der Hauptzweck der Eigentümerschaft die
Verwaltung der Haldenspeicher-Daten ist, kann helfen zu erklären, warum es so
funktioniert, wie es funktioniert.</p>
</blockquote>
<h3 id="eigentumsregeln"><a class="header" href="#eigentumsregeln">Eigentumsregeln</a></h3>
<p>Lass uns zunächst einen Blick auf die Eigentumsregeln (ownership rules) werfen.
Behalte diese Regeln im Hinterkopf, während wir veranschaulichende Beispiele
durcharbeiten:</p>
<ul>
<li>Jeder Wert in Rust hat eine Variable, die als sein <em>Eigentümer</em> bezeichnet
wird.</li>
<li>Es kann immer nur einen Eigentümer zur gleichen Zeit geben.</li>
<li>Wenn der Eigentümer den Gültigkeitsbereich verlässt, wird der Wert
aufgeräumt.</li>
</ul>
<h3 id="gültigkeitsbereich-scope-einer-variable"><a class="header" href="#gültigkeitsbereich-scope-einer-variable">Gültigkeitsbereich (scope) einer Variable</a></h3>
<p>Da wir nun über die grundlegende Syntax hinausgehen, werden wir nicht mehr den
gesamten <code>fn main() {</code>-Code in die Beispiele aufnehmen. Wenn du also
weitermachst, musst du die folgenden Beispiele manuell in eine Funktion <code>main</code>
einfügen. Folglich werden unsere Beispiele etwas prägnanter sein, damit wir uns
auf die eigentlichen Details konzentrieren können, anstatt auch den Code darum
herum betrachten zu müssen.</p>
<p>Als erstes Beispiel zu Eigentümerschaft werden wir uns den <em>Gültigkeitsbereich</em>
(scope) einiger Variablen ansehen. Der Gültigkeitsbereich ist der Bereich
innerhalb eines Programms, in dem ein Element gültig ist. Sieh dir folgende
Variable an:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hallo&quot;;
<span class="boring">}</span></code></pre></pre>
<p>Die Variable <code>s</code> bezieht sich auf ein Zeichenkettenliteral, wobei der Wert der
Zeichenkette fest in den Text unseres Programms kodiert ist. Die Variable ist
ab der Stelle, an der sie deklariert wurde, bis zum Ende des aktuellen
<em>Gültigkeitsbereichs</em> gültig. Codeblock 4-1 zeigt ein Programm mit Kommentaren,
die zeigen wo die Variable <code>s</code> gültig ist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{                      // s ist hier nicht gültig, es wurde noch nicht deklariert
    let s = &quot;Hallo&quot;;   // s ist ab dieser Stelle gültig

    // etwas mit s machen
}                      // dieser Gültigkeitsbereich ist nun vorbei,
                       // und s ist nicht mehr gültig
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 4-1: Eine Variable und der Bereich, in dem sie
gültig ist</span></p>
<p>Mit anderen Worten, es gibt hier zwei wichtige Zeitpunkte:</p>
<ul>
<li>Wenn <code>s</code> <em>in den Gültigkeitsbereich</em> kommt, ist es gültig.</li>
<li>Es bleibt gültig, bis es <em>den Gültigkeitsbereich</em> verlässt.</li>
</ul>
<p>An diesem Punkt ist die Beziehung zwischen Gültigkeitsbereichen und wann
Variablen gültig sind ähnlich zu anderen Programmiersprachen. Nun werden wir
auf diesem Verständnis aufbauen, indem wir den Typ <code>String</code> einführen.</p>
<h3 id="der-typ-string"><a class="header" href="#der-typ-string">Der Typ <code>String</code></a></h3>
<p>Um die Eigentumsregeln zu veranschaulichen, benötigen wir einen Datentyp, der
komplexer ist als die, die wir im Abschnitt <a href="ch03-02-data-types.html">„Datentypen“</a> in
Kapitel 3 behandelt haben. Die zuvor behandelten Typen haben eine bekannte
Größe, können auf dem Stapelspeicher gelegt und vom Stapelspeicher entfernt
werden, wenn ihr Gültigkeitsbereich beendet ist, und können schnell und trivial
kopiert werden, um eine neue, unabhängige Instanz zu erzeugen, wenn ein anderer
Teil des Codes denselben Wert in einem anderen Gültigkeitsbereich verwenden
muss. Wir wollen uns jedoch Daten ansehen, die im Haldenspeicher gespeichert
sind, und untersuchen, woher Rust weiß, wann es diese Daten aufräumen muss, und
der Typ <code>String</code> ist ein gutes Beispiel dafür.</p>
<p>Wir werden uns auf die Teile von <code>String</code> konzentrieren, die sich auf die
Eigentümerschaft beziehen. Diese Aspekte gelten auch für andere komplexe
Datentypen, unabhängig davon, ob sie von der Standardbibliothek bereitgestellt
oder von dir erstellt wurden. Wir werden <code>String</code> in <a href="ch08-02-strings.html">Kapitel 8</a>
eingehender behandeln.</p>
<p>Wir haben bereits Zeichenkettenliterale gesehen, bei denen ein
Zeichenkettenwert fest in unserem Programm kodiert ist. Zeichenkettenliterale
sind praktisch, aber sie eignen sich nicht für jede Situation, in der wir Text
verwenden möchten. Ein Grund dafür ist, dass sie unveränderbar sind. Ein
anderer Grund ist, dass nicht jeder Zeichenkettenwert bekannt ist, wenn wir
unseren Code schreiben: Was ist zum Beispiel, wenn wir Benutzereingaben
entgegennehmen und speichern wollen? Für diese Situationen hat Rust einen
zweiten Zeichenkettentyp: <code>String</code>. Dieser Typ verwaltet Daten, die auf dem
Haldenspeicher allokiert sind, und kann so eine Textmenge speichern, die uns
zur Kompilierzeit unbekannt ist. Du kannst einen <code>String</code> aus einem
Zeichenkettenliteral erzeugen, indem du die Funktion <code>from</code> wie folgt
verwendest:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Der doppelte Doppelpunkt (<code>::</code>) Operator erlaubt uns, diese spezielle Funktion
<code>from</code> mit dem Namensraum des <code>String</code>-Typs zu benennen, anstatt einen Namen
wie <code>string_from</code> zu verwenden. Wir werden diese Syntax im Abschnitt
<a href="ch05-03-method-syntax.html">„Methodensyntax“</a> in Kapitel 5 näher betrachten, und wenn wir
in Kapitel 7 unter <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit Pfaden auf ein Element im Modulbaum
verweisen“</a> über den Namensraum mit Modulen sprechen. </p>
<p>Diese Art von Zeichenkette kann <em>verändert</em> werden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

s.push_str(&quot; Welt!&quot;); // push_str() hängt ein Literal an eine Zeichenfolge an

println!(&quot;{}&quot;, s);    // Gibt `Hallo Welt!` aus
<span class="boring">}</span></code></pre></pre>
<p>Was ist hier nun der Unterschied? Warum kann <code>String</code> verändert werden,
Literale jedoch nicht? Der Unterschied liegt darin, wie diese beiden Typen mit
dem Arbeitsspeicher umgehen.</p>
<h3 id="speicher-und-allokation"><a class="header" href="#speicher-und-allokation">Speicher und Allokation</a></h3>
<p>Im Falle eines Zeichenkettenliterals kennen wir den Inhalt zum Zeitpunkt der
Kompilierung, sodass der Text direkt in die endgültige ausführbare Datei fest
kodiert wird. Aus diesem Grund sind Zeichenkettenliterale schnell und
effizient. Allerdings ergeben sich diese Eigenschaften nur aus der
Unveränderbarkeit des Zeichenkettenliterals. Leider können wir nicht für jedes
Stück Text, dessen Größe zum Zeitpunkt der Kompilierung unbekannt ist und
dessen Größe sich während der Ausführung des Programms ändern könnte, einen
Speicherblock in die Binärdatei packen.</p>
<p>Um mit dem Typ <code>String</code> einen veränderbaren, größenänderbaren Textabschnitt zu
unterstützen, müssen wir Speicher im Haldenspeicher allokieren, dessen
Größe zur Kompilierzeit unbekannt ist. Dies bedeutet:</p>
<ul>
<li>Der Speicher muss zur Laufzeit vom Speicher-Allokator angefordert werden.</li>
<li>Wir brauchen eine Möglichkeit, diesen Speicher an den Speicher-Allokator
zurückzugeben, wenn wir mit unserem <code>String</code> fertig sind.</li>
</ul>
<p>Der erste Teil wird von uns erledigt: Wenn wir <code>String::from</code> aufrufen, fordert
seine Implementierung den Speicher an, den sie benötigt. Dies ist in
Programmiersprachen ziemlich einheitlich.</p>
<p>Der zweite Teil ist jedoch anders. In Sprachen mit einer <em>automatischen
Speicherbereinigung</em> (garbage collector, GC) behält der GC den Überblick und
räumt Speicherplatz, der nicht mehr verwendet wird, auf; wir brauchen nicht
darüber nachzudenken. Ohne einen GC liegt es in unserer Verantwortung, zu
erkennen, wann Speicherplatz nicht mehr benutzt wird, und Code aufzurufen, der
ihn explizit zurückgibt, so wie wir es beim Anfordern auch getan haben. Dies
korrekt zu tun, war in der Vergangenheit ein schwieriges Programmierproblem.
Wenn wir es vergessen, verschwenden wir Speicher. Wenn wir es zu früh machen,
haben wir eine ungültige Variable. Wenn wir es zweimal machen, ist das auch ein
Fehler. Wir müssen eine <em>Allokierung</em> mit genau einer <em>Freigabe</em> paaren.</p>
<p>Rust geht einen anderen Weg: Der Speicher wird automatisch zurückgegeben,
sobald die Variable, die ihn besitzt, den Gültigkeitsbereich verlässt. Hier ist
eine Variante unseres Gültigkeitsbereich-Beispiels aus Codeblock 4-1, bei der
ein <code>String</code> anstelle eines Zeichenkettenliterals verwendet wird:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;Hallo&quot;); // s ist ab dieser Stelle gültig

    // etwas mit s machen
}                                  // dieser Gültigkeitsbereich ist nun vorbei,
                                   // und s ist nicht mehr gültig
<span class="boring">}</span></code></pre></pre>
<p>Es gibt eine natürliche Stelle, an der wir den Speicher, den unser <code>String</code>
benötigt, an den Speicher-Allokator zurückgeben können: Wenn <code>s</code> den
Gültigkeitsbereich verlässt. Wenn eine Variable den Gültigkeitsbereich
verlässt, ruft Rust für uns eine spezielle Funktion auf: Diese Funktion heißt
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a> und an dieser Stelle kann der Autor von <code>String</code> Code
einfügen, um den Speicher zurückzugeben. Rust ruft <code>drop</code> automatisch an der
schließenden geschweiften Klammer auf.</p>
<blockquote>
<p>Hinweis: In C++ wird dieses Muster der Freigabe von Ressourcen am Ende der
Lebensdauer eines Elements manchmal als <em>Ressourcenbelegung ist
Initialisierung</em> (resource acquisition is initialization, RAII) bezeichnet.
Die Funktion <code>drop</code> in Rust wird dir vertraut vorkommen, wenn du bereits
RAII-Muster verwendet hast.</p>
</blockquote>
<p>Dieses Muster hat einen tiefgreifenden Einfluss auf die Art und Weise, wie
Rust-Code geschrieben wird. Es mag im Moment einfach erscheinen, aber das
Verhalten von Code kann in komplizierteren Situationen unerwartet sein, wenn
wir wollen, dass mehrere Variablen Daten verwenden, die wir im dynamischen
Speicher allokiert haben. Lass uns jetzt einige dieser Situationen untersuchen.</p>
<h4 id="variablen-und-daten-im-zusammenspiel-mit-move"><a class="header" href="#variablen-und-daten-im-zusammenspiel-mit-move">Variablen und Daten im Zusammenspiel mit Move</a></h4>
<p>Mehrere Variablen können in Rust auf unterschiedliche Weise mit denselben Daten
interagieren. Betrachten wir ein Beispiel mit einer ganzen Zahl in Codeblock
4-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 4-2: Zuweisen des ganzzahligen Wertes der
Variablen <code>x</code> an <code>y</code></span></p>
<p>Wir können wahrscheinlich erahnen, was das bewirkt: „Binde den Wert <code>5</code> an <code>x</code>;
dann erstelle eine Kopie des Wertes in <code>x</code> und binde ihn an <code>y</code>.“ Wir haben
jetzt zwei Variablen <code>x</code> und <code>y</code> und beide sind gleich <code>5</code>. Das ist in der Tat
der Fall, denn ganze Zahlen sind einfache Werte mit einer bekannten, festen
Größe, und diese beiden Werte <code>5</code> werden auf den Stapelspeicher gelegt.</p>
<p>Schauen wir uns nun die <code>String</code>-Variante an:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>Dies sieht sehr ähnlich aus, sodass wir annehmen könnten, dass die
Funktionsweise die gleiche wäre: Das heißt, die zweite Zeile würde eine Kopie
des Wertes in <code>s1</code> erstellen und sie an <code>s2</code> binden. Aber das ist nicht ganz
das, was passiert.</p>
<p>Betrachte Abbildung 4-1, um zu sehen, was mit dem <code>String</code> unter der Haube
geschieht. Ein <code>String</code> besteht aus drei Teilen, die auf der linken Seite
dargestellt sind: Einem Zeiger auf den Speicherbereich, der den Inhalt der
Zeichenkette enthält, die Länge und die Kapazität. Dieser Datenblock wird auf
dem Stapelspeicher gespeichert. Auf der rechten Seite ist der Speicherbereich
im Haldenspeicher, der den Inhalt enthält.</p>
<p><img alt="Zwei Tabellen: Die erste Tabelle enthält die Darstellung von s1 auf
dem Stapelspeicher, bestehend aus seiner Länge (5), seiner Kapazität (5) und
einem Zeiger auf den ersten Wert in der zweiten Tabelle. Die zweite Tabelle
enthält die Darstellung der Zeichenkettendaten auf dem Haldenspeicher, Byte für
Byte." src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-1: Speicherdarstellung eines <code>String</code> mit dem
Wert „Hallo“, gebunden an <code>s1</code></span></p>
<p>Die Länge gibt an, wie viel Speicherplatz in Bytes der Inhalt der Zeichenkette
derzeit belegt. Die Kapazität ist die Gesamtmenge des Speichers in Bytes, die
der <code>String</code> vom Speicher-Allokator erhalten hat. Der Unterschied zwischen
Länge und Kapazität ist von Bedeutung, aber nicht in diesem Zusammenhang,
deshalb ist es im Moment in Ordnung, die Kapazität zu ignorieren.</p>
<p>Wenn wir <code>s1</code> an <code>s2</code> zuweisen, werden die <code>String</code>-Daten kopiert, d.h. wir
kopieren den Zeiger, die Länge und die Kapazität, die sich auf dem
Stapelspeicher befinden. Wir kopieren nicht die Daten im Haldenspeicher,
auf die sich der Zeiger bezieht. Die Speicherdarstellung sieht also wie in
Abbildung 4-2 aus.</p>
<p><img alt="Drei Tabellen: Die Tabellen s1 und s2, die die Zeichenketten auf dem
Stapelspeicher repräsentieren und beide auf die gleichen Zeichenkettendaten auf
dem Haldenspeicher verweisen." src="img/trpl04-02.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-2: Speicherdarstellung der Variable <code>s2</code>, die
eine Kopie des Zeigers, der Länge und der Kapazität von <code>s1</code> hat</span></p>
<p>Die Darstellung sieht <em>nicht</em> wie Abbildung 4-3 aus, so wie der Speicher
aussehen würde, wenn Rust stattdessen auch die Daten im Haldenspeicher
kopieren würde. Würde Rust dies tun, könnte die Operation <code>s2 = s1</code> bei großen
Datenmengen im Haldenspeicher sehr teuer hinsichtlich der
Laufzeitperformanz werden.</p>
<p><img alt="Vier Tabellen: Zwei Tabellen, die die Stapelspeicher-Daten für s1 und
s2 darstellen, und jede zeigt auf ihre eigene Kopie der Zeichenketten-Daten auf
dem Haldenspeicher." src="img/trpl04-03.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-3: Eine weitere Möglichkeit für das, was
<code>s2 = s1</code> tun könnte, falls Rust auch die Daten im Haldenspeicher
kopieren würde</span></p>
<p>Vorhin sagten wir, dass Rust automatisch die Funktion <code>drop</code> aufruft und den
Haldenspeicher für diese Variable säubert, wenn eine Variable den
Gültigkeitsbereich verlässt. Abbildung 4-2 zeigt jedoch, dass beide Datenzeiger
auf dieselbe Stelle zeigen. Das ist ein Problem: Wenn <code>s2</code> und <code>s1</code> den
Gültigkeitsbereich verlassen, werden beide versuchen, den gleichen Speicher
freizugeben. Dies wird als <em>doppelter Freigabefehler</em> (double free error)
bezeichnet und ist einer der Speichersicherheitsfehler, die wir zuvor erwähnt
haben. Das zweimalige Freigeben des Speichers kann zu einer
Speicherverfälschung führen, was potenziell zu Sicherheitslücken führen kann.</p>
<p>Um Speichersicherheit zu gewährleisten, betrachtet Rust nach der Zeile <code>let s2 = s1;</code> die Variable <code>s1</code> als nicht mehr gültig. Daher braucht Rust nichts
freizugeben, wenn <code>s1</code> den Gültigkeitsbereich verlässt. Schau dir an, was
passiert, wenn du versuchst, <code>s1</code> zu benutzen, nachdem <code>s2</code> erstellt wurde; es
wird nicht funktionieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let s2 = s1;

println!(&quot;{} Welt!&quot;, s1);
<span class="boring">}</span></code></pre></pre>
<p>Du erhältst eine Fehlermeldung wie diese, wodurch Rust dich daran hindert, die
ungültige Referenz zu verwenden:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;Hallo&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{} Welt!&quot;, s1);
  |                          ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Wenn du beim Arbeiten mit anderen Sprachen schon mal die Begriffe <em>flache
Kopie</em> (shallow copy) und <em>tiefe Kopie</em> (deep copy) gehört hast, hört sich das
Konzept des Kopierens des Zeigers, der Länge und der Kapazität ohne Kopieren
der Daten nach einer flachen Kopie an. Aber weil Rust auch die erste Variable
ungültig macht, wird es nicht als flache Kopie, sondern als <em>Verschieben</em>
(move) bezeichnet. In diesem Beispiel würden wir sagen, dass <code>s1</code> in <code>s2</code>
<em>verschoben</em> wurde. Was tatsächlich geschieht, ist in Abbildung 4-4
dargestellt.</p>
<p><img alt="Drei Tabellen: Die Tabellen s1 und s2, die jeweils die Zeichenketten
auf dem Stapelspeicher darstellen und beide auf dieselben Zeichenkettendaten
auf dem Haldenspeicher referenzieren. Die Tabelle s1 ist durchgestrichen, weil
s1 nicht mehr gültig ist; nur s2 kann für den Zugriff auf die
Haldenspeicher-Daten verwendet werden." src="img/trpl04-04.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-4: Speicherdarstellung, nachdem <code>s1</code> ungültig
gemacht wurde</span></p>
<p>Damit ist unser Problem gelöst! Da nur <code>s2</code> gültig ist, wenn es den
Gültigkeitsbereich verlässt, wird es allein den Speicher freigeben, und wir
sind fertig.</p>
<p>Darüber hinaus gibt es eine Entwurfsentscheidung, die damit impliziert ist:
Rust wird niemals automatisch „tiefe“ Kopien deiner Daten erstellen. Daher kann
man davon ausgehen, dass jedes <em>automatische</em> Kopieren im Hinblick auf die
Laufzeitperformanz kostengünstig ist.</p>
<h4 id="variablen-und-daten-im-zusammenspiel-mit-clone"><a class="header" href="#variablen-und-daten-im-zusammenspiel-mit-clone">Variablen und Daten im Zusammenspiel mit Clone</a></h4>
<p>Wenn wir die Daten von <code>String</code> im Haldenspeicher <em>tief</em> kopieren wollen,
nicht nur die Stapelspeicher-Daten, können wir eine gängige Methode namens
<code>clone</code> verwenden. Wir werden die Methodensyntax in Kapitel 5 besprechen, aber
da Methoden eine gängige Funktionalität vieler Programmiersprachen sind, hast
du sie wahrscheinlich schon einmal gesehen.</p>
<p>Hier ist ein Beispiel für die Methode <code>clone</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}</span></code></pre></pre>
<p>Das funktioniert sehr gut und erzeugt explizit das in Abbildung 4-3 gezeigte
Verhalten, bei dem die Daten im Haldenspeicher <em>kopiert</em> werden.</p>
<p>Wenn du einen Aufruf von <code>clone</code> siehst, weißt du, dass irgendein beliebiger
Code ausgeführt wird und dass dieser Code teuer sein könnte. Es ist ein
visueller Indikator dafür, dass etwas anderes vor sich geht.</p>
<h4 id="nur-stapelspeicher-daten-kopieren-copy"><a class="header" href="#nur-stapelspeicher-daten-kopieren-copy">Nur Stapelspeicher-Daten: Kopieren (copy)</a></h4>
<p>Es gibt noch einen weiteren Kniff, über den wir noch nicht gesprochen haben.
Folgender Code mit ganzen Zahlen, der teilweise in Codeblock 4-2 gezeigt wurde,
funktioniert und ist gültig:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}</span></code></pre></pre>
<p>Aber dieser Code scheint dem zu widersprechen, was wir gerade gelernt haben:
Wir haben keinen Aufruf von <code>clone</code>, aber <code>x</code> ist immer noch gültig und wurde
nicht in <code>y</code> verschoben.</p>
<p>Der Grund dafür ist, dass Typen wie ganze Zahlen, die zur Kompilierzeit eine
bekannte Größe haben, vollständig auf dem Stack gespeichert werden, so dass
Kopien der tatsächlichen Werte schnell erstellt werden können. Das bedeutet,
dass es keinen Grund gibt, warum wir verhindern wollen, dass <code>x</code> gültig ist,
nachdem wir die Variable <code>y</code> erstellt haben. Mit anderen Worten, es gibt hier
keinen Unterschied zwischen tiefen und flachen Kopien, also würde der Aufruf
<code>clone</code> nichts anderes tun als das übliche flache Kopieren, und wir können es
weglassen.</p>
<p>Rust hat eine spezielle Annotation, das Merkmal <code>Copy</code>, die wir an Typen hängen
können, die auf dem Stapelspeicher wie ganze Zahlen gespeichert sind (wir
werden in <a href="ch10-02-traits.html">Kapitel 10</a> mehr über Merkmale sprechen). Wenn ein Typ das
Merkmal <code>Copy</code> implementiert, werden Variablen, die dieses Merkmal verwenden,
nicht verschoben, sondern trivialerweise kopiert, sodass sie auch nach der
Zuweisung an eine andere Variable noch gültig sind.</p>
<p>Rust lässt uns einen Typ nicht mit dem Merkmal <code>Copy</code> annotieren, wenn der Typ
oder einer seiner Teile das Merkmal <code>Drop</code> implementiert. Wenn der Typ eine
Sonderbehandlung benötigt, wenn der Wert den Gültigkeitsbereich verlässt und
wir die Annotation <code>Copy</code> zu diesem Typ hinzufügen, erhalten wir einen
Kompilierfehler. Um zu erfahren, wie du die <code>Copy</code>-Annotation zu deinem Typ
hinzufügen kannst, siehe <a href="appendix-03-derivable-traits.html">„Ableitbare Merkmale (traits)“</a> in
Anhang C.</p>
<p>Welche Typen unterstützen also <code>Copy</code>? Du kannst die Dokumentation für einen
gegebenen Typ überprüfen, um sicherzugehen, aber als allgemeine Regel gilt:
Jede Gruppierung von einfachen skalaren Werten unterstützt <code>Copy</code>, und nichts,
was eine Allokation erfordert oder irgendeine Form von Ressource ist, kann
<code>Copy</code> implementieren. Hier sind einige Typen, die <code>Copy</code> unterstützen:</p>
<ul>
<li>Alle ganzzahligen Typen, z.B. <code>u32</code>.</li>
<li>Der boolesche Typ <code>bool</code> mit den Werten <code>true</code> und <code>false</code>.</li>
<li>Alle Fließkomma-Typen, z.B. <code>f64</code>.</li>
<li>Der Zeichentyp <code>char</code>.</li>
<li>Tupel, wenn sie nur Typen enthalten, die auch <code>Copy</code> unterstützen. Zum
Beispiel unterstützt <code>(i32, i32)</code> <code>Copy</code>, nicht aber <code>(i32, String)</code>.</li>
</ul>
<h3 id="eigentümerschaft-und-funktionen"><a class="header" href="#eigentümerschaft-und-funktionen">Eigentümerschaft und Funktionen</a></h3>
<p>Die Übergabe eines Wertes an eine Funktion funktioniert ähnlich wie die
Zuweisung eines Wertes an eine Variable. Wenn eine Variable an eine Funktion
übergeben wird, wird sie verschoben oder kopiert, genau wie bei der Zuweisung.
Codeblock 4-3 enthält ein Beispiel mit einigen Anmerkungen, aus denen
hervorgeht, wo Variablen in den Gültigkeitsbereich fallen und wo nicht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;Hallo&quot;);  // s kommt in den Gültigkeitsbereich

    takes_ownership(s);             // Der Wert von s wird in die Funktion verschoben,
                                    // und ist daher hier nicht mehr gültig.

    let x = 5;                      // x kommt in den Gültigkeitsbereich

    makes_copy(x);                  // x würde in die Funktion verschoben werden,
                                    // aber i32 erlaubt Copy, also ist es in Ordnung,
                                    // danach immer noch x zu verwenden,

} // Hier verlässt x den Gültigkeitsbereich, dann s.
  // Aber weil der Wert von s verschoben wurde, passiert nichts Besonderes.

fn takes_ownership(some_string: String) { // some_string kommt in den Gültigkeitsbereich
    println!(&quot;{}&quot;, some_string);
} // Hier verlässt some_string den Gültigkeitsbereich und `drop` wird aufgerufen.
  // Der zugehörige Speicherplatz wird freigegeben.

fn makes_copy(some_integer: i32) { // some_integer kommt in den Gültigkeitsbereich
    println!(&quot;{}&quot;, some_integer);
} // Hier verlässt some_integer den Gültigkeitsbereich. Es passiert nichts Besonderes.</code></pre></pre>
<p><span class="caption">Codeblock 4-3: Funktionen mit kommentierter
Eigentümerschaft und Gültigkeitsbereich</span></p>
<p>Wenn wir versuchen würden, <code>s</code> nach dem Aufruf von <code>takes_ownership</code> zu
verwenden, würde Rust einen Kompilierfehler anzeigen. Diese statischen
Prüfungen schützen uns vor Fehlern. Versuche, weiteren Code zu <code>main</code>
hinzuzufügen, der <code>s</code> und <code>x</code> verwendet, um zu sehen, wo du sie verwenden
kannst und wo die Eigentumsregeln dich daran hindern.</p>
<h3 id="rückgabewerte-und-gültigkeitsbereich"><a class="header" href="#rückgabewerte-und-gültigkeitsbereich">Rückgabewerte und Gültigkeitsbereich</a></h3>
<p>Rückgabewerte können auch Eigentümerschaft übertragen. Codeblock 4-4 ist ein
Beispiel für eine Funktion mit einem Rückgabewert mit ähnlichen Anmerkungen wie
die in Codeblock 4-3.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership verschiebt seinen
                                        // Rückgabewert in s1

    let s2 = String::from(&quot;Hallo&quot;);     // s2 kommt in den Gültigkeitsbereich

    let s3 = takes_and_gives_back(s2);  // s2 wird in takes_and_gives_back verschoben
                                        // und der Rückgabewert wird in s3 verschoben

} // Hier verlässt s3 den Gültigkeitsbereich und wird aufgeräumt.
  // s2 wurde verschoben, es passiert also nichts.
  // s1 verlässt den Gültigkeitsbereich und wird aufgeräumt.

fn gives_ownership() -&gt; String {        // gives_ownership verschiebt seinen
                                        // Rückgabewert in die aufrufende Funktion

    let some_string = String::from(&quot;Hallo&quot;); // some_string kommt in den
                                             // Gültigkeitsbereich

    some_string                         // some_string wird zurückgegeben und
                                        // wird an die aufrufende Funktion verschoben
}

// Diese Funktion nimmt einen String entgegen und gibt einen zurück
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string kommt in den
                                                      // Gültigkeitsbereich

    a_string  // a_string wird zurückgegeben und
              // an die aufrufende Funktion verschoben
}</code></pre></pre>
<p><span class="caption">Codeblock 4-4: Übertragen der Eigentümerschaft an Rückgabewerten</span></p>
<p>Die Eigentümerschaft an einer Variable folgt jedes Mal dem gleichen Muster: Das
Zuweisen eines Wertes an eine andere Variable verschiebt diese. Wenn eine
Variable, die Daten im Haldenspeicher enthält, den Gültigkeitsbereich
verlässt, wird der Wert durch <code>drop</code> aufgeräumt, es sei denn, die
Eigentümerschaft wurde auf eine andere Variable verschoben.</p>
<p>Dies funktioniert zwar, allerdings ist es etwas mühsam, die Eigentümerschaft zu
übernehmen und in jeder Funktion zurückzugeben. Was ist, wenn wir eine Funktion
einen Wert nutzen lassen wollen, aber nicht die Eigentümerschaft übergeben
wollen? Es ist ziemlich lästig, dass alles, was wir übergeben, auch wieder
zurückgegeben werden muss, wenn wir es wieder verwenden wollen, zusätzlich zu
den Daten, die sich aus dem Funktionsrumpf ergeben, die wir vielleicht auch
zurückgeben wollen.</p>
<p>Rust macht es es möglich, mehrere Werte mit Hilfe eines Tupels zurückzugeben,
wie in Codeblock 4-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;Hallo&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;Die Länge von '{}' ist {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() gibt die Länge der Zeichenkette zurück

    (s, length)
}</code></pre></pre>
<p><span class="caption">Codeblock 4-5: Rückgeben der Eigentümerschaft an
Parametern</span></p>
<p>Aber das ist zu viel Zeremonie und zu viel Arbeit für ein Konzept, das
gebräuchlich sein sollte. Zum Glück gibt es in Rust eine Funktion, mit der man
einen Wert verwenden kann, ohne die Eigentümerschaft zu übertragen, nämlich
<em>Referenzen</em> (references).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referenzen-und-ausleihen-borrowing"><a class="header" href="#referenzen-und-ausleihen-borrowing">Referenzen und Ausleihen (borrowing)</a></h2>
<p>Das Problem mit dem Tupelcode in Codeblock 4-5 ist, dass wir der aufrufenden
Funktion den <code>String</code> zurückgeben müssen, damit wir den <code>String</code> nach dem
Aufruf von <code>calculate_length</code> weiter verwenden können, weil der <code>String</code> in
<code>calculate_length</code> verschoben wurde. Stattdessen können wir eine Referenz auf
den <code>String</code>-Wert angeben. Eine <em>Referenz</em> ist wie ein Zeiger, d.h. eine
Adresse, der wir folgen können, um auf Daten zugreifen zu können, die an dieser
Adresse gespeichert sind und einer anderen Variablen gehören. Im Gegensatz zu
einem Zeiger ist bei einer Referenz garantiert, dass sie auf einen gültigen
Wert eines bestimmten Typs zeigt.</p>
<p>Im Folgenden siehst du, wie du eine Funktion <code>calculate_length</code> definieren und
verwenden kannst, die eine Referenz auf ein Objekt als Parameter hat, anstatt
die Eigentümerschaft (ownership) des Wertes zu übernehmen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;Hallo&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;Die Länge von '{}' ist {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
<p>Beachte, dass der gesamte Tupelcode aus der Variablendeklaration und dem
Rückgabewert der Funktion verschwunden ist. Beachte des Weiteren, dass wir
<code>&amp;s1</code> an <code>calculate_length</code> übergeben und in seiner Definition <code>&amp;String</code> statt
<code>String</code> steht. Das <code>&amp;</code>-Zeichen steht für eine <em>Referenz</em>, und sie ermöglicht
es dir, sich auf einen Wert zu beziehen, ohne dessen Eigentümerschaft zu
übernehmen. Abbildung 4-5 zeigt die Speicherdarstellung.</p>
<p><img alt="Drei Tabellen: Die Tabelle für s enthält nur einen Zeiger auf die
Tabelle für s1. Die Tabelle für s1 enthält die Stapelspeicher-Daten für s1 und
zeigt auf die Zeichenketten-Daten auf dem Haldenspeicher."
src="img/trpl04-05.svg" class="center" /></p>
<p><span class="caption">Abbildung 4-5: Eine Grafik mit <code>&amp;String s</code>, das auf
<code>String s1</code> zeigt</span></p>
<blockquote>
<p>Anmerkung: Das Gegenteil der Referenzierung durch <code>&amp;</code> ist die
<em>Dereferenzierung</em> (dereferencing), die mittels Dereferenzoperator <code>*</code>
erfolgt. Wir werden in Kapitel 8 einige Verwendungen des Dereferenzoperators
sehen und in Kapitel 15 Einzelheiten der Dereferenzierung besprechen.</p>
</blockquote>
<p>Schauen wir uns den Funktionsaufruf hier genauer an:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hallo&quot;);

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;Die Länge von '{}' ist {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p>Die Syntax <code>&amp;s1</code> erlaubt es uns, eine Referenz zu erstellen, die auf den Wert
von <code>s1</code> <em>referenziert</em>, ihn aber nicht besitzt. Da sie diesen nicht besitzt,
verfällt der Wert, auf den sie verweist, nicht, wenn die Referenz nicht mehr
benutzt wird.</p>
<p>Ebenso verwendet die Signatur der Funktion das Zeichen <code>&amp;</code>, um anzuzeigen, dass
der Typ des Parameters <code>s</code> eine Referenz ist. Lass uns einige erklärende
Anmerkungen ergänzen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;Hallo&quot;);
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Länge von '{}' ist {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s ist eine Referenz
                                           // auf eine Zeichenkette
    s.len()
} // Hier verlässt s den Gültigkeitsbereich. Aber weil es keine
  // Eigentümerschaft an dem hat, worauf es referenziert, passiert nichts.</code></pre></pre>
<p>Der Gültigkeitsbereich, in dem die Variable <code>s</code> gültig ist, ist derselbe wie
der Gültigkeitsbereich eines Funktionsparameters, aber der Wert, auf den die
Referenz zeigt, wird nicht aufgeräumt, wenn <code>s</code> nicht mehr verwendet wird, weil
<code>s</code> keine Eigentümerschaft hat. Wenn Funktionen statt der tatsächlichen Werte
Referenzen als Parameter haben, brauchen wir die Werte nicht zurückzugeben, um
die Eigentümerschaft zurückzugeben, denn wir hatten nie die Eigentümerschaft.</p>
<p>Wir nennen den Vorgang des Erstellens einer Referenz <em>Ausleihen</em> (borrowing).
Wenn eine Person im richtigen Leben etwas besitzt, kannst du es von ihr
ausleihen. Wenn du fertig bist, musst du es zurückgeben. Es gehört dir nicht.</p>
<p>Was passiert nun, wenn wir versuchen, etwas zu verändern, das wir uns
ausleihen? Versuche den Code in Codeblock 4-6. Achtung: Es funktioniert nicht!</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let s = String::from(&quot;Hallo&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot; Welt&quot;);
}</code></pre></pre>
<p><span class="caption">Codeblock 4-6: Versuch, einen ausgeliehenen Wert zu
verändern</span></p>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     some_string.push_str(&quot; Welt&quot;);
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>So wie Variablen standardmäßig unveränderbar sind, so sind auch Referenzen
unveränderbar. Es ist uns nicht erlaubt, etwas zu verändern, auf das wir eine
Referenz haben.</p>
<h3 id="veränderbare-referenzen"><a class="header" href="#veränderbare-referenzen">Veränderbare Referenzen</a></h3>
<p>Wir können den Code aus Codeblock 4-6 so ändern, dass wir einen geliehenen Wert
mit ein paar kleinen Änderungen ändern können, die stattdessen eine
<em>veränderbare Referenz</em> verwenden:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;Hallo&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot; Welt&quot;);
}</code></pre></pre>
<p>Zuerst ändern wir <code>s</code>, um <code>mut</code> zu sein. Dann erstellen wir eine
veränderbare Referenz mit <code>&amp;mut s</code>, wo wir die Funktion <code>change</code>
aufrufen, und aktualisieren die Funktionssignatur, um eine veränderbare
Referenz mit <code>some_string: &amp;mut String</code> entgegenzunehmen. Dies macht deutlich,
dass die Funktion <code>change</code> den Wert, den sie ausleiht, verändert.</p>
<p>Veränderbare Referenzen haben eine große Einschränkung: Wenn du eine
veränderbare Referenz auf einen Wert hast, kannst du keine andere Referenz auf
diesen Wert haben. Dieser Code versucht, zwei veränderbare Referenzen auf <code>s</code>
zu erstellen, und wird fehlschlagen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}</span></code></pre></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Dieser Fehler besagt, dass dieser Code ungültig ist, weil wir <code>s</code> nicht mehr
als einmal zur gleichen Zeit als veränderbar ausleihen können. Die erste
veränderbare Ausleihe ist in <code>r1</code> und muss beibehalten werden, bis sie in
<code>println!</code> verwendet wird, aber zwischen dem Erstellen dieser veränderbaren
Referenz und ihrer Verwendung haben wir versucht, eine andere veränderbare
Referenz in <code>r2</code> zu erstellen, der die gleichen Daten wie <code>r1</code> ausleiht.</p>
<p>Die Beschränkung, die mehrere veränderbare Referenz auf dieselben Daten zur
gleichen Zeit verhindert, erlaubt Veränderung, aber in einer sehr
kontrollierten Weise. Das ist etwas, womit Rust-Neulinge zu kämpfen haben, denn
in den meisten Sprachen kann man verändern wann immer man will. Diese
Beschränkung hat den Vorteil, dass Rust Daten-Wettlaufsituation zur
Kompilierzeit verhindern kann. Eine <em>Daten-Wettlaufsituation</em> (data race) ist
ähnlich einer Wettlaufsituation (race condition) und tritt auf, wenn diese drei
Verhaltensweisen auftreten:</p>
<ul>
<li>Zwei oder mehr Zeiger greifen gleichzeitig auf die gleichen Daten zu.</li>
<li>Mindestens einer der Zeiger wird zum Schreiben auf die Daten verwendet.</li>
<li>Es gibt keinen Mechanismus, um den Zugriff auf die Daten zu synchronisieren.</li>
</ul>
<p>Daten-Wettlaufsituationen verursachen undefiniertes Verhalten und können
schwierig zu diagnostizieren und zu beheben sein, wenn du versuchst, sie zur
Laufzeit aufzuspüren; Rust verhindert dieses Problem, indem es Code mit
Daten-Wettlaufsituationen gar nicht erst kompiliert!</p>
<p>Wie immer können wir geschweifte Klammern verwenden, um einen neuen
Gültigkeitsbereich zu schaffen, der mehrere veränderbare Referenzen erlaubt,
nur nicht <em>gleichzeitige</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

{
    let r1 = &amp;mut s;
} // r1 verlässt hier den Gültigkeitsbereich, sodass wir
  // problemlos eine neue Referenz erstellen können.

let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>Rust erzwingt eine ähnliche Regel für die Kombination von veränderbaren und
unveränderbaren Referenzen. Dieser Code führt zu einem Fehler:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

let r1 = &amp;s;     // kein Problem
let r2 = &amp;s;     // kein Problem
let r3 = &amp;mut s; // GROSSES PROBLEM

println!(&quot;{}, {} und {}&quot;, r1, r2, r3);
<span class="boring">}</span></code></pre></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s;     // kein Problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s;     // kein Problem
6 |     let r3 = &amp;mut s; // GROSSES PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;{}, {} und {}&quot;, r1, r2, r3);
  |                               -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Puh! Wir können auch keine veränderbaren Referenzen verwenden, solange wir eine
unveränderbare Referenz auf denselben Wert haben.</p>
<p>Nutzer einer unveränderbaren Referenz erwarten nicht, dass sich die Werte
dahinter plötzlich ändern! Mehrere unveränderbare Referenzen sind jedoch in
Ordnung, da niemand, der die Daten nur liest, die Möglichkeit hat, das Lesen
der Daten durch andere zu beeinflussen.</p>
<p>Beachte, dass der Gültigkeitsbereich einer Referenz dort beginnt, wo sie
eingeführt wird, und sich bis zur letzten Verwendung dieser Referenz fortsetzt. 
Zum Beispiel kompiliert dieser Code, weil die letzte Verwendung der
unveränderbaren Referenzen in <code>println!</code> vor der Einführung der veränderbaren
Referenz erfolgt:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

let r1 = &amp;s; // kein Problem
let r2 = &amp;s; // kein Problem
println!(&quot;{} und {}&quot;, r1, r2);
// r1 und r2 werden nach dieser Stelle nicht mehr verwendet

let r3 = &amp;mut s; // kein Problem
println!(&quot;{}&quot;, r3);
<span class="boring">}</span></code></pre></pre>
<p>Die Gültigkeitsbereiche der unveränderbaren Referenzen <code>r1</code> und <code>r2</code> enden
nach dem <code>println!</code>, wo sie zuletzt verwendet werden, d.h. bevor die
veränderbare Referenz <code>r3</code> erstellt wird. Diese Gültigkeitsbereiche
überschneiden sich nicht, daher ist dieser Code zulässig: Der Compiler kann
erkennen, dass die Referenz bereits vor dem Ende des Gültigkeitsbereichs nicht
mehr verwendet wird.</p>
<p>Auch wenn Fehler durch Ausleihen manchmal frustrierend sein können, denke
daran, dass es der Rust-Compiler ist, der frühzeitig (zur Kompilierzeit und
nicht zur Laufzeit) auf einen möglichen Fehler hinweist und dir genau zeigt, wo
das Problem liegt. Dann musst du nicht aufspüren, warum deine Daten nicht so
sind, wie du dachtest.</p>
<h3 id="hängende-referenzen"><a class="header" href="#hängende-referenzen">Hängende Referenzen</a></h3>
<p>In Sprachen mit Zeigern ist es leicht, fälschlicherweise einen <em>hängenden
Zeiger</em> (dangling pointer) zu erzeugen, also einen Zeiger, der auf eine Stelle
im Speicher verweist, die vielleicht an jemand anderem vergeben wurde, weil der
Speicher freigegeben wurde, während noch ein Zeiger auf diesen Speicher
bestehen bleibt. In Rust hingegen garantiert der Compiler, dass Referenzen
niemals hängende Referenzen sein können: Wenn du eine Referenz auf Daten hast,
stellt der Compiler sicher, dass die Daten nicht den Gültigkeitsbereich
verlassen, bevor die Referenz auf die Daten dies tut.</p>
<p>Versuchen wir, eine hängende Referenz zu erstellen, um zu sehen wie Rust das
mit einem Kompilierfehler verhindert:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;Hallo&quot;);

    &amp;s
}</code></pre></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Diese Fehlermeldung bezieht sich auf eine Funktionalität, die wir noch nicht
behandelt haben: Die Lebensdauer. Wir werden die Lebensdauer in Kapitel 10 im
Detail besprechen. Abgesehen von den Hinweisen zur Lebensdauer enthält die
Meldung den entscheidenden Hinweis, warum dieser Code nicht funktioniert:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>Lass uns einen genaueren Blick auf das werfen, was in jeder Phase unseres
<code>dangle</code>-Codes geschieht:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle gibt eine Referenz
                         // auf eine Zeichenkette zurück

    let s = String::from(&quot;Hallo&quot;); // s ist eine neue Zeichenkette

    &amp;s // wir geben einen Verweis auf die Zeichenkette s zurück
} // Hier verlässt s den Gültigkeitsbereich und wird verworfen.
  // Sein Speicherplatz wird aufgeräumt. Gefahr!</code></pre></pre>
<p>Da <code>s</code> innerhalb <code>dangle</code> erzeugt wird, wird <code>s</code> wieder freigegeben, wenn der
Code von <code>dangle</code> zu Ende ist. Aber wir haben versucht, eine Referenz darauf
zurückzugeben. Das heißt, diese Referenz würde auf einen ungültigen <code>String</code>
verweisen. Das ist nicht gut! Rust lässt uns das nicht tun.</p>
<p>Die Lösung ist, den <code>String</code> direkt zurückzugeben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;Hallo&quot;);

    s
}</code></pre></pre>
<p>Dies funktioniert ohne Probleme. Die Eigentümerschaft wird nach außen
verschoben, und nichts wird freigegeben.</p>
<h3 id="regeln-für-referenzen"><a class="header" href="#regeln-für-referenzen">Regeln für Referenzen</a></h3>
<p>Lass uns rekapitulieren, was wir über Referenzen gelernt haben:</p>
<ul>
<li>Zu jedem beliebigen Zeitpunkt kannst du <em>entweder</em> eine veränderbare
Referenz <em>oder</em> eine beliebige Anzahl unveränderbarer Referenzen haben.</li>
<li>Referenzen müssen immer gültig sein.</li>
</ul>
<p>Als Nächstes werden wir uns mit einer anderen Art von Referenz befassen:
Anteilstypen (slice).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="der-anteilstyp-slice"><a class="header" href="#der-anteilstyp-slice">Der Anteilstyp (slice)</a></h2>
<p>Mit <em>Anteilstypen</em> kannst du auf eine zusammenhängende Folge von Elementen in
einer Kollektion referenzieren anstatt auf die gesamte Kollektion. Ein
Anteilstyp ist eine Art Referenz und hat daher keine Eigentümerschaft.</p>
<p>Hier ist ein kleines Programmierproblem: Schreibe eine Funktion, die eine
Zeichenkette mit durch Leerzeichen getrennten Wörtern entgegennimmt und das
erste Wort zurückgibt, das sie in dieser Zeichenkette findet. Wenn die Funktion
kein Leerzeichen in der Zeichenkette findet, muss die gesamte Zeichenkette ein
Wort sein, also sollte die gesamte Zeichenkette zurückgegeben werden.</p>
<p>Gehen wir einmal durch, wie wir die Signatur dieser Funktion ohne Verwendung
von Anteilstypen schreiben würden, um das Problem zu verstehen, das durch
Anteilstypen gelöst wird:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p>Die Funktion <code>first_word</code> hat einen <code>&amp;String</code> als Parameter. Wir wollen keine
Eigentümerschaft, also ist das in Ordnung. Aber was sollen wir zurückgeben? Wir
haben nicht wirklich eine Möglichkeit, über <em>einen Teil</em> einer Zeichenkette zu
sprechen. Wir könnten jedoch den Index des Wortendes zurückgeben. Versuchen wir
das, wie in Codeblock 4-7 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 4-7: Die Funktion <code>first_word</code>, die einen
Byte-Indexwert zum Parameter <code>String</code> zurückgibt</span></p>
<p>Da wir den <code>String</code> Zeichen für Zeichen durchgehen und prüfen müssen, ob ein
Wert ein Leerzeichen ist, wandeln wir unseren <code>String</code> mit der Methode
<code>as_bytes</code> in ein Byte-Array um.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Als nächstes erstellen wir einen Iterator über das Byte-Array, indem wir die
Methode <code>iter</code> verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Auf Iteratoren werden wir in <a href="ch13-02-iterators.html">Kapitel 13</a> näher eingehen. Fürs Erste
solltest du wissen, dass <code>iter</code> eine Methode ist, die jedes Element in einer
Kollektion zurückgibt und dass <code>enumerate</code> das Ergebnis von <code>iter</code> umhüllt und
stattdessen jedes Element als Teil eines Tupels zurückgibt. Das erste Element
des Tupels, das von <code>enumerate</code> zurückgegeben wird, ist der Index, und das
zweite Element ist eine Referenz auf das Element. Das ist etwas bequemer, als
den Index selbst zu berechnen.</p>
<p>Da die Methode <code>enumerate</code> ein Tupel zurückgibt, können wir Muster verwenden,
um dieses Tupel zu zerlegen. Wir werden uns in <a href="ch06-02-match.html#muster-die-werte-binden">Kapitel 6</a> eingehender mit
Mustern befassen. In der <code>for</code>-Schleife spezifizieren wir also ein Muster, das
<code>i</code> für den Index im Tupel und <code>&amp;item</code> für das einzelne Byte im Tupel hat. Da
wir eine Referenz auf das Element aus <code>.iter().enumerate()</code> erhalten, verwenden
wir <code>&amp;</code> im Muster.</p>
<p>Innerhalb der <code>for</code>-Schleife suchen wir mit Hilfe der Byte-Literal-Syntax
<code>b' '</code> nach dem Byte, das das Leerzeichen repräsentiert. Wenn wir ein
Leerzeichen finden, geben wir die Position zurück. Andernfalls geben wir die
Länge der Zeichenkette zurück, indem wir <code>s.len()</code> verwenden.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Wir haben jetzt eine Möglichkeit, den Index des ersten Wortendes in der
Zeichenkette herauszufinden, aber es gibt ein Problem. Wir geben ein <code>usize</code>
für sich allein zurück, aber die Zahl ist nur aussagekräftig im Kontext des
<code>&amp;String</code>. Mit anderen Worten: Da es sich um einen vom <code>String</code> getrennten Wert
handelt, gibt es keine Garantie, dass er auch in Zukunft noch gültig ist.
Betrachte das Programm in Codeblock 4-8, das die Funktion <code>first_word</code> aus
Codeblock 4-7 verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;Hallo Welt&quot;);

    let word = first_word(&amp;s); // word erhält den Wert 5

    s.clear(); // leert die Zeichenkette und macht sie gleich &quot;&quot;

    // word hat noch immer den Wert 5, aber es gibt keine Zeichenkette mehr,
    // mit der wir den Wert 5 sinnvoll verwenden könnten.
    // word ist jetzt völlig ungültig!
}</code></pre></pre>
<p><span class="caption">Codeblock 4-8: Speichern des Ergebnisses des
Funktionsaufrufs <code>first_word</code> und anschließendes Ändern des Inhalts der
Zeichenkette</span></p>
<p>Dieses Programm kompiliert fehlerfrei und würde dies auch tun, wenn wir <code>word</code>
nach dem Aufruf von <code>s.clear()</code> benutzen würden. Da <code>word</code> überhaupt nicht mit
dem Zustand von <code>s</code> verbunden ist, enthält <code>word</code> immer noch den Wert <code>5</code>. Wir
könnten den Wert <code>5</code> mit der Variable <code>s</code> verwenden, um zu versuchen, das erste
Wort zu extrahieren, aber das wäre ein Fehler, weil sich der Inhalt von <code>s</code>
geändert hat, nachdem wir <code>5</code> in <code>word</code> gespeichert haben.</p>
<p>Sich darum kümmern zu müssen, dass der Index in <code>word</code> mit den Daten in <code>s</code>
konform ist, ist mühsam und fehleranfällig! Das Verwalten dieser Indizes ist
noch fehleranfälliger, wenn wir eine Funktion <code>second_word</code> schreiben. Ihre
Signatur müsste dann so aussehen:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>Jetzt verfolgen wir einen Anfangs- <em>und</em> einen Endindex, und wir haben noch
mehr Werte, die aus Daten in einem bestimmten Zustand berechnet wurden, aber
überhaupt nicht an diesen Zustand gebunden sind. Wir haben drei unverbundene
Variablen, die synchron gehalten werden müssen.</p>
<p>Glücklicherweise hat Rust eine Lösung für dieses Problem:
Zeichenkettenanteilstypen</p>
<h3 id="zeichenkettenanteilstypen-string-slices"><a class="header" href="#zeichenkettenanteilstypen-string-slices">Zeichenkettenanteilstypen (string slices)</a></h3>
<p>Ein <em>Zeichenkettenanteilstyp</em>  (string slice) ist ein Verweis auf einen Teil
eines <code>String</code>, und er sieht so aus:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo Welt&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..10];
<span class="boring">}</span></code></pre></pre>
<p>Anstelle einer Referenz auf den gesamten <code>String</code> ist <code>hello</code> eine Referenz auf
einen Teil des <code>String</code>, der mit dem zusätzlichen <code>[0..5]</code> spezifiziert ist.
Wir erstellen Anteilstypen unter Angabe eines Bereichs innerhalb von Klammern,
indem wir <code>[starting_index..ending_index]</code> angeben, wobei <code>starting_index</code> die
erste Position im Anteilstyp und <code>ending_index</code> eine Position mehr als die
letzte Position im Anteilstyp ist. Intern speichert die
Anteilstyp-Datenstruktur die Anfangsposition und die Länge des Anteilstypen,
was <code>ending_index</code> minus <code>starting_index</code> entspricht. Im Fall von <code>let world = &amp;s[6..10];</code> wäre <code>world</code> also ein Anteilstyp, der einen Zeiger auf das Byte bei
Index 6 von <code>s</code> mit dem Längenwert <code>4</code> enthält.</p>
<p>Abbildung 4-6 stellt dies dar.</p>
<p><img alt="Drei Tabellen: Eine Tabelle, die die Stapelspeicher-Daten von s
darstellt, die auf das Byte bei Index 0 in einer Tabelle der
Zeichenketten-Daten &quot;Hallo Welt&quot; auf dem Haldenspeicher zeigt. Die
dritte Tabelle repräsentiert die Stapelspeicher-Daten des Anteilstypen Welt,
der den Längenwert 4 hat und auf Byte 6 der Haldenspeicher-Datentabelle zeigt."
src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-6: Zeichenkettenanteilstyp, der sich auf einen
Teil eines <code>String</code> bezieht</span></p>
<p>Wenn du mit der Bereichssyntax <code>..</code> in Rust beim Index 0 beginnen willst,
kannst du den Wert vor den zwei Punkte weglassen. Mit anderen Worten sind diese
gleich:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre></pre>
<p>Ebenso kannst du den Endindex weglassen, wenn dein Anteilstyp das letzte Byte
des <code>String</code> enthält. Das bedeutet, dass diese gleich sind:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>Du kannst auch beide Werte weglassen, um einen Ausschnitt der gesamten
Zeichenkette zu beschreiben. Diese sind also gleichwertig:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Hinweis: Bereichsindizes bei Zeichenkettenanteilstypen müssen sich nach
gültigen UTF-8-Zeichengrenzen richten. Wenn du versuchst, einen
Zeichenkettenanteilstyp in der Mitte eines Mehrbyte-Zeichens zu erstellen,
wird dein Programm mit einem Fehler abbrechen. Bei der Einführung von
Zeichenkettenanteilstypen in diesem Abschnitt gehen wir nur von ASCII aus;
eine eingehendere Diskussion der UTF-8-Behandlung findet sich im Abschnitt
<a href="ch08-02-strings.html">„UTF-8-kodierten Text in Zeichenketten (strings) ablegen“</a> in
Kapitel 8.</p>
</blockquote>
<p>Mit all diesen Informationen im Hinterkopf schreiben wir <code>first_word</code> so um,
dass es einen Anteilstyp zurückgibt. Der Typ mit der Bedeutung
„Zeichenkettenanteilstyp“ wird <code>&amp;str</code> geschrieben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">}</span></code></pre></pre>
<p>Den Index für das Wortende erhalten wir auf die gleiche Weise wie in Codeblock
4-7, indem wir nach dem ersten Vorkommen eines Leerzeichens suchen. Wenn wir
ein Leerzeichen finden, geben wir einen Zeichenkettenanteilstyp zurück, wobei
wir den Anfang der Zeichenkette und den Index des Leerzeichens als Anfangs-
bzw. Endindex verwenden.</p>
<p>Wenn wir nun <code>first_word</code> aufrufen, erhalten wir einen einzelnen Wert zurück,
der an die zugrundeliegenden Daten gebunden ist. Der Wert setzt sich aus einer
Referenz auf den Startpunkt des Anteilstyps und der Anzahl der Elemente im
Anteilstyp zusammen.</p>
<p>Die Rückgabe eines Anteilstyps würde auch für eine Funktion <code>second_word</code>
funktionieren:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Wir haben jetzt eine einfache API, die viel schwieriger durcheinanderzubringen
ist, weil der Compiler sicherstellt, dass die Referenzen auf den <code>String</code>
gültig bleiben. Erinnere dich an den Fehler im Programm in Codeblock 4-8, als
wir den Index bis zum Ende des ersten Wortes erhielten, dann aber die
Zeichenkette löschten, sodass unser Index ungültig wurde. Dieser Code war
logisch falsch, zeigte aber keine unmittelbaren Fehler. Die Probleme würden
sich später zeigen, wenn wir weiterhin versuchen würden, den ersten Wortindex
mit einer leeren Zeichenkette zu verwenden. Anteilstypen machen diesen Fehler
unmöglich und lassen uns viel früher wissen, dass wir ein Problem mit unserem
Code haben. Die Anteilstypen-Variante von <code>first_word</code> führt zu einem
Kompilierfehler:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;Hallo Welt&quot;);

    let word = first_word(&amp;s);

    s.clear(); // Fehler!

    println!(&quot;Das erste Wort ist: {}&quot;, word);
}</code></pre></pre>
<p>Hier ist der Kompilierfehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // Fehler!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;Das erste Wort ist: {}&quot;, word);
   |                                        ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Erinnere dich an die Ausleihregeln, durch die wir, wenn wir eine
unveränderbare Referenz auf etwas haben, nicht noch eine veränderbare
Referenz anlegen können. Da <code>clear</code> den <code>String</code> abschneiden muss, muss es
eine veränderbare Referenz erhalten. Das <code>println!</code> nach dem Aufruf von
<code>clear</code> verwendet die Referenz in <code>word</code>, sodass die unveränderbare Referenz
zu diesem Zeitpunkt noch aktiv sein muss. Rust verbietet, dass die
veränderbare Referenz in <code>clear</code> und die unveränderbare Referenz in <code>word</code>
nicht gleichzeitig existieren, und die Kompilierung schlägt fehl. Rust hat
nicht nur die Benutzung unserer API vereinfacht, sondern auch eine ganze Klasse
von Fehlern zur Kompilierzeit beseitigt!</p>
<h4 id="zeichenkettenliterale-als-anteilstypen"><a class="header" href="#zeichenkettenliterale-als-anteilstypen">Zeichenkettenliterale als Anteilstypen</a></h4>
<p>Erinnere dich, dass wir darüber sprachen, dass Zeichenkettenliterale in der
Binärdatei gespeichert werden. Jetzt, da wir über Anteilstypen Bescheid wissen,
können wir Zeichenkettenliterale richtig verstehen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hallo Welt!&quot;;
<span class="boring">}</span></code></pre></pre>
<p>Der Typ von <code>s</code> hier ist <code>&amp;str</code>: Es ist ein Anteilstyp, der auf diesen
speziellen Punkt der Binärdatei zeigt. Das ist auch der Grund, warum
Zeichenkettenliterale unveränderbar sind; <code>&amp;str</code> ist eine unveränderbare
Referenz.</p>
<h4 id="zeichenkettenanteilstypen-als-parameter"><a class="header" href="#zeichenkettenanteilstypen-als-parameter">Zeichenkettenanteilstypen als Parameter</a></h4>
<p>Das Wissen, dass man Anteilstypen von Literalen und <code>String</code>-Werten erstellen
kann, führt uns zu einer weiteren Verbesserung von <code>first_word</code>, und das ist
ihre Signatur:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Ein erfahrenerer Rust-Entwickler würde stattdessen die in Codeblock 4-9
gezeigte Signatur schreiben, da sie es uns erlaubt, dieselbe Funktion sowohl
auf <code>&amp;String</code>-Werte als auch auf <code>&amp;str</code>-Werte anzuwenden.</p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;Hallo Welt&quot;);
</span><span class="boring">
</span><span class="boring">    // `first_word` funktioniert mit Anteilstypen von `String`, ob teilweise oder ganz
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` funktioniert auch bei Referenzen auf `String`, die
</span><span class="boring">    // äquivalent zu ganzen Anteilstypen von `String` sind
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;Hallo Welt&quot;;
</span><span class="boring">
</span><span class="boring">    // `first_word` funktioniert mit Anteilstypen von Zeichenkettenliteralen, ob teilweise oder ganz
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
</span><span class="boring">    // funktioniert dies auch ohne die Anteilstypensyntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 4-9: Verbessern der Funktion <code>first_word</code> durch
Verwenden eines Zeichenkettenanteilstyps für den Typ des Parameters <code>s</code></span></p>
<p>Wenn wir einen Zeichenkettenanteilstyp haben, können wir diesen direkt
übergeben. Wenn wir einen <code>String</code> haben, können wir einen Anteilstyp des
<code>String</code> oder eine Referenz auf den <code>String</code> übergeben. Diese Flexibilität
nutzt die Vorteile der <em>automatischen Umwandlung</em>, eine Funktionalität, die wir
im Abschnitt <a href="ch15-02-deref.html#implizite-automatische-umwandlung-mit-funktionen-und-methoden">„Implizite automatische Umwandlung mit Funktionen und
Methoden“</a> in Kapitel 15 behandeln.</p>
<p>Das Definieren einer Funktion, die einen Zeichenkettenanteilstyp statt einer
Referenz auf einen <code>String</code> entgegennimmt, macht unsere API allgemeiner und
nützlicher, ohne an Funktionalität einzubüßen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;Hallo Welt&quot;);

    // `first_word` funktioniert mit Anteilstypen von `String`, ob teilweise oder ganz
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` funktioniert auch bei Referenzen auf `String`, die
    // äquivalent zu ganzen Anteilstypen von `String` sind
    let word = first_word(&amp;my_string);

    let my_string_literal = &quot;Hallo Welt&quot;;

    // `first_word` funktioniert mit Anteilstypen von Zeichenkettenliteralen, ob teilweise oder ganz
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
    // funktioniert dies auch ohne die Anteilstypensyntax!
    let word = first_word(my_string_literal);
}</code></pre></pre>
<h3 id="andere-anteilstypen"><a class="header" href="#andere-anteilstypen">Andere Anteilstypen</a></h3>
<p>Zeichenkettenanteilstypen sind, wie du dir vorstellen kannst, spezifisch für
Zeichenketten. Es gibt aber auch einen allgemeineren Anteilstyp. Betrachte
dieses Array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Genauso wie wir vielleicht auf einen Teil einer Zeichenkette verweisen möchten,
möchten wir vielleicht auf einen Teil eines Arrays verweisen. Wir würden das so
machen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>Dieser Anteilstyp hat den Typ <code>&amp;[i32]</code>. Es funktioniert auf die gleiche Weise
wie bei Zeichenkettenanteilstypen, indem es eine Referenz auf das erste Element
und eine Länge speichert. Du wirst diese Art von Anteilstyp für alle möglichen
anderen Kollektionen verwenden. Wir werden diese Kollektionen im Detail
besprechen, wenn wir in Kapitel 8 über Vektoren sprechen.</p>
<h2 id="zusammenfassung-3"><a class="header" href="#zusammenfassung-3">Zusammenfassung</a></h2>
<p>Die Konzepte von Eigentümerschaft, Ausleihen und Anteilstypen gewährleisten
Speichersicherheit zur Kompilierzeit in Rust-Programmen. Die Sprache Rust gibt
dir Kontrolle über die Speicherverwendung auf die gleiche Weise wie andere
Systemprogrammiersprachen, aber dadurch, dass der Eigentümer der Daten diese
automatisch aufräumt, wenn der Eigentümer den Gültigkeitsbereich verlässt,
bedeutet dies, dass du keinen zusätzlichen Code schreiben und debuggen musst,
um diese Kontrolle zu erhalten.</p>
<p>Die Eigentümerschaft wirkt sich auf die Funktionsweise vieler anderer Teile von
Rust aus, deshalb werden wir im weiteren Verlauf des Buchs weiter über diese
Konzepte sprechen. Lass uns zu Kapitel 5 übergehen und uns das Gruppieren von
Datenteilen zu einer <code>struct</code> ansehen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strukturen-structs-für-zusammenhängende-daten-verwenden"><a class="header" href="#strukturen-structs-für-zusammenhängende-daten-verwenden">Strukturen (structs) für zusammenhängende Daten verwenden</a></h1>
<p>Eine <em>Struktur</em> (struct) ist ein benutzerdefinierter Datentyp, mit dem man
mehrere zusammenhängende Werte, die eine sinnvolle Gruppe bilden,
zusammenpacken und benennen kann. Wenn du mit einer objektorientierten Sprache
vertraut bist, ist eine <em>Struktur</em> analog zu den Datenattributen eines Objekts.
In diesem Kapitel werden wir Tupel mit Strukturen vergleichen und
gegenüberstellen, um auf den bereits vorhandenen Kenntnissen aufzubauen und zu
zeigen, wann Strukturen eine bessere Möglichkeit zur Gruppierung von Daten
sind.</p>
<p>Wir werden zeigen, wie man Strukturen definiert und instanziiert. Wir werden
besprechen, wie man assoziierte Funktionen definiert, insbesondere die Art
assoziierter Funktionen, die <em>Methoden</em> genannt werden, um das Verhalten eines
Strukturtyps zu spezifizieren. Strukturen und Aufzählungen (enums) (siehe
Kapitel 6) sind die Bausteine zum Erstellen neuer Typen in der Domäne deines
Programms, mit denen du die Vorteile der Kompilierzeit-Typprüfung von Rust voll
ausschöpfen kannst.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="strukturen-structs-definieren-und-instanziieren"><a class="header" href="#strukturen-structs-definieren-und-instanziieren">Strukturen (structs) definieren und instanziieren</a></h2>
<p>Strukturen (structs) ähneln Tupeln, die im Abschnitt <a href="ch03-02-data-types.html#der-tupel-typ">„Der Tupel-Typ“</a>
besprochen wurden. Wie bei Tupeln können die Teile einer Struktur verschiedene
Typen haben. Anders als bei Tupeln benennst du jedes Teil, so dass klar ist, was
die Werte bedeuten. Durch diese Namen sind Strukturen flexibler als Tupel: Du
musst dich nicht auf die Reihenfolge der Daten verlassen, um die Werte einer
Instanz zu spezifizieren oder auf sie zuzugreifen.</p>
<p>Um eine Struktur zu definieren, geben wir das Schlüsselwort <code>struct</code> an und
benennen die gesamte Struktur. Der Name einer Struktur sollte die Bedeutung der
Daten beschreiben, die gruppiert werden. Dann definieren wir innerhalb
geschweifter Klammern die Namen und Typen der Datenteile, die wir <em>Felder</em>
nennen. Beispielsweise zeigt Codeblock 5-1 eine Struktur, die Informationen
über ein Benutzerkonto speichert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 5-1: Definition der Struktur <code>User</code></span></p>
<p>Um eine Struktur zu verwenden, nachdem wir sie definiert haben, erstellen wir
eine <em>Instanz</em> dieser Struktur, indem wir für jedes Feld einen konkreten Wert
angeben. Wir erzeugen eine Instanz, indem wir den Namen der Struktur angeben
und dann in geschweiften Klammern die <em>Schlüssel: Wert</em>-Paare angeben, wobei
die Schlüssel die Namen der Felder und die Werte die Daten sind, die wir in
diesen Feldern speichern wollen. Wir müssen die Felder nicht in der gleichen
Reihenfolge angeben, in der wir sie in der Struktur deklariert haben. Anders
gesagt ist die Strukturdefinition wie eine allgemeine Typvorlage und Instanzen
füllen diese Vorlage mit bestimmten Daten aus, um Werte des Typs zu erzeugen.
Beispielsweise können wir einen bestimmten Benutzer deklarieren, wie in
Codeblock 5-2 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        email: String::from(&quot;jemand@example.com&quot;),
        username: String::from(&quot;benutzername123&quot;),
        active: true,
        sign_in_count: 1,
    };
}</code></pre></pre>
<p><span class="caption">Codeblock 5-2: Eine Instanz der Struktur <code>User</code>
erzeugen</span></p>
<p>Um auf einen bestimmten Wert in einer Struktur zuzugreifen, verwenden wir die
Punktnotation. Um beispielsweise auf die E-Mail-Adresse dieses Benutzers
zuzugreifen, verwenden wir <code>user1.email</code>. Wenn die Instanz veränderbar ist,
können wir einen Wert ändern, indem wir die Punktnotation verwenden und ihn
einem bestimmten Feld zuweisen. Codeblock 5-3 gezeigt, wie der Wert im Feld
<code>email</code> einer veränderbaren <code>User</code>-Instanz geändert werden kann.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        email: String::from(&quot;jemand@example.com&quot;),
        username: String::from(&quot;benutzername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;andere-email@example.com&quot;);
}</code></pre></pre>
<p><span class="caption">Codeblock 5-3: Wert im Feld <code>email</code> einer <code>User</code>-Instanz ändern</span></p>
<p>Beachte, dass die gesamte Instanz veränderbar sein muss. Rust erlaubt es
nicht, nur einzelne Felder als veränderbar zu markieren. Wie mit jedem
Ausdruck können wir eine neue Instanz der Struktur als letzten Ausdruck im
Funktionsrumpf erzeugen, um diese neue Instanz implizit zurückzugeben.</p>
<p>Codeblock 5-4 zeigt eine Funktion <code>build_user</code>, die eine <code>User</code>-Instanz mit der
angegebenen E-Mail und dem Benutzernamen zurückgibt. Das Feld <code>active</code> erhält
den Wert <code>true</code> und das Feld <code>sign_in_count</code> den Wert <code>1</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        String::from(&quot;benutzername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 5-4: Funktion <code>build_user</code>, die eine E-Mail und
einen Benutzernamen entgegennimmt und eine <code>User</code>-Instanz zurückgibt</span></p>
<p>Es ist sinnvoll, den Funktionsparametern dieselben Namen wie die der
Strukturfelder zu geben, jedoch ist das Wiederholen der Feldnamen <code>email</code> und
<code>username</code> etwas mühsam. Wenn die Struktur mehr Felder hätte, würde das
Wiederholen jedes Namens noch lästiger werden. Glücklicherweise gibt es eine
praktische Kurznotation!</p>
<h3 id="kurznotation-der-feld-initialisierung-verwenden"><a class="header" href="#kurznotation-der-feld-initialisierung-verwenden">Kurznotation der Feld-Initialisierung verwenden</a></h3>
<p>Da die Parameter und die Strukturfelder in Codeblock 5-4 die gleichen Namen
haben, können wir die <em>Kurznotation der Feld-Initialisierung</em> (field init
shorthand syntax) verwenden, um die Funktion <code>build_user</code> so umzuschreiben,
dass sie sich unverändert gleich verhält, ohne <code>email</code> und <code>username</code> zu
wiederholen, siehe Codeblock 5-5.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        String::from(&quot;benutzername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 5-5: Funktion <code>build_user</code> mit Kurznotation der
Feld-Initialisierung, weil die Parameternamen <code>email</code> und <code>username</code> identisch
mit den Strukturfeldern sind</span></p>
<p>Hier erzeugen wir eine neue Instanz der Struktur <code>User</code>, die ein Feld namens
<code>email</code> hat. Wir wollen den Wert des Feldes <code>email</code> auf den Wert des Parameters
<code>email</code> der Funktion <code>build_user</code> setzen. Da das Feld <code>email</code> und der Parameter
<code>email</code> den gleichen Namen haben, brauchen wir nur <code>email</code> statt <code>email: email</code>
zu schreiben.</p>
<h3 id="instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax"><a class="header" href="#instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax">Instanzen aus anderen Instanzen erzeugen mit der Strukturaktualisierungssyntax</a></h3>
<p>Oft ist es hilfreich, eine neue Instanz einer Struktur zu erstellen, die die
meisten Werte einer alten Instanz verwendet und nur einige davon verändert. Du
kannst dazu die <em>Strukturaktualisierungssyntax</em> (struct update syntax)
verwenden.</p>
<p>Zunächst zeigt Codeblock 5-6, wie wir eine neue <code>User</code>-Instanz <code>user2</code> ohne
Aktualisierungssyntax erstellen. Wir setzen einen neuen Wert für <code>email</code>,
verwenden aber ansonsten die gleichen Werte von <code>user1</code>, die wir in Codeblock
5-2 erstellt haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --abschneiden--
<span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;benutzername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;andere@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
<p><span class="caption">Codeblock 5-6: Erstellen einer neuen <code>User</code>-Instanz unter
Verwendung eines Werts von <code>user1</code>.</span></p>
<p>Durch Verwenden der Strukturaktualisierungssyntax können wir dasselbe Ergebnis
mit weniger Code erreichen, wie Codeblock 5-7 zeigt. Die Syntax <code>..</code> gibt an,
dass die restlichen Felder, die nicht explizit gesetzt wurden, den gleichen
Wert haben sollen wie die Felder in der gegebenen Instanz.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --abschneiden--
<span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;benutzername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from(&quot;andere@example.com&quot;),
        ..user1
    };
}</code></pre></pre>
<p><span class="caption">Codeblock 5-7: Verwenden der
Strukturaktualisierungssyntax, um einen neuen Wert für <code>email</code> in der
<code>User</code>-Instanz zu setzen und die restlichen Werte aus der Instanz <code>user1</code> zu
übernehmen</span></p>
<p>Der Code in Codeblock 5-7 erzeugt auch eine Instanz <code>user2</code>, die einen anderen
Wert für <code>email</code> hat, aber die gleichen Werte der Felder <code>username</code>, <code>active</code>
und <code>sign_in_count</code> wie <code>user1</code>. Das <code>..user1</code> muss an letzter Stelle stehen um
festzulegen, dass alle verbleibenden Felder ihre Werte von den entsprechenden
Feldern in <code>user1</code> beziehen sollen, aber wir können Werte für so viele Felder
in beliebiger Reihenfolge angeben, unabhängig von der Reihenfolge der Felder in
der Strukturdefinition.</p>
<p>Beachte, dass die Strukturaktualisierungssyntax wie eine Zuweisung mit <code>=</code> ist,
da sie die Daten verschiebt, wie wir im Abschnitt <a href="ch04-01-what-is-ownership.html#variablen-und-daten-im-zusammenspiel-mit-move">„Variablen und Daten im
Zusammenspiel mit Move“</a> gesehen haben. In diesem Beispiel können wir
<code>user1</code> nicht mehr als Ganzes verwenden, nachdem wir <code>user2</code> erzeugt haben,
weil der <code>String</code> im Feld <code>username</code> von <code>user1</code> in <code>user2</code> verschoben wurde.
Hätten wir <code>user2</code> neue <code>String</code>-Werte für beide Felder <code>email</code> und <code>username</code>
gegeben und somit nur die Werte <code>active</code> und <code>sign_in_count</code> von <code>user1</code>
verwendet, wäre <code>user1</code> auch nach dem Erstellen von <code>user2</code> noch gültig. Die
Typen <code>active</code> und <code>sign_in_count</code> sind Typen, die das Merkmal <code>Copy</code>
implementieren, sodass das Verhalten, das wir im Abschnitt <a href="ch04-01-what-is-ownership.html#nur-stapelspeicher-daten-kopieren-copy">„Nur
Stapelspeicher-Daten: Kopieren (copy)“</a> besprochen haben, zutreffen
würde.</p>
<h3 id="verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen"><a class="header" href="#verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen">Verwenden von Tupel-Strukturen ohne benannte Felder um verschiedene Typen zu erzeugen</a></h3>
<p>Du kannst auch Strukturen definieren, die wie Tupel aussehen, sogenannte
<em>Tupel-Strukturen</em> (tuple structs). Tupel-Strukturen sind Strukturen, die
keine Feldnamen haben, sondern nur die Typen der Felder. Tupel-Strukturen sind
hilfreich, wenn du dem gesamten Tupel einen Namen geben und erreichen willst,
dass das Tupel einen anderen Typ als die anderen Tupel hat und Feldnamen wie in
einer regulären Struktur langatmig oder unnötig wären.</p>
<p>Um eine Tupel-Struktur zu definieren, starte mit dem Schlüsselwort <code>struct</code>,
gefolgt vom Strukturnamen und den Typen im Tupel. Nachfolgend ein Beispiel mit
Definition und Verwendung zweier Tupel-Strukturen <code>Color</code> und <code>Point</code>:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
<p>Beachte, dass die Werte <code>black</code> und <code>origin</code> unterschiedliche Typen haben, weil
sie Instanzen unterschiedlicher Tupel-Strukturen sind. Jede von dir definierte
Struktur ist ein eigenständiger Typ, auch wenn die Felder innerhalb der
Struktur die gleichen Typen haben könnten. Zum Beispiel kann eine Funktion, die
einen Parameter vom Typ <code>Color</code> hat, keinen <code>Point</code> als Argument nehmen, obwohl
beide Typen aus drei <code>i32</code>-Werten bestehen. Ansonsten ähneln
Tupel-Struktur-Instanzen den Tupeln insofern, als dass sie in ihre einzelnen
Teile zerlegt werden können, und du kannst ein <code>.</code> gefolgt vom Index verwenden,
um auf einen einzelnen Wert zuzugreifen.</p>
<h3 id="einheitstyp-ähnliche-strukturen-ohne-felder"><a class="header" href="#einheitstyp-ähnliche-strukturen-ohne-felder">Einheitstyp-ähnliche Strukturen ohne Felder</a></h3>
<p>Du kannst auch Strukturen definieren, die gar keine Felder haben! Diese werden
<em>Einheitstyp</em> (unit-like structs) genannt, weil sie sich ähnlich zum leeren
Tupel <code>()</code> verhalten, das wir im Abschnitt <a href="ch03-02-data-types.html#der-tupel-typ">„Der Tupel-Typ“</a> erwähnt
haben. Einheitstypen können in Situationen nützlich sein, in denen du ein
Merkmal (trait) zu einem Typ implementieren musst, du aber keine Daten hast,
die im Typ gespeichert werden sollen. Wir werden Merkmale in Kapitel 10
besprechen. Hier ist ein Beispiel für die Deklaration und Instanziierung einer
Unit-Struktur namens <code>AlwaysEqual</code>:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
<p>Um <code>AlwaysEqual</code> zu definieren, verwenden wir das Schlüsselwort <code>struct</code>, den
gewünschten Namen und dann ein Semikolon. Geschweifte Klammern und Klammern
sind nicht erforderlich! Dann können wir eine Instanz von <code>AlwaysEqual</code> in der
Variable <code>subject</code> auf ähnliche Weise erhalten: Mit dem Namen, den wir
definiert haben, ohne geschweifte Klammern oder Klammern. Stell dir vor, wir
implementieren ein Verhalten für diesen Typ, bei dem jede Instanz immer gleich
ist mit jeder Instanz jedes anderen Typs, vielleicht um ein bekanntes Ergebnis
für Testzwecke zu haben. Wir bräuchten keine Daten, um dieses Verhalten
umzusetzen! In Kapitel 10 wirst du sehen, wie man Merkmale definiert und sie
für jeden Typ implementiert, auch für unit-ähnliche Strukturen.</p>
<blockquote>
<h3 id="eigentümerschaft-von-strukturdaten"><a class="header" href="#eigentümerschaft-von-strukturdaten">Eigentümerschaft von Strukturdaten</a></h3>
<p>In der Strukturdefinition <code>User</code> in Codeblock 5-1 haben wir den Typ <code>String</code>
anstelle von <code>&amp;str</code> verwendet. Dies ist eine bewusste Entscheidung, denn wir
wollen, dass Instanzen dieser Struktur all ihre Daten besitzen und diese
Daten so lange gültig sind, wie die gesamte Struktur gültig ist.</p>
<p>Bei Strukturen ist es möglich, Referenzen auf Daten zu speichern, die im
Besitz von etwas anderem sind, aber das erfordert die Verwendung von
<em>Lebensdauern</em>, einer Rust-Funktionalität, die wir in Kapitel 10 besprechen
werden. Die Lebensdauer stellt sicher, dass die von einer Struktur
referenzierten Daten so lange gültig sind, wie die Struktur gültig ist.
Angenommen, du versuchst eine Referenz in einer Struktur zu speichern, ohne
eine Lebensdauer anzugeben, wird das nicht funktionieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: &quot;benutzername123&quot;,
        email: &quot;jemand@example.com&quot;,
        sign_in_count: 1,
    };
}</code></pre></pre>
<p>Der Compiler wird sich beschweren, dass die Lebensdauer nicht angegeben ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling playground v0.0.1 (/playground)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct User&lt;'a&gt; {
2 |     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct User&lt;'a&gt; {
2 |     username: &amp;str,
3 |     email: &amp;'a str,
  |

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0106`.
error: could not compile `playground`

To learn more, run the command again with --verbose.
</code></pre>
<p>In Kapitel 10 werden wir klären, wie man diese Fehler behebt und Referenzen
in Strukturen speichern kann. Aber für den Moment werden wir Fehler wie diese
vermeiden, indem wir Typen wie <code>String</code> anstelle von Referenzen wie <code>&amp;str</code>
verwenden.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="beispielprogramm-mit-strukturen-structs"><a class="header" href="#beispielprogramm-mit-strukturen-structs">Beispielprogramm mit Strukturen (structs)</a></h2>
<p>Um besser zu verstehen, wann wir Strukturen verwenden können, schreiben wir ein
Programm, das die Fläche eines Rechtecks berechnet. Wir beginnen mit einzelnen
Variablen und schreiben das Programm dann um, bis wir stattdessen Strukturen
einsetzen.</p>
<p>Legen wir mit Cargo ein neues Binärprojekt namens <em>rectangles</em> an, das die
Breite und Höhe eines in Pixeln angegebenen Rechtecks nimmt und die Fläche des
Rechtecks berechnet.</p>
<p>Codeblock 5-8 zeigt ein kurzes Programm, das genau das in <em>src/main.rs</em> unseres
Projekts macht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
<p><span class="caption">Codeblock 5-8: Berechnen der Fläche eines Rechtecks, das
durch separate Breiten- und Höhenvariablen beschrieben wird</span></p>
<p>Nun führe dieses Programm mit <code>cargo run</code> aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/structs`
Die Fläche des Rechtecks ist 1500 Quadratpixel.
</code></pre>
<p>Mit diesem Code gelingt es, die Fläche des Rechtecks zu ermitteln, indem die
Funktion <code>area</code> mit jeder Dimension aufgerufen wird. Aber wir können noch mehr
tun, um diesen Code klar und lesbar zu machen.</p>
<p>Das Problem dieses Codes wird bei der Signatur von <code>area</code> deutlich:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre></pre>
<p>Die Funktion <code>area</code> soll die Fläche eines Rechtecks berechnen, aber die von uns
geschriebene Funktion hat zwei Parameter und es geht in unserem Programm
nirgendwo klar hervor, dass die Parameter zusammenhängen. Es wäre besser lesbar
und überschaubarer, Breite und Höhe zusammenzufassen. Eine Möglichkeit dazu
haben wir bereits im Abschnitt <a href="ch03-02-data-types.html#der-tupel-typ">„Der Tupel-Typ“</a> in Kapitel 3
vorgestellt: Der Einsatz von Tupeln.</p>
<h3 id="refaktorierung-mit-tupeln"><a class="header" href="#refaktorierung-mit-tupeln">Refaktorierung mit Tupeln</a></h3>
<p>Codeblock 5-9 zeigt eine weitere Version unseres Programms, die Tupel
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre></pre>
<p><span class="caption">Codeblock 5-9: Breite und Höhe des Rechtecks werden mit
einem Tupel beschrieben</span></p>
<p>In einem Punkt ist dieses Programm besser. Das Tupel bringt etwas Struktur
hinein und wir geben jetzt nur noch ein Argument weiter. Andererseits ist
dieser Ansatz weniger deutlich: Tupel benennen ihre Elemente nicht, sodass wir
die Teile des Tupels indizieren müssen, was unsere Berechnung weniger klar
macht.</p>
<p>Die Verwechslung von Breite und Höhe ist für die Flächenberechnung nicht von
Bedeutung, aber wenn wir das Rechteck auf dem Bildschirm zeichnen wollen, wäre
es wichtig! Wir müssen uns merken, dass <code>width</code> der Tupelindex <code>0</code> und <code>height</code>
der Tupelindex <code>1</code> ist. Für andere wäre es noch schwieriger, dies
herauszufinden und im Kopf zu behalten, wenn sie unseren Code verwenden würden.
Da wir die Bedeutung unserer Daten nicht in unseren Code übertragen haben, ist
es jetzt einfacher, Fehler zu machen.</p>
<h3 id="refaktorierung-mit-strukturen-mehr-semantik"><a class="header" href="#refaktorierung-mit-strukturen-mehr-semantik">Refaktorierung mit Strukturen: Mehr Semantik</a></h3>
<p>Verwenden wir Strukturen, um durch die Benennung der Daten deren Bedeutung
anzugeben. Wir können das verwendete Tupel in eine Struktur mit einem Namen
für das Ganze sowie mit Namen für die Einzelteile umwandeln, wie in Codeblock
5-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
<p><span class="caption">Codeblock 5-10: Definieren der Struktur <code>Rectangle</code></span></p>
<p>Hier haben wir eine Struktur definiert und sie <code>Rectangle</code> genannt. Innerhalb
der geschweiften Klammern haben wir die Felder <code>width</code> und <code>height</code> definiert,
die beide den Typ <code>u32</code> haben. Dann erzeugten wir in <code>main</code> eine Instanz von
<code>Rectangle</code> mit der Breite <code>30</code> und Höhe <code>50</code>.</p>
<p>Unsere Funktion <code>area</code> hat nun einen Parameter, den wir <code>rectangle</code> genannt
haben und dessen Typ eine unveränderbare Ausleihe (immutable borrow) einer
Strukturinstanz <code>Rectangle</code> ist. Wie in Kapitel 4 erwähnt, wollen wir die
Struktur nur ausleihen, nicht aber deren Eigentümerschaft (ownership)
übernehmen. Auf diese Weise behält <code>main</code> seine Eigentümerschaft und kann
weiterhin <code>rect1</code> verwenden, weshalb wir <code>&amp;</code> in der Funktionssignatur und an
der Aufrufstelle verwenden.</p>
<p>Die Funktion <code>area</code> greift auf die Felder <code>width</code> und <code>height</code> der Instanz
<code>Rectangle</code> zu. (Beachte, dass der Zugriff auf Felder einer ausgeliehenen
Struktur-Instanz die Feldwerte nicht verschiebt, weshalb du häufig Ausleihen
von Strukturen siehst.) Unsere Funktionssignatur für <code>area</code> sagt jetzt genau,
was wir meinen: Berechne die Fläche von <code>Rectangle</code> unter Verwendung seiner
Felder <code>width</code> und <code>height</code>. Dies drückt aus, dass Breite und Höhe in Beziehung
zueinander stehen, und gibt den Werten beschreibende Namen, ohne die
Tupelindexwerte <code>0</code> und <code>1</code> zu verwenden. Das erhöht die Lesbarkeit.</p>
<h3 id="hilfreiche-funktionalität-mit-abgeleiteten-merkmalen-derived-traits"><a class="header" href="#hilfreiche-funktionalität-mit-abgeleiteten-merkmalen-derived-traits">Hilfreiche Funktionalität mit abgeleiteten Merkmalen (derived traits)</a></h3>
<p>Es wäre hilfreich, eine Instanz von <code>Rectangle</code> samt der Werte seiner Felder
ausgeben zu können, während wir unser Programm debuggen. In Codeblock 5-11
versuchen wir, das <a href="https://doc.rust-lang.org/std/macro.println.html">Makro <code>println!</code></a> zu verwenden, das wir in den
vorangegangenen Kapiteln verwendet haben. Dies wird jedoch nicht funktionieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 ist {}&quot;, rect1);
}</code></pre></pre>
<p><span class="caption">Codeblock 5-11: Versuch, eine <code>Rectangle</code>-Instanz
auszugeben</span></p>
<p>Wenn wir diesen Code kompilieren, erhalten wir folgende Fehlermeldung:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>Das Makro <code>println!</code> kann diverse Formatierungen vornehmen. Die geschweiften
Klammern weisen <code>println!</code> an, die Formatierung <code>Display</code> zu verwenden, bei der
die Ausgabe direkt für den Endbenutzer bestimmt ist. Die primitiven Typen, die
wir bisher gesehen haben, implementieren <code>Display</code> standardmäßig, denn es gibt
nur eine Möglichkeit, dem Benutzer eine <code>1</code> oder einen anderen primitiven Typ
zu zeigen. Aber bei Strukturen ist die Formatierung, die <code>println!</code> verwenden
soll, weniger klar, da es mehrere Darstellungsmöglichkeiten gibt: Möchtest du
Kommas oder nicht? Möchtest du die geschweiften Klammern ausgeben? Sollen alle
Felder angezeigt werden? Aufgrund der vielen Möglichkeiten versucht Rust nicht
zu erraten, was wir wollen. Strukturen haben daher keine
Standardimplementierung von <code>Display</code>, um die mit <code>println!</code> und dem
Platzhalter <code>{}</code> verwenden zu können.</p>
<p>Wenn wir die Fehlerausgabe weiterlesen, werden wir diesen hilfreichen Hinweis
finden:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Lass es uns versuchen! Der Makroaufruf <code>println!</code> wird geändert in
<code>println!(&quot;rect1 ist {:?}&quot;, rect1);</code>. Wenn wir das Symbol <code>:?</code> innerhalb der
geschweiften Klammern angeben, teilen wir <code>println!</code> mit, dass wir das
Ausgabeformat <code>Debug</code> verwenden wollen. Das Merkmal <code>Debug</code> ermöglicht es, die
Struktur so auszugeben, dass Entwickler ihren Wert erkennen können, während sie
den Code debuggen.</p>
<p>Kompiliere den Code mit dieser Änderung. Verflixt! Wir erhalten immer noch
einen Fehler:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>Aber auch hier gibt uns der Compiler einen hilfreichen Hinweis:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`
</code></pre>
<p>Rust enthält durchaus eine Funktionalität zum Ausgeben von Debug-Informationen,
aber wir müssen diese explizit für unsere Struktur aktivieren. Dazu fügen wir
das äußere Attribut <code>#[derive(Debug)]</code> unmittelbar vor der Strukturdefinition
ein, wie in Codeblock 5-12 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 ist {:?}&quot;, rect1);
}</code></pre></pre>
<p><span class="caption">Codeblock 5-12: Attribut zum Verwenden des Merkmals
<code>Debug</code> und Ausgeben der Instanz <code>Rectangle</code> mittels Debug-Formatierung</span></p>
<p>Wenn wir das Programm nun ausführen, werden wir keinen Fehler mehr erhalten und
folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 ist Rectangle { width: 30, height: 50 }
</code></pre>
<p>Toll! Es ist nicht die schönste Ausgabe, aber sie zeigt die Werte aller Felder
dieser Instanz, was bei der Fehlersuche definitiv hilfreich ist. Bei größeren
Strukturen ist es hilfreich, eine leichter lesbare Ausgabe zu erhalten.
In diesen Fällen können wir <code>{:#?}</code> anstelle von <code>{:?}</code> in der
<code>println!</code>-Meldung verwenden. In diesem Beispiel wird bei Verwendung von
<code>{:#?}</code> folgendes ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 ist Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Eine andere Möglichkeit, einen Wert im <code>Debug</code>-Format auszugeben, ist die
Verwendung des <a href="https://doc.rust-lang.org/std/macro.dbg.html">Makros <code>dbg!</code></a>, das die Eigentümerschaft eines Ausdrucks
übernimmt (im Gegensatz zu <code>println!</code>, das eine Referenz nimmt), die Datei und
Zeilennummer, in der der <code>dbg!</code>-Makroaufruf in deinem Code vorkommt, zusammen
mit dem resultierenden Wert des Ausdrucks ausgibt und die Eigentümerschaft am
Wert zurückgibt.</p>
<blockquote>
<p>Hinweis: Der Aufruf des Makros <code>dbg!</code> schreibt in den
Standard-Fehler-Konsolenstrom (<code>stderr</code>), im Gegensatz zu <code>println!</code>, das in
den Standard-Ausgabe-Konsolenstrom (<code>stdout</code>) schreibt. Wir werden mehr über
<code>stderr</code> und <code>stdout</code> im Abschnitt <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">„Fehlermeldungen in die
Standardfehlerausgabe anstatt der Standardausgabe schreiben“ in Kapitel
12</a> erfahren.</p>
</blockquote>
<p>Hier ist ein Beispiel, bei dem wir am Wert interessiert sind, der dem Feld
<code>width</code> zugewiesen wird, als auch am Wert der gesamten Struktur in <code>rect1</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre></pre>
<p>Wir können <code>dbg!</code> um den Ausdruck <code>30 * scale</code> setzen, und da <code>dbg!</code> die
Eigentümerschaft des Werts des Ausdrucks zurückgibt, erhält das Feld <code>width</code>
denselben Wert, als wenn wir den <code>dbg!</code>-Aufruf dort nicht hätten. Wir wollen
nicht, dass <code>dbg!</code> die Eigentümerschaft von <code>rect1</code> übernimmt, also übergeben
wir eine Referenz auf <code>rect1</code> im nächsten Aufruf. So sieht die Ausgabe dieses
Beispiels aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>Wir können sehen, dass der erste Teil der Ausgabe von <em>src/main.rs</em> Zeile 10
stammt, wo wir den Ausdruck <code>30 * scale</code> debuggen, und der Ergebniswert ist
<code>60</code> (die <code>Debug</code>-Formatierung, die für Ganzzahlen implementiert ist, gibt nur
deren Wert aus). Der <code>dbg!</code>-Aufruf in Zeile 14 von <em>src/main.rs</em> gibt den Wert
von <code>&amp;rect1</code> aus, der die Struktur <code>Rectangle</code> ist. Diese Ausgabe verwendet die
hübsche <code>Debug</code>-Formatierung des Typs <code>Rectangle</code>. Das Makro <code>dbg!</code> kann sehr
hilfreich sein, wenn du versuchst, herauszufinden, was dein Code macht!</p>
<p>Zusätzlich zum Merkmal <code>Debug</code> hat Rust eine Reihe von Merkmalen für uns
bereitgestellt, die wir mit dem Attribut <code>derive</code> verwenden können und die
unseren benutzerdefinierten Typen nützliches Verhalten verleihen können. Diese
Merkmale und ihr Verhalten sind in <a href="appendix-03-derivable-traits.html">Anhang C</a> aufgeführt. In Kapitel 10
werden wir behandeln, wie man diese Merkmale mit benutzerdefiniertem Verhalten
implementiert und wie man eigene Merkmale erstellt. Es gibt auch viele andere
Attribute als <code>derive</code>; für weitere Informationen, siehe den <a href="https://doc.rust-lang.org/reference/attributes.html">Abschnitt
„Attribute“ in der Rust-Referenz</a>.</p>
<p>Unsere Funktion <code>area</code> ist sehr spezifisch: Sie berechnet nur die Fläche von
Rechtecken. Es wäre hilfreich, dieses Verhalten enger mit unserer Struktur
<code>Rectangle</code> zu verbinden, da es zu keinem anderen Typ passt. Schauen wir uns
an, wie wir den Code weiter umgestalten und unsere Funktion <code>area</code> in eine
<em>Methode</em> <code>area</code> unseres Typs <code>Rectangle</code> verwandeln können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="methodensyntax"><a class="header" href="#methodensyntax">Methodensyntax</a></h2>
<p><em>Methoden</em> sind Funktionen recht ähnlich: Sie werden mit dem Schlüsselwort <code>fn</code>
und ihrem Namen deklariert, sie können Parameter und einen Rückgabewert haben,
und sie enthalten etwas Code, der ausgeführt wird, wenn sie aufgerufen werden. 
Methoden unterscheiden sich jedoch von Funktionen dadurch, dass sie im Kontext
einer Struktur (struct) (oder einer Aufzählung (enum) oder eines
Merkmalsobjektes (trait object), die wir in <a href="ch06-00-enums.html">Kapitel 6</a> und <a href="ch17-02-trait-objects.html">Kapitel
17</a> behandeln) definiert werden und ihr erster Parameter stets
<code>self</code> ist. <code>self</code> repräsentiert die Instanz der Struktur, zu der die Methode
aufgerufen wird.</p>
<h3 id="definieren-von-methoden"><a class="header" href="#definieren-von-methoden">Definieren von Methoden</a></h3>
<p>Lass uns die Funktion <code>area</code>, die eine <code>Rectangle</code>-Instanz als Parameter hat,
ändern und stattdessen eine Methode <code>area</code> auf der Struktur <code>Rectangle</code>
definieren, wie in Codeblock 5-13 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        rect1.area()
    );
}</code></pre></pre>
<p><span class="caption">Codeblock 5-13: Methode <code>area</code> der Struktur <code>Rectangle</code></span></p>
<p>Um die Funktion im Kontext von <code>Rectangle</code> zu definieren, beginnen wir mit dem
Block <code>impl</code> (Implementierung) für <code>Rectangle</code>. Alles in diesem Block wird mit
dem Typ <code>Rectangle</code> assoziiert. Dann verschieben wir die Funktion <code>area</code> in die
geschweiften Klammern von <code>impl</code>, ändern den ersten (und in diesem Fall
einzigen) Parameter zu <code>self</code> und passen den Methodenrumpf entsprechend an. In
<code>main</code>, wo wir die Funktion <code>area</code> aufrufen und <code>rect1</code> als Argument übergeben,
können wir stattdessen die <em>Methodensyntax</em> verwenden, um die Methode <code>area</code>
auf unserer <code>Rectangle</code>-Instanz aufzurufen. Die Methodensyntax bezieht sich auf
eine Instanz: Wir ergänzen einen Punkt, gefolgt vom Methodennamen, Klammern und
Argumenten.</p>
<p>In der Signatur von <code>area</code> verwenden wir <code>&amp;self</code> anstelle von <code>rectangle: &amp;Rectangle</code>. Das <code>&amp;self</code> ist eigentlich die Abkürzung für <code>self: &amp;Self</code>.
Innerhalb eines <code>impl</code>-Blocks ist der Typ <code>Self</code> ein Alias für den Typ, für den
der <code>impl</code>-Block steht. Methoden müssen einen Parameter mit dem Namen <code>self</code>
vom Typ <code>Self</code> als ihren ersten Parameter haben, Rust lässt dich dies abkürzen,
indem du nur den Namen <code>self</code> an der Stelle des ersten Parameters angibst.
Beachte, dass wir immer noch das <code>&amp;</code> vor der Abkürzung <code>self</code> verwenden müssen,
um anzuzeigen, dass diese Methode die Instanz <code>Self</code> ausleiht, genau wie in
<code>Rechteck: &amp;Rechteck</code>. Methoden können die Eigentümerschaft von <code>self</code>
übernehmen, <code>self</code> unveränderbar ausleihen, wie wir es hier getan haben, oder
<code>self</code> veränderbar ausleihen, so wie bei jedem anderen Parameter auch.</p>
<p>Wir haben hier <code>&amp;self</code> aus dem gleichen Grund gewählt wie <code>&amp;Rectangle</code> in der
Funktionsvariante: Wir wollen keine Eigentümerschaft übernehmen, wir wollen die
Daten der Struktur nur lesen, nicht schreiben. Wenn wir die Instanzdaten ändern
wollten, müssten wir <code>&amp;mut self</code> als ersten Parameter verwenden. Es kommt nur
selten vor, dass eine Methode die Eigentümerschaft der Instanz übernimmt, indem
sie <code>self</code> als ersten Parameter verwendet. Diese Technik wird typischerweise
dann verwendet, wenn die Methode <code>self</code> in etwas anderes transformiert und man
verhindern will, dass der Aufrufer nach der Transformation die ursprüngliche
Instanz verwendet.</p>
<p>Der Hauptgrund für Methoden gegenüber Funktionen liegt abgesehen davon, dass
bei jeder Methodendeklaration der Typ von <code>self</code> nicht ständig wiederholt
werden muss, in der Organisation. Wir haben alle Dinge, die wir mit einer
Instanz eines Typs tun können, in einen einzigen <code>impl</code> Block gepackt.
Zukünftige Nutzer unseres Codes müssen so nicht an verschiedenen Stellen in der
von uns bereitgestellten Bibliothek nach Fähigkeiten von <code>Rectangle</code> suchen.</p>
<p>Beachte, dass wir einer Methode denselben Namen geben können wie einem der
Felder der Struktur. Zum Beispiel können wir eine Methode auf <code>Rectangle</code>
definieren, die ebenfalls <code>width</code> heißt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(&quot;Das Rechteck hat eine Breite ungleich Null; sie ist {}&quot;, rect1.width);
    }
}</code></pre></pre>
<p>Hier entscheiden wir uns dafür, dass die Methode <code>width</code> den Wert <code>true</code>
zurückgibt, wenn der Wert im Feld <code>width</code> der Instanz größer als 0 ist, und
<code>false</code>, wenn der Wert 0 ist: Wir können ein Feld innerhalb einer gleichnamigen
Methode für jeden Zweck verwenden. Wenn wir in <code>main</code> nach <code>rect1.width</code> eine
Klammer setzen, weiß Rust, dass wir die Methode <code>width</code> meinen. Wenn wir keine
Klammern verwenden, weiß Rust, dass wir das Feld <code>width</code> meinen.</p>
<p>Oft, aber nicht immer, wird eine Methode mit demselben Namen wie ein Feld so
definiert, dass sie nur den Wert des Feldes zurückgeben und nichts anderes tun.
Methoden wie diese werden <em>getters</em> genannt, und Rust implementiert sie nicht
automatisch für Strukturfelder, wie es einige andere Sprachen tun. Getter sind
nützlich, weil man das Feld als privat, die Methode aber als öffentlich
kennzeichnen und so den Nur-Lese-Zugriff auf dieses Feld als Teil der
öffentlichen API des Typs erhält. Was öffentlich und privat bedeuten und wie
man ein Feld oder eine Methode als öffentlich oder privat kennzeichnet, werden
wir in <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#pfade-mit-dem-schl%C3%BCsselwort-pub-%C3%B6ffnen">Kapitel 7</a> behandeln.</p>
<blockquote>
<h3 id="wo-ist-der-operator--"><a class="header" href="#wo-ist-der-operator--">Wo ist der Operator <code>-&gt;</code>?</a></h3>
<p>In C und C++ werden zwei verschiedene Operatoren für den Aufruf von Methoden
verwendet: Man verwendet <code>.</code>, wenn eine Methode direkt auf dem Objekt
aufgerufen wird, und <code>-&gt;</code>, wenn die Methode auf einem Zeiger auf das Objekt
aufrufen und der Zeiger zuerst dereferenziert werden muss. Anders gesagt,
wenn <code>object</code> ein Zeiger ist, ist <code>object-&gt;something()</code> ähnlich zu
<code>(*object).something()</code>.</p>
<p>Rust hat kein Äquivalent zum Operator <code>-&gt;</code>. Stattdessen hat Rust eine
Funktionalität namens <em>automatische Referenzierung und Dereferenzierung</em>
(automatic referencing and dereferencing). Der Aufruf von Methoden ist einer
der wenigen Orte in Rust, der dieses Verhalten aufweist.</p>
<p>Und so funktioniert es: Wenn du eine Methode mit <code>object.something()</code>
aufrufst, fügt Rust automatisch <code>&amp;</code>, <code>&amp;mut</code> oder <code>*</code> hinzu, sodass <code>object</code>
zur Signatur der Methode passt. Mit anderen Worten sind folgende Aufrufe
gleich:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>Der erste Aufruf sieht viel sauberer aus. Die automatische Referenzierung
funktioniert, weil Methoden einen eindeutigen Empfänger haben - den Typ von
<code>self</code>. Wenn man den Empfänger und den Namen einer Methode angibt, kann Rust
eindeutig herausfinden, ob die Methode lesend (<code>&amp;self</code>), veränderbar
(<code>&amp;mut self</code>) oder konsumierend (<code>self</code>) ist. Die Tatsache, dass Rust das
Ausleihen für die Methodenempfänger implizit macht, ist ein großer Beitrag
zur Ergonomie der Eigentümerschaft in der Praxis.</p>
</blockquote>
<h3 id="methoden-mit-mehreren-parametern"><a class="header" href="#methoden-mit-mehreren-parametern">Methoden mit mehreren Parametern</a></h3>
<p>Lass uns den Umgang mit Methoden üben, indem wir eine zweite Methode zur
Struktur <code>Rectangle</code> implementieren. Diesmal soll eine zweite Instanz von
<code>Rectangle</code> entgegengenommen und <code>true</code> zurückgeben werden, wenn das zweite
<code>Rectangle</code> vollständig in <code>self</code> (dem ersten <code>Rectangle</code>) hineinpasst;
andernfalls soll <code>false</code> zurückgegeben werden. Das heißt, sobald wir die
Methode <code>can_hold</code> definiert haben, wollen wir in der Lage sein, das in
Codeblock 5-14 gezeigte Programm zu schreiben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Umfasst rect1 rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Umfasst rect1 rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}</code></pre>
<p><span class="caption">Codeblock 5-14: Verwendung der noch nicht geschriebenen
Methode <code>can_hold</code></span></p>
<p>Die erwartete Ausgabe würde wie folgt aussehen, da beide Dimensionen von
<code>rect2</code> kleiner als die Dimensionen von <code>rect1</code> sind, aber <code>rect3</code> breiter als
<code>rect1</code> ist:</p>
<pre><code class="language-text">Umfasst rect1 rect2? true
Umfasst rect1 rect3? false
</code></pre>
<p>Wir wissen, dass wir eine Methode definieren wollen, also wird sie innerhalb
des Blocks <code>impl Rectangle</code> liegen. Die Methode wird <code>can_hold</code> heißen und sie
wird einen weiteren Parameter vom Typ <code>Rectangle</code> unveränderbar ausleihen. Wir
können den Typ des Parameters erkennen, indem wir uns den Code ansehen, der die
Methode aufruft: <code>rect1.can_hold(&amp;rect2)</code> nimmt <code>&amp;rect2</code> entgegen, also eine
unveränderbare Ausleihe von <code>rect2</code> vom Typ <code>Rectangle</code>. Das macht Sinn, da
wir <code>rect2</code> nur lesen müssen (anstatt zu schreiben, wofür wir eine
veränderbare Ausleihe bräuchten) und <code>main</code> die Eigentümerschaft an <code>rect2</code>
zurückerhalten soll, sodass wir es nach dem Aufruf der Methode <code>can_hold</code>
weiter verwenden können. Der Rückgabewert von <code>can_hold</code> ist ein boolescher
Wert und die Implementierung prüft, ob Breite und Höhe von <code>self</code> jeweils
größer als von <code>Rectangle</code> sind. Fügen wir die neue Methode <code>can_hold</code> zum
Block <code>impl</code> aus Codeblock 5-13 hinzu, wie in Codeblock 5-15 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Umfasst rect1 rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Umfasst rect1 rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 5-15: Implementierung der Methode <code>can_hold</code>
auf <code>Rectangle</code>, die eine weitere <code>Rectangle</code>-Instanz als Parameter hat</span></p>
<p>Wenn wir diesen Code mit der Funktion <code>main</code> in Codeblock 5-14 ausführen,
erhalten wir die gewünschte Ausgabe. Methoden können mehrere Parameter haben,
die wir in der Signatur nach dem Parameter <code>self</code> angeben. Diese Parameter
funktionieren genau wie Parameter in Funktionen.</p>
<h3 id="assoziierte-funktionen"><a class="header" href="#assoziierte-funktionen">Assoziierte Funktionen</a></h3>
<p>Alle Funktionen, die innerhalb eines <code>impl</code>-Blocks definiert sind, werden
<em>assoziierte Funktionen</em> genannt, weil sie mit dem Typ assoziiert sind, der
nach dem <code>impl</code> benannt ist. Wir können assoziierte Funktionen definieren, die
nicht <code>self</code> als ihren ersten Parameter haben (und somit keine Methoden sind),
weil sie keine Instanz des Typs benötigen, um damit zu arbeiten. Wir haben
bereits eine solche Funktion verwendet: Die Funktion <code>String::from</code>, die für
den Typ <code>String</code> definiert ist.</p>
<p>Assoziierte Funktionen, die keine Methoden sind, werden oft als Konstruktoren
verwendet, die eine neue Instanz der Struktur zurückgeben. Diese werden oft als
<code>new</code> bezeichnet, aber <code>new</code> ist kein spezieller Name und ist nicht in die
Sprache eingebaut. Wir könnten zum Beispiel eine assoziierte Funktion mit dem
Namen <code>square</code> bereitstellen, die einen eindimensionalen Parameter hat und
diesen sowohl für die Breite als auch für die Höhe verwendet, sodass es
einfacher ist, ein quadratisches <code>Rectangle</code> zu erstellen, anstatt denselben
Wert zweimal angeben zu müssen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>Die Schlüsselwörter <code>Self</code> im Rückgabetyp und im Rumpf der Funktion sind Aliase
für den Typ, der nach dem Schlüsselwort <code>impl</code> steht, in diesem Fall
<code>Rectangle</code>.</p>
<p>Um diese assoziierte Funktion aufzurufen, verwenden wir die Syntax <code>::</code> mit dem
Strukturnamen, z.B. <code>let sq = Rectangle::square(3);</code>. Diese Funktion gehört zum
Namensraum der Struktur: Die Syntax <code>::</code> wird sowohl für assoziierte Funktionen
als auch für Namensräume, die von Modulen erzeugt werden, verwendet. Wir werden
die Module in <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">Kapitel 7</a> besprechen.</p>
<h3 id="mehrere-impl-blöcke"><a class="header" href="#mehrere-impl-blöcke">Mehrere <code>impl</code>-Blöcke</a></h3>
<p>Jede Struktur darf mehrere <code>impl</code>-Blöcke haben. Beispielsweise entspricht
Codeblock 5-15 dem in Codeblock 5-16 gezeigten Code, bei dem jede Methode in
einem eigenen <code>impl</code>-Block steht.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Umfasst rect1 rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Umfasst rect1 rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 5-16: Neuschreiben von Codeblock 5-15 unter
Verwendung mehrerer <code>impl</code>-Blöcke</span></p>
<p>Es ist nicht nötig, diese Methoden hier auf mehrere <code>impl</code>-Blöcke zu verteilen,
aber es handelt sich um eine gültige Syntax. Wir werden in Kapitel 10 einen
Fall sehen, bei dem mehrere <code>impl</code>-Blöcke hilfreich sind, wenn wir generische
Typen und Merkmale behandeln.</p>
<h2 id="zusammenfassung-4"><a class="header" href="#zusammenfassung-4">Zusammenfassung</a></h2>
<p>Mit Strukturen kannst du benutzerdefinierte Typen erstellen, die in deiner
Domäne eine Bedeutung haben. Durch die Verwendung von Strukturen kannst du
zusammengehörige Datenteile miteinander verbunden halten und jedes Teil
benennen, um deinen Code verständlich zu machen. In <code>impl</code>-Blöcken kannst du
Funktionen definieren, die mit deinem Typ assoziiert sind, und Methoden sind
eine Art assoziierte Funktion, mit der du das Verhalten von Instanzen deiner
Strukturen festlegen kannst.</p>
<p>Aber Strukturen sind nicht die einzige Möglichkeit, benutzerdefinierte Typen zu
definieren: Wenden wir uns der Rust-Funktionalität Aufzählung zu, um ein
weiteres Werkzeug in deinen Werkzeugkasten zu legen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aufzählungen-enums-und-musterabgleich-pattern-matching"><a class="header" href="#aufzählungen-enums-und-musterabgleich-pattern-matching">Aufzählungen (enums) und Musterabgleich (pattern matching)</a></h1>
<p>In diesem Kapitel werden wir uns mit <em>Aufzählungen</em> (enumerations, kurz: enums)
befassen. Aufzählungen erlauben es, einen Typ durch Aufzählung seiner möglichen
<em>Varianten</em> (variants) zu definieren. Zuerst werden wir eine Aufzählung
definieren und verwenden, um zu zeigen, wie eine Aufzählung mit Daten eine
Bedeutung kodieren kann. Als Nächstes werden wir eine besonders nützliche
Aufzählung untersuchen, die <code>Option</code> genannt wird und zum Ausdruck bringt, dass
ein Wert entweder etwas oder nichts sein kann. Dann sehen wir uns an, wie man
mit dem Musterabgleich (pattern matching) im Ausdruck <code>match</code> auf einfache
Weise unterschiedlichen Code für verschiedene Werte einer Aufzählung
auszuführen kann. Schließlich werden wir uns mit dem Konstrukt <code>if let</code>
befassen, einem weiteren bequemen und prägnanten Idiom, um mit Aufzählungen in
deinem Code umzugehen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="eine-aufzählung-enum-definieren"><a class="header" href="#eine-aufzählung-enum-definieren">Eine Aufzählung (enum) definieren</a></h2>
<p>Während Strukturen (structs) eine Möglichkeit bieten, zusammengehörige Felder
und Daten zu gruppieren, wie ein <code>Rectangle</code> mit seiner <code>width</code> und <code>height</code>,
bieten Aufzählungen (enums) eine Möglichkeit, einen Wert als einen aus einer
möglichen Gruppe von Werten anzugeben. Wir können zum Beispiel sagen, dass
<code>Rectangle</code> eine von mehreren möglichen Formen ist, zu denen auch <code>Circle</code> und
<code>Triangle</code> gehören. Um dies zu tun, erlaubt Rust uns, diese Möglichkeiten als
Aufzählung zu kodieren.</p>
<p>Schauen wir uns eine Situation an, die wir vielleicht in Code ausdrücken
wollen, und sehen wir, warum Aufzählungen in diesem Fall nützlich und besser
geeignet sind als Strukturen. Angenommen, wir müssen mit IP-Adressen arbeiten.
Aktuell werden zwei Hauptstandards für IP-Adressen verwendet: Version vier und
Version sechs. Da dies die einzigen Möglichkeiten für eine IP-Adresse sind, auf
die unser Programm stößt, können wir alle möglichen Varianten <em>aufzählen</em>,
woher die Aufzählung ihren Namen hat.</p>
<p>Jede IP-Adresse kann entweder eine Adresse der Version vier oder der Version
sechs sein, aber nicht beides gleichzeitig. Diese Eigenschaft der IP-Adressen
passt zur Aufzählungs-Datenstruktur, da ein Aufzählungswert nur eine seiner
Varianten sein kann. Sowohl die Adressen der Version vier als auch der Version
sechs sind grundsätzlich immer noch IP-Adressen, sodass sie als der gleiche Typ
behandelt werden sollten, wenn der Code mit Situationen zu tun hat, die für
beide IP-Adressenarten gelten.</p>
<p>Wir können dieses Konzept im Code ausdrücken, indem wir eine Aufzählung
<code>IpAddrKind</code> definieren und die möglichen Varianten auflisten, die eine
IP-Adresse haben kann, <code>V4</code> und <code>V6</code>. Hier die Varianten der Aufzählung:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code> ist jetzt ein benutzerdefinierter Datentyp, den wir an anderer
Stelle in unserem Code verwenden können.</p>
<h3 id="werte-in-aufzählungen"><a class="header" href="#werte-in-aufzählungen">Werte in Aufzählungen</a></h3>
<p>Wir können Instanzen von beiden Varianten von <code>IpAddrKind</code> wie folgt erstellen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Beachte, dass die Varianten der Aufzählung mit dem Namensraum des Bezeichners
angegeben sind und wir einen doppelten Doppelpunkt verwenden, um die beiden zu
trennen. Das ist sinnvoll, weil beide Werte <code>IpAddrKind::V4</code> und
<code>IpAddrKind::V6</code> vom gleichen Typ sind: <code>IpAddrKind</code>. Wir können dann zum
Beispiel eine Funktion definieren, die jedes <code>IpAddrKind</code> annimmt:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>Und wir können diese Funktion mit beiden Varianten aufrufen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Aufzählungen haben noch weitere Vorteile. Wenn wir weiter über unseren
IP-Adresstyp nachdenken, haben wir im Moment keine Möglichkeit, den <em>Wert</em> der
tatsächlichen IP-Adresse zu speichern; wir wissen nur, um welche <em>Variante</em> es
sich handelt. Mit dem was du gerade erst in Kapitel 5 über Strukturen gelernt
hast, könntest du versucht sein, dieses Problem mit Strukturen zu lösen, wie in
Codeblock 6-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-1: Speichern des Wertes und der
<code>IpAddrKind</code>-Variante einer IP-Adresse mittels <code>struct</code></span></p>
<p>Hier haben wir eine Struktur <code>IpAddr</code> definiert, die zwei Felder hat:  Ein Feld
<code>kind</code> vom Typ <code>IpAddrKind</code> (die zuvor definierte Aufzählung) und ein Feld
<code>address</code> vom Typ <code>String</code>. Wir haben zwei Instanzen dieser Struktur erzeugt.
Die erste ist <code>home</code> und hat die Variante <code>IpAddrKind::V4</code> und die zugehörige
Adresse <code>127.0.0.1</code>. Die zweite Instanz ist <code>loopback</code> und hat die Variante
<code>V6</code> von <code>IpAddrKind</code> als ihren Wert für <code>kind</code> und die zugehörige Adresse
<code>::1</code>. Wir haben eine Struktur verwendet, um die Werte <code>kind</code> und <code>address</code> zu
bündeln, sodass jetzt die Variante mit dem Wert verbunden ist.</p>
<p>Allerdings ist die Darstellung desselben Konzepts mit einer Aufzählung
prägnanter: Anstelle einer Aufzählung innerhalb einer Struktur können wir die
Daten direkt in jede Aufzählungsvariante einfügen. Diese neue Definition der
Aufzählung <code>IpAddr</code> legt fest, dass sowohl die Variante <code>V4</code> als auch <code>V6</code>
zugehörige <code>String</code>-Werte haben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}</span></code></pre></pre>
<p>Wir hängen die Daten direkt an jede Variante der Aufzählung an, so dass keine
zusätzliche Struktur erforderlich ist. Hier ist es auch einfacher, ein weiteres
Detail der Funktionsweise von Aufzählungen zu betrachten: Der Name jeder
Aufzählungs-Variante, die wir definieren, wird auch zu einer Funktion, die eine
Instanz der Aufzählung konstruiert. Das heißt, <code>IpAddr::V4()</code> ist ein
Funktionsaufruf der ein <code>String</code>-Argument entgegennimmt und eine Instanz des
Typs <code>IpAddr</code> zurückgibt. Diese Konstruktorfunktion wird automatisch definiert
als Ergebnis der Definition der Aufzählung.</p>
<p>Es gibt noch einen weiteren Vorteil, eine Aufzählung statt einer Struktur zu
verwenden: Jede Variante kann verschiedene Typen und verschieden viele
zugehöriger Daten haben. IP-Adressen der Version vier haben stets vier
numerische Komponenten, die Werte zwischen 0 und 255 haben. Wenn wir
<code>V4</code>-Adressen als vier <code>u8</code>-Werte speichern und <code>V6</code>-Adressen als einen
<code>String</code>-Wert ausdrücken wollten, wäre das mit einer Struktur nicht möglich.
Aufzählungen lösen diesen Fall ganz einfach:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}</span></code></pre></pre>
<p>Wir haben verschiedene Möglichkeiten zur Definition von Datenstrukturen
gezeigt, die Version vier und sechs einer IP-Adresse speichern können.
Wie sich jedoch herausstellt, ist der Wunsch, IP-Adressen inklusive deren
Variante zu speichern, so verbreitet, dass <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">die Standardbibliothek eine
Definition bereitstellt</a>, die wir verwenden können! Schauen wir uns an,
wie die Standardbibliothek <code>IpAddr</code> definiert: Es hat genau die Aufzählung und
die Varianten, die wir definiert und verwendet haben, aber es bettet die
Adressdaten innerhalb der Varianten in Form von zwei verschiedenen Strukturen
ein, die für jede Variante unterschiedlich definiert sind:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --abschneiden--
}

struct Ipv6Addr {
    // --abschneiden--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code veranschaulicht, dass du jede Art von Daten in eine
Aufzählungsvariante einfügen kannst: Zeichenketten, numerische Typen,
Strukturen usw. Du kannst sogar eine weitere Aufzählung einfügen! Außerdem sind
Standardbibliothekstypen oft nicht viel komplizierter als das, was du dir
vielleicht ausdenkst. Beachte, dass wir, obwohl die Standardbibliothek eine
Definition für <code>IpAddr</code> enthält, konfliktfrei unsere eigene Definition
erstellen und verwenden können, da wir die Definition der Standardbibliothek
nicht in unseren Gültigkeitsbereich aufgenommen haben. Wir werden in Kapitel 7
mehr darauf eingehen, wie man Typen in den Gültigkeitsbereich aufnimmt.</p>
<p>Schauen wir uns ein weiteres Beispiel für eine Aufzählung in Codeblock 6-2 an:
In dieser Aufzählung ist eine Vielzahl von Typen in ihren Varianten eingebettet.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-2: Eine Aufzählung <code>Message</code>, deren Varianten
jeweils eine unterschiedliche Anzahl an Werttypen speichern</span></p>
<p>Diese Aufzählung hat vier Varianten mit unterschiedlichen Typen:</p>
<ul>
<li><code>Quit</code> hat überhaupt keine Daten.</li>
<li><code>Move</code> hat benannte Felder wie eine Struktur.</li>
<li><code>Write</code> enthält einen einzelnen <code>String</code>.</li>
<li><code>ChangeColor</code> enthält drei <code>i32</code>-Werte.</li>
</ul>
<p>Die Definition einer Aufzählung mit Varianten wie in Codeblock 6-2 ist ähnlich
zur Definition verschiedener Arten von Strukturdefinitionen, außer dass die
Aufzählung nicht das Schlüsselwort <code>struct</code> verwendet und alle Varianten unter
dem Typ <code>Message</code> zusammengefasst sind. Die folgenden Strukturen könnten die
gleichen Daten aufnehmen wie die vorhergehenden Aufzählungsvarianten:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct QuitMessage; // leere Struktur
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // Tupelstruktur
struct ChangeColorMessage(i32, i32, i32); // Tupelstruktur
<span class="boring">}</span></code></pre></pre>
<p>Aber wenn wir die verschiedenen Strukturen verwenden würden, die jeweils ein
eigener Typ sind, könnten wir nicht so einfach eine Funktion definieren, die
eine dieser Nachrichtenarten entgegennimmt, wie wir es mit der in Codeblock 6-2
definierten Aufzählung <code>Message</code> gemacht haben, bei der es sich um einen
einzigen Typ handelt.</p>
<p>Es gibt noch eine weitere Ähnlichkeit zwischen Aufzählungen und Strukturen: So
wie wir Methoden für Strukturen mit <code>impl</code> definieren können, können wir auch
Methoden für Aufzählungen definieren. Hier ist eine Methode namens <code>call</code>, die
wir für unsere Aufzählung <code>Message</code> definieren könnten:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // Methodenrumpf
        }
    }

    let m = Message::Write(String::from(&quot;hallo&quot;));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>Der Methodenrumpf würde <code>self</code> benutzen, um den Wert zu erhalten, auf den wir
die Methode aufgerufen haben. In diesem Beispiel haben wir eine Variable <code>m</code>
erstellt, die den Wert <code>Message::Write(String::from(&quot;hallo&quot;))</code> hat. Genau
diesen Wert wird <code>self</code> im Rumpf der Methode <code>call</code> haben, wenn <code>m.call()</code>
ausgeführt wird.</p>
<p>Sehen wir uns eine weitere Aufzählung in der Standardbibliothek an, die sehr
verbreitet und hilfreich ist: <code>Option</code></p>
<h3 id="die-aufzählung-option-und-ihre-vorteile-gegenüber-nullwerten"><a class="header" href="#die-aufzählung-option-und-ihre-vorteile-gegenüber-nullwerten">Die Aufzählung <code>Option</code> und ihre Vorteile gegenüber Nullwerten</a></h3>
<p>Dieser Abschnitt befasst sich mit einer Fallstudie zu <code>Option</code>, einer weiteren
Aufzählung, die von der Standardbibliothek definiert wird. Der Typ <code>Option</code>
kodiert das sehr häufige Szenario, in dem ein Wert etwas oder nichts sein kann.</p>
<p>Wenn du zum Beispiel das erste Element einer nichtleeren Liste anforderst,
erhältst du einen Wert. Wenn du das erste Element einer leeren Liste abfragst,
erhältst du nichts. Im Sinne des Typsystems bedeutet das, dass der Compiler
überprüfen kann, ob du alle Fälle behandelt hast, die du behandelt haben solltest.
Diese Funktionalität kann Fehler vermeiden, die in anderen Programmiersprachen
extrem häufig auftreten.</p>
<p>Bei der Entwicklung von Programmiersprachen wird oft überlegt, welche
Funktionalität aufgenommen werden soll, aber auch die auszuschließende
Funktionalität ist wichtig. Rust hat nicht die Funktionalität „null“, die es in
vielen anderen Sprachen gibt. <em>Null</em> ist ein Wert, der bedeutet, dass kein Wert
vorhanden ist. In Sprachen mit null können sich Variablen immer in einem von
zwei Zuständen befinden: null oder nicht null.</p>
<p>In seinem Vortrag „Nullreferenzen: Der milliardenschwere Fehler“ von 2009 hat
Tony Hoare, der Erfinder von null, folgendes gesagt:</p>
<blockquote>
<p>Ich nenne es meinen milliardenschweren Fehler. Zu dieser Zeit entwarf ich das
erste umfangreiche Typsystem für Referenzen in einer objektorientierten
Sprache. Mein Ziel war es, sicherzustellen, dass jede Verwendung von
Referenzen absolut sicher sein sollte, wobei die Überprüfung automatisch
durch den Compiler durchgeführt wird. Aber ich konnte der Versuchung nicht
widerstehen, eine Nullreferenz einzuführen, nur weil sie so einfach
umzusetzen war. Dies hat zu unzähligen Fehlern, Schwachstellen und
Systemabstürzen geführt, die in den letzten vierzig Jahren wahrscheinlich
eine Milliarde Dollar Schmerz und Schaden verursacht haben.</p>
</blockquote>
<p>Das Problem mit Nullwerten besteht darin, dass du einen Fehler erhältst, wenn
du versuchst, einen Nullwert als Nicht-Nullwert zu verwenden. Da diese Null-
oder Nicht-Null-Eigenschaft allgegenwärtig ist, ist es extrem einfach, einen
derartigen Fehler zu machen.</p>
<p>Das Konzept, das die Null zum Ausdruck bringen will, ist jedoch nach wie vor
nützlich: Null ist ein Wert, der aktuell ungültig ist oder aus irgendeinem
Grund nicht vorhanden ist.</p>
<p>Das Problem liegt nicht wirklich im Konzept, sondern in der konkreten
Umsetzung. Als solches hat Rust keine Nullen, aber es hat eine Aufzählung, die
das Konzept des Vorhandenseins oder Nichtvorhandenseins eines Wertes abbilden
kann. Diese Aufzählung heißt <code>Option&lt;T&gt;</code> und ist
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">in der Standardbibliothek</a> wie folgt definiert:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>Die Aufzählung <code>Option&lt;T&gt;</code> ist so nützlich, dass sie sogar im Präludium
enthalten ist; du musst sie nicht explizit in den Gültigkeitsbereich bringen.
Ihre Varianten sind ebenfalls im Präludium enthalten: Du kannst <code>Some</code> und
<code>None</code> direkt ohne Präfix <code>Option::</code> verwenden. Die Aufzählung <code>Option&lt;T&gt;</code> ist
dennoch nur eine normale Aufzählung, und <code>Some(T)</code> und <code>None</code> sind nur
Varianten des Typs <code>Option&lt;T&gt;</code>.</p>
<p>Die Syntax <code>&lt;T&gt;</code> ist eine Funktionalität von Rust, über die wir noch nicht
gesprochen haben. Es handelt sich um einen generischen Typparameter, auf den
wir in Kapitel 10 näher eingehen werden. Für den Moment musst du nur wissen,
dass <code>&lt;T&gt;</code> bedeutet, dass die Variante <code>Some</code> der Aufzählung <code>Option</code> einen
Wert eines beliebigen Typs enthalten kann und dass jeder konkrete Typ, der
anstelle von <code>T</code> verwendet wird, den Gesamttyp <code>Option&lt;T&gt;</code> zu einem anderen Typ
macht. Hier sind einige Beispiele für die Verwendung von <code>Option</code>-Werten zur
Aufnahme von Zahlentypen und Zeichenkettentypen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>Der Typ von <code>some_number</code> ist <code>Option&lt;i32&gt;</code>. Der Typ von <code>some_char</code> ist
<code>Option&lt;char&gt;</code>, was ein anderer Typ ist. Rust kann diese Typen ableiten, weil
wir einen Wert innerhalb der <code>Some</code>-Variante angegeben haben. Für
<code>absent_number</code> verlangt Rust den gesamten Typ <code>Option</code> zu annotieren: Der
Compiler kann den Typ, den die entsprechende <code>Some</code>-Variante haben wird, nicht
ableiten, wenn sie nur einen <code>None</code>-Wert enthält. Hier sagen wir Rust, dass
<code>absent_number</code> vom Typ <code>Option&lt;i32&gt;</code> sein soll.</p>
<p>Wenn wir einen Wert <code>Some</code> haben, wissen wir, dass ein Wert vorhanden ist und
der Wert innerhalb von <code>Some</code> gehalten wird. Wenn wir einen Wert <code>None</code> haben,
bedeutet das in gewisser Weise dasselbe wie Null: Wir haben keinen gültigen
Wert. Warum ist nun besser <code>Option&lt;T&gt;</code> anstelle von Null zu verwenden?</p>
<p>Kurz gesagt, weil <code>Option&lt;T&gt;</code> und <code>T</code> (wobei <code>T</code> ein beliebiger Typ sein kann)
unterschiedliche Typen sind, erlaubt es der Compiler nicht <code>Option&lt;T&gt;</code> so zu
verwenden als wäre es definitiv ein gültiger Wert. Beispielsweise lässt sich
dieser Code nicht kompilieren, weil er versucht, ein <code>i8</code> mit einem
<code>Option&lt;i8&gt;</code> zu addieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
<span class="boring">}</span></code></pre></pre>
<p>Wenn wir diesen Code ausführen, erhalten wir eine Fehlermeldung wie diese:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</code></pre>
<p>Stark! Tatsächlich bedeutet diese Fehlermeldung, dass Rust nicht versteht, wie
man ein <code>i8</code> und eine <code>Option&lt;i8&gt;</code> addiert, da es sich um unterschiedliche Typen
handelt. Wenn wir einen Wert eines Typs wie <code>i8</code> in Rust haben, stellt der
Compiler sicher, dass wir immer einen gültigen Wert haben. Wir können getrost fortfahren, ohne vor der Verwendung dieses Wertes auf Null prüfen zu
müssen. Nur wenn wir eine <code>Option&lt;i8&gt;</code> (oder einen anderen Werttyp) haben,
müssen wir befürchten, dass wir möglicherweise keinen Wert haben, und der
Compiler wird sicherstellen, dass wir diesen Fall behandeln, bevor wir den
Wert verwenden.</p>
<p>Mit anderen Worten musst du eine <code>Option&lt;T&gt;</code> in ein <code>T</code> konvertieren, bevor du
<code>T</code>-Operationen darauf durchführen kannst. Im Allgemeinen hilft dies, eines der
häufigsten Probleme mit Null abzufangen: Anzunehmen, dass etwas nicht null ist,
obwohl es tatsächlich null ist.</p>
<p>Durch Vermeiden des Risikos, fälschlicherweise einen Nicht-Null-Wert
anzunehmen, gewinnst du mehr Vertrauen in deinen Code. Um einen Wert zu haben,
der möglicherweise null sein kann, musst du dich explizit dafür entscheiden,
indem du als Typ <code>Option&lt;T&gt;</code> verwendest. Wenn du dann diesen Wert verwendest,
musst du den Fall null explizit behandeln. Überall dort, wo ein Wert nicht den
Typ <code>Option&lt;T&gt;</code> hat, kannst du <em>sicher</em> sein, dass der Wert nicht null ist.
Dies war eine bewusste Konstruktionsentscheidung bei Rust, um die Verbreitung
von Null einzuschränken und die Sicherheit von Rust-Code zu erhöhen.</p>
<p>Wie erhältst du nun den <code>T</code>-Wert aus einer Variante <code>Some</code>, wenn du einen Wert
vom Typ <code>Option&lt;T&gt;</code> hast? Die Aufzählung <code>Option&lt;T&gt;</code> enthält eine große Anzahl
von Methoden, die in einer Vielzahl von Situationen nützlich sind; mehr dazu
findest du in <a href="https://doc.rust-lang.org/std/option/enum.Option.html">der Dokumentation</a>. Sich mit den Methoden von <code>Option&lt;T&gt;</code>
vertraut zu machen, wird dir auf deiner Reise mit Rust äußerst nützlich sein.</p>
<p>Um einen <code>Option&lt;T&gt;</code>-Wert zu verwenden, benötigst du im Allgemeinen Code, der
jede Variante behandelt. Du möchtest einen Code, der nur läuft, wenn du einen
Wert <code>Some(T)</code> hast, und dieser Code darf das innere <code>T</code> benutzen. Du möchtest,
dass ein anderer Code ausgeführt wird, wenn du einen Wert <code>None</code> hast, und
dieser Code hat keinen <code>T</code>-Wert. Der Ausdruck <code>match</code> ist ein
Kontrollflusskonstrukt, das genau dies tut, wenn es mit Aufzählungen verwendet
wird: Es führt unterschiedlichen Code aus, je nachdem, welche Variante der
Aufzählung es hat, und dieser Code kann die Daten innerhalb des passenden
Wertes verwenden.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="das-kontrollflusskonstrukt-match"><a class="header" href="#das-kontrollflusskonstrukt-match">Das Kontrollflusskonstrukt <code>match</code></a></h2>
<p>Rust verfügt über ein extrem leistungsfähiges Kontrollflusskonstrukt namens
<code>match</code>, der es dir ermöglicht, einen Wert mit einer Reihe von Mustern
abzugleichen und dann Code zum jeweils passenden Muster auszuführen. Muster
können sich aus Literalen, Variablennamen, Platzhaltern und vielen anderen
Dingen zusammensetzen. <a href="ch18-00-patterns.html">Kapitel 18</a> befasst sich mit all den
verschiedenen Musterarten und wie sie funktionieren. Die Mächtigkeit von
<code>match</code> kommt von der Ausdruckskraft der Muster und der Tatsache, dass der
Compiler sicherstellt, dass alle möglichen Fälle behandelt werden.</p>
<p>Stelle dir einen <code>match</code>-Ausdruck wie eine Münzsortiermaschine vor:  Die Münzen
rutschen eine Bahn mit unterschiedlich großen Löchern entlang, und jede Münze
fällt durch das erste Loch, in das sie hineinpasst. Auf die gleiche Weise
durchlaufen die Werte die Muster in einem <code>match</code>-Ausdruck und beim ersten
„passenden“ Muster fällt der Wert in den zugehörigen Codeblock, der ausgeführt
werden soll.</p>
<p>Apropos Münzen, nehmen wir sie als Beispiel für die Verwendung von <code>match</code>! Wir
können eine Funktion schreiben, die eine unbekannte US-Münze nimmt und, ähnlich
wie die Zählmaschine, bestimmt, um welche Münze es sich handelt und ihren Wert
in Cent zurückgibt, wie in Codeblock 6-3 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-3: Eine Aufzählung und ein <code>match</code>-Ausdruck,
der die Varianten der Aufzählung als Muster hat</span></p>
<p>Lass uns den <code>match</code>-Ausdruck in der Funktion <code>value_in_cents</code> aufschlüsseln. 
Zuerst geben wir das Schlüsselwort <code>match</code> an, gefolgt von einem Ausdruck, der
in diesem Fall der Wert <code>coin</code> ist. Dies scheint einem bedingten Ausdruck sehr
ähnlich zu sein, der bei <code>if</code> verwendet wird, aber es gibt einen großen
Unterschied: Bei <code>if</code> muss die Bedingung einen booleschen Wert ergeben, aber
hier kann ein beliebiger Typ zurückgegeben werden. Der Typ von <code>coin</code> ist in
diesem Beispiel die Aufzählung <code>Coin</code>, die wir in der ersten Zeile definiert
haben.</p>
<p>Als nächstes kommen die <code>match</code>-Zweige. Ein Zweig hat zwei Teile: Ein Muster
und etwas Code. Der erste Zweig hat als Muster den Wert <code>Coin::Penny</code>, dann den
Operator <code>=&gt;</code>, der das Muster und den auszuführenden Code trennt. Der Code ist
in diesem Fall nur der Wert <code>1</code>. Jeder Zweig wird durch ein Komma vom nächsten
getrennt.</p>
<p>Wenn der <code>match</code>-Ausdruck ausgeführt wird, gleicht er den Ergebniswert mit dem
Muster jedes Zweigs ab, und zwar der Reihe nach. Wenn ein Muster zum Wert
passt, wird der zu diesem Muster gehörende Code ausgeführt. Wenn das Muster
nicht zum Wert passt, wird die Ausführung beim nächsten Zweig fortgesetzt,
ähnlich wie bei einer Münzsortiermaschine. Wir können so viele Zweige haben,
wie wir brauchen: In Codeblock 6-3 hat unser <code>match</code>-Ausdruck vier Zweige.</p>
<p>Der zu jedem Zweig gehörende Code ist ein Ausdruck, und der Ergebniswert des
Ausdrucks im zugehörenden Zweig ist der Wert, der für den gesamten
<code>match</code>-Ausdruck zurückgegeben wird. </p>
<p>Wir verwenden üblicherweise keine geschweiften Klammern, wenn der Zweig-Code
kurz ist, so wie in Codeblock 6-3, wo jeder Zweig nur einen Wert zurückgibt.
Wenn du mehrere Codezeilen in einem Zweig ausführen möchtest, musst du
geschweifte Klammern verwenden, und das Komma nach dem Zweig ist dann optional.
Zum Beispiel gibt der folgende Code jedes Mal „Glückspfennig!“ aus, wenn die
Methode mit <code>Coin::Penny</code> aufgerufen wird, er gibt aber immer noch den letzten
Wert <code>1</code> des Blocks zurück:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Glückspfennig!&quot;);
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="muster-die-werte-binden"><a class="header" href="#muster-die-werte-binden">Muster, die Werte binden</a></h3>
<p>Ein weitere nützliche Funktionalität von <code>match</code>-Zweigen ist, dass sie Teile
der Werte binden können, die dem Muster entsprechen. Auf diese Weise können wir
Werte aus Aufzählungsvarianten extrahieren.</p>
<p>Lass uns als Beispiel eine unserer Aufzählungsvarianten so ändern, dass sie
Daten enthält. Von 1999 bis 2008 prägten die Vereinigten Staaten 25-Cent-Münzen
mit unterschiedlichem Aussehen auf einer Seite für jeden der 50 Staaten. Keine
andere Münze hatte ein Staaten-spezifisches Aussehen, sodass nur 25-Cent-Münzen
diese zusätzliche Eigenschaft haben. Wir können diese Information in unserer
Aufzählung unterbringen, indem wir die Variante <code>Quarter</code> so ändern, dass sie
einen <code>UsState</code>-Wert enthält, wie in Codeblock 6-4 umgesetzt.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum UsState {
    Alabama,
    Alaska,
    // --abschneiden--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-4: Aufzählung <code>Coin</code>, bei der die Variante
<code>Quarter</code> zusätzlich einen <code>UsState</code>-Wert enthält</span></p>
<p>Stellen wir uns vor, dass ein Freund versucht, 25-Cent-Münzen aller 50
Staaten zu sammeln. Während wir unser Kleingeld nach Münzsorten sortieren,
geben wir auch den Namen des Staates der 25-Cent-Münze aus, sodass es unser
Freund in seine Sammlung aufnehmen kann, falls er es nicht hat. Im
<code>match</code>-Ausdruck für diesen Code fügen wir zum Muster der Variante
<code>Coin::Quarter</code> eine Variable <code>state</code> hinzu. Wenn der Zweig für <code>Coin::Quarter</code>
passt, wird die Variable <code>state</code> an den Wert der Eigenschaft der 25-Cent-Münze
gebunden. Dann können wir <code>state</code> im Code für diesen Zweig etwa so verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)] // um den Staat mit println! ausgeben zu können
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;25-Cent-Münze aus {:?}!&quot;, state);
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p>Wenn wir <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code> aufrufen würden,
hätte <code>coin</code> den Wert <code>Coin::Quarter(UsState::Alaska)</code>. Gleichen wir den Wert
mit jedem der <code>match</code>-Zweige ab, passt keiner von ihnen, bis wir
<code>Coin::Quarter(state)</code> erreichen. An diesem Punkt wird <code>state</code> an den Wert
<code>UsState::Alaska</code> gebunden. Wir können dann diese Bindung im
<code>println!</code>-Ausdruck verwenden und so den inneren Zustandswert aus der
<code>Coin</code>-Aufzählungsvariante für <code>Quarter</code> herausholen.</p>
<h3 id="abgleich-mit-optiont"><a class="header" href="#abgleich-mit-optiont">Abgleich mit <code>Option&lt;T&gt;</code></a></h3>
<p>Im vorigen Abschnitt wollten wir den inneren <code>T</code>-Wert aus dem Fall <code>Some</code>
herausholen, als wir <code>Option&lt;T&gt;</code> verwendet haben. Wir können <code>Option&lt;T&gt;</code> ebenso
mit <code>match</code> handhaben, wie wir es mit der Aufzählung <code>Coin</code> getan haben! Statt
Münzen zu vergleichen, werden wir die Varianten von <code>Option&lt;T&gt;</code> vergleichen,
aber die Art und Weise, wie der <code>match</code>-Ausdruck funktioniert, bleibt die
gleiche.</p>
<p>Nehmen wir an, wir wollen eine Funktion schreiben, die eine <code>Option&lt;i32&gt;</code> nimmt
und, falls ein Wert darin enthalten ist, zu diesem Wert 1 addiert. Wenn darin
kein Wert enthalten ist, soll die Funktion den Wert <code>None</code> zurückgeben und
nicht versuchen, irgendwelche Operationen durchzuführen.</p>
<p>Diese Funktion ist dank <code>match</code> sehr einfach zu schreiben und wird wie in
Codeblock 6-5 aussehen.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-5: Eine Funktion, die einen <code>match</code>-Ausdruck
auf einer <code>Option&lt;i32&gt;</code> verwendet</span></p>
<p>Lass uns die erste Ausführung von <code>plus_one</code> näher betrachten. Wenn wir
<code>plus_one(five)</code> aufrufen, wird die Variable <code>x</code> im Rumpf von <code>plus_one</code> den
Wert <code>Some(5)</code> haben. Dann vergleichen wir das mit jedem <code>match</code>-Zweig:</p>
<pre><code class="language-rust ignore">None =&gt; None,</code></pre>
<p>Der Wert <code>Some(5)</code> passt nicht zum Muster <code>None</code>, also fahren wir mit dem
nächsten Zweig fort:</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),</code></pre>
<p>Passt <code>Some(5)</code> zu <code>Some(i)</code>? Das tut es! Wir haben die gleiche Variante. <code>i</code>
bindet den in <code>Some</code> enthaltenen Wert, sodass <code>i</code> den Wert <code>5</code> annimmt. Dann
wird der Code im <code>match</code>-Zweig ausgeführt, also fügen wir 1 zum Wert von <code>i</code>
hinzu und erzeugen einen neuen <code>Some</code>-Wert mit der Summe <code>6</code> darin.</p>
<p>Betrachten wir nun den zweiten Aufruf von <code>plus_one</code> in Codeblock 6-5, wo <code>x</code>
den Wert <code>None</code> hat. Wir betreten den <code>match</code>-Block und vergleichen mit dem
ersten Zweig:</p>
<pre><code class="language-rust ignore">None =&gt; None,</code></pre>
<p>Er passt! Es gibt keinen Wert zum Hinzufügen, also stoppt das Programm und gibt
den Wert <code>None</code> auf der rechten Seite von <code>=&gt;</code> zurück. Da der erste Zweig
passt, werden keine anderen Zweige abgeglichen.</p>
<p>Die Kombination von <code>match</code> und Aufzählungen ist in vielen Situationen
nützlich. Du wirst dieses Muster häufig in Rust-Code sehen: <code>match</code> mit einer
Aufzählung, eine Variable an die darin enthaltenen Daten binden und dann
dazugehörenden Code ausführen. Am Anfang ist es etwas knifflig, aber wenn man
sich erst einmal daran gewöhnt hat, wird man sich wünschen, es in allen
Sprachen zu haben. Es ist durchweg ein beliebtes Werkzeug.</p>
<h3 id="abgleiche-sind-vollständig"><a class="header" href="#abgleiche-sind-vollständig">Abgleiche sind vollständig</a></h3>
<p>Es gibt noch einen weiteren Aspekt von <code>match</code>, den wir besprechen müssen: Die
Muster der Zweige müssen alle Möglichkeiten abdecken. Betrachte folgende
Version unserer Funktion <code>plus_one</code>, die einen Fehler hat und sich nicht
kompilieren lässt:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
<p>Wir haben den Fall <code>None</code> nicht behandelt, daher wird dieser Code einen Fehler
verursachen. Glücklicherweise ist es ein Fehler, von dem Rust weiß, wie er
zu lösen ist. Wenn wir versuchen, diesen Code zu kompilieren, werden wir
diese Fehlermeldung bekommen:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option&lt;i32&gt;`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
</code></pre>
<p>Rust weiß, dass wir nicht alle möglichen Fälle abgedeckt haben, und es weiß
sogar, welches Muster wir vergessen haben! Abgleiche in Rust sind
<em>vollständig</em>: Wir müssen jede letzte Möglichkeit ausschöpfen, damit der Code
gültig ist! Speziell im Fall <code>Option&lt;T&gt;</code> schützt uns Rust davor, den Fall
<code>None</code> zu übersehen, und davon auszugehen, dass wir einen Wert haben, obwohl
vielleicht null vorliegt, und macht so den zuvor besprochenen Milliardenfehler
unmöglich.</p>
<h3 id="auffangmuster-und-der-platzhalter-_"><a class="header" href="#auffangmuster-und-der-platzhalter-_">Auffangmuster und der Platzhalter <code>_</code></a></h3>
<p>Mit Aufzählungen können wir auch spezielle Aktionen für ausgewählte Werte
durchführen und für alle anderen Werte eine Standardaktion. Stell dir vor, wir
implementieren ein Spiel, bei dem ein Spieler bei einem Würfelwurf von 3 einen
schicken Hut bekommt anstatt sich zu bewegen. Wenn du eine 7 würfelst, verliert
dein Spieler einen schicken Hut. Bei allen anderen Werten zieht der Spieler die
entsprechende Anzahl an Feldern auf dem Spielfeld. Hier ist ein <code>match</code>, das
diese Logik implementiert, wobei das Ergebnis des Würfelwurfs anstelle eines
Zufallswerts fest kodiert ist, und alle weitere Logik wird durch Funktionen ohne
Rumpf dargestellt, da die tatsächliche Implementierung für dieses Beispiel den
Rahmen sprengen würde:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dice_roll = 9;
match dice_roll {
    3 =&gt; add_fancy_hat(),
    7 =&gt; remove_fancy_hat(),
    other =&gt; move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>Bei den ersten beiden Zweigen sind die Muster die literalen Werte <code>3</code> und <code>7</code>.
Beim letzten Zweig, der alle anderen möglichen Werte abdeckt, ist das Muster
die Variable die wir als <code>other</code> bezeichnet haben. Der Code, der für den
<code>other</code>-Zweig läuft, verwendet die Variable, indem er sie an die Funktion
<code>move_player</code> übergibt.</p>
<p>Dieser Code lässt sich kompilieren, auch wenn wir nicht alle möglichen Werte
aufgelistet haben, die ein <code>u8</code> haben kann, weil das letzte Muster zu allen
nicht explizit aufgeführten Werte passt. Dieses Auffangmuster (catch-all
pattern) erfüllt die Anforderung, dass <code>match</code> vollständig sein muss. Beachte,
dass wir den Auffangzweig an letzter Stelle angeben müssen, da die Muster der
Reihe nach ausgewertet werden. Wenn wir den Auffangzweig früher einfügen
würden, würden die anderen Zweige nie ausgeführt werden, also warnt uns Rust,
wenn wir Zweige nach einem Auffangzweig hinzufügen!</p>
<p>Rust hat auch ein Muster, das wir verwenden können, wenn wir einen Auffangzweig
wollen, aber den Wert im Auffangmuster <em>nicht</em> verwenden wollen: <code>_</code> ist ein
spezielles Muster, das zu jedem Wert passt und nicht an diesen Wert bindet.
Dies sagt Rust, dass wir den Wert nicht verwenden werden, damit Rust uns nicht
vor einer unbenutzten Variable warnt.</p>
<p>Ändern wir die Spielregeln: Wenn du jetzt etwas anderes als eine 3 oder eine 7
würfelst, musst du erneut würfeln. Wir brauchen den Auffangwert nicht mehr zu
verwenden, also können wir unseren Code so ändern, dass wir <code>_</code> anstelle der
Variable namens <code>other</code> verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dice_roll = 9;
match dice_roll {
    3 =&gt; add_fancy_hat(),
    7 =&gt; remove_fancy_hat(),
    _ =&gt; reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>Dieses Beispiel erfüllt auch die Bedingung der Vollständigkeit, weil wir
ausdrücklich alle anderen Werte im letzten Zweig ignorieren; wir haben nichts
vergessen.</p>
<p>Zum Schluss ändern wir die Spielregeln noch einmal, sodass bei einem Zug nichts
anderes passiert, wenn etwas anderes als eine 3 oder eine 7 gewürfelt wird. Wir
können das ausdrücken, indem wir den Einheitswert (den leeren Tupel-Typ, den
wir im Abschnitt <a href="ch03-02-data-types.html#der-tupel-typ">„Der Tupel-Typ“</a> erwähnt haben) als Code im <code>_</code>-Zweig
angeben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dice_roll = 9;
match dice_roll {
    3 =&gt; add_fancy_hat(),
    7 =&gt; remove_fancy_hat(),
    _ =&gt; (),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>Hier teilen wir Rust explizit mit, dass wir keinen anderen Wert verwenden
werden, der nicht mit einem Muster in einem früheren Zweig übereinstimmt, und
dass wir in diesem Fall keinen Code ausführen wollen.</p>
<p>Weitere Informationen zu Mustern und Abgleich findest du in <a href="ch18-00-patterns.html">Kapitel
18</a>. Für den Moment machen wir mit der <code>if let</code>-Syntax
weiter, die in Situationen nützlich sein kann, in denen der <code>match</code>-Ausdruck
etwas wortreich ist.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="prägnanter-kontrollfluss-mit-if-let"><a class="header" href="#prägnanter-kontrollfluss-mit-if-let">Prägnanter Kontrollfluss mit <code>if let</code></a></h2>
<p>Mit der Syntax <code>if let</code> kannst du <code>if</code> und <code>let</code> in einer weniger wortreichen
Weise kombinieren, um mit Werten umzugehen, die einem Muster entsprechen,
während der Rest ignoriert wird. Betrachte das Programm in Codeblock 6-6, das
auf einen <code>Option&lt;u8&gt;</code>-Wert in der Variable <code>config_max</code> passt, aber nur dann
Code ausführen soll, wenn der Wert die <code>Some</code>-Variante ist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_max = Some(3u8);
match config_max {
    Some(max) =&gt; println!(&quot;Das Maximum ist mit {} konfiguriert&quot;, max),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 6-6: Ein <code>match</code>-Ausdruck, der nur dann Code
ausführt, wenn der Wert <code>Some</code> ist</span></p>
<p>Wenn der Wert <code>Some</code> ist, geben wir den Wert in der Variante <code>Some</code> aus, indem
wir den Wert an die Variable <code>max</code> im Muster binden. Wir wollen nichts mit dem
Wert <code>None</code> machen. Um den Ausdruck <code>match</code> zu erfüllen, müssen wir nach der
Verarbeitung nur einer Variante <code>_ =&gt; ()</code> hinzufügen, was lästiger Codeballast
ist.</p>
<p>Stattdessen könnten wir dies in kürzerer Form schreiben, indem wir <code>if let</code>
verwenden. Der folgende Code verhält sich genauso wie der <code>match</code>-Ausdruck in
Codeblock 6-6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_max = Some(3u8);
if let Some(max) = config_max {
    println!(&quot;Das Maximum ist mit {} konfiguriert&quot;, max);
}
<span class="boring">}</span></code></pre></pre>
<p>Die Syntax <code>if let</code> nimmt ein Muster und einen Ausdruck, getrennt durch ein
Gleichheitszeichen. Sie funktioniert auf gleiche Weise wie bei <code>match</code>, wo der
Ausdruck hinter <code>match</code> angegeben wird und das Muster der erste Zweig ist. In
diesem Fall ist das Muster <code>Some(max)</code> und das <code>max</code> ist an den Wert innerhalb
von <code>Some</code> gebunden. Wir können dann <code>max</code> im Rumpf des <code>if let</code>-Blocks auf die
gleiche Weise verwenden, wie <code>max</code> im entsprechenden <code>match</code>-Zweig. Der Code im
<code>if let</code>-Block wird nicht ausgeführt, wenn der Wert nicht zum Muster passt.</p>
<p>Die Verwendung von <code>if let</code> bedeutet weniger Tipparbeit, weniger Einrückung und
weniger Codeanteil. Du verlierst jedoch die Prüfung auf Vollständigkeit, die
<code>match</code> erzwingt. Die Wahl zwischen <code>match</code> und <code>if let</code> hängt davon ab, was
du in der speziellen Situation machst, und davon, ob ein Gewinn an Prägnanz ein
angemessener Kompromiss für den Verlust einer Prüfung auf Vollständigkeit ist.</p>
<p>Anders gesagt kannst du dir <code>if let</code> als syntaktischen Zucker für einen
<code>match</code>-Ausdruck vorstellen, der Code nur bei Übereinstimmung mit einem Muster
ausführt und alle anderen Werte ignoriert.</p>
<p>Wir können ein <code>else</code> an ein <code>if let</code> anhängen. Der Code-Block, der zum <code>else</code>
gehört, ist der gleiche wie der Code-Block, der zum <code>_</code>-Zweig im
<code>match</code>-Ausdruck gehören würde. Erinnere dich an die Aufzählung <code>Coin</code> in
Codeblock 6-4, wo die Variante <code>Quarter</code> auch einen <code>UsState</code>-Wert enthielt.
Wenn wir alle Nicht-25-Cent-Münzen zählen wollten, während wir die Eigenschaft
der 25-Cent-Münzen ausgeben, könnten wir das mit einem <code>match</code>-Ausdruck wie
diesem tun:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;25-Cent-Münze aus {:?}!&quot;, state),
        _ =&gt; count += 1,
    }
<span class="boring">}</span></code></pre></pre>
<p>Oder wir könnten einen Ausdruck mit <code>if let</code> und <code>else</code> wie diesen verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;25-Cent-Münze aus {:?}!&quot;, state);
    } else {
        count += 1;
    }
<span class="boring">}</span></code></pre></pre>
<p>Wenn du eine Situation hast, in der dein Programm über eine Logik verfügt, die
mit einem <code>match</code>-Ausdruck zu wortreich auszudrücken wäre, denke daran, dass
<code>if let</code> ebenfalls in deinem Rust-Werkzeugkasten enthalten ist.</p>
<h2 id="zusammenfassung-5"><a class="header" href="#zusammenfassung-5">Zusammenfassung</a></h2>
<p>Wir haben uns damit befasst, wie man Aufzählungen verwendet, um
benutzerdefinierte Typen zu erstellen, die zu einem Satz von Aufzählungswerten
gehören können. Wir haben gezeigt, wie der Typ <code>Option&lt;T&gt;</code> der
Standardbibliothek dir dabei hilft, das Typsystem zu verwenden, um Fehler zu
vermeiden. Wenn Aufzählungswerte Daten enthalten, kannst du diese Werte mit
<code>match</code> oder <code>if let</code> extrahieren und verwenden, je nachdem, wie viele Fälle du
behandeln musst.</p>
<p>Deine Rust-Programme können nun Konzepte in deiner Domäne mit Hilfe von
Strukturen und Aufzählungen ausdrücken. Das Erstellen benutzerdefinierter Typen
zur Verwendung in deiner API gewährleistet Typsicherheit: Der Compiler wird
sicherstellen, dass deine Funktionen nur Werte jenes Typs erhalten, den die
Funktion erwartet.</p>
<p>Um deinen Nutzern eine gut organisierte API zur Verfügung zu stellen, die
einfach zu benutzen ist und nur genau das offenbart, was deine Nutzer
benötigen, wenden wir uns nun den Modulen von Rust zu.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wachsende-projekte-verwalten-mit-paketen-packages-kisten-crates-und-modulen"><a class="header" href="#wachsende-projekte-verwalten-mit-paketen-packages-kisten-crates-und-modulen">Wachsende Projekte verwalten mit Paketen (packages), Kisten (crates) und Modulen</a></h1>
<p>Wenn du große Programme schreibst, wird die Organisation deines Codes immer
wichtiger. Durch die Gruppierung verwandter Funktionen und die Trennung von
Code mit unterschiedlichen Funktionalitäten wird klar, wo der Code zu finden
ist, der eine bestimmte Funktionalität implementiert, und an welcher Stelle
die Funktionalität eines Merkmals zu ändern ist.</p>
<p>Die Programme, die wir bisher geschrieben haben, waren in einem Modul in einer
Datei. Wenn ein Projekt wächst, solltest du den Code organisieren, indem du ihn
in mehrere Module und dann in mehrere Dateien aufteilst. Ein Paket (package)
kann mehrere Binär-Kisten (binary crates) und optional eine Bibliotheks-Kiste
(library crate) enthalten. Wenn ein Paket wächst, kannst du Teile in separate
Kisten extrahieren, die zu externen Abhängigkeiten werden. Dieses Kapitel
behandelt all diese Techniken. Für sehr große Projekte aus einer Reihe von
zusammenhängenden Paketen, die sich gemeinsam weiterentwickeln, stellt Cargo
<em>Arbeitsbereiche</em> zur Verfügung, die wir im Abschnitt
<a href="ch14-03-cargo-workspaces.html">„Cargo-Arbeitsbereiche“</a> in Kapitel 14 behandeln werden.</p>
<p>Wir werden auch die Kapselung von Implementierungsdetails besprechen, wodurch
du Code auf einer höheren Ebene wiederverwenden kannst: Sobald du eine
Operation implementiert hast, kann anderer Code diesen Code über die
öffentliche Schnittstelle des Codes aufrufen, ohne wissen zu müssen, wie die
Implementierung funktioniert. Die Art und Weise, wie du Code schreibst,
definiert, welche Teile für anderen Code öffentlich sind und welche Teile
private Implementierungsdetails sind, deren Änderung du dir vorbehältst. Dies
ist eine weitere Möglichkeit, die Menge der Details, die man im Kopf behalten
muss, zu begrenzen.</p>
<p>Ein verwandtes Konzept ist der Gültigkeitsbereich (scope): Der verschachtelte
Kontext, in dem Code geschrieben wird, hat eine Reihe von Namen, die als „im
Gültigkeitsbereich“ (in scope) definiert sind. Beim Lesen, Schreiben und
Kompilieren von Code müssen Programmierer und Compiler wissen, ob sich ein
bestimmter Name an einer bestimmten Stelle auf eine Variable, Funktion,
Struktur (struct), Aufzählung (enum), Modul, Konstante oder ein anderes Element
bezieht und was dieses Element bedeutet. Du kannst Gültigkeitsbereiche
erstellen und verändern, welche Namen in oder außerhalb des Gültigkeitsbereichs
liegen. Du kannst nicht zwei Elemente mit gleichem Namen im selben
Gültigkeitsbereich haben; es sind Werkzeuge zur Lösung von Namenskonflikten
vorhanden.</p>
<p>Rust verfügt über eine Reihe von Funktionalitäten, mit denen du die
Organisation deines Codes verwalten kannst, z.B. welche Details offengelegt
werden, welche Details privat sind und welche Namen im jeweiligen
Gültigkeitsbereich deines Programms sind. Zu diesen Funktionalitäten, die
manchmal kollektiv als <em>Modulsystem</em> bezeichnet werden, gehören:</p>
<ul>
<li><strong>Pakete (packages):</strong> Eine Cargo-Funktionalität, mit der du Kisten bauen,
testen und gemeinsam nutzen kannst.</li>
<li><strong>Kisten (crates):</strong> Ein Baum von Modulen, der eine Bibliothek oder ein
ausführbares Programm erzeugt.</li>
<li><strong>Module</strong> und <strong><code>use</code></strong>: Ermöglicht dir, die Organisation, den
Gültigkeitsbereich und den Datenschutz von Pfaden zu steuern.</li>
<li><strong>Pfade:</strong> Eine Möglichkeit, ein Element zu benennen, z.B. eine Struktur,
eine Funktion oder ein Modul.</li>
</ul>
<p>In diesem Kapitel gehen wir auf all diese Funktionalitäten ein, besprechen, wie
sie zusammenwirken, und erklären, wie sie zur Verwaltung der
Gültigkeitsbereiche eingesetzt werden können. Am Ende solltest du ein solides
Verständnis des Modulsystems haben und in der Lage sein, mit den
Gültigkeitsbereichen wie ein Profi zu arbeiten!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pakete-packages-und-kisten-crates"><a class="header" href="#pakete-packages-und-kisten-crates">Pakete (packages) und Kisten (crates)</a></h2>
<p>Die ersten Teile des Modulsystems, die wir behandeln werden, sind Pakete und
Kisten.</p>
<p>Eine <em>Kiste</em> ist die kleinste Menge an Code, die der Rust-Compiler zu einem
bestimmten Zeitpunkt berücksichtigt. Selbst wenn du <code>rustc</code> anstelle von
<code>cargo</code> ausführst und eine einzelne Quellcodedatei übergibst (wie wir es
bereits im Abschnitt „Schreiben und Ausführen eines Rust-Programms“ in Kapitel
1 getan haben), betrachtet der Compiler diese Datei als eine Kiste. Kisten
können Module enthalten, und die Module können in anderen Dateien definiert
sein, die mit der Kiste kompiliert werden, wie wir in den nächsten Abschnitten
sehen werden.</p>
<p>Es gibt zwei Arten von Kisten: Binäre Kisten und Bibliothekskisten. <em>Binäre
Kisten</em> (binary crates) sind Programme, die du zu einer ausführbaren Datei
kompilieren und starten kannst, z.B. ein Befehlszeilenprogramm
oder einen Server. Jede muss eine Funktion namens <code>main</code> haben, die definiert,
was passiert, wenn die ausführbare Datei läuft. Alle Kisten, die wir bisher
erstellt haben, waren binäre Kisten.</p>
<p><em>Bibliothekskisten</em> (library crates) haben keine <code>main</code>-Funktion und sie werden
nicht zu einer ausführbaren Datei kompiliert. Stattdessen definieren sie
Funktionalität, die für mehrere Projekte gemeinsam genutzt werden soll. Zum
Beispiel bietet die Kiste <code>rand</code>, die wir in <a href="ch02-00-guessing-game-tutorial.html#generieren-einer-geheimzahl">Kapitel 2</a> verwendet haben,
Funktionalität, die Zufallszahlen erzeugt. Wenn Rust-Entwickler „Kiste“ sagen,
meinen sie meistens „Bibliothekskiste“, und sie verwenden „Kiste“ austauschbar
mit dem allgemeinen Programmierkonzept einer „Bibliothek“.</p>
<p>Die <em>Kistenwurzel</em> ist eine Quelldatei, von der der Rust-Compiler ausgeht und
die das Wurzel-Modul deiner Kiste bildet (Module werden im Abschnitt <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">„Mit
Modulen den Kontrollumfang und Datenschutz steuern“</a> ausführlich
erklärt).</p>
<p>Ein <em>Paket</em> ist ein Bündel von einer oder mehreren Kisten, die eine Reihe von
Funktionalitäten bereitstellen. Ein Paket enthält eine Datei <em>Cargo.toml</em>, die
beschreibt, wie diese Kisten zu bauen sind. Cargo ist eigentlich ein Paket, das
die Binärkiste für das Kommandozeilenwerkzeug enthält, das du zum Erstellen
deines Codes verwendet hast. Das Cargo-Paket enthält auch eine
Bibliothekskiste, von der die binäre Kiste abhängt. Andere Projekte können von
der Cargo-Bibliothekskiste abhängen, um die gleiche Logik wie das
Cargo-Befehlszeilenwerkzeug zu verwenden.</p>
<p>Ein Paket kann beliebig viele Binärkisten enthalten, aber höchstens eine
Bibliothekskiste. Ein Paket muss mindestens eine Kiste enthalten, unabhängig
davon, ob es sich um eine Bibliothek oder eine binäre Kiste handelt.</p>
<p>Lass uns durchgehen, was passiert, wenn wir ein Paket erstellen. Zuerst geben
wir den Befehl <code>cargo new</code> ein:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>Nachdem wir <code>cargo new</code> ausgeführt haben, verwenden wir <code>ls</code>, um zu sehen, was
Cargo erzeugt. Im Projektverzeichnis gibt es eine Datei <em>Cargo.toml</em>, die uns
ein Paket gibt. Es gibt auch ein Verzeichnis <em>src</em>, das <em>main.rs</em> enthält.
Öffne <em>Cargo.toml</em> in deinem Texteditor und beachte, dass <em>src/main.rs</em> nicht
erwähnt wird. Cargo folgt der Konvention, dass <em>src/main.rs</em> die Kistenwurzel
einer binären Kiste mit dem gleichen Namen wie das Paket ist. Ebenso weiß
Cargo, dass, wenn das Paketverzeichnis <em>src/lib.rs</em> enthält, das Paket eine
Bibliothekskiste mit dem gleichen Namen wie das Paket enthält, und <em>src/lib.rs</em>
deren Kistenstamm ist. Cargo übergibt die Kistenwurzel-Dateien an <code>rustc</code>, um
die Bibliothek oder Binärdatei zu bauen.</p>
<p>Hier haben wir ein Paket, das nur <em>src/main.rs</em> enthält, d.h. es enthält nur
eine binäre Kiste mit dem Namen <code>my-project</code>. Wenn ein Paket <em>src/main.rs</em> und
<em>src/lib.rs</em> enthält, hat es zwei Kisten: Eine binäre und eine Bibliothek,
beide mit dem gleichen Namen wie das Paket. Ein Paket kann mehrere binäre
Kisten haben, indem es Dateien im Verzeichnis <em>src/bin</em> ablegt: Jede Datei ist
dann eine eigene binäre Kiste.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mit-modulen-den-kontrollumfang-und-datenschutz-steuern"><a class="header" href="#mit-modulen-den-kontrollumfang-und-datenschutz-steuern">Mit Modulen den Kontrollumfang und Datenschutz steuern</a></h2>
<p>In diesem Abschnitt werden wir über Module und andere Teile des Modulsystems
sprechen, nämlich <em>Pfade</em>, die es dir erlauben, Elemente zu benennen; das
Schlüsselwort <code>use</code>, das einen Pfad in den Gültigkeitsbereich bringt; und das
Schlüsselwort <code>pub</code>, um Elemente öffentlich zu machen. Wir werden auch das
Schlüsselwort <code>as</code>, externe Pakete und den Stern-Operator (glob operator)
besprechen.</p>
<p>Zunächst werden wir mit einer Liste von Regeln beginnen, damit du bei der
künftigen Organisation deines Codes leicht nachschlagen kannst. Dann werden wir
jede der Regeln im Detail erklären.</p>
<h3 id="spickzettel-für-module"><a class="header" href="#spickzettel-für-module">Spickzettel für Module</a></h3>
<p>Hier bieten wir eine Kurzreferenz darüber, wie Module, Pfade, das Schlüsselwort
<code>use</code> und das Schlüsselwort <code>pub</code> im Compiler funktionieren und wie die meisten
Entwickler ihren Code organisieren. Wir werden im Laufe dieses Kapitels
Beispiele für jede dieser Regeln durchgehen, aber dies ist ein guter Ort, um
sich daran zu erinnern, wie Module funktionieren.</p>
<ul>
<li><strong>Beginne bei der Kistenwurzel (crate root)</strong>: Beim Kompilieren einer Kiste
sucht der Compiler zuerst in der Wurzeldatei der Kiste (normalerweise
<em>src/lib.rs</em> für eine Bibliothekskiste oder <em>src/main.rs</em> für eine
Binärkiste).</li>
<li><strong>Module deklarieren</strong>: In der Kisten-Stammdatei kannst du neue Module
deklarieren; z.B. deklarierst du ein „Garten“-Modul mit <code>mod garden;</code>. Der
Compiler wird an diesen Stellen nach dem Code des Moduls suchen:
<ul>
<li>In der Zeile direkt nach <code>mod garden</code>, in geschweiften Klammern anstelle
des Semikolons</li>
<li>In der Datei <em>src/garden.rs</em></li>
<li>In der Datei <em>src/garden/mod.rs</em></li>
</ul>
</li>
<li><strong>Submodule deklarieren</strong>: In jeder anderen Datei als der Kistenwurzel
kannst du Untermodule deklarieren. Du kannst zum Beispiel <code>mod vegetables;</code>
in <em>src/garden.rs</em> deklarieren. Der Compiler sucht den Code des Submoduls in
dem Verzeichnis, das nach dem übergeordneten Modul benannt ist, an folgenden
Stellen:
<ul>
<li>In der Zeile direkt nach <code>mod vegetables</code>, in geschweiften Klammern
anstelle des Semikolons</li>
<li>In der Datei <em>src/garden/vegetables.rs</em></li>
<li>In der Datei <em>src/garden/vegetables/mod.rs</em></li>
</ul>
</li>
<li><strong>Pfade zum Code in Modulen</strong>: Sobald ein Modul Teil deiner Kiste ist, kannst
du auf den Code in diesem Modul von jedem anderen Ort in derselben Kiste aus
referenzieren, solange die Datenschutzregeln dies zulassen, indem du den Pfad
zum Code verwendest. Zum Beispiel würde ein Typ <code>Asparagus</code> im
Gartengemüse-Modul unter <code>crate::garden::vegetables::Asparagus</code> zu finden
sein.</li>
<li><strong>Privat vs. öffentlich</strong>: Der Code innerhalb eines Moduls ist standardmäßig
für seine übergeordneten Module nicht zugänglich. Um ein Modul öffentlich zu
machen, deklariere es mit <code>pub mod</code> anstelle von <code>mod</code>. Um Elemente innerhalb
eines öffentlichen Moduls ebenfalls öffentlich zu machen, verwende <code>pub</code> vor
ihren Deklarationen.</li>
<li><strong>Das Schlüsselwort <code>use</code></strong>: Innerhalb eines Gültigkeitsbereichs werden mit
dem Schlüsselwort <code>use</code> Verknüpfungen zu Elementen erstellt, um die
Wiederholung langer Pfade zu reduzieren. In jedem Gültigkeitsbereichs, der
auf <code>crate::garden::vegetables::Asparagus</code> referenzieren kann, kann man eine
Verknüpfung mit <code>use crate::garden::vegetables::Asparagus</code> erstellen und von
da an braucht man nur noch <code>Asparagus</code> zu schreiben, um diesen Typ im
Gültigkeitsbereich zu verwenden.</li>
</ul>
<p>Hier erstellen wir eine binäre Kiste namens <code>backyard</code> (Hinterhof), die diese
Regeln veranschaulicht. Das Verzeichnis der Kiste, ebenfalls <code>backyard</code>
genannt, enthält diese Dateien und Verzeichnisse:</p>
<pre><code class="language-text">backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
</code></pre>
<p>Die Stammdatei der Kiste ist in diesem Fall <em>src/main.rs</em>, und sie enthält:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!(&quot;Ich baue {:?} an!&quot;, plant);
}</code></pre>
<p>Die Zeile <code>pub mod garden;</code> weist den Compiler an, den Code einzubinden, den er
in <em>src/garden.rs</em> findet, nämlich:</p>
<p><span class="filename">Dateiname: src/garden.rs</span></p>
<pre><code class="language-rust noplayground ignore">pub mod vegetables;</code></pre>
<p>Hier bedeutet <code>pub mod vegetables;</code>, dass der Code in
<em>src/garden/vegetables.rs</em> ebenfalls enthalten ist. Dieser Code ist:</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}</code></pre>
<p>Lass uns nun auf die Einzelheiten dieser Regeln eingehen und sie in der Praxis demonstrieren!</p>
<h3 id="gruppierung-von-zugehörigem-code-in-modulen"><a class="header" href="#gruppierung-von-zugehörigem-code-in-modulen">Gruppierung von zugehörigem Code in Modulen</a></h3>
<p><em>Module</em> ermöglichen es uns, den Code innerhalb einer Kiste zu organisieren,
damit er lesbar und leicht wiederverwendbar ist. Mit Modulen können wir auch
den <em>Datenschutz</em> (privacy) von Elementen kontrollieren, da Code innerhalb
eines Moduls standardmäßig privat ist. Private Elemente sind interne
Implementierungsdetails, die nicht für die externe Nutzung zur Verfügung
stehen. Wir können uns dafür entscheiden, Module und die darin enthaltenen
Elemente öffentlich zu machen, damit externer Code sie verwenden und von ihnen
abhängen kann.</p>
<p>Als Beispiel schreiben wir eine Bibliothekskiste, die die Funktionalität eines
Restaurants bietet. Wir werden die Signaturen der Funktionen definieren, aber
ihre Rümpfe leer lassen, um uns auf die Organisation des Codes zu konzentrieren
und nicht auf die Implementierung eines Restaurants.</p>
<p>Im Gaststättengewerbe werden einige Teile eines Restaurants als <em>Vorderseite
des Hauses</em> und andere als <em>Hinterseite des Hauses</em> bezeichnet. Auf der
Vorderseite des Hauses sind die Kunden; hier setzen Gastgeber ihre Kunden hin,
Kellner nehmen Bestellungen auf und rechnen ab und Barkeeper machen die
Getränke. Auf der Hinterseite des Hauses arbeiten die Küchenchefs und Köche in
der Küche, Geschirrspüler waschen ab und Manager erledigen Verwaltungsarbeiten.</p>
<p>Um unsere Kiste auf diese Weise zu strukturieren, können wir ihre Funktionen in
verschachtelten Modulen organisieren. Erstelle eine neue Bibliothek namens
<code>restaurant</code>, indem du <code>cargo new --lib restaurant</code> ausführst; gib dann den
Code in Codeblock 7-1 in <em>src/lib.rs</em> ein, um einige Module und
Funktionssignaturen zu definieren. Hier ist der vordere Teil des Hauses:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}</code></pre>
<p><span class="caption">Codeblock 7-1: Ein Modul <code>front_of_house</code>, das andere
Module enthält, die dann Funktionen enthalten</span></p>
<p>Wir definieren ein Modul mit dem Schlüsselwort <code>mod</code>, gefolgt vom Namen des
Moduls (in diesem Fall <code>front_of_house</code>). Der Rumpf des Moduls steht dann in
geschweiften Klammern. Innerhalb von Modulen können wir andere Module
platzieren, wie in diesem Fall mit den Modulen <code>hosting</code> und <code>serving</code>. Module
können auch Definitionen für andere Elemente enthalten, wie Strukturen,
Aufzählungen, Konstanten, Merkmalen und – wie in Codeblock 7-1 –
Funktionen.</p>
<p>Durch die Verwendung von Modulen können wir verwandte Definitionen gruppieren
und angeben, warum sie verwandt sind. Programmierer, die diesen Code verwenden,
können anhand der Gruppen durch den Code navigieren, anstatt alle Definitionen
lesen zu müssen, und finden so leichter die für sie relevanten Definitionen.
Programmierer, die diesem Code neue Funktionalität hinzufügen, wissen, wo sie
den Code platzieren müssen, damit das Programm übersichtlich bleibt.</p>
<p>Vorhin haben wir erwähnt, dass <em>src/main.rs</em> und <em>src/lib.rs</em> als Kistenwurzel
bezeichnet werden. Der Grund für ihren Namen ist, dass der Inhalt dieser beiden
Dateien ein Modul namens <code>crate</code> an der Wurzel der Modulstruktur der Kiste
bilden, die als <em>Modulbaum</em> bekannt ist.</p>
<p>Codeblock 7-2 zeigt den Modulbaum für die Struktur in Codeblock 7-1.</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Codeblock 7-2: Modulbaum für den Code in Codeblock
7-1</span></p>
<p>Dieser Baum zeigt, wie einige der Module ineinander verschachtelt sind; z.B.
ist <code>hosting</code> innerhalb von <code>front_of_house</code>. Der Baum zeigt auch, dass einige
Module <em>Geschwister</em> voneinander sind, was bedeutet, dass sie im selben Modul
definiert sind; <code>hosting</code> und <code>serving</code> sind Geschwister, die innerhalb von
<code>front_of_house</code> definiert sind. Wenn Modul A innerhalb von Modul B enthalten
ist, sagen wir, dass Modul A das <em>Kind</em> (child) von Modul B ist und dass Modul
B der <em>Elternteil</em> (parent) von Modul A ist. Beachte, dass der gesamte
Modulbaum als Wurzel das implizite Modul namens <code>crate</code> hat.</p>
<p>Der Modulbaum könnte dich an den Verzeichnisbaum des Dateisystems auf deinem
Computer erinnern; dies ist ein sehr treffender Vergleich! Genau wie
Verzeichnisse in einem Dateisystem verwendest du Module, um deinen Code zu
organisieren. Und genau wie Dateien in einem Verzeichnis brauchen wir einen
Weg, unsere Module zu finden.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mit-pfaden-auf-ein-element-im-modulbaum-verweisen"><a class="header" href="#mit-pfaden-auf-ein-element-im-modulbaum-verweisen">Mit Pfaden auf ein Element im Modulbaum verweisen</a></h2>
<p>Um Rust zu zeigen, wo ein Element in einem Modulbaum zu finden ist, verwenden
wir einen Pfad, auf gleiche Weise wie beim Navigieren durch ein Dateisystem.
Um eine Funktion aufzurufen, müssen wir ihren Pfad kennen.</p>
<p>Ein Pfad kann zwei Formen annehmen:</p>
<ul>
<li>Ein <em>absoluter Pfad</em> ist der vollständige Pfad ausgehend von einer
Kistenwurzel; für Code aus einer externen Kiste beginnt der absolute Pfad mit
der Kistenwurzel, und für Code aus der aktuellen Kiste beginnt er mit dem
Literal <code>crate</code>.</li>
<li>Ein <em>relativer Pfad</em> startet beim aktuellen Modul und benutzt <code>self</code>, <code>super</code>
oder einen Bezeichner im aktuellen Modul.</li>
</ul>
<p>Sowohl absolute als auch relative Pfade bestehen aus einem oder mehreren
Bezeichnern, die durch doppelte Doppelpunkte (<code>::</code>) getrennt sind.</p>
<p>Um zu Codeblock 7-1 zurückzukehren, nehmen wir an, wir wollen die Funktion
<code>add_to_waitlist</code> aufrufen. Das ist dasselbe wie die Frage, wie der Pfad der
Funktion <code>add_to_waitlist</code> ist. Codeblock 7-3 enthält Codeblock 7-1, wobei
einige Module und Funktionen entfernt wurden.</p>
<p>Wir zeigen zwei Möglichkeiten, wie die Funktion <code>add_to_waitlist</code> von einer
neuen Funktion <code>eat_at_restaurant</code> aus aufgerufen werden kann, die in der
Kistenwurzel definiert ist. Diese Pfade sind korrekt, aber es gibt noch ein
weiteres Problem, das verhindert, dass dieses Beispiel in dieser Form
kompiliert. Wir werden gleich erklären, warum.</p>
<p>Die Funktion <code>eat_at_restaurant</code> ist Teil der öffentlichen
Programmierschnittstelle (API) unserer Bibliothekskiste, daher markieren wir
sie mit dem Schlüsselwort <code>pub</code>. Im Abschnitt <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#pfade-mit-dem-schl%C3%BCsselwort-pub-%C3%B6ffnen">„Pfade mit dem Schlüsselwort
<code>pub</code> öffnen“</a> gehen wir näher auf <code>pub</code> ein.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // absoluter Pfad
    crate::front_of_house::hosting::add_to_waitlist();

    // relativer Pfad
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-3: Aufruf der Funktion <code>add_to_waitlist</code>
mittels absoluter und relativer Pfade</span></p>
<p>Beim ersten Aufruf der Funktion <code>add_to_waitlist</code> in <code>eat_at_restaurant</code>
verwenden wir einen absoluten Pfad. Die Funktion <code>add_to_waitlist</code> ist in der
gleichen Kiste definiert wie <code>eat_at_restaurant</code>, daher können wir das
Schlüsselwort <code>crate</code> verwenden, um einen absoluten Pfad zu beginnen. Dann
geben wir jedes der aufeinanderfolgenden Module an, bis wir <code>add_to_waitlist</code>
erreichen. Du kannst dir ein Dateisystem mit der gleichen Struktur vorstellen:
Wir würden den Pfad <code>/front_of_house/hosting/add_to_waitlist</code> angeben, um das
Programm <code>add_to_waitlist</code> auszuführen; das Verwenden des Namens <code>crate</code>, um
von der Kistenwurzel aus zu beginnen, ist analog zu <code>/</code>, um vom
Dateisystem-Wurzelverzeichnis in deiner Eingabeaufforderung aus zu beginnen.</p>
<p>Beim zweiten Aufruf von <code>add_to_waitlist</code> in <code>eat_at_restaurant</code> verwenden wir
einen relativen Pfad. Der Pfad beginnt mit <code>front_of_house</code>, dem Namen des
Moduls, das auf der gleichen Ebene des Modulbaums definiert ist wie
<code>eat_at_restaurant</code>. Hier wäre das Dateisystem-Äquivalent die Verwendung des
Pfades <code>front_of_house/hosting/add_to_waitlist</code>. Mit einem Modulnamen zu
beginnen bedeutet, dass der Pfad relativ ist.</p>
<p>Die Überlegung, ob ein relativer oder absoluter Pfad verwendet wird, ist eine
Entscheidung, die du auf Basis deines Projekts treffen wirst, und hängt davon
ab, ob du den Code für die Elementdefinition eher separat oder zusammen mit dem
Code ablegen möchtest, der das Element verwendet. Wenn wir zum Beispiel das
Modul <code>front_of_house</code> und die Funktion <code>eat_at_restaurant</code> in ein Modul namens
<code>customer_experience</code> verschieben, müssten wir den absoluten Pfad in
<code>add_to_waitlist</code> ändern, aber der relative Pfad wäre immer noch gültig. Wenn
wir jedoch die Funktion <code>eat_at_restaurant</code> in ein separates Modul namens
<code>dining</code> verschieben würden, würde der absolute Pfad beim Aufruf
<code>add_to_waitlist</code> gleich bleiben, aber der relative Pfad müsste aktualisiert
werden. Wir bevorzugen generell die Angabe absoluter Pfade, da es
wahrscheinlicher ist, dass Codedefinitionen und Elementaufrufe unabhängig
voneinander verschoben werden.</p>
<p>Lass uns versuchen, Codeblock 7-3 zu kompilieren, und herausfinden, warum er
sich noch nicht kompilieren lässt! Der Fehler, den wir erhalten, ist in
Codeblock 7-4 zu sehen.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">Codeblock 7-4: Kompilierfehler im Code in Codeblock
7-3</span></p>
<p>Die Fehlermeldungen besagen, dass das Modul <code>hosting</code> privat ist. Mit anderen
Worten, wir haben die korrekten Pfade für das Modul <code>hosting</code> und die Funktion
<code>add_to_waitlist</code> angegeben, aber Rust lässt sie uns nicht nutzen, weil es
keinen Zugriff auf die privaten Abschnitte hat. In Rust sind alle Elemente
(Funktionen, Methoden, Strukturen, Aufzählungen, Module und Konstanten)
standardmäßig privat für übergeordnete Module. Wenn du ein Element wie eine
Funktion oder Struktur privat machen willst, setze es in ein Modul.</p>
<p>Objekte in einem übergeordneten Modul können die privaten Objekte in
untergeordneten Modulen nicht verwenden, aber Objekte in untergeordneten
Modulen können die Objekte in ihren übergeordneten Modulen verwenden. Der Grund
dafür ist, dass untergeordnete Module ihre Implementierungsdetails ein- und
ausblenden, aber die untergeordneten Module können den Gültigkeitsbereich
sehen, in dem sie definiert sind. Um mit unserer Metapher fortzufahren, stelle
dir die Datenschutzregeln wie das Backoffice eines Restaurants vor: Was dort
drinnen passiert, ist für Restaurantkunden privat, aber Büroleiter können alles
im Restaurant, in dem sie arbeiten, sehen und tun.</p>
<p>Rust entschied sich dafür, das Modulsystem auf diese Weise funktionieren zu
lassen, sodass das Ausblenden innerer Implementierungsdetails die Vorgabe ist.
Auf diese Weise weißt du, welche Teile des inneren Codes du ändern kannst, ohne
den äußeren Code zu brechen. Rust gibt dir jedoch die Möglichkeit, innere Teile
des Codes von Kindmodulen für äußere Vorgängermodule offenzulegen, indem du das
Schlüsselwort <code>pub</code> verwendest, um ein Element öffentlich zu machen.</p>
<h3 id="pfade-mit-dem-schlüsselwort-pub-öffnen"><a class="header" href="#pfade-mit-dem-schlüsselwort-pub-öffnen">Pfade mit dem Schlüsselwort <code>pub</code> öffnen</a></h3>
<p>Kehren wir zum Fehler in Codeblock 7-4 zurück, der uns sagte, das Modul
<code>hosting</code> sei privat. Wir wollen, dass die Funktion <code>eat_at_restaurant</code> im
übergeordneten Modul Zugriff auf die Funktion <code>add_to_waitlist</code> im
untergeordneten Modul hat, also markieren wir das Modul <code>hosting</code> mit dem
Schlüsselwort <code>pub</code>, wie in Codeblock 7-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolutet Pfad
    crate::front_of_house::hosting::add_to_waitlist();

    // Relativer Pfad
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-5: Deklarieren des Moduls <code>hosting</code> als
<code>pub</code>, um es von <code>eat_at_restaurant</code> aus zu benutzen</span></p>
<p>Leider führt der Code in Codeblock 7-5 immer noch zu einem Fehler, wie
Codeblock 7-6 zeigt.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">Codeblock 7-6: Kompilierfehler im Code in Codeblock
7-5</span></p>
<p>Was ist passiert? Das Hinzufügen des Schlüsselworts <code>pub</code> vor <code>mod hosting</code>
macht das Modul öffentlich. Wenn wir auf <code>front_of_house</code> zugreifen können,
können wir mit dieser Änderung auch auf <code>hosting</code> zugreifen. Aber die <em>Inhalte</em>
von <code>hosting</code> sind immer noch privat; das Modul öffentlich zu machen, macht
seinen Inhalt nicht öffentlich. Das Schlüsselwort <code>pub</code> für ein Modul erlaubt
es dem Code in seinen Vorgängermodulen nur, auf das Modul zu referenzieren,
nicht aber auf seinen inneren Code zuzugreifen. Da Module Container sind,
können wir nicht viel tun, indem wir nur das Modul öffentlich machen; wir
müssen weiter gehen und eines oder mehrere der Elemente innerhalb des Moduls
ebenfalls öffentlich machen.</p>
<p>Die Fehler in Codeblock 7-6 besagen, dass die Funktion <code>add_to_waitlist</code> privat
ist. Die Datenschutzregeln gelten für Strukturen, Aufzählungen, Funktionen und
Methoden sowie für Module.</p>
<p>Lass uns auch die Funktion <code>add_to_waitlist</code> öffentlich machen, indem wir das
Schlüsselwort <code>pub</code> vor ihre Definition hinzufügen, wie in Codeblock 7-7.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // absoluter Path
    crate::front_of_house::hosting::add_to_waitlist();

    // relativer Path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Codeblock 7-7: Das Hinzufügen des Schlüsselworts <code>pub</code> zu
<code>mod hosting</code> und <code>fn add_to_waitlist</code> lässt uns die Funktion in
<code>eat_at_restaurant</code> aufrufen</span></p>
<p>Jetzt kompiliert der Code! Um zu sehen, warum das Hinzufügen des Schlüsselworts
<code>pub</code> uns erlaubt, diese Pfade in <code>add_to_waitlist</code> im Hinblick auf die
Datenschutzregeln zu verwenden, sehen wir uns die absoluten und relativen Pfade
an.</p>
<p>Auf dem absoluten Pfad beginnen wir mit <code>crate</code>, der Wurzel des Modulbaums
unserer Kiste. Dann wird das Modul <code>front_of_house</code> in der Kistenwurzel
definiert. Während das Modul <code>front_of_house</code> nicht öffentlich ist, weil die
<code>eat_at_restaurant</code>-Funktion im gleichen Modul wie <code>front_of_house</code> definiert
ist (d.h. <code>eat_at_restaurant</code> und <code>front_of_house</code> sind Geschwister), können
wir auf <code>front_of_house</code> von <code>eat_at_restaurant</code> aus zugreifen. Als nächstes
wird das Modul <code>hosting</code> mit <code>pub</code> gekennzeichnet. Wir können auf das
übergeordnete Modul von <code>hosting</code> zugreifen, also können wir auf <code>hosting</code>
zugreifen. Schließlich wird die Funktion <code>add_to_waitlist</code> mit <code>pub</code> markiert
und wir können auf ihr Elternmodul zugreifen, sodass dieser Funktionsaufruf
klappt!</p>
<p>Beim relativen Pfad ist die Logik die gleiche wie beim absoluten Pfad, mit
Ausnahme des ersten Schritts: Anstatt von der Kistenwurzel auszugehen, beginnt
der Pfad mit <code>front_of_house</code>. Das Modul <code>front_of_house</code> wird innerhalb
desselben Moduls wie <code>eat_at_restaurant</code> definiert, sodass der relative Pfad
ausgehend vom Modul, in dem <code>eat_at_restaurant</code> definiert ist, funktioniert.
Weil <code>hosting</code> und <code>add_to_waitlist</code> nun mit <code>pub</code> markiert sind, funktioniert
der Rest des Pfades, und dieser Funktionsaufruf ist gültig!</p>
<p>Wenn du vorhast, deine Bibliothekskiste weiterzugeben, damit andere Projekte
deinen Code verwenden können, ist deine öffentliche API deine Übereinkunft mit den
Benutzern deiner Kiste, die festlegt, wie sie mit deinem Code interagieren
können. Es gibt viele Überlegungen zum Umgang mit Änderungen an deiner
öffentlichen API, um es für andere einfacher zu machen, sich auf deine Kiste zu
verlassen. Diese Überlegungen liegen außerhalb des Rahmens dieses Buches; wenn
du an diesem Thema interessiert bist, lies <a href="https://rust-lang.github.io/api-guidelines/">The Rust API
Guidelines</a>.</p>
<blockquote>
<h4 id="bewährte-praktiken-für-pakete-mit-einer-binärdatei-und-einer-bibliothek"><a class="header" href="#bewährte-praktiken-für-pakete-mit-einer-binärdatei-und-einer-bibliothek">Bewährte Praktiken für Pakete mit einer Binärdatei und einer Bibliothek</a></h4>
<p>Wir haben bereits erwähnt, dass ein Paket sowohl eine Binärkistenwurzel
<em>src/main.rs</em> als auch eine Bibliothekskistenwurzel <em>src/lib.rs</em> enthalten
kann, und beide Kisten tragen standardmäßig den Paketnamen. Normalerweise
haben Pakete mit diesem Muster, die sowohl eine Bibliothek als auch eine
Binärkiste enthalten, gerade genug Code in der Binärkiste, um eine
ausführbare Datei zu starten, die Code aus der Bibliothekskiste aufruft.
Dadurch können andere Projekte von den meisten Funktionen des Pakets
profitieren, da der Code der Bibliothekskiste gemeinsam genutzt werden kann.</p>
<p>Der Modulbaum sollte in <em>src/lib.rs</em> definiert werden. Dann können alle
öffentlichen Elemente in der Binärkiste verwendet werden, indem die Pfade
mit dem Namen des Pakets beginnen. Die binäre Kiste wird zu einem Benutzer
der Bibliothekskiste, so wie eine vollständig externe Kiste die
Bibliothekskiste verwenden würde: Sie kann nur die öffentliche API
verwenden. Dies hilft dir, eine gute API zu entwerfen; Du bist nicht nur der
Autor, sondern auch ein Kunde!</p>
<p>In <a href="ch12-00-an-io-project.html">Kapitel 12</a> werden wir diese organisatorische Praxis anhand eines
Befehlszeilenprogramms demonstrieren, das sowohl eine Binärkiste als auch
eine Bibliothekskiste enthält.</p>
</blockquote>
<h3 id="relative-pfade-mit-super-beginnen"><a class="header" href="#relative-pfade-mit-super-beginnen">Relative Pfade mit <code>super</code> beginnen</a></h3>
<p>Wir können relative Pfade konstruieren, die im übergeordneten Modul beginnen
und nicht im aktuellen Modul oder der Kistenwurzel, indem wir <code>super</code> am Anfang
des Pfades verwenden. Dies ist so, als würde man einen Dateisystempfad mit der
Syntax <code>..</code> beginnen. Das Verwenden von <code>super</code> erlaubt es uns, auf ein Element
zu referenzieren, von dem wir wissen, dass es sich im übergeordneten Modul
befindet, was die Neuordnung des Modulbaums erleichtern kann, wenn das Modul
eng mit dem übergeordneten Modul verwandt ist, aber das übergeordnete Modul
eines Tages an eine andere Stelle im Modulbaum verschoben werden könnte.</p>
<p>Betrachte den Code in Codeblock 7-8, der die Situation nachbildet, in der ein
Koch eine falsche Bestellung korrigiert und persönlich zum Kunden bringt. Die
Funktion <code>fix_incorrect_order</code>, die im Modul <code>back_of_house</code> definiert ist,
ruft die im übergeordneten Modul definierte Funktion <code>deliver_order</code> auf, indem
sie den Pfad zu <code>deliver_order</code> angibt, der mit <code>super</code> beginnt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-8: Aufrufen einer Funktion unter Verwendung
eines relativen Pfades, der mit <code>super</code> beginnt</span></p>
<p>Die Funktion <code>fix_incorrect_order</code> befindet sich im Modul <code>back_of_house</code>,
sodass wir <code>super</code> benutzen können, um zum Elternmodul von <code>back_of_house</code> zu
gelangen, was in diesem Fall die Wurzel <code>crate</code> ist. Von dort aus suchen wir
nach <code>deliver_order</code> und finden es. Erfolg! Wir denken, dass das Modul
<code>back_of_house</code> und die Funktion <code>deliver_order</code> wahrscheinlich in der gleichen Beziehung zueinander stehen und zusammen verschoben werden, sollten wir uns dazu
entschließen, den Modulbaum der Kiste neu zu organisieren. Deshalb haben wir
<code>super</code> verwendet, sodass wir in Zukunft weniger Codestellen zu aktualisieren
haben, wenn dieser Code in ein anderes Modul verschoben wird.</p>
<h3 id="strukturen-und-aufzählungen-öffentlich-machen"><a class="header" href="#strukturen-und-aufzählungen-öffentlich-machen">Strukturen und Aufzählungen öffentlich machen</a></h3>
<p>Wir können auch <code>pub</code> verwenden, um Strukturen und Aufzählungen als öffentlich
zu kennzeichnen, aber es gibt ein paar zusätzliche Details zur Verwendung von
<code>pub</code> mit Strukturen und Aufzählungen. Wenn wir <code>pub</code> vor einer
Struktur-Definition verwenden, machen wir die Struktur öffentlich, aber die
Felder der Struktur sind immer noch privat. Wir können jedes Feld von Fall zu
Fall öffentlich machen oder auch nicht. In Codeblock 7-9 haben wir eine
öffentliche Struktur <code>back_of_house::Breakfast</code> mit einem öffentlichen Feld
<code>toast</code>, aber einem privaten Feld <code>seasonal_fruit</code> definiert. Dies ist der Fall
in einem Restaurant, in dem der Kunde die Brotsorte auswählen kann, die zu
einer Mahlzeit gehört, aber der Küchenchef entscheidet, welche Früchte die
Mahlzeit begleiten, je nach Saison und Vorrat. Das verfügbare Obst ändert sich
schnell, sodass die Kunden nicht wählen oder gar sehen können, welches Obst sie
bekommen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;Pfirsiche&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Bestelle im Sommer ein Frühstück mit Roggentoast
    let mut meal = back_of_house::Breakfast::summer(&quot;Roggen&quot;);
    // Ändere unsere Meinung darüber, welche Brotsorte wir gerne hätten
    meal.toast = String::from(&quot;Weizen&quot;);
    println!(&quot;Ich möchte {}-Toast&quot;, meal.toast);

    // Die nächste Zeile lässt sich nicht kompilieren, wenn wir sie nicht
    // auskommentieren; wir dürfen die Früchte der Saison, die wir mit der
    // Mahlzeit bekommen, weder sehen noch verändern.
    // meal.seasonal_fruit = String::from(&quot;Heidelbeeren&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-9: Eine Struktur mit öffentlichen und
privaten Feldern</span></p>
<p>Da das Feld <code>toast</code> in der Struktur <code>back_of_house::Breakfast</code> öffentlich ist,
können wir in <code>eat_at_restaurant</code> in das Feld <code>toast</code> schreiben und lesen,
indem wir die Punktnotation verwenden. Beachte, dass wir das Feld
<code>seasonal_fruit</code> in <code>eat_at_restaurant</code> nicht verwenden können, weil
<code>seasonal_fruit</code> privat ist. Versuche, die Kommentarzeichen in der Zeile, die
den Feldwert <code>seasonal_fruit</code> modifiziert, zu entfernen, um zu sehen, welchen
Fehler du erhältst!</p>
<p>Beachte auch, dass, weil <code>back_of_house::Breakfast</code> ein privates Feld hat, die
Struktur eine öffentliche Funktion (hier haben wir sie <code>summer</code> genannt) zum
Erzeugen einer Instanz von <code>Breakfast</code> bereitstellen muss. Wenn <code>Breakfast</code>
keine solche Funktion hätte, könnten wir keine Instanz von <code>Breakfast</code> in
<code>eat_at_restaurant</code> erzeugen, weil wir den Wert des privaten Feldes
<code>seasonal_fruit</code> in <code>eat_at_restaurant</code> nicht setzen könnten.</p>
<p>Wenn wir dagegen eine Aufzählung veröffentlichen, dann sind alle ihre
Varianten öffentlich. Wir brauchen nur das Schlüsselwort <code>pub</code> vor dem
Schlüsselwort <code>enum</code>, wie in Codeblock 7-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-10: Kennzeichnen einer Aufzählung als
öffentlich macht alle ihre Varianten öffentlich</span></p>
<p>Da wir die Aufzählung <code>Appetizer</code> öffentlich gemacht haben, können wir die
Varianten <code>Soup</code> und <code>Salad</code> in <code>eat_at_restaurant</code> verwenden.</p>
<p>Aufzählungen wären ohne öffentliche Varianten nicht sehr nützlich; es wäre
ärgerlich, alle Aufzählungs-Varianten stets mit <code>pub</code> annotieren zu müssen,
daher sind die Aufzählungs-Varianten standardmäßig öffentlich. Strukturen sind
auch ohne öffentliche Felder nützlich, daher folgen Strukturfelder
standardmäßig der allgemeinen Regel, dass alles privat ist, es sei denn, es
wird mit <code>pub</code> annotiert.</p>
<p>Es gibt noch eine weitere Situation mit <code>pub</code>, die wir noch nicht behandelt
haben, und das ist unser letztes Modulsystem-Feature: Das Schlüsselwort <code>use</code>.
Zuerst werden wir <code>use</code> an sich behandeln, und dann zeigen wir, wie man <code>pub</code>
und <code>use</code> kombiniert.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfade-in-den-gültigkeitsbereich-bringen-mit-dem-schlüsselwort-use"><a class="header" href="#pfade-in-den-gültigkeitsbereich-bringen-mit-dem-schlüsselwort-use">Pfade in den Gültigkeitsbereich bringen mit dem Schlüsselwort <code>use</code></a></h2>
<p>Die Pfade für den Aufruf von Funktionen auszuschreiben, kann lästig sein und
sich wiederholen. In Codeblock 7-7 mussten wir, unabhängig davon, ob wir den
absoluten oder relativen Pfad zur Funktion <code>add_to_waitlist</code> wählten, jedes
Mal, wenn wir <code>add_to_waitlist</code> aufrufen wollten, auch <code>front_of_house</code> und
<code>hosting</code> angeben. Glücklicherweise gibt es eine Möglichkeit, diesen Vorgang zu
vereinfachen: Wir können eine Verknüpfung zu einem Pfad mit dem Schlüsselwort
<code>use</code> einmal erstellen und dann den kürzeren Namen überall sonst im
Gültigkeitsbereich verwenden.</p>
<p>In Codeblock 7-11 bringen wir das Modul <code>crate::front_of_house::hosting</code> in den
Gültigkeitsbereich der Funktion <code>eat_at_restaurant</code>, sodass wir nur noch
<code>hosting::add_to_waitlist</code> angeben müssen, um die Funktion <code>add_to_waitlist</code> in
<code>eat_at_restaurant</code> aufzurufen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Codeblock 7-11: Ein Modul mit <code>use</code> in den
Gültigkeitsbereich bringen</span></p>
<p>Das Angeben von <code>use</code> und einem Pfad in einem Gültigkeitsbereich ist ähnlich
dem Erstellen eines symbolischen Links im Dateisystem. Durch Hinzufügen von
<code>use crate::front_of_house::hosting</code> in der Kistenwurzel ist <code>hosting</code> nun ein
gültiger Name in diesem Gültigkeitsbereich, so als wäre das Modul <code>hosting</code> in
der Kistenwurzel definiert worden. Pfade, die mit <code>use</code> in den
Gültigkeitsbereich gebracht werden, überprüfen wie alle anderen Pfade auch die
Privatsphäre.</p>
<p>Beachte, dass <code>use</code> nur die Verknüpfung für den jeweiligen Gültigkeitsbereich
erstellt, in dem <code>use</code> vorkommt. Codeblock 7-12 verschiebt die Funktion
<code>eat_at_restaurant</code> in ein neues untergeordnetes Modul namens <code>customer</code>, das
dann einen anderen Gültigkeitsbereich als die <code>use</code>-Anweisung hat, sodass der
Funktionsrumpf nicht kompiliert werden kann:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness does_not_compile">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
<p><span class="caption">Codeblock 7-12: Eine <code>use</code>-Anweisung gilt nur in dem
Gültigkeitsbereich, in dem sie steht</span></p>
<p>Der Compilerfehler zeigt, dass die Verknüpfung innerhalb des Moduls <code>customer</code>
nicht mehr gilt:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` due to previous error; 1 warning emitted
</code></pre>
<p>Beachte, dass es auch eine Warnung gibt, dass <code>use</code> nicht mehr in seinem
Gültigkeitsbereich verwendet wird! Um dieses Problem zu beheben, verschiebe
<code>use</code> auch innerhalb des Moduls <code>customer</code>, oder referenziere die Verknüpfung
im übergeordneten Modul mit <code>super::hosting</code> innerhalb des untergeordneten
Moduls <code>customer</code>.</p>
<h3 id="idiomatische-use-pfade-erstellen"><a class="header" href="#idiomatische-use-pfade-erstellen">Idiomatische <code>use</code>-Pfade erstellen</a></h3>
<p>In Codeblock 7-11 hast du dich vielleicht gefragt, warum wir <code>use crate::front_of_house::hosting</code> angegeben und dann <code>hosting::add_to_waitlist</code>
in <code>eat_at_restaurant</code> aufgerufen haben, anstatt den <code>use</code>-Pfad bis hin zur
Funktion <code>add_to_waitlist</code> anzugeben, um dasselbe Ergebnis zu erzielen wie in
Codeblock 7-13.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
<p><span class="caption">Codeblock 7-13: Die Funktion <code>add_to_waitlist</code> mit <code>use</code>
in den Gültigkeitsbereich bringen ist nicht idiomatisch.</span></p>
<p>Obwohl sowohl Codeblock 7-11 als auch Codeblock 7-13 die gleiche Aufgabe
erfüllen, ist Codeblock 7-11 der idiomatische Weg, eine Funktion mit <code>use</code> in
den Gültigkeitsbereich zu bringen. Wenn wir das Elternmodul der Funktion mit
<code>use</code> in den Gültigkeitsbereich bringen, sodass wir das Elternmodul beim Aufruf
der Funktion angeben müssen, wird klar, dass die Funktion nicht lokal definiert
ist, während gleichzeitig die Wiederholung des vollständigen Pfades minimiert
wird. Im Code in Codeblock 7-13 ist unklar, wo <code>add_to_waitlist</code> definiert ist.</p>
<p>Wenn andererseits Strukturen, Aufzählungen und andere Elemente mit <code>use</code>
eingebracht werden, ist es idiomatisch, den vollständigen Pfad anzugeben.
Codeblock 7-14 zeigt den idiomatischen Weg, die Struktur <code>HashMap</code> der
Standardbibliothek in den Gültigkeitsbereich einer binären Kiste zu bringen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
<p><span class="caption">Codeblock 7-14: <code>HashMap</code> auf idiomatische Weise in den
Gültigkeitsbereich bringen</span></p>
<p>Es gibt keinen triftigen Grund für dieses Idiom: Es ist einfach eine
Konvention, die entstanden ist, und die Leute haben sich daran gewöhnt,
Rust-Code auf diese Weise zu lesen und zu schreiben.</p>
<p>Die Ausnahme von diesem Idiom ist, wenn wir zwei gleichnamige Elemente mit
<code>use</code> in den Gültigkeitsbereich bringen, denn das lässt Rust nicht zu. In
Codeblock 7-15 wird gezeigt, wie zwei <code>Result</code>-Typen mit gleichem Namen, aber
unterschiedlichen Elternmodulen in den Gültigkeitsbereich gebracht werden und
wie auf sie verwiesen werden kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --abschneiden--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --abschneiden--
<span class="boring">    Ok(())
</span>}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-15: Um zwei Typen mit dem gleichen Namen in
denselben Gültigkeitsbereich zu bringen, müssen ihre übergeordneten Module
angegeben werden.</span></p>
<p>Wie du sehen kannst, unterscheidet die Verwendung der übergeordneten Module die
beiden <code>Result</code>-Typen. Wenn wir stattdessen <code>use std::fmt::Result</code> und
<code>use std::io::Result</code> angeben würden, hätten wir zwei <code>Result</code>-Typen im selben
Gültigkeitsbereich und Rust wüsste nicht, welchen wir beim Verwenden von
<code>Result</code> meinten.</p>
<h3 id="mit-dem-schlüsselwort-as-neue-namen-vergeben"><a class="header" href="#mit-dem-schlüsselwort-as-neue-namen-vergeben">Mit dem Schlüsselwort <code>as</code> neue Namen vergeben</a></h3>
<p>Es gibt eine andere Lösung für das Problem, zwei Typen desselben Namens mit
<code>use</code> in den gleichen Gültigkeitsbereich zu bringen: Hinter dem Pfad können wir
<code>as</code> und einen neuen lokalen Namen oder <em>Alias</em> für den Typ angeben. Codeblock
7-16 zeigt eine weitere Möglichkeit, den Code in Codeblock 7-15 zu schreiben,
indem einer der beiden <code>Result</code>-Typen mittels <code>as</code> umbenannt wird.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --abschneiden--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --abschneiden--
<span class="boring">    Ok(())
</span>}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-16: Umbenennen eines Typs, wenn er mit dem
Schlüsselwort <code>as</code> in den Gültigkeitsbereich gebracht wird</span></p>
<p>In der zweiten <code>use</code>-Anweisung wählten wir den neuen Namen <code>IoResult</code> für den
Typ <code>std::io::Result</code>, der nicht im Konflikt zum ebenfalls von uns in den
Gültigkeitsbereich gebrachten <code>Result</code> aus <code>std::fmt</code> steht. Codeblock 7-15
und Codeblock 7-16 gelten als idiomatisch, die Wahl liegt also bei dir!</p>
<h3 id="rück-exportieren-von-namen-mit-pub-use"><a class="header" href="#rück-exportieren-von-namen-mit-pub-use">Rück-Exportieren von Namen mit <code>pub use</code></a></h3>
<p>Wenn wir einen Namen mit dem Schlüsselwort <code>use</code> in den Gültigkeitsbereich
bringen, ist der im neuen Gültigkeitsbereich verfügbare Name privat. Damit der
Code, der unseren Code aufruft, auf diesen Namen verweisen kann, als wäre er im
Gültigkeitsbereich dieses Codes definiert worden, können wir <code>pub</code> und <code>use</code>
kombinieren. Diese Technik wird <em>Rück-Exportieren</em> (re-exporting) genannt, weil
wir ein Element in den Gültigkeitsbereich bringen, dieses Element aber auch
anderen zur Verfügung stellen, um es in ihren Gültigkeitsbereich zu bringen.</p>
<p>Codeblock 7-17 zeigt den Code in Codeblock 7-11, wobei <code>use</code> im Wurzelmodul in
<code>pub use</code> geändert wurde.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Codeblock 7-17: Bereitstellen eines Namens für externen
Code zum Verwenden in einem neuen Gültigkeitsbereich mit <code>pub use</code></span></p>
<p>Vor dieser Änderung musste externer Code die Funktion <code>add_to_waitlist</code> mit dem
Pfad <code>restaurant::front_of_house::hosting::add_to_waitlist()</code> aufrufen. Nun, da
<code>pub use</code> das Modul <code>hosting</code> aus dem Wurzel-Modul re-exportiert hat, kann
externer Code nun stattdessen den Pfad <code>restaurant::hosting::add_to_waitlist()</code>
verwenden.</p>
<p>Der Rück-Export ist nützlich, wenn sich die interne Struktur deines Codes von
dem unterscheidet, wie Programmierer, die deinen Code
aufrufen, über die Domäne denken würden. In der Restaurantmetapher denken die
Betreiber des Restaurants zum Beispiel an die „Vorderseite des Hauses“ und die
„Rückseite des Hauses“. Mit <code>pub use</code> können wir unseren Code mit einer
Struktur schreiben, aber eine andere Struktur veröffentlichen. Auf diese Weise
ist unsere Bibliothek für Programmierer, die an der Bibliothek arbeiten, und
Programmierer, die die Bibliothek aufrufen, gut organisiert. Ein weiteres
Beispiel für <code>pub use</code> und wie es sich auf die Dokumentation deiner Kiste
auswirkt, werden wir im Abschnitt <a href="ch14-02-publishing-to-crates-io.html#mit-pub-use-eine-benutzerfreundliche-%C3%B6ffentliche-api-exportieren">„Mit <code>pub use</code> eine benutzerfreundliche
öffentliche API exportieren“</a> in Kapitel 14 betrachten.</p>
<h3 id="verwenden-externer-pakete"><a class="header" href="#verwenden-externer-pakete">Verwenden externer Pakete</a></h3>
<p>In Kapitel 2 programmierten wir ein Ratespielprojekt, das ein externes Paket
namens <code>rand</code> benutzte, um Zufallszahlen zu generieren. Um <code>rand</code> in unserem
Projekt zu verwenden, fügten wir diese Zeile zu <em>Cargo.toml</em> hinzu:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<p>Das Hinzufügen von <code>rand</code> als Abhängigkeit in <em>Cargo.toml</em> weist Cargo an, das
Paket <code>rand</code> und alle Abhängigkeiten von <a href="https://crates.io/">crates.io</a>
herunterzuladen und <code>rand</code> für unser Projekt verfügbar zu machen.</p>
<p>Um dann Definitionen von <code>rand</code> in den Gültigkeitsbereich unseres Pakets
aufzunehmen, haben wir eine Zeile mit <code>use</code> hinzugefügt, die mit dem
Kistennamen <code>rand</code> beginnt und die Elemente auflistet, die wir in den
Gültigkeitsbereich bringen wollten. Erinnere dich, dass wir im Abschnitt
<a href="ch02-00-guessing-game-tutorial.html#generieren-einer-geheimzahl">„Generieren einer Geheimzahl“</a> in Kapitel 2 das Merkmal <code>Rng</code> in den
Gültigkeitsbereich gebracht und die Funktion <code>rand::thread_rng</code> aufgerufen
haben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!(&quot;Die geheime Zahl ist: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Vermutung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen einer Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geraten: {}&quot;, guess);
</span>}</code></pre></pre>
<p>Mitglieder der Rust-Gemeinschaft haben viele Pakete unter
<a href="https://crates.io/">crates.io</a> zur Verfügung gestellt und wenn du eines davon
in dein Paket aufnimmst, sind die gleichen Schritte erforderlich: Liste sie
in der Datei <em>Cargo.toml</em> deines Pakets auf und verwende <code>use</code>, um Elemente aus
ihren Kisten in den Gültigkeitsbereich zu bringen.</p>
<p>Beachte, dass die Standardbibliothek <code>std</code> ebenfalls eine Kiste ist, die nicht
zu unserem Paket gehört. Da die Standardbibliothek mit der Sprache Rust
ausgeliefert wird, brauchen wir <em>Cargo.toml</em> nicht zu ändern, um <code>std</code>
einzubinden. Aber wir müssen <code>use</code> verwenden, um Elemente von dort in den
Gültigkeitsbereich unseres Pakets zu bringen. Zum Beispiel würden wir für
<code>HashMap</code> diese Zeile verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>Dies ist ein absoluter Pfad, der mit <code>std</code>, dem Namen der
Standard-Bibliothekskiste, beginnt.</p>
<h3 id="verschachtelte-pfade-verwenden-um-lange-use-listen-zu-vereinfachen"><a class="header" href="#verschachtelte-pfade-verwenden-um-lange-use-listen-zu-vereinfachen">Verschachtelte Pfade verwenden, um lange <code>use</code>-Listen zu vereinfachen</a></h3>
<p>Wenn wir mehrere in der gleichen Kiste oder im gleichen Modul definierte
Elemente verwenden, kann das Auflisten jedes Elements in einer eigenen Zeile
viel vertikalen Platz in unseren Dateien einnehmen. Zum Beispiel bringen diese
beiden <code>use</code>-Anweisungen, die wir im Ratespiel in Codeblock 2-4 hatten,
Elemente aus <code>std</code> in den Gültigkeitsbereich:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// --abschneiden--
use std::cmp::Ordering;
use std::io;
// --abschneiden--
<span class="boring">}</span></code></pre></pre>
<p>Stattdessen können wir verschachtelte Pfade verwenden, um die gleichen Elemente
in einer Zeile in den Gültigkeitsbereich zu bringen. Wir tun dies, indem wir
den gemeinsamen Teil des Pfades angeben, gefolgt von zwei Doppelpunkten und
dann geschweiften Klammern um Liste der Pfadteile, die sich unterscheiden, wie
in Codeblock 7-18 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// --abschneiden--
use std::{cmp::Ordering, io};
// --abschneiden--
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-18: Angeben eines verschachtelten Pfades, um
mehrere Elemente mit demselben Präfix in den Gültigkeitsbereich zu
bringen</span></p>
<p>In größeren Programmen kann das Einbeziehen vieler Elemente aus derselben Kiste
oder demselben Modul in den Gültigkeitsbereich durch verschachtelte Pfade die
Anzahl der separaten <code>use</code>-Anweisungen um ein Vielfaches reduzieren!</p>
<p>Wir können einen verschachtelten Pfad auf jeder Ebene in einem Pfad verwenden,
was nützlich ist, wenn zwei <code>use</code>-Anweisungen kombiniert werden, die sich einen
Teilpfad teilen. Beispielsweise zeigt Codeblock 7-19 zwei <code>use</code>-Anweisungen:
Eine, die <code>std::io</code> in den Gültigkeitsbereich bringt, und eine, die
<code>std::io::Write</code> in den Gültigkeitsbereich bringt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Write;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-19: Zwei <code>use</code>-Anweisungen, bei denen eine
ein Teilpfad der anderen ist</span></p>
<p>Der gemeinsame Teil dieser beiden Pfade ist <code>std::io</code> und das ist der
vollständige erste Pfad. Um diese beiden Pfade zu einer einzigen
<code>use</code>-Anweisung zu verschmelzen, können wir <code>self</code> im verschachtelten Pfad
verwenden, wie in Codeblock 7-20 gezeigt wird.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 7-20: Zusammenfassen der Pfade aus Codeblock
7-19 zu einer <code>use</code>-Anweisung</span></p>
<p>Diese Zeile bringt <code>std::io</code> und <code>std::io::Write</code> in den Gültigkeitsbereich.</p>
<h3 id="der-stern-operator-glob"><a class="header" href="#der-stern-operator-glob">Der Stern-Operator (glob)</a></h3>
<p>Wenn wir <em>alle</em> öffentlichen Elemente, die in einem Pfad definiert sind, in den
Gültigkeitsbereich bringen wollen, können wir diesen Pfad gefolgt vom
Stern-Operator <code>*</code> angeben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>Diese <code>use</code>-Anweisung bringt alle öffentlichen Elemente, die in
<code>std::collections</code> definiert sind, in den aktuellen Gültigkeitsbereich. Sei
vorsichtig beim Verwenden des Stern-Operators! Er kann es schwieriger machen,
zu erkennen, welche Namen in den Gültigkeitsbereich fallen und wo ein in deinem
Programm verwendeter Name definiert wurde.</p>
<p>Der Stern-Operator wird oft beim Testen verwendet, um alles, was getestet wird,
in das Modul <code>tests</code> zu bringen. Wir werden darüber im Abschnitt <a href="ch11-01-writing-tests.html">„Tests
schreiben“</a> in Kapitel 11 sprechen. Der Stern-Operator wird
manchmal auch als Teil des Präludiumsmusters (prelude pattern) verwendet: Siehe
<a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">Standardbibliotheksdokumentation</a> für weitere Informationen
zu diesem Muster.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="module-in-verschiedene-dateien-aufteilen"><a class="header" href="#module-in-verschiedene-dateien-aufteilen">Module in verschiedene Dateien aufteilen</a></h2>
<p>Bisher haben alle Beispiele in diesem Kapitel mehrere Module in einer Datei
definiert. Wenn Module groß werden, solltest du ihre Definitionen in eine
separate Datei verschieben, um die Navigation im Code zu erleichtern.</p>
<p>Gehen wir zum Beispiel von dem Code in Codeblock 7-17 aus, der mehrere
Restaurantmodule enthält. Wir verschieben das Modul <code>front_of_house</code> in seine
eigene Datei <em>src/front_of_house.rs</em>, indem wir die Kistenwurzeldatei so
ändern, dass sie den in Codeblock 7-21 gezeigten Code enthält. In diesem Fall
ist die Kistenwurzeldatei <em>src/lib.rs</em>, aber diese Vorgehensweise funktioniert
auch mit binären Kisten, deren Kistenwurzeldatei <em>src/main.rs</em> ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Codeblock 7-21: Deklarieren des Moduls <code>front_of_house</code>,
dessen Rumpf sich in <em>src/front_of_house.rs</em> befinden wird</span></p>
<p>Als nächstes fügst du den Code in den geschweiften Klammern in eine neue Datei
namens <em>src/front_of_house.rs</em> ein, wie in Codeblock 7-22 zu sehen ist. Der
Compiler weiß, dass er in dieser Datei suchen muss, weil er auf die
Moduldeklaration in der Kistenwurzel mit dem Namen <code>front_of_house</code> gestoßen
ist.</p>
<p><span class="filename">Dateiname: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}</code></pre>
<p><span class="caption">Codeblock 7-22: Definitionen innerhalb des Moduls
<code>front_of_house</code> in <em>src/front_of_house.rs</em></span></p>
<p>Beachte, dass du den Inhalt einer Datei mit einer <code>mod</code>-Deklaration nur
<em>einmal</em> in deinem Modulbaum laden musst. Sobald der Compiler weiß, dass die
Datei Teil des Projekts ist (und weiß, wo im Modulbaum sich der Code befindet,
weil du die <code>mod</code>-Anweisung eingefügt hast), sollten andere Dateien in deinem
Projekt auf den Code der geladenen Datei referenzieren, indem sie einen Pfad zu
der Stelle verwenden, an der er deklariert wurde, wie im Abschnitt <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit Pfaden
auf ein Element im Modulbaum verweisen“</a> beschrieben. Mit anderen
Worten: <code>mod</code> ist <em>keine</em> „include“-Operation, wie du sie vielleicht aus
anderen Programmiersprachen kennst.</p>
<p>Als Nächstes extrahieren wir das Modul <code>hosting</code> in seine eigene Datei. Der
Prozess ist ein bisschen anders, weil <code>hosting</code> ein untergeordnetes Modul von
<code>front_of_house</code> ist, nicht vom Stammmodul. Wir legen die Datei für <code>hosting</code>
in einem neuen Verzeichnis ab, das nach seinen Vorgängern im Modulbaum benannt
wird, in diesem Fall <em>src/front_of_house/</em>.</p>
<p>Um mit dem Verschieben von <code>hosting</code> zu beginnen, ändern wir
<em>src/front_of_house.rs</em> so, dass es nur die Deklaration des <code>hosting</code>-Moduls
enthält:</p>
<p><span class="filename">Dateiname: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting;</code></pre>
<p>Dann erstellen wir ein Verzeichnis <em>src/front_of_house</em> und eine Datei
<em>hosting.rs</em>, die die Definitionen des Moduls <code>hosting</code> enthält:</p>
<p><span class="filename">Dateiname: src/front_of_house/hosting.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_to_waitlist() {}
<span class="boring">}</span></code></pre></pre>
<p>Wenn wir stattdessen <em>hosting.rs</em> in das <em>src</em>-Verzeichnis legen, würde der
Compiler erwarten, dass der <em>hosting.rs</em>-Code in einem <code>hosting</code>-Modul
enthalten ist, das im Stammverzeichnis der Kiste deklariert ist, und nicht als
Kind des <code>front_of_house</code>-Moduls. Die Regeln des Compilers dafür, welche
Dateien auf den Code welcher Module zu prüfen sind, bedeuten, dass die
Verzeichnisse und Dateien dem Modulbaum besser entsprechen.</p>
<blockquote>
<h3 id="alternative-dateipfade"><a class="header" href="#alternative-dateipfade">Alternative Dateipfade</a></h3>
<p>Bis jetzt haben wir die idiomatischsten Dateipfade behandelt, die der
Rust-Compiler verwendet, aber Rust unterstützt auch eine ältere Art von
Dateipfaden. Für ein Modul mit dem Namen <code>front_of_house</code>, das in der
Kistenwurzel deklariert ist, sucht der Compiler den Code des Moduls in:</p>
<ul>
<li><em>src/front_of_house.rs</em> (was wir behandelt haben)</li>
<li><em>src/front_of_house/mod.rs</em> (älterer Stil, noch unterstützter Pfad)</li>
</ul>
<p>Bei einem Modul mit dem Namen <code>hosting</code>, das ein Untermodul von
<code>front_of_house</code> ist, sucht der Compiler den Code des Moduls in:</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (was wir behandelt haben)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (älterer Stil, noch unterstützter Pfad)</li>
</ul>
<p>Wenn du beide Stile für dasselbe Modul verwendest, erhältst einen
Compilerfehler. Die Verwendung einer Mischung beider Stile für verschiedene
Module im selben Projekt ist zulässig, kann aber für die Benutzer verwirrend
sein, die durch dein Projekt navigieren.</p>
<p>Der größte Nachteil des Stils, der Dateien mit dem Namen <em>mod.rs</em> verwendet,
ist, dass dein Projekt am Ende viele Dateien mit dem Namen <em>mod.rs</em> haben
kann, was verwirrend sein kann, wenn du sie gleichzeitig in deinem Editor
geöffnet hast.</p>
</blockquote>
<p>Wir haben den Code jedes Moduls in eine separate Datei verschoben, und der
Modulbaum bleibt derselbe. Die Funktionsaufrufe in <code>eat_at_restaurant</code>
funktionieren ohne jede Änderung, auch wenn die Definitionen in verschiedenen
Dateien stehen. Mit dieser Technik kannst du Module in neue Dateien
verschieben, wenn diese größer werden.</p>
<p>Beachte, dass sich die Anweisung <code>pub use crate::front_of_house::hosting</code> in
<em>src/lib.rs</em> ebenfalls nicht geändert hat und dass <code>use</code> keinen Einfluss darauf
hat, welche Dateien als Teil der Kiste kompiliert werden. Das Schlüsselwort
<code>mod</code> deklariert Module und Rust sucht in einer Datei mit dem Modulnamen nach
dem Code, der zu diesem Modul gehört.</p>
<h2 id="zusammenfassung-6"><a class="header" href="#zusammenfassung-6">Zusammenfassung</a></h2>
<p>Mit Rust kannst du ein Paket in mehrere Kisten und eine Kiste in Module
aufteilen, sodass du auf in einem Modul definierte Elemente aus einem anderen
Modul verweisen kannst. Du kannst dies tun, indem du absolute oder relative
Pfade angibst. Diese Pfade können mit einer <code>use</code>-Anweisung in den
Gültigkeitsbereich gebracht werden, sodass du einen kürzeren Pfad für mehrere
Verwendungen des Elements in diesem Gültigkeitsbereich angeben kannst. Der
Modulcode ist standardmäßig privat, aber du kannst Definitionen öffentlich
machen, indem du das Schlüsselwort <code>pub</code> angibst.</p>
<p>Im nächsten Kapitel werden wir uns einige Kollektionsdatenstrukturen in der
Standardbibliothek ansehen, die du in deinem ordentlich organisierten Code
verwenden kannst.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allgemeine-kollektionen"><a class="header" href="#allgemeine-kollektionen">Allgemeine Kollektionen</a></h1>
<p>Die Standardbibliothek von Rust enthält eine Reihe sehr nützlicher
Datenstrukturen, die <em>Kollektionen</em> (collections) genannt werden. Die meisten
anderen Datentypen repräsentieren einen bestimmten Wert, aber Kollektionen
können mehrere Werte enthalten. Im Gegensatz zu den eingebauten Array- und
Tupel-Typen werden die Daten, auf die diese Kollektionen zeigen, im dynamischen
Speicher abgelegt. Somit muss die Datenmenge zum Kompilierzeitpunkt nicht
bekannt sein und kann während der Programmausführung wachsen oder schrumpfen.
Jede Kollektionsart hat unterschiedliche Fähigkeiten und Kosten, und die
Auswahl einer für deine aktuelle Situation geeigneten Kollektion ist eine
Fähigkeit, die du im Laufe der Zeit entwickeln wirst. In diesem Kapitel
besprechen wir drei Kollektionen, die sehr häufig in Rust-Programmen verwendet
werden:</p>
<ul>
<li>Ein <em>Vektor</em> erlaubt es dir, eine variable Anzahl von Werten nebeneinander zu
speichern.</li>
<li>Eine <em>Zeichenkette</em> ist eine Kollektion von Zeichen. Wir haben den Typ
<code>String</code> bereits kennengelernt, aber in diesem Kapitel werden wir ausführlich
darauf eingehen.</li>
<li>Eine <em>Hashtabelle</em> (hash map) erlaubt es dir, einen Wert mit einem
bestimmten Schlüssel zu assoziieren. Es ist eine spezielle Implementierung
der allgemeineren Datenstruktur, die <em>assoziatives Datenfeld</em> (map) genannt
wird.</li>
</ul>
<p>Informationen über weitere Kollektionsarten, die von der Standardbibliothek
bereitgestellt werden, findest du in <a href="https://doc.rust-lang.org/std/collections/index.html">der Dokumentation</a>.</p>
<p>Wir werden erörtern, wie Vektoren, Zeichenketten und Hashtabellen erstellt und
aktualisiert werden und was jede einzelne besonders macht.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="wertlisten-in-vektoren-ablegen"><a class="header" href="#wertlisten-in-vektoren-ablegen">Wertlisten in Vektoren ablegen</a></h2>
<p>Der erste Kollektionstyp, den wir betrachten werden, ist <code>Vec&lt;T&gt;</code>, auch bekannt
als <em>Vektor</em>. Vektoren ermöglichen es dir, mehr als einen Wert in einer
einzigen Datenstruktur zu speichern und alle Werte nebeneinander im Speicher
abzulegen. Vektoren können nur Werte desselben Typs speichern. Sie sind nützlich,
wenn du eine Liste von Einträgen hast, z.B. die Textzeilen einer Datei oder die
Preise der Artikel in einem Einkaufswagen.</p>
<h3 id="erstellen-eines-neuen-vektors"><a class="header" href="#erstellen-eines-neuen-vektors">Erstellen eines neuen Vektors</a></h3>
<p>Um einen neuen, leeren Vektor zu erstellen, rufen wir die Funktion <code>Vec::new</code>
auf, wie in Codeblock 8-1 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-1: Erstellen eines neuen, leeren Vektors zur
Aufnahme von Werten des Typs <code>i32</code></span></p>
<p>Beachte, dass wir hier eine Typ-Annotation hinzugefügt haben. Da wir keine
Werte in diesen Vektor einfügen, weiß Rust nicht, welche Art von Elementen wir
zu speichern beabsichtigen. Dies ist ein wichtiger Punkt. Vektoren werden mit
Hilfe generischer Typen implementiert; wie du eigene generische Typen verwenden
kannst, wird in Kapitel 10 behandelt. Für den Moment sollst du wissen, dass der
von der Standardbibliothek bereitgestellte Typ <code>Vec&lt;T&gt;</code> jeden Typ enthalten
kann. Wenn wir einen Vektor zu einem bestimmten Typ erstellen, wird der Typ
in spitzen Klammern angegeben. In Codeblock 8-1 haben wir Rust gesagt, dass der
Vektor <code>Vec&lt;T&gt;</code> in <code>v</code> Elemente des Typs <code>i32</code> enthalten wird.</p>
<p>Meistens wird man ein <code>Vec&lt;T&gt;</code> mit Anfangswerten erstellen und Rust wird den
Typ des Wertes, den man speichern will, ableiten, sodass man diese
Typ-Annotation nur selten benötigt. Rust bietet praktischerweise das Makro
<code>vec!</code>, das einen neuen Vektor erzeugt, der die von dir angegebenen Werte
enthält. Codeblock 8-2 erzeugt einen neuen <code>Vec&lt;i32&gt;</code>, der die Werte <code>1</code>, <code>2</code>
und <code>3</code> enthält. Als Integer-Typ wird <code>i32</code> verwendet, weil das der
Standard-Integer-Typ ist, wie wir im Abschnitt <a href="ch03-02-data-types.html">„Datentypen“</a> in
Kapitel 3 besprochen haben.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-2: Erstellen eines neuen Vektors mit
Werten</span></p>
<p>Da wir initiale <code>i32</code>-Werte angegeben haben, kann Rust daraus schließen, dass
<code>v</code> den Typ <code>Vec&lt;i32&gt;</code> hat, und die Typ-Annotation ist nicht notwendig. Als
Nächstes werden wir uns ansehen, wie man einen Vektor modifiziert.</p>
<h3 id="aktualisieren-eines-vektors"><a class="header" href="#aktualisieren-eines-vektors">Aktualisieren eines Vektors</a></h3>
<p>Um einen Vektor zu erstellen und ihm dann Elemente hinzuzufügen, können wir die
Methode <code>push</code> verwenden, wie in Codeblock 8-3 zu sehen ist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-3: Verwenden der Methode <code>push</code> zum
Hinzufügen von Werten zu einem Vektor</span></p>
<p>Wie bei jeder Variablen müssen wir, wenn wir ihren Wert ändern wollen, sie mit
dem Schlüsselwort <code>mut</code> als veränderbar markieren, wie in Kapitel 3
besprochen. Die Zahlen, die wir darin platzieren, sind alle vom Typ <code>i32</code>, und
Rust leitet dies aus den Daten ab, sodass wir die Annotation <code>Vec&lt;i32&gt;</code> nicht
benötigen.</p>
<h3 id="elemente-aus-vektoren-lesen"><a class="header" href="#elemente-aus-vektoren-lesen">Elemente aus Vektoren lesen</a></h3>
<p>Es gibt zwei Möglichkeiten, einen in einem Vektor gespeicherten Wert zu
referenzieren. In den Beispielen haben wir zur besseren Lesbarkeit die
Werttypen, die von den Funktionen zurückgegeben werden, mit angegeben.</p>
<p>Codeblock 8-4 zeigt beide Zugriffsmethoden auf einen Wert in einem Vektor,
mittels Indexierungssyntax und der Methode <code>get</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
println!(&quot;Das dritte Element ist {}&quot;, third);

let third: Option&lt;&amp;i32&gt; = v.get(2);
match third {
    Some(third) =&gt; println!(&quot;Das dritte Element ist {}&quot;, third),
    None =&gt; println!(&quot;Es gibt kein drittes Element.&quot;),
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-4: Verwenden der Indexierungssyntax und der
Methode <code>get</code> für den Zugriff auf ein Element in einem Vektor</span></p>
<p>Beachte hier einige Details. Wir verwenden den Indexwert <code>2</code>, um das dritte
Element zu erhalten, da Vektoren mit Zahlen beginnend bei null indiziert
werden. Mit <code>&amp;</code> und <code>[]</code> erhalten wir eine Referenz auf das Element mit dem
Indexwert. Wenn wir die Methode <code>get</code> mit dem Index als Argument verwenden,
erhalten wir eine <code>Option&lt;&amp;T&gt;</code>, die wir mit <code>match</code> verwenden können.</p>
<p>Der Grund, warum Rust diese beiden Möglichkeiten, auf ein Element zu
referenzieren, bietet ist, dass du wählen kannst, wie sich das Programm
verhält, wenn du versuchst, einen Indexwert außerhalb des Bereichs der
vorhandenen Elemente zu verwenden. Als Beispiel wollen wir sehen, was ein
Programm tut, wenn wir bei einem Vektor mit fünf Elementen versuchen, auf ein
Element mit Index 100 zuzugreifen, wie in Codeblock 8-5 zu sehen ist.</p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-5: Versuch, auf das Element mit Index 100 in
einem Vektor zuzugreifen, der fünf Elemente enthält</span></p>
<p>Wenn wir diesen Code ausführen, wird die erste <code>[]</code> Variante das Programm abbrechen
lassen, weil es auf ein nicht existierendes Element verweist. Diese Methode
wird vorzugsweise verwendet, wenn du dein Programm abstürzen lassen möchtest,
wenn versucht wird, auf ein Element hinter dem Ende des Vektors zuzugreifen.</p>
<p>Wenn der Methode <code>get</code> ein Index außerhalb des Vektors übergeben wird, gibt sie
<code>None</code> zurück, ohne abzubrechen. Du würdest diese Methode verwenden, wenn der
Zugriff auf ein Element außerhalb des Bereichs des Vektors unter normalen
Umständen gelegentlich vorkommt. Dein Code wird dann eine Logik haben, die mit
<code>Some(&amp;element)</code> und <code>None</code> umgehen kann, wie in Kapitel 6 besprochen. Der
Index könnte zum Beispiel von einer Person stammen, die eine Zahl eingibt. Wenn
sie versehentlich eine zu große Zahl eingibt und das Programm einen <code>None</code>-Wert
erhält, kannst du dem Benutzer mitteilen, wie viele Elemente sich aktuell im
Vektor befinden und ihm eine weitere Chance geben, einen gültigen Wert
einzugeben. Das wäre benutzerfreundlicher, als das Programm wegen eines
Tippfehlers abstürzen zu lassen!</p>
<p>Wenn das Programm über eine gültige Referenz verfügt, stellt der
Ausleihenprüfer mittels Eigentümerschafts- und Ausleihregeln (siehe Kapitel 4)
sicher, dass diese Referenz und alle anderen Referenzen auf den Inhalt des
Vektors gültig bleiben. Erinnere dich an die Regel, die besagt, dass du keine
veränderbaren und unveränderbaren Referenzen im gleichen Gültigkeitsbereich
haben kannst. Diese Regel trifft in Codeblock 8-6 zu, wo wir eine
unveränderbare Referenz auf das erste Element in einem Vektor halten und
versuchen, am Ende ein Element hinzuzufügen. Das wird nicht funktionieren, wenn
wir später in der Funktion versuchen auch auf dieses Element zuzugreifen:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);

println!(&quot;Das erste Element ist: {}&quot;, first);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-6: Versuch, ein Element zu einem Vektor
hinzuzufügen, während eine Referenz auf ein Element gehalten wird</span></p>
<p>Das Kompilieren dieses Codes führt zu folgendem Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;Das erste Element ist: {}&quot;, first);
  |                                           ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
</code></pre>
<p>Der Code in Codeblock 8-6 sieht so aus, als könnte er funktionieren: Warum
sollte sich eine Referenz auf das erste Element darum kümmern, was sich am
Ende des Vektors ändert? Dieser Fehler ist in der Funktionsweise von Vektoren
begründet: Weil Vektoren die Werte nebeneinander im Speicher ablegen, könnte
das Hinzufügen eines neuen Elements am Ende des Vektors die Allokation neuen
Speichers und das Kopieren der alten Elemente an die neue Stelle erfordern,
wenn nicht genügend Platz vorhanden ist, um alle Elemente nebeneinander an der
aktuellen Stelle des Vektors zu platzieren. In diesem Fall würde die Referenz
auf das erste Element auf einen freigegebenen Speicherplatz verweisen. Die
Ausleihregeln verhindern, dass Programme in diese Situation geraten.</p>
<blockquote>
<p>Anmerkung: Weitere Einzelheiten zu den Implementierungsdetails des Typs
<code>Vec&lt;T&gt;</code> findest du in <a href="https://doc.rust-lang.org/nomicon/vec.html">„Das Rustonomicon“</a>.</p>
</blockquote>
<h3 id="iterieren-über-die-werte-in-einem-vektor"><a class="header" href="#iterieren-über-die-werte-in-einem-vektor">Iterieren über die Werte in einem Vektor</a></h3>
<p>Um auf die Elemente eines Vektors der Reihe nach zuzugreifen, können wir über
alle Elemente iterieren, anstatt Indizes zu verwenden, um auf jeweils ein
Element zur gleichen Zeit zuzugreifen. Codeblock 8-7 zeigt, wie man eine
<code>for</code>-Schleife verwendet, um unveränderbare Referenzen auf die Elemente eines
Vektors von <code>i32</code>-Werten zu erhalten und diese auszugeben.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![100, 32, 57];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-7: Ausgeben aller Elemente eines Vektors
durch Iterieren über die Elemente mittels <code>for</code>-Schleife</span></p>
<p>Wir können auch über veränderbare Referenzen der Elemente eines veränderbaren
Vektors iterieren, um Änderungen an allen Elementen vorzunehmen. Die
<code>for</code>-Schleife in Codeblock 8-8 addiert zu jedem Element <code>50</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-8: Iterieren über veränderbare Referenzen
der Elemente eines Vektors</span></p>
<p>Um den Wert, auf den sich die veränderbare Referenz bezieht, zu ändern, müssen
wir den Dereferenzierungsoperator (<code>*</code>) verwenden, um an den Wert in <code>i</code> zu
kommen, bevor wir den Operator <code>+=</code> verwenden können. Wir werden mehr über den
Dereferenzierungsoperator im Abschnitt <a href="ch15-02-deref.html#dem-zeiger-zum-wert-folgen">„Dem Zeiger zum Wert folgen“</a> in
Kapitel 15 sprechen.</p>
<p>Die Iteration über einen Vektor, ob unveränderbar oder veränderbar, ist
aufgrund der Regeln des Ausleihenprüfers sicher. Wenn wir versuchen würden,
Elemente in den <code>for</code>-Schleifenrümpfen in Codeblock 8-7 und Codeblock 8-8
einzufügen oder zu entfernen, würden wir einen Compilerfehler erhalten, ähnlich
dem, den wir mit dem Code in Codeblock 8-6 erhalten haben. Die Referenz auf den
Vektor, den die <code>for</code>-Schleife enthält, verhindert eine gleichzeitige Änderung
des gesamten Vektors.</p>
<h3 id="verwenden-einer-aufzählung-zum-speichern-mehrerer-typen"><a class="header" href="#verwenden-einer-aufzählung-zum-speichern-mehrerer-typen">Verwenden einer Aufzählung zum Speichern mehrerer Typen</a></h3>
<p>Vektoren können nur Werte desselben Typs speichern. Das kann unbequem sein; es
gibt definitiv Anwendungsfälle, in denen es notwendig ist, eine Liste von
Einträgen unterschiedlicher Typen zu speichern. Glücklicherweise werden die
Varianten einer Aufzählung unter dem gleichen Aufzählungstyp definiert. Wenn
wir also Elemente eines anderen Typs in einem Vektor speichern wollen, können
wir eine Aufzählung definieren und verwenden!</p>
<p>Angenommen, wir möchten Werte aus einer Zeile einer Tabellenkalkulationstabelle
erhalten, in der einige Spalten der Zeile ganze Zahlen, Fließkommazahlen und
Zeichenketten enthalten. Wir können eine Aufzählung definieren, deren Varianten
die verschiedenen Werttypen enthalten, und alle Aufzählungsvarianten werden als
derselbe Typ angesehen: Der Typ der Aufzählung. Dann können wir einen Vektor
erstellen, der diese Aufzählung und damit letztlich verschiedene Typen enthält.
Wir haben dies in Codeblock 8-9 demonstriert.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blau&quot;)),
    SpreadsheetCell::Float(10.12),
];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-9: Definieren eines <code>enum</code>, um Werte
verschiedener Typen in einem Vektor zu speichern</span></p>
<p>Rust muss wissen, welche Typen zur Kompilierzeit im Vektor enthalten sein
werden, damit es genau weiß, wie viel Speicherplatz im Haldenspeicher
benötigt wird, um alle Elemente zu speichern. Wir müssen auch eindeutig
festlegen, welche Typen in diesem Vektor zulässig sind. Wenn Rust einen Vektor
mit beliebigen Typen zuließe, bestünde die Möglichkeit, dass einer oder mehrere
Typen Fehler bei den an den Elementen des Vektors durchgeführten Operationen
verursachen würden. Das Verwenden einer Aufzählung zusammen mit einem
<code>match</code>-Ausdruck bedeutet, dass Rust zur Kompilierzeit sicherstellt, dass jeder
mögliche Fall behandelt wird, wie in Kapitel 6 besprochen.</p>
<p>Wenn du nicht weißt, welche Typen ein Programm zur Laufzeit in einem Vektor
speichern kann, funktioniert der Aufzählungsansatz nicht. Stattdessen kannst du
ein Merkmalsobjekt (trait object) verwenden, das wir in Kapitel 17 behandeln
werden.</p>
<p>Nachdem wir nun einige der gängigsten Methoden zur Verwendung von Vektoren
besprochen haben, solltest du dir unbedingt die <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">API-Dokumentation</a> zu
den vielen nützlichen Methoden ansehen, die die Standardbibliothek für <code>Vec&lt;T&gt;</code>
mitbringt. Zum Beispiel gibt es zusätzlich zu <code>push</code> die Methode <code>pop</code>, die das
letzte Element entfernt und zurückgibt.</p>
<h3 id="beim-aufräumen-eines-vektors-werden-seine-elemente-aufgeräumt"><a class="header" href="#beim-aufräumen-eines-vektors-werden-seine-elemente-aufgeräumt">Beim Aufräumen eines Vektors werden seine Elemente aufgeräumt</a></h3>
<p>Wie bei jeder anderen Struktur wird ein Vektor freigegeben, wenn er den
Gültigkeitsbereich verlässt, wie in Codeblock 8-10 kommentiert wird.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let v = vec![1, 2, 3, 4];

    // mache etwas mit v
} // &lt;- v verlässt den Gültigkeitsbereich und wird hier freigegeben
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-10: Zeigt, wo der Vektor und seine Elemente
aufgeräumt werden</span></p>
<p>Wenn der Vektor aufgeräumt wird, wird auch sein gesamter Inhalt aufgeräumt,
d.h. die ganzen Zahlen, die er enthält, werden beseitigt. Der Ausleihenprüfer
stellt sicher, dass alle Referenzen auf den Inhalt eines Vektors nur verwendet
werden, solange der Vektor selbst gültig ist.</p>
<p>Lass uns zum nächsten Kollektionstyp übergehen: <code>String</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="utf-8-kodierten-text-in-zeichenketten-strings-ablegen"><a class="header" href="#utf-8-kodierten-text-in-zeichenketten-strings-ablegen">UTF-8-kodierten Text in Zeichenketten (strings) ablegen</a></h2>
<p>Wir haben in Kapitel 4 über Zeichenketten (strings) gesprochen, aber wir werden
uns jetzt eingehender damit befassen. Neue Rust-Entwickler haben gewöhnlich aus
einer Kombination von drei Gründen Probleme mit Zeichenketten: Rusts Neigung,
mögliche Fehler aufzudecken, Zeichenketten als eine kompliziertere
Datenstruktur, als viele Programmierer ihnen zugestehen, und UTF-8. Diese
Faktoren kombinieren sich in einer Weise, die schwierig erscheinen kann, wenn
man von anderen Programmiersprachen kommt.</p>
<p>Wir besprechen Zeichenketten im Kontext von Kollektionen, da Zeichenketten als
Byte-Kollektion implementiert sind, sowie einige Methoden, die nützliche
Funktionalitäten bieten, wenn diese Bytes als Text interpretiert werden. In
diesem Abschnitt werden wir über <code>String</code>-Operationen sprechen, die jeder
Kollektionstyp hat, wie das Erstellen, Aktualisieren und Lesen. Wir werden auch
die Art und Weise besprechen, in der sich <code>String</code> von den anderen Kollektionen
unterscheidet, nämlich warum die Indexierung bei einem <code>String</code> kompliziert
ist, weil Menschen und Computer <code>String</code>-Daten unterschiedlich interpretieren.</p>
<h3 id="was-ist-eine-zeichenkette"><a class="header" href="#was-ist-eine-zeichenkette">Was ist eine Zeichenkette?</a></h3>
<p>Zuerst werden wir definieren, was wir mit dem Begriff <em>Zeichenkette</em> (string)
meinen. Rust hat nur einen einzigen Zeichenkettentyp in der Kernsprache,
nämlich den Zeichenkettenanteilstyp <code>str</code>, der üblicherweise in seiner
Ausleihenform <code>&amp;str</code> zu sehen ist. In Kapitel 4 sprachen wir über
<em>Zeichenkettenanteilstypen</em> (string slices), die Referenzen auf einige
UTF-8-kodierte Zeichenkettendaten sind, die anderswo gespeichert sind.
Zeichenkettenliterale werden beispielsweise in der Binärdatei des Programms
gespeichert und sind daher Zeichenkettenanteilstypen.</p>
<p>Der Typ <code>String</code>, der von Rusts Standardbibliothek zur Verfügung gestellt wird
und nicht in die Kernsprache kodiert ist, ist ein größenänderbarer,
veränderbarer, aneigenbarer, UTF-8-kodierter Zeichenkettentyp. Wenn
Rust-Entwickler von Zeichenketten in Rust sprechen, meinen sie normalerweise
den Typ <code>String</code> sowie den Zeichenkettenanteilstyp <code>&amp;str</code>, nicht nur einen
dieser Typen. Obwohl es in diesem Abschnitt weitgehend um <code>String</code> geht, werden
beide Typen in Rusts Standardbibliothek stark verwendet, und sowohl <code>String</code>
als auch Zeichenkettenanteilstypen sind UTF-8-kodiert.</p>
<p>Die Standardbibliothek von Rust enthält auch eine Reihe anderer
Zeichenkettentypen wie <code>OsString</code>, <code>OsStr</code>, <code>CString</code> und <code>CStr</code>.
Bibliothekskisten (library crates) können noch weitere Möglichkeiten zum
Speichern von Zeichenkettendaten bieten. Fällt dir auf, dass diese Namen alle
auf <code>String</code> oder <code>Str</code> enden? Sie beziehen sich auf aneigenbare und
ausgeliehene Varianten, genau wie die Typen <code>String</code> und <code>str</code>, die du zuvor
gesehen hast. Diese Zeichenkettentypen können z.B. Text in verschiedenen
Kodierungen speichern oder unterschiedliche Speicherdarstellungen haben. Diese
anderen Zeichenkettentypen werden in diesem Kapitel nicht besprochen; in ihrer
API-Dokumentation erfährst du mehr darüber, wie sie zu verwenden sind und wozu
jeder einzelne geeignet ist.</p>
<h3 id="erstellen-einer-neuen-zeichenkette"><a class="header" href="#erstellen-einer-neuen-zeichenkette">Erstellen einer neuen Zeichenkette</a></h3>
<p>Viele der gleichen Operationen, die mit <code>Vec&lt;T&gt;</code> verfügbar sind, sind auch mit
<code>String</code> verfügbar, weil <code>String</code> eigentlich als Hülle um einen Vektor von
Bytes mit einigen zusätzlichen Garantien, Einschränkungen und Fähigkeiten
implementiert ist. Ein Beispiel für eine Funktion, die auf die gleiche Weise
mit <code>Vec&lt;T&gt;</code> und <code>String</code> arbeitet, ist die Funktion <code>new</code> zum Erstellen einer
Instanz, die in Codeblock 8-11 gezeigt wird.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-11: Erstellen einer neuen, leeren
Zeichenkette</span></p>
<p>Diese Zeile erzeugt eine neue, leere Zeichenkette namens <code>s</code>, in die wir dann
Daten aufnehmen können. Oft werden wir einige initiale Daten haben, mit denen
wir die Zeichenkette füllen wollen. Dazu verwenden wir die Methode <code>to_string</code>,
die für jeden Typ verfügbar ist, der das Merkmal <code>Display</code> implementiert, wie
es bei Zeichenkettenliteralen der Fall ist. Codeblock 8-12 zeigt zwei
Beispiele.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = &quot;initialer Inhalt&quot;;

let s = data.to_string();

// die Methode funktioniert auch direkt für ein Literal:
let s = &quot;initialer Inhalt&quot;.to_string();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-12: Verwenden der Methode <code>to_string</code> zum
Erzeugen eines <code>String</code> aus einem Zeichenkettenliteral</span></p>
<p>Dieser Code erzeugt eine Zeichenkette mit dem Inhalt <code>initialer Inhalt</code>.</p>
<p>Wir können auch die Funktion <code>String::from</code> verwenden, um einen <code>String</code> aus
einem Zeichenkettenliteral zu erzeugen. Der Code in Codeblock 8-13 ist
äquivalent zum Code in Codeblock 8-12, der <code>to_string</code> verwendet.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;initialer Inhalt&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-13: Verwenden der Funktion <code>String::from</code> zum
Erzeugen eines <code>String</code> aus einem Zeichenkettenliteral</span></p>
<p>Da Zeichenketten für so viele Dinge verwendet werden, können wir viele
verschiedene generische Programmierschnittstellen (APIs) für Zeichenketten
verwenden, was uns viele Möglichkeiten bietet. Einige von ihnen können
überflüssig erscheinen, aber sie alle haben ihren Platz! In diesem Fall machen
<code>String::from</code> und <code>to_string</code> dasselbe, also ist die Wahl eine Frage des
Stils und der Lesbarkeit.</p>
<p>Denke daran, dass Zeichenketten UTF-8-kodiert sind, sodass sie alle
ordnungsgemäß kodierten Daten aufnehmen können, wie in Codeblock 8-14 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;السلام عليكم&quot;);
let hello = String::from(&quot;Dobrý den&quot;);
let hello = String::from(&quot;Hallo&quot;);
let hello = String::from(&quot;Hello&quot;);
let hello = String::from(&quot;שָׁלוֹם&quot;);
let hello = String::from(&quot;नमस्ते&quot;);
let hello = String::from(&quot;こんにちは&quot;);
let hello = String::from(&quot;안녕하세요&quot;);
let hello = String::from(&quot;你好&quot;);
let hello = String::from(&quot;Olá&quot;);
let hello = String::from(&quot;Здравствуйте&quot;);
let hello = String::from(&quot;Hola&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-14: Speichern von Begrüßungstexten in
verschiedenen Sprachen in Zeichenketten</span></p>
<p>All dies sind gültige <code>String</code>-Werte.</p>
<h3 id="aktualisieren-einer-zeichenkette"><a class="header" href="#aktualisieren-einer-zeichenkette">Aktualisieren einer Zeichenkette</a></h3>
<p>Ein <code>String</code> kann an Größe zunehmen und sein Inhalt kann sich ändern, genau wie
der Inhalt eines <code>Vec&lt;T&gt;</code>, wenn du mehr Daten hineinschiebst. Darüber hinaus
kannst du bequem den Operator <code>+</code> oder das Makro <code>format!</code> verwenden, um
<code>String</code>-Werte aneinanderzuhängen.</p>
<h4 id="anhängen-an-eine-zeichenkette-mit-push_str-und-push"><a class="header" href="#anhängen-an-eine-zeichenkette-mit-push_str-und-push">Anhängen an eine Zeichenkette mit <code>push_str</code> und <code>push</code></a></h4>
<p>Wir können einen <code>String</code> wachsen lassen, indem wir die Methode <code>push_str</code>
verwenden, um einen Zeichenkettenanteilstyp anzuhängen, wie in Codeblock 8-15
zu sehen ist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-15: Anhängen eines Zeichenkettenanteilstyps
an einen <code>String</code> mit der Methode <code>push_str</code></span></p>
<p>Nach diesen beiden Zeilen enthält <code>s</code> den Wert <code>foobar</code>. Die Methode <code>push_str</code>
nimmt einen Zeichenkettenanteilstyp, weil wir nicht unbedingt die
Eigentümerschaft des Parameters übernehmen wollen. Zum Beispiel wollen wir im
Code in Codeblock 8-16 in der Lage sein, <code>s2</code> zu verwenden, nachdem wir seinen
Inhalt an <code>s1</code> angehängt haben.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(s2);
println!(&quot;s2 ist {}&quot;, s2);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-16: Verwenden eines Zeichenkettenanteilstyps
nach dem Anhängen seines Inhalts an eine Zeichenkette</span></p>
<p>Wenn die Methode <code>push_str</code> die Eigentümerschaft von <code>s2</code> übernehmen würde,
könnten wir ihren Wert nicht in der letzten Zeile ausgeben. Dieser Code
funktioniert jedoch wie erwartet!</p>
<p>Die Methode <code>push</code> nimmt ein einzelnes Zeichen als Parameter und fügt es dem
<code>String</code> hinzu. Codeblock 8-17 fügt den Buchstaben <code>l</code> mit der Methode <code>push</code>
zu einem <code>String</code> hinzu.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;lo&quot;);
s.push('l');
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-17: Hinzufügen eines Zeichens zu einem
<code>String</code>-Wert mit <code>push</code></span></p>
<p>Als Ergebnis wird <code>s</code> den Wert <code>lol</code> enthalten.</p>
<h4 id="aneinanderhängen-mit-dem-operator--und-dem-makro-format"><a class="header" href="#aneinanderhängen-mit-dem-operator--und-dem-makro-format">Aneinanderhängen mit dem Operator <code>+</code> und dem Makro <code>format!</code></a></h4>
<p>Häufig möchtest du zwei vorhandene Zeichenketten kombinieren. Eine Möglichkeit
das zu tun ist, den Operator <code>+</code> zu verwenden, wie in Codeblock 8-18 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo &quot;);
let s2 = String::from(&quot;Welt!&quot;);
let s3 = s1 + &amp;s2; // Beachte, s1 wurde hierher verschoben und
                   // kann nicht mehr verwendet werden
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-18: Verwenden des Operators <code>+</code>, um zwei
Zeichenketten zu einer neuen zu kombinieren</span></p>
<p>Die Zeichenkette <code>s3</code> wird <code>Hallo Welt!</code> enthalten. Der Grund, warum <code>s1</code> nach
der Addition nicht mehr gültig ist und warum wir eine Referenz auf <code>s2</code>
verwendet haben, hat mit der Signatur der Methode zu tun, die aufgerufen wird,
wenn wir den Operator <code>+</code> verwenden. Der Operator <code>+</code> benutzt die Methode
<code>add</code>, deren Signatur ungefähr so aussieht:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>In der Standardbibliothek wird <code>add</code> mittels generischer Datentypen und
assoziierter Typen definiert. Hier haben wir konkrete Typen ersetzt, was
geschieht, wenn wir diese Methode mit <code>String</code>-Werten aufrufen. Wir werden
generische Datentypen in Kapitel 10 besprechen. Diese Signatur gibt uns den
entscheidenden Hinweis, um die kniffligen Stellen des Operators <code>+</code> zu
verstehen.</p>
<p>Erstens hat <code>s2</code> ein <code>&amp;</code>, was bedeutet, dass wir eine <em>Referenz</em> der zweiten
Zeichenkette an die erste Zeichenkette anhängen. Der Grund dafür ist der
Parameter <code>s</code> in der Funktion <code>add</code>: Wir können nur einen <code>&amp;str</code> zu einem
<code>String</code> hinzufügen; wir können nicht zwei <code>String</code>-Werte aneinanderhängen.
Aber warte – der Typ von <code>&amp;s2</code> ist <code>&amp;String</code>, nicht <code>&amp;str</code>, wie im
zweiten Parameter von <code>add</code> spezifiziert. Warum kompiliert also Codeblock 8-18?</p>
<p>Der Grund, warum wir <code>&amp;s2</code> im Aufruf von <code>add</code> verwenden können, ist, dass der
Compiler das Argument <code>&amp;String</code> in einen <code>&amp;str</code> umwandeln (coerce) kann.
Wenn wir die Methode <code>add</code> aufrufen, benutzt Rust eine <em>automatische
Umwandlung</em> (deref coercion), die hier <code>&amp;s2</code> in <code>&amp;s2[...]</code> umwandelt. Auf die
automatische Umwandlung werden wir in Kapitel 15 tiefer eingehen. Da <code>add</code>
nicht die Eigentümerschaft des Parameters <code>s</code> übernimmt, ist <code>s2</code> auch nach
dieser Operation immer noch ein gültiger <code>String</code>.</p>
<p>Zweitens können wir in der Signatur sehen, dass <code>add</code> die Eigentümerschaft von
<code>self</code> übernimmt, weil <code>self</code> <em>kein</em> <code>&amp;</code> hat. Das bedeutet, dass <code>s1</code> in
Codeblock 8-18 in den Aufruf von <code>add</code> verschoben wird und danach nicht mehr
gültig ist. Obwohl also <code>let s3 = s1 + &amp;s2;</code> so aussieht, als ob beide
Zeichenketten kopiert und eine neue erzeugt wird, übernimmt diese Anweisung
tatsächlich die Eigentümerschaft von <code>s1</code>, hängt eine Kopie des Inhalts von
<code>s2</code> an und gibt dann die Eigentümerschaft des Ergebnisses zurück. In anderen
Worten sieht es so aus, als würde es viele Kopien erstellen, das ist aber nicht
so; die Implementierung ist effizienter als Kopieren.</p>
<p>Wenn wir mehrere Zeichenketten aneinanderhängen wollen, wird das Verhalten des
Operators <code>+</code> unhandlich:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>An diesem Punkt wird <code>s</code> den Wert <code>tic-tac-toe</code> haben. Bei all den Zeichen <code>+</code>
und <code>&quot;</code> ist es schwer zu erkennen, was vor sich geht. Für kompliziertere
String-Kombinationen können wir stattdessen das Makro <code>format!</code> verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}</span></code></pre></pre>
<p>Auch bei diesem Code wird <code>s</code> den Wert <code>tic-tac-toe</code> haben. Das Makro <code>format!</code>
funktioniert wie <code>println!</code>, aber anstatt das Ergebnis auf den Bildschirm
auszugeben, gibt es einen <code>String</code> mit dem Inhalt zurück. Die Codevariante, die
<code>format!</code> verwendet, ist viel leichter zu lesen, und der durch das Makro
<code>format!</code> erzeugte Code verwendet Referenzen sodass dieser Aufruf keine
Eigentümerschaft seiner Parameter übernimmt.</p>
<h3 id="indexierung-von-zeichenketten"><a class="header" href="#indexierung-von-zeichenketten">Indexierung von Zeichenketten</a></h3>
<p>In vielen anderen Programmiersprachen ist das Zugreifen auf einzelne Zeichen in
einer Zeichenkette mittels Index eine gültige und gängige Operation. Wenn du
jedoch in Rust versuchst, mittels Indexierungssyntax auf Teile einer
Zeichenkette zuzugreifen, wirst du einen Fehler erhalten. Betrachte den
ungültigen Code in Codeblock 8-19.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let h = s1[0];


<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-19: Versuch, die Indexierungssyntax bei einer
Zeichenkette zu verwenden</span></p>
<p>Dieser Code führt zu folgendem Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
</code></pre>
<p>Die Fehlermeldung und der Hinweis erzählen die Geschichte: Zeichenketten in
Rust unterstützen keine Indexierung. Aber warum nicht? Um diese Frage zu
beantworten, müssen wir uns ansehen, wie Rust Zeichenketten im Speicher ablegt.</p>
<h4 id="interne-darstellung"><a class="header" href="#interne-darstellung">Interne Darstellung</a></h4>
<p>Ein <code>String</code> ist eine Hülle um einen <code>Vec&lt;u8&gt;</code>. Sehen wir uns einige unserer
korrekt kodierten UTF-8-Beispielzeichenketten aus Codeblock 8-14 an. Zuerst
diese:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;Hola&quot;);
<span class="boring">}</span></code></pre></pre>
<p>In diesem Fall wird <code>hello.len()</code> gleich 4 sein, was bedeutet, dass der Vektor,
der die Zeichenkette „Hola“ speichert, 4 Bytes lang ist. Jeder dieser
Buchstaben benötigt 1 Byte in UTF-8-Kodierung. Die folgende Zeile mag dich
jedoch überraschen. (Beachte, dass diese Zeichenkette mit dem kyrillischen
Großbuchstaben „Ze“ beginnt, nicht mit der arabischen Zahl 3.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;Здравствуйте&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Auf die Frage, wie lang die Zeichenkette ist, könnte man sagen: 12. Die Antwort
von Rust lautet jedoch 24: Das ist die Anzahl der Bytes, die benötigt wird, um
„Здравствуйте“ in UTF-8 zu kodieren, da jeder Unicode-Skalarwert in dieser
Zeichenkette 2 Bytes Speicherplatz benötigt. Daher wird ein Index auf die Bytes
der Zeichenkette nicht immer mit einem gültigen Unicode-Skalarwert korrelieren.
Um das zu erläutern, betrachte diesen ungültigen Rust-Code:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];


<span class="boring">}</span></code></pre></pre>
<p>Du weißt bereits, dass <code>answer</code> nicht <code>З</code>, der erste Buchstabe, sein wird. In
der UTF-8-Kodierung von <code>З</code> ist das erste Byte <code>208</code> und das zweite <code>151</code>,
sodass <code>answer</code> eigentlich <code>208</code> sein müsste, aber <code>208</code> ist kein eigenständig
gültiges Zeichen. Die Rückgabe von <code>208</code> ist wahrscheinlich nicht das, was ein
Nutzer wünschen würde, wenn er nach dem ersten Buchstaben dieser Zeichenkette
fragte; das sind jedoch die einzigen Daten, die Rust beim Byte-Index 0 hat.
Nutzer wollen im Allgemeinen nicht, dass der Byte-Wert zurückgegeben wird,
selbst wenn die Zeichenkette nur lateinische Buchstaben enthält: Wenn
<code>&amp;&quot;hallo&quot;[0]</code> gültiger Code wäre, der den Byte-Wert zurückgibt, würde er <code>104</code>
zurückgeben, nicht <code>h</code>.</p>
<p>Um zu vermeiden, dass ein unerwarteter Wert zurückgegeben wird und dadurch
Fehler entstehen, die möglicherweise nicht sofort entdeckt werden, kompiliert
Rust diesen Code überhaupt nicht und verhindert so Missverständnisse in einem
frühen Stadium des Entwicklungsprozesses.</p>
<h4 id="bytes-skalare-werte-und-graphemgruppen-grapheme-clusters-oje"><a class="header" href="#bytes-skalare-werte-und-graphemgruppen-grapheme-clusters-oje">Bytes, skalare Werte und Graphemgruppen (grapheme clusters)! Oje!</a></h4>
<p>Ein weiterer Punkt bei UTF-8 ist, dass es eigentlich drei relevante
Möglichkeiten gibt, Zeichenketten aus Rusts Perspektive zu betrachten: Als
Bytes, als skalare Werte und als Graphemgruppen (das, was wir am ehesten als
<em>Buchstaben</em> bezeichnen würden).</p>
<p>Wenn wir uns das in der Devanagari-Schrift geschriebene Hindi-Wort „नमस्ते“
(<a href="https://de.wikipedia.org/wiki/Namaste"><em>Namaste</em></a>) ansehen, wird es als ein 
Vektor von <code>u8</code>-Werten gespeichert, der wie folgt aussieht:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Das sind 18 Bytes, so wie ein Computer diese Daten letztendlich speichert. Wenn
wir sie als Unicode-Skalarwerte betrachten, also als das, was der Typ <code>char</code> in
Rust ist, sehen diese Bytes wie folgt aus:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Es gibt hier sechs <code>char</code>-Werte, aber der vierte und der sechste sind keine
Buchstaben: Sie sind diakritische Zeichen, die für sich allein genommen keinen
Sinn ergeben. Wenn wir sie schließlich als Graphemgruppen betrachten, erhalten
wir das, was eine Person die vier Buchstaben nennen würde, aus denen das
Hindi-Wort besteht:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust bietet verschiedene Möglichkeiten zur Interpretation von rohen
Zeichenkettendaten, die von Computern gespeichert werden, sodass jedes Programm
die Interpretation wählen kann, die es benötigt, unabhängig davon, in welcher
menschlichen Sprache die Daten vorliegen. Ein letzter Grund, warum Rust uns
nicht erlaubt, eine Zeichenkette zu indexieren, um ein Zeichen zu erhalten,
ist, dass von Indexoperationen erwartet wird, dass sie immer in konstanter Zeit
(O(1)) erfolgen. Es ist jedoch nicht möglich, diese Zeitgarantie bei einem
<code>String</code> einzuhalten, da Rust den Inhalt von Anfang an bis zum Index durchgehen
müsste, um festzustellen, wie viele gültige Zeichen es gibt.</p>
<h3 id="anteilige-zeichenketten"><a class="header" href="#anteilige-zeichenketten">Anteilige Zeichenketten</a></h3>
<p>Die Indexierung einer Zeichenkette ist oft eine schlechte Idee, weil nicht klar
ist, was der Rückgabetyp der Zeichenketten-Indexoperation sein soll: Ein
Byte-Wert, ein Zeichen, eine Graphemgruppe oder ein Zeichenkettenanteilstyp.
Wenn du wirklich Indizes verwenden musst, um Zeichenkettenanteilstypen zu
erstellen, bittet Rust dich daher, genauer zu sein.</p>
<p>Anstatt <code>[]</code> mit einer einzelnen Zahl zu indizieren, kannst du <code>[]</code> mit einem
Bereich verwenden, um ein Zeichenkettenanteilstyp zu erstellen, der bestimmte
Bytes enthält:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>Hier wird <code>s</code> ein <code>&amp;str</code> sein, das die ersten 4 Bytes der Zeichenkette enthält.
Vorhin haben wir bereits erwähnt, dass jedes dieser Zeichen 2 Bytes lang ist,
was bedeutet, dass <code>s</code> gleich <code>Зд</code> ist.</p>
<p>Wenn wir versuchen würden, nur einen Teil der Bytes eines Zeichens mit etwas
wie <code>&amp;hello[0..1]</code> zu zerschneiden, würde Rust das Programm zur Laufzeit
abbrechen, genauso als wenn mit einem ungültigen Index auf einen Vektor
zugegriffen würde:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2069:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Bei der Verwendung von Bereichen zum Erstellen von Zeichenkettenanteilstypen
ist Vorsicht geboten, da dies zum Absturz deines Programms führen kann.</p>
<h3 id="methoden-zum-iterieren-über-zeichenketten"><a class="header" href="#methoden-zum-iterieren-über-zeichenketten">Methoden zum Iterieren über Zeichenketten</a></h3>
<p>Der beste Weg, um mit Teilen von Zeichenketten zu arbeiten, besteht darin,
explizit anzugeben, ob du Zeichen oder Bytes benötigst. Für einzelne
Unicode-Skalarwerte ist die Methode <code>chars</code> zu verwenden. Der Aufruf von
<code>chars</code> auf „Зд“ trennt zwei Werte vom Typ <code>char</code> heraus und gibt sie
zurück, und du kannst über das Ergebnis iterieren, um auf jedes Element
zuzugreifen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;Зд&quot;.chars() {
    println!(&quot;{c}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code wird folgendes ausgeben:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>Die Methode <code>bytes</code> gibt jedes rohe Byte zurück, das für deinen
Verwendungszweck benötigt wird:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;Зд&quot;.bytes() {
    println!(&quot;{b}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code gibt die vier Bytes aus, aus denen diese Zeichenkette besteht:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>Aber denke daran, dass gültige Unicode-Skalarwerte aus mehr als 1 Byte bestehen
können.</p>
<p>Die Ermittlung von Graphemgruppen aus Zeichenketten wie bei der
Devanagari-Schrift ist komplex, sodass diese Funktionalität nicht von der
Standardbibliothek bereitgestellt wird. Kisten (crates) sind unter
<a href="https://crates.io/">crates.io</a> verfügbar, falls du diese Funktionalität
benötigst.</p>
<h3 id="zeichenketten-sind-nicht-so-einfach"><a class="header" href="#zeichenketten-sind-nicht-so-einfach">Zeichenketten sind nicht so einfach</a></h3>
<p>Zusammenfassend kann man sagen, dass Zeichenketten kompliziert sind.
Verschiedene Programmiersprachen treffen unterschiedliche Entscheidungen
darüber, wie diese Komplexität dem Programmierer angezeigt wird. Rust hat sich
dafür entschieden, den korrekten Umgang mit Zeichenkettendaten zum
Standardverhalten für alle Rust-Programme zu machen, was bedeutet, dass
Programmierer sich im Vorfeld mehr Gedanken über den Umgang mit UTF-8-Daten
machen müssen. Dieser Zielkonflikt macht die Komplexität von Zeichenketten
größer als in anderen Programmiersprachen, aber er verhindert, dass du später
in deinem Entwicklungslebenszyklus mit Fehlern umgehen musst, wenn
Nicht-ASCII-Zeichen vorkommen.</p>
<p>Die gute Nachricht ist, dass die Standardbibliothek eine Vielzahl von
Funktionen bietet, die auf den Typen <code>String</code> und <code>&amp;str</code> aufbauen, um diese
komplexen Situationen korrekt zu behandeln. In der Dokumentation findest du
nützliche Methoden wie <code>contains</code> zum Suchen in einer Zeichenkette und
<code>replace</code> zum Ersetzen von Teilen einer Zeichenkette durch eine andere
Zeichenkette.</p>
<p>Lass uns zu etwas weniger Kompliziertem übergehen: Hashtabellen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="schlüssel-mit-zugehörigen-werten-in-hashtabellen-ablegen"><a class="header" href="#schlüssel-mit-zugehörigen-werten-in-hashtabellen-ablegen">Schlüssel mit zugehörigen Werten in Hashtabellen ablegen</a></h2>
<p>Die letzte unserer allgemeinen Kollektionen ist die <em>Hashtabelle</em> (hash map).
Der Typ <code>HashMap&lt;K, V&gt;</code> speichert eine Zuordnung von Schlüsseln vom Typ <code>K</code> zu
Werten vom Typ <code>V</code> mittels einer <em>Hashfunktion</em> (hash function), die bestimmt,
wie er diese Schlüssel und Werte im Speicher ablegt. Viele Programmiersprachen
unterstützen diese Art Datenstruktur, aber sie verwenden oft einen anderen
Namen, z.B. Hash, Abbildung (map), Objekt, Hashtabelle (hash table), Wörterbuch
(dictionary) oder assoziatives Array (associative array), um nur einige zu
nennen. Hashtabellen sind nützlich, wenn du Daten nicht wie bei Vektoren über
einen Index nachschlagen willst, sondern über einen Schlüssel, der ein
beliebiger Typ sein kann. Beispielsweise könntest du in einem Spiel den
Spielstand jedes Teams in einer Hashtabelle vermerken, in der die Schlüssel den
Teamnamen und die Werte den Spielstand des jeweiligen Teams darstellen. Wenn du
den Namen eines Teams angibst, kannst du seine Punktzahl abrufen.</p>
<p>In diesem Abschnitt gehen wir die grundlegende Programmierschnittstelle (API)
von Hashtabellen durch, aber viele weitere Leckerbissen verbergen sich in den
Funktionen, die in der Standardbibliothek für <code>HashMap&lt;K, V&gt;</code> definiert sind.
Weitere Informationen findest du wie immer in der
Standardbibliotheksdokumentation.</p>
<h3 id="erstellen-einer-neuen-hashtabelle"><a class="header" href="#erstellen-einer-neuen-hashtabelle">Erstellen einer neuen Hashtabelle</a></h3>
<p>Ein Weg um eine leere Hashtabelle zu erzeugen ist mit <code>new</code> und um Elemente
hinzuzufügen mit <code>insert</code>. In Codeblock 8-20 verfolgen wir die Ergebnisse
zweier Mannschaften mit den Namen Blau und Gelb. Das Team Blau startet mit 10
Punkten, das Team Gelb mit 50 Punkten.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blau&quot;), 10);
scores.insert(String::from(&quot;Gelb&quot;), 50);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-20: Erstellen einer neuen Hashtabelle und
Einfügen einiger Schlüssel und Werte</span></p>
<p>Beachte, dass wir zuerst mit <code>use</code> die <code>HashMap</code> aus dem Kollektionsteil der
Standardbibliothek einbinden müssen. Von unseren drei allgemeinen Kollektionen
wird diese am seltensten verwendet, sodass sie nicht zu den Funktionalitäten
gehört, die automatisch in den Gültigkeitsbereich aufgenommen werden.
Hashtabellen werden auch weniger von der Standardbibliothek unterstützt; es
gibt zum Beispiel kein eingebautes Makro, um sie zu erzeugen.</p>
<p>Genau wie Vektoren speichern Hashtabellen ihre Daten im Haldenspeicher. 
Obige <code>HashMap</code> hat Schlüssel vom Typ <code>String</code> und Werte vom Typ <code>i32</code>.
Hashtabellen sind wie Vektoren homogen: Alle Schlüssel müssen denselben Typ
haben und alle Werte müssen denselben Typ haben.</p>
<h3 id="zugreifen-auf-werte-in-einer-hashtabelle"><a class="header" href="#zugreifen-auf-werte-in-einer-hashtabelle">Zugreifen auf Werte in einer Hashtabelle</a></h3>
<p>Wir können einen Wert aus der Hashtabelle herausholen, indem wir die Methode
<code>get</code> mit ihrem Schlüssel aufrufen, wie in Codeblock 8-21 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blau&quot;), 10);
scores.insert(String::from(&quot;Geld&quot;), 50);

let team_name = String::from(&quot;Blau&quot;);
let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-21: Zugreifen auf den Spielstand von Team
Blau in der Hashtabelle</span></p>
<p>Hier wird <code>score</code> den Wert haben, der mit Team Blau assoziiert ist, und das
Ergebnis wird <code>10</code> sein. Die Methode <code>get</code> gibt eine <code>Option&lt;&amp;V&gt;</code> zurück;
wenn es keinen Wert für diesen Schlüssel in der Hashtabelle gibt, gibt <code>get</code>
den Wert <code>None</code> zurück. Dieses Programm behandelt die <code>Option</code>, indem es
<code>copied</code> aufruft, um eine <code>Option&lt;i32&gt;</code> anstelle einer <code>Option&lt;&amp;i32&gt;</code> zu
erhalten, und ruft dann <code>unwrap_or</code> auf, um <code>score</code> auf Null zu setzen, wenn
<code>scores</code> keinen Eintrag für den Schlüssel hat.</p>
<p>Wir können über jedes Schlüssel-Wert-Paar in einer Hashtabelle auf ähnliche
Weise iterieren wie bei Vektoren, indem wir eine <code>for</code>-Schleife verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blau&quot;), 10);
scores.insert(String::from(&quot;Gelb&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{key}: {value}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code gibt alle Paare in einer beliebigen Reihenfolge aus:</p>
<pre><code class="language-text">Gelb: 50
Blau: 10
</code></pre>
<h3 id="hashtabellen-und-eigentümerschaft"><a class="header" href="#hashtabellen-und-eigentümerschaft">Hashtabellen und Eigentümerschaft</a></h3>
<p>Bei Typen wie <code>i32</code>, die das Merkmal <code>Copy</code> implementieren, werden die Werte in
die Hashtabelle kopiert. Bei aneigenbaren Werten wie <code>String</code> werden die Werte
verschoben und die Hashtabelle ist Eigentümer dieser Werte, wie in Codeblock
8-22 gezeigt wird.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let field_name = String::from(&quot;Lieblingsfarbe&quot;);
let field_value = String::from(&quot;Blau&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name und field_value sind nach diesem Zeitpunkt ungültig.
// Versuche, sie zu benutzen und beobachte, welchen Kompilierfehler du erhältst!
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-22: Zeigt, dass Schlüssel und Werte nach dem
Aufruf von <code>insert</code> Eigentum der Hashtabelle sind</span></p>
<p>Wir können die Variablen <code>field_name</code> und <code>field_value</code> nicht mehr verwenden,
nachdem sie mit dem Aufruf von <code>insert</code> in die Hashtabelle verschoben wurden.</p>
<p>Wenn wir Referenzen auf Werte in die Hashtabelle einfügen, werden die Werte
nicht in die Hashtabelle verschoben. Die Werte, auf die die Referenzen zeigen,
müssen mindestens so lange gültig sein, wie die Hashtabelle gültig ist. Wir
werden mehr über diese Fragen im Abschnitt <a href="ch10-03-lifetime-syntax.html">„Referenzen validieren mit
Lebensdauern“</a> in Kapitel 10 sprechen.</p>
<h3 id="aktualisieren-einer-hashtabelle"><a class="header" href="#aktualisieren-einer-hashtabelle">Aktualisieren einer Hashtabelle</a></h3>
<p>Obwohl die Anzahl der Schlüssel- und Wertepaare vergrößerbar ist, kann jedem
eindeutigen Schlüssel jeweils nur ein Wert zugeordnet werden (aber nicht
umgekehrt: Zum Beispiel könnten sowohl das blaue Team als auch das gelbe Team
den Wert 10 in der Hashtabelle <code>scores</code> gespeichert haben).</p>
<p>Wenn du die Daten in einer Hashtabelle ändern willst, musst du entscheiden, wie
der Fall zu behandeln ist, wenn einem Schlüssel bereits ein Wert zugewiesen
wurde. Du kannst den alten Wert durch den neuen ersetzen und dabei den alten
Wert völlig außer Acht lassen. Du kannst den alten Wert behalten und den neuen
Wert ignorieren und nur dann den neuen Wert hinzufügen, wenn der Schlüssel noch
<em>keinen</em> zugewiesenen Wert hat. Oder du kannst den alten und neuen Wert
kombinieren. Schauen wir uns an, wie diese Varianten jeweils funktionieren!</p>
<h4 id="Überschreiben-eines-wertes"><a class="header" href="#Überschreiben-eines-wertes">Überschreiben eines Wertes</a></h4>
<p>Wenn wir einen Schlüssel und einen Wert in eine Hashtabelle einfügen und dann
denselben Schlüssel mit einem anderen Wert einfügen, wird der mit diesem
Schlüssel assoziierte Wert ersetzt. Auch wenn der Code in Codeblock 8-23
zweimal <code>insert</code> aufruft, wird die Hashtabelle nur ein Schlüssel-Wert-Paar
enthalten, weil wir beide Male einen Wert für den Schlüssel des Teams Blau
einfügen.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blau&quot;), 10);
scores.insert(String::from(&quot;Blau&quot;), 25);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-23: Ersetzen eines gespeicherten Wertes für
einen bestimmten Schlüssel</span></p>
<p>Dieser Code wird <code>{&quot;Blau&quot;: 25}</code> ausgeben. Der ursprüngliche Wert <code>10</code> wurde
überschrieben.</p>
<h4 id="nur-einen-schlüssel-und-wert-einfügen-wenn-der-schlüssel-nicht-vorhanden-ist"><a class="header" href="#nur-einen-schlüssel-und-wert-einfügen-wenn-der-schlüssel-nicht-vorhanden-ist">Nur einen Schlüssel und Wert einfügen, wenn der Schlüssel nicht vorhanden ist</a></h4>
<p>Es ist üblich, zu prüfen, ob ein bestimmter Schlüssel bereits in der
Hashtabelle mit einem Wert vorhanden ist, und dann folgende Maßnahmen zu
ergreifen: Wenn der Schlüssel in der Hashtabelle vorhanden ist, sollte der
vorhandene Wert so bleiben, wie er ist. Wenn der Schlüssel nicht vorhanden ist,
füge ihn und einen Wert für ihn ein.</p>
<p>Hashtabellen haben dafür eine spezielle Programmierschnittstelle (API) namens
<code>entry</code>, die den Schlüssel, den du prüfen willst, als Parameter nimmt. Der
Rückgabewert der Methode <code>entry</code> ist eine Aufzählung (enum) namens <code>Entry</code>, die
einen Wert repräsentiert, der existieren könnte oder auch nicht. Nehmen wir an,
wir wollen prüfen, ob der Schlüssel für das Team Gelb einen Wert hat. Wenn das
nicht der Fall ist, wollen wir den Wert 50 einfügen, und dasselbe gilt für das
Team Blau. Bei Verwendung von <code>entry</code> sieht der Code wie Codeblock 8-24 aus.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blau&quot;), 10);

scores.entry(String::from(&quot;Gelb&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blau&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-24: Verwenden der Methode <code>entry</code> zum
Einfügen, nur wenn der Schlüssel nicht bereits einen Wert hat</span></p>
<p>Die Methode <code>or_insert</code> von <code>Entry</code> ist so definiert, dass sie eine
veränderbare Referenz auf den Wert des entsprechenden <code>Entry</code>-Schlüssels
zurückgibt, wenn dieser Schlüssel existiert, andernfalls fügt sie den Parameter
als neuen Wert für diesen Schlüssel ein und gibt eine veränderbare Referenz
auf den neuen Wert zurück. Diese Technik ist viel sauberer, als die Logik
selbst zu schreiben, und sie harmoniert besser mit dem Ausleihenprüfer.</p>
<p>Der Code in Codeblock 8-24 gibt <code>{&quot;Gelb&quot;: 50, &quot;Blau&quot;: 10}</code> aus. Beim ersten
Aufruf von <code>entry</code> wird der Schlüssel von Team Gelb mit dem Wert 50 eingefügt,
da das Team Gelb noch keinen Wert hat. Der zweite Aufruf von <code>entry</code> wird die
Hashtabelle nicht verändern, da das Team Blau bereits den Wert 10 hat.</p>
<h4 id="aktualisieren-eines-wertes-auf-basis-des-alten-wertes"><a class="header" href="#aktualisieren-eines-wertes-auf-basis-des-alten-wertes">Aktualisieren eines Wertes auf Basis des alten Wertes</a></h4>
<p>Ein weiterer gängiger Anwendungsfall für Hashtabellen besteht darin, den Wert
eines Schlüssels nachzuschlagen und ihn dann auf Basis des alten Wertes zu
aktualisieren. Beispielsweise zeigt Codeblock 8-25 einen Code, der zählt, wie
oft jedes Wort in einem Text vorkommt. Wir verwenden eine Hashtabelle mit den
Wörtern als Schlüssel und inkrementieren den Wert, um nachzuvollziehen, wie oft
wir dieses Wort schon gesehen haben. Wenn es das erste Mal ist, dass wir ein
Wort sehen, fügen wir zuerst den Wert 0 ein.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let text = &quot;Hallo Welt wunderbare Welt&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 8-25: Zählen des Vorkommens von Wörtern mit
Hilfe einer Hashtabelle, die Wörter speichert und zählt</span></p>
<p>Dieser Code gibt <code>{&quot;Welt&quot;: 2, &quot;wunderbare&quot;: 1, &quot;Hallo&quot;: 1}</code> aus. Es kann sein,
dass dieselben Schlüssel/Wert-Paare in einer anderen Reihenfolge ausgegeben
werden: Du erinnerst dich an den Abschnitt <a href="ch08-03-hash-maps.html#zugreifen-auf-werte-in-einer-hashtabelle">„Zugreifen auf Werte in einer
Hashtabelle“</a>, dass die Iteration über eine Hashtabelle in beliebiger
Reihenfolge erfolgt.</p>
<p>Die Methode <code>split_whitespace</code> gibt einen Iterator über durch Leerzeichen
getrennte Sub-Anteilstypen des Wertes in <code>text</code> zurück. Die Methode <code>or_insert</code>
gibt eine veränderbare Referenz (<code>&amp;mut V</code>) auf den Wert für den angegebenen
Schlüssel zurück. Hier speichern wir diese veränderbaren Referenz in der
Variablen <code>count</code>. Um diesen Wert zuzuweisen, müssen wir also zuerst <code>count</code>
mit dem Stern (<code>*</code>) derefenzieren. Die veränderbare Referenz verlässt am Ende
der <code>for</code>-Schleife dem Gültigkeitsbereich, sodass alle diese Änderungen sicher
und gemäß der Ausleihregeln zulässig sind.</p>
<h3 id="hash-funktionen"><a class="header" href="#hash-funktionen">Hash-Funktionen</a></h3>
<p>Standardmäßig verwendet <code>HashMap</code> eine Hash-Funktion namens <em>SipHash</em>, die robust
gegen Denial-of-Service-Angriffe (DoS) mit Hash-Tabellen<sup class="footnote-reference"><a href="#siphash">1</a></sup> ist. Dies
ist nicht der schnellste verfügbare Hashing-Algorithmus, aber der Kompromiss
zugunsten einer höheren Sicherheit gegenüber einer geringeren Performanz ist es
Wert. Wenn du eine Performanzanalyse deines Codes machst und feststellst, dass
die Standard-Hash-Funktion für deine Zwecke zu langsam ist, kannst du zu einer
anderen Funktion wechseln, indem du eine andere Hash-Funktion angibst. Eine
<em>Hash-Funktion</em> ist ein Typ, der das Merkmal <code>BuildHasher</code> implementiert. Wir
werden in Kapitel 10 über Merkmale und ihre Implementierung sprechen. Du musst
nicht unbedingt deine eigene Hash-Funktion von Grund auf implementieren;
<a href="https://crates.io/">crates.io</a> verfügt über Bibliotheken, die von anderen
Rust-Nutzern bereitgestellt werden und viele gängige Hash-Funktionen
implementieren.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<h2 id="zusammenfassung-7"><a class="header" href="#zusammenfassung-7">Zusammenfassung</a></h2>
<p>Vektoren, Zeichenketten und Hashtabellen bieten eine große Menge an
Funktionalität, die in Programmen benötigt wird, wenn du Daten speichern,
darauf zugreifen und sie verändern willst. Hier sind einige Übungen, für deren
Lösung du jetzt gerüstet sein solltest:</p>
<ul>
<li>Verwende bei einer Liste von ganzen Zahlen einen Vektor und gib den
Median (wenn sortiert, den Wert in der Mitte) und den Modus (den Wert,
der am häufigsten vorkommt; eine Hashtabelle ist hier hilfreich) der Liste
zurück.</li>
<li>Wandle Zeichenketten in Schweinelatein (pig latin) um. Der erste Konsonant
jedes Wortes wird an das Ende des Wortes verschoben und „ay“ angehängt,
sodass „zuerst“ zu „uerst-zay“ wird. Bei Wörtern, die mit einem Vokal
beginnen, wird stattdessen „hay“ an das Ende angefügt („ansehen“ wird zu
„ansehen-hay“). Beachte die Details zur UTF-8-Kodierung!</li>
<li>Erstelle mit Hilfe einer Hashtabelle und Vektoren eine Textschnittstelle, die
es einem Benutzer ermöglicht, Mitarbeiternamen zu einer Abteilung in einem
Unternehmen hinzuzufügen. Zum Beispiel „Sally zur Technik hinzufügen“ oder
„Amir zum Vertrieb hinzufügen“. Lass den Benutzer dann eine alphabetisch
sortierte Liste aller Personen in einer Abteilung oder aller Personen in der
Firma nach Abteilung ausgeben.</li>
</ul>
<p>Die API-Dokumentation der Standard-Bibliothek beschreibt Methoden für Vektoren,
Zeichenketten und Hashtabellen, die für diese Übungen hilfreich sind!</p>
<p>Wir steigen in komplexere Programme ein, in denen Operationen fehlschlagen
können, daher ist es ein perfekter Zeitpunkt, auf die Fehlerbehandlung
einzugehen. Das werden wir als nächstes tun!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fehlerbehandlung"><a class="header" href="#fehlerbehandlung">Fehlerbehandlung</a></h1>
<p>Fehler sind eine Tatsache im Software-Alltag, deshalb enthält Rust eine Reihe von
Funktionalitäten zur Behandlung von Situationen, in denen etwas schiefgeht. In
vielen Fällen verlangt Rust von dir, dass du die Möglichkeit eines Fehlers
anerkennst und Vorkehrungen ergreifst, damit dein Code kompiliert werden kann.
Diese Anforderung macht dein Programm robuster, da sichergestellt wird, dass du
Fehler entdeckst und diese angemessen behandelst, bevor dein Code in Produktion
gebracht wird!</p>
<p>Rust gruppiert Fehler in zwei Hauptkategorien: <em>Behebbare</em> (recoverable) und
<em>nicht behebbare</em> (unrecoverable) Fehler. Bei einem behebbaren Fehler, z.B.
„Datei nicht gefunden“, wollen wir das Problem wahrscheinlich dem Benutzer
melden und den Vorgang erneut versuchen. Nicht behebbare Fehler sind immer
Symptome von Programmierfehlern, z.B. der Versuch, auf eine Stelle hinter dem
Ende eines Arrays zuzugreifen, und deshalb wollen wir das Programm sofort
anhalten.</p>
<p>Die meisten Sprachen unterscheiden nicht zwischen diesen beiden Fehlerarten und
behandeln beide auf die gleiche Weise, indem sie Mechanismen wie die
Ausnahmebehandlung verwenden. Rust hat keine Ausnahmebehandlung. Stattdessen
hat es den Typ <code>Result&lt;T, E&gt;</code> für behebbare Fehler und das Makro <code>panic!</code>, das
die Ausführung stoppt, wenn das Programm auf einen nicht behebbaren Fehler
stößt. Dieses Kapitel behandelt zuerst das Aufrufen von <code>panic!</code> und spricht
dann über die Rückgabe von <code>Result&lt;T, E&gt;</code>-Werten. Darüber hinaus werden wir
uns mit der Frage befassen, wann man versuchen sollte, einen Fehler zu beheben
oder die Ausführung zu stoppen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nicht-behebbare-fehler-mit-panic"><a class="header" href="#nicht-behebbare-fehler-mit-panic">Nicht behebbare Fehler mit <code>panic!</code></a></h2>
<p>Manchmal passieren schlimme Dinge in deinem Code und du kannst nichts dagegen
tun. Für diese Fälle hat Rust das Makro <code>panic!</code>. In der Praxis gibt es zwei
Möglichkeiten, ein Programm abstürzen zu lassen: Durch eine Aktion, die unseren
Code abstürzen lässt (z.B. Zugriff auf ein Array über das Ende hinaus) oder
durch den expliziten Aufruf des Makros <code>panic!</code>. In beiden Fällen brechen wir
unser Programm ab. Standardmäßig geben diese Programmabbrüche eine
Fehlermeldung aus, räumen den Stapelspeicher auf und beenden sich. Über eine
Umgebungsvariable kannst du auch festlegen, dass Rust den Stapelspeicher
anzeigt, wenn das Programm abbricht, damit du die Quelle des Abbruchs leichter
aufspüren kannst.</p>
<blockquote>
<h3 id="auflösen-des-stapelspeichers-oder-abbrechen-als-fehlerreaktion"><a class="header" href="#auflösen-des-stapelspeichers-oder-abbrechen-als-fehlerreaktion">Auflösen des Stapelspeichers oder Abbrechen als Fehlerreaktion</a></h3>
<p>Wenn ein Programmabbruch auftritt, beginnt das Programm standardmäßig mit dem
<em>Abwickeln</em>, was bedeutet, dass Rust den Stapelspeicher wieder nach oben geht
und die Daten von jeder Funktion, auf die es trifft, bereinigt. Allerdings
ist dieses Zurückgehen und Aufräumen eine Menge Arbeit. Rust bietet dir als
Alternative daher an, das Programm sofort <em>abzubrechen</em>, wobei das Programm
beendet wird, ohne aufzuräumen.</p>
<p>Der Speicher, den das Programm benutzt hat, muss dann vom Betriebssystem
aufgeräumt werden. Wenn du in deinem Projekt die resultierende Binärdatei so
klein wie möglich machen willst, kannst du für ein vorzeitiges Programmende
vom Abwickeln zum sofortigen Abbrechen umschalten, indem du <code>panic = 'abort'</code>
in den entsprechenden <code>[profile]</code>-Abschnitten in deiner <em>Cargo.toml</em>-Datei
hinzufügst. Wenn du beispielsweise im Freigabemodus (release mode) im
Fehlerfall sofort abbrechen möchtest, füge dies hinzu:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Versuchen wir <code>panic!</code> in einem einfachen Programm aufzurufen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;abstürzen und verbrennen&quot;);
}</code></pre></pre>
<p>Wenn du das Programm ausführst, wirst du in etwa das hier sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'abstürzen und verbrennen', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Der Aufruf von <code>panic!</code> verursacht die in den letzten beiden Zeilen enthaltene
Fehlermeldung. Die erste Zeile zeigt unsere Fehlermeldung und die Position in
unserem Quellcode, an der der Fehler aufgetreten ist: <em>src/main.rs:2:5</em> gibt
an, dass es sich um die zweite Zeile und dem fünften Zeichen in unserer Datei
<em>src/main.rs</em> handelt.</p>
<p>In diesem Fall ist die angegebene Zeile Teil unseres Codes und wenn wir uns
diese Zeile ansehen, sehen wir den Makroaufruf <code>panic!</code>. In anderen Fällen
könnte der Aufruf von <code>panic!</code> in Code erfolgen, den unser Code aufruft, und
der Dateiname und die Zeilennummer in der Fehlermeldung gehören zu Code von
jemand anderen, der das Makro <code>panic!</code> aufruft, nicht zu unserem Code, der
schließlich zum Aufruf von <code>panic!</code> geführt hat. Wir können die Aufrufhistorie
(backtrace) der Funktionen, von der der <code>panic!</code>-Aufruf kam, nutzen, um den
Codeteil zu ermitteln, der das Problem verursacht. Wir werden Aufrufhistorien
im nächsten Abschnitt ausführlicher besprechen.</p>
<h3 id="verwenden-einer-panic-aufrufhistorie"><a class="header" href="#verwenden-einer-panic-aufrufhistorie">Verwenden einer <code>panic!</code>-Aufrufhistorie</a></h3>
<p>Sehen wir uns ein weiteres Beispiel an, bei dem der <code>panic!</code>-Aufruf von einer
Bibliothek kommt, weil wir einen Fehler in unserem Code haben, anstatt das
Makro direkt aufzurufen. Codeblock 9-1 enthält einen Code, der versucht, auf
einen Index in einem Vektor zuzugreifen, der außerhalb des Bereichs gültiger
Indizes liegt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}</code></pre></pre>
<p><span class="caption">Codeblock 9-1: Versuch, auf ein Element jenseits des
Endes eines Vektors zuzugreifen, was einen Aufruf von <code>panic!</code> auslöst</span></p>
<p>Hier versuchen wir, auf das 100. Element unseres Vektors zuzugreifen (das bei
Index 99 liegt, weil die Indexierung bei Null beginnt), der Vektor hat aber nur
3 Elemente. In dieser Situation wird Rust das Programm abbrechen. Das Verwenden
von <code>[]</code> soll ein Element zurückgeben, aber wenn du einen ungültigen Index
übergibst, gibt es kein Element, das Rust hier korrekterweise zurückgeben
könnte.</p>
<p>In C ist der Versuch, über das Ende einer Datenstruktur hinaus zu lesen, ein
undefiniertes Verhalten. Möglicherweise erhältst du den Wert im Speicher an der
der Datenstruktur entsprechenden Stelle, selbst wenn der Speicher nicht zu
dieser Struktur gehört. Dies wird als <em>Hinauslesen über den Puffer</em> (buffer
overread) bezeichnet und kann zu Sicherheitslücken führen, wenn ein Angreifer
in der Lage ist, den Index so zu manipulieren, dass er unerlaubterweise Daten
lesen kann, die nach der Datenstruktur gespeichert sind.</p>
<p>Um dein Programm vor dieser Art Verwundbarkeit zu schützen, wird Rust beim
Versuch, ein Element an einem Index zu lesen, der nicht existiert, die
Ausführung stoppen und die Fortsetzung verweigern. Versuchen wir es und sehen,
was passiert:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806:10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Dieser Fehler weist auf Zeile 4 in unserer <code>main.rs</code> hin, wo wir versuchen, auf
den Index 99 zuzugreifen. Die nächste Hinweiszeile sagt uns, dass wir die
Umgebungsvariable <code>RUST_BACKTRACE</code> setzen können, um einen Backtrace zu
erhalten, was genau passiert ist, das den Fehler verursacht hat. Ein
<em>Backtrace</em> ist eine Liste aller Funktionen, die aufgerufen wurden, um an
diesen Punkt zu gelangen. Backtraces in Rust funktionieren wie in anderen
Sprachen: Der Schlüssel zum Lesen des Backtraces ist, von oben zu beginnen und
zu lesen, bis du Dateien siehst, die du geschrieben hast. Das ist die Stelle,
an der das Problem entstanden ist. Die Zeilen darüber sind Code, den dein Code
aufgerufen hat; die Zeilen darunter sind Code, der deinen Code aufgerufen hat.
Diese Zeilen können Core-Rust-Code, Code der Standardbibliothek oder Kisten,
enthalten, die du verwendest. Versuchen wir, einen Backtrace zu erhalten, indem
wir die Umgebungsvariable <code>RUST_BACKTRACE</code> auf einen beliebigen Wert außer 0
setzen. Codeblock 9-2 zeigt eine ähnliche Ausgabe wie die, die du sehen wirst.</p>
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/std/src/panicking.rs:483
   1: core::panicking::panic_fmt
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:85
   2: core::panicking::panic_bounds_check
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:62
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:255
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:15
   5: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/alloc/src/vec.rs:1982
   6: panic::main
             at ./src/main.rs:4
   7: core::ops::function::FnOnce::call_once
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/ops/function.rs:227
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p><span class="caption">Codeblock 9-2: Aufrufhistorie, erzeugt durch einen Aufruf
von <code>panic!</code>, wenn die Umgebungsvariable <code>RUST_BACKTRACE</code> gesetzt ist</span></p>
<p>Das ist eine lange Ausgabe! Die genaue Ausgabe kann je nach Betriebssystem und
Rust-Version unterschiedlich sein. Um Aufrufhistorien mit diesen Informationen
zu erhalten, müssen Fehlersuchinfos (debug symbols) aktiviert sein.
Fehlersuchinfos sind standardmäßig aktiviert, wenn du <code>cargo build</code> oder
<code>cargo run</code> ohne Flag <code>--release</code> verwendest, wie wir es hier haben.</p>
<p>In der Ausgabe in Codeblock 9-2 zeigt Zeile 17 der Aufrufhistorie auf die Zeile
in unserem Projekt, die das Problem verursacht: Zeile 4 in <em>src/main.rs</em>. Wenn
wir nicht wollen, dass unser Programm abbricht, sollten wir bei der ersten
Zeile, die auf eine von uns geschriebenen Datei verweist, mit der Untersuchung
beginnen. In Codeblock 9-1, wo wir absichtlich Code geschrieben haben, der das
Programm abbricht, besteht die Möglichkeit das Problem zu beheben darin, kein
Element außerhalb des Bereichs der Vektorindizes anzufordern. Wenn dein Code in
Zukunft abbricht, musst du herausfinden, bei welcher Aktion der Code mit
welchen Werten abbricht und was der Code stattdessen tun sollte.</p>
<p>In Abschnitt <a href="ch09-03-to-panic-or-not-to-panic.html">„Wann <code>panic!</code> verwenden und wann
nicht?“</a> später in diesem Kapitel kommen wir noch
einmal auf <code>panic!</code> zurück und wann wir <code>panic!</code> verwenden sollten und wann
nicht, um Fehlerfälle zu behandeln. Als Nächstes schauen wir uns an, wie man
Fehler mit <code>Result</code> abfangen kann.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="behebbare-fehler-mit-result"><a class="header" href="#behebbare-fehler-mit-result">Behebbare Fehler mit <code>Result</code></a></h2>
<p>Die meisten Fehler sind nicht so schwerwiegend, dass das Programm ganz
abgebrochen werden müsste. Manchmal, wenn eine Funktion fehlschlägt, hat das
einen Grund, den man leicht erkennen und darauf reagieren kann. Wenn du
beispielsweise versuchst, eine Datei zu öffnen, und dieser Vorgang schlägt
fehl, weil die Datei nicht existiert, könntest du die Datei erstellen, anstatt
den Vorgang zu beenden.</p>
<p>Erinnere dich an <a href="ch02-00-guessing-game-tutorial.html#behandeln-potentieller-fehler-mit-result">„Behandeln potentieller Fehler mit dem Typ
<code>Result</code>“</a> in Kapitel 2, das die Aufzählung <code>Result</code> mit zwei
Varianten <code>Ok</code> und <code>Err</code> definiert, wie nachfolgend zu sehen ist:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>T</code> und <code>E</code> sind generische Typparameter: Wir werden generische Datentypen in
Kapitel 10 ausführlicher besprechen. Was du jetzt wissen musst, ist, dass <code>T</code>
den Typ des Wertes darstellt, der im Erfolgsfall innerhalb der <code>Ok</code>-Variante
zurückgegeben wird, und <code>E</code> den Typ des Fehlers, der im Fehlerfall innerhalb
der <code>Err</code>-Variante zurückgegeben wird. Da <code>Result</code> diese generischen
Typparameter hat, können wir den <code>Result</code>-Typ und die Funktionen, die darauf
definiert sind, in vielen verschiedenen Situationen verwenden, in denen der
Erfolgswert und der Fehlerwert, den wir zurückgeben wollen, unterschiedlich
sein können.</p>
<p>Rufen wir eine Funktion auf, die einen <code>Result</code>-Wert zurückgibt, weil die
Funktion fehlschlagen könnte. In Codeblock 9-3 versuchen wir, eine Datei zu
öffnen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hallo.txt&quot;);
}</code></pre></pre>
<p><span class="caption">Codeblock 9-3: Eine Datei öffnen</span></p>
<p>Der Rückgabetyp von <code>File::open</code> ist <code>Result&lt;T, E&gt;</code>. Der generische Parameter
<code>T</code> wurde hier mit dem Typ des Erfolgswertes <code>std::fs::File</code>, der eine
Dateiressource (file handle) ist, gefüllt. Der Typ <code>E</code> für den Fehlerwert ist
<code>std::io::Error</code>. Dieser Rückgabetyp bedeutet, dass der Aufruf von <code>File::open</code>
erfolgreich sein könnte und eine Dateiressource zurückgibt, aus der wir lesen
oder in die wir schreiben können. Der Funktionsaufruf kann auch fehlschlagen:
Zum Beispiel könnte die Datei nicht existieren oder wir haben möglicherweise
keine Zugriffsberechtigung für die Datei. Die Funktion <code>File::open</code> muss eine
Möglichkeit haben, uns zu sagen, ob sie erfolgreich war oder fehlgeschlagen
ist, und uns gleichzeitig entweder die Dateiressource oder die
Fehlerinformationen liefern. Diese Informationen sind genau das, was die
Aufzählung <code>Result</code> übermittelt.</p>
<p>Falls <code>File::open</code> erfolgreich ist, wird der Wert der Variable
<code>greeting_file_result</code> eine Instanz von <code>Ok</code> sein, die eine Dateiressource
enthält. Im Fehlerfall ist der Wert von <code>greeting_file_result</code> eine Instanz von
<code>Err</code>, die mehr Informationen über die Art des aufgetretenen Fehlers enthält.</p>
<p>Wir müssen den Code in Codeblock 9-3 ergänzen, um abhängig vom Rückgabewert von
<code>File::open</code> unterschiedliche Aktionen durchzuführen. Codeblock 9-4 zeigt eine
Möglichkeit, <code>Result</code> mit Hilfe eines grundlegenden Werkzeugs, dem Ausdruck
<code>match</code>, den wir in Kapitel 6 besprochen haben, zu behandeln.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hallo.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem beim Öffnen der Datei: {:?}&quot;, error),
    };
}</code></pre></pre>
<p><span class="caption">Codeblock 9-4: Verwenden eines <code>match</code>-Ausdrucks zum
Behandeln der <code>Result</code>-Varianten, die zurückgegeben werden könnten</span></p>
<p>Beachte, dass die Aufzählung <code>Result</code> und ihre Varianten automatisch im
Gültigkeitsbereich verfügbar sind, genau wie bei der Aufzählung <code>Option</code>,
sodass wir in den <code>match</code>-Zweigen nicht mehr <code>Result::</code> vor den Varianten <code>Ok</code>
und <code>Err</code> angeben müssen.</p>
<p>Wenn das Ergebnis <code>Ok</code> ist, gibt dieser Code den inneren <code>file</code>-Wert aus der
<code>Ok</code>-Variante zurück, und wir weisen diese Dateiressource der Variablen 
<code>greeting_file </code> zu.
Nach dem <code>match</code> können wir die Dateiressource zum Lesen und Schreiben verwenden.</p>
<p>Der andere Zweig von <code>match</code> behandelt den Fall, dass wir einen <code>Err</code>-Wert von
<code>File::open</code> erhalten. In diesem Beispiel haben wir uns dafür entschieden, das
Makro <code>panic!</code> aufzurufen. Wenn es keine Datei namens <em>hallo.txt</em> in unserem
aktuellen Verzeichnis gibt und wir diesen Code ausführen, sehen wir die
folgende Ausgabe des Makros <code>panic!</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem beim Öffnen der Datei: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Wie üblich sagt uns diese Ausgabe genau, was schiefgelaufen ist.</p>
<h3 id="abgleich-verschiedener-fehler"><a class="header" href="#abgleich-verschiedener-fehler">Abgleich verschiedener Fehler</a></h3>
<p>Der Code in Codeblock 9-4 wird abbrechen, egal aus welchem Grund <code>File::open</code>
fehlschlug. Nun wollen wir jedoch bei verschiedenen Fehlerursachen
unterschiedliche Maßnahmen ergreifen: Wenn <code>File::open</code> fehlgeschlagen ist,
weil die Datei nicht existiert, wollen wir die Datei erstellen und die
Dateiressource der neuen Datei zurückgeben. Wenn <code>File::open</code> aus irgendeinem
anderen Grund fehlschlug, z.B. weil wir keine Berechtigung zum Öffnen der Datei
hatten, wollen wir immer noch, dass der Code abbricht, so wie es in Codeblock
9-4 der Fall war. Dazu fügen wir einen inneren <code>match</code>-Ausdruck hinzu, wie in
Codeblock 9-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open(&quot;hallo.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hallo.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem beim Erstellen der Datei: {:?}&quot;, e),
            },
            other_error =&gt; {
                panic!(&quot;Problem beim Öffnen der Datei: {:?}&quot;, other_error)
            }
        },
    };
}</code></pre></pre>
<p><span class="caption">Codeblock 9-5: Unterschiedliche Arten von Fehlern auf
unterschiedliche Weise behandeln</span></p>
<p>Der Typ des Wertes, den <code>File::open</code> innerhalb der Variante <code>Err</code> zurückgibt,
ist <code>io::Error</code>, eine Struktur (struct), die von der Standardbibliothek zur
Verfügung gestellt wird. Diese Struktur hat eine Methode <code>kind</code>, die wir
aufrufen können, um einen <code>io::ErrorKind</code>-Wert zu erhalten. Die Aufzählung
<code>io::ErrorKind</code> wird von der Standardbibliothek zur Verfügung gestellt und
enthält Varianten, die die verschiedenen Fehlerarten repräsentieren, die bei
einer <code>io</code>-Operation auftreten können. Die Variante, die wir verwenden wollen,
ist <code>ErrorKind::NotFound</code>, was bedeutet, dass die Datei, die wir zu öffnen
versuchen, noch nicht existiert. Wir werten also <code>greeting_file_result</code> aus,
als auch <code>error.kind()</code>.</p>
<p>Die Bedingung, die wir beim inneren Abgleich überprüfen wollen, ist, ob der von
<code>error.kind()</code> zurückgegebene Wert die Variante <code>NotFound</code> der Aufzählung
<code>ErrorKind</code> ist. Wenn das der Fall ist, versuchen wir, die Datei mit
<code>File::create</code> zu erstellen. Da <code>File::create</code> aber auch scheitern könnte,
brauchen wir einen zweiten Zweig im inneren <code>match</code>-Ausdruck. Wenn die Datei
nicht erstellt werden kann, wird eine andere Fehlermeldung ausgegeben. Der
zweite Zweig des äußeren <code>match</code> bleibt gleich, sodass das Programm bei jedem
Fehler, außer dem Fehler der fehlenden Datei, abbricht.</p>
<h3 id="alternativen-zur-verwendung-von-match-mit-resultt-e"><a class="header" href="#alternativen-zur-verwendung-von-match-mit-resultt-e">Alternativen zur Verwendung von <code>match</code> mit <code>Result&lt;T, E&gt;</code></a></h3>
<blockquote>
<p>Das sind viele <code>match</code>! Der Ausdruck <code>match</code> ist sehr nützlich, aber auch
sehr primitiv. In Kapitel 13 wirst du etwas über Funktionsabschlüsse
(closures) lernen, die mit vielen der auf <code>Result&lt;T, E&gt;</code> definierten Methoden
verwendet werden. Diese Methoden können prägnanter sein als die Verwendung
von <code>match</code> bei der Behandlung von <code>Result&lt;T, E&gt;</code>-Werten in deinem Code.</p>
<p>Hier ist zum Beispiel eine andere Möglichkeit, die gleiche Logik wie in
Codeblock 9-5 zu schreiben, aber unter Verwendung von Funktionsabschlüssen
und der Methode <code>unwrap_or_else</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open(&quot;hallo.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hallo.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem beim Erstellen der Datei: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Problem beim Öffnen der Datei: {:?}&quot;, error);
        }
    });
}</code></pre></pre>
<p>Obwohl dieser Code dasselbe Verhalten wie Codeblock 9-5 aufweist, enthält er
keine <code>match</code>-Ausdrücke und ist einfacher zu lesen. Kehre zu diesem Beispiel
zurück, nachdem du Kapitel 13 gelesen hast, und schlage die Methode
<code>unwrap_or_else</code> in der Standardbibliotheksdokumentation nach. Viele weitere
dieser Methoden können große, verschachtelte <code>match</code>-Ausdrücke vermeiden,
wenn du mit Fehlern zu tun hast.</p>
</blockquote>
<h3 id="abkürzungen-zum-abbrechen-im-fehlerfall-unwrap-und-expect"><a class="header" href="#abkürzungen-zum-abbrechen-im-fehlerfall-unwrap-und-expect">Abkürzungen zum Abbrechen im Fehlerfall: <code>unwrap</code> und <code>expect</code></a></h3>
<p>Das Verwenden von <code>match</code> funktioniert gut genug, aber es kann etwas langatmig
sein und vermittelt das Vorhaben nicht immer gut. Der Typ <code>Result&lt;T, E&gt;</code> bietet
viele Hilfsmethoden, um verschiedene, spezifischere Aufgaben zu erledigen. Die
Methode <code>unwrap</code> ist eine Abkürzungsmethode, implementiert wie der Ausdruck
<code>match</code>, den wir in Codeblock 9-4 verwendet haben. Wenn der <code>Result</code>-Wert die
Variante <code>Ok</code> ist, gibt <code>unwrap</code> den Wert innerhalb <code>Ok</code> zurück. Wenn <code>Result</code>
die Variante <code>Err</code> ist, ruft <code>unwrap</code> das Makro <code>panic!</code> für uns auf. Hier ist
ein Beispiel für <code>unwrap</code> im Einsatz:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hallo.txt&quot;).unwrap();
}</code></pre></pre>
<p>Wenn wir diesen Code ohne eine Datei <em>hallo.txt</em> ausführen, werden wir die
Fehlermeldung des <code>panic!</code>-Aufrufs sehen, den die Methode <code>unwrap</code> macht:</p>
<pre><code class="language-console">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }',
src/main.rs:4:49
</code></pre>
<p>In ähnlicher Weise können wir bei der Methode <code>expect</code> auch die Fehlermeldung
von <code>panic!</code> angeben. Das Verwenden von <code>expect</code> anstelle von <code>unwrap</code> und das
Angeben guter Fehlermeldungen kann deine Absicht vermitteln und das Aufspüren
der Fehlerursache erleichtern. Die Syntax von <code>expect</code> sieht wie folgt aus:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hallo.txt&quot;).expect(&quot;Problem beim Öffnen von hallo.txt&quot;);
}</code></pre></pre>
<p>Wir benutzen <code>expect</code> auf die gleiche Weise wie <code>unwrap</code>: Um die Dateiressource
zurückzugeben oder das Makro <code>panic!</code> aufzurufen. Die Fehlermeldung, die
<code>expect</code> beim Aufruf von <code>panic!</code> mitgibt, wird als Parameter an <code>expect</code>
übergeben, anstelle der standardmäßigen <code>panic!</code>-Nachricht, die <code>unwrap</code>
verwendet. So sieht sie aus:</p>
<pre><code class="language-text">thread 'main' panicked at 'Problem beim Öffnen von hallo.txt: Os {
code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }',
src/main.rs:5:10
</code></pre>
<p>In produktivem Code wählen die meisten Rust-Entwickler <code>expect</code> statt
<code>unwrap</code> und geben mehr Kontext darüber an, warum die Operation voraussichtlich
immer erfolgreich sein wird. Auf diese Weise hast du mehr Informationen, die du
bei der Fehlersuche verwenden kannst, falls sich deine Annahmen als falsch
erweisen sollten.</p>
<h3 id="weitergabe-von-fehlern"><a class="header" href="#weitergabe-von-fehlern">Weitergabe von Fehlern</a></h3>
<p>Wenn die Implementierung einer Funktion etwas aufruft, das fehlschlagen könnte,
kannst du, anstatt den Fehler innerhalb dieser Funktion zu behandeln, den
Fehler an den aufrufenden Code zurückgeben, damit dieser entscheiden kann, was
zu tun ist. Dies wird als <em>Weitergeben</em> (propagating) des Fehlers bezeichnet
und gibt dem aufrufenden Code mehr Kontrolle, wo mehr Informationen und Logik
zur Fehlerbehandlung vorhanden sein könnte, als im Kontext deines Codes zur
Verfügung steht.</p>
<p>Beispielsweise zeigt Codeblock 9-6 eine Funktion, die einen Benutzernamen aus
einer Datei liest. Wenn die Datei nicht existiert oder nicht gelesen werden
kann, gibt diese Funktion den Fehler an den Code zurück, der die Funktion
aufgerufen hat.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open(&quot;hallo.txt&quot;);

    let mut username_file = match username_file_result  {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 9-6: Eine Funktion, die mit <code>match</code> Fehler an
den aufrufenden Code zurückgibt</span></p>
<p>Diese Funktion kann auf eine viel kürzere Art und Weise geschrieben werden,
aber wir wollen für den Anfang viel davon manuell machen, um die
Fehlerbehandlung kennen zu lernen; am Ende werden wir den kürzeren Weg zeigen. Sehen
wir uns zunächst den Rückgabetyp der Funktion an: <code>Result&lt;String, io::Error&gt;</code>.
Das bedeutet, dass die Funktion einen Wert vom Typ <code>Result&lt;T, E&gt;</code> zurückgibt,
wobei der generische Typ <code>T</code> mit dem konkreten Typ <code>String</code> und der generische
Typ <code>E</code> mit dem konkreten Typ <code>io::Error</code> gefüllt wurde.</p>
<p>Wenn diese Funktion erfolgreich ist, erhält der aufrufende Code einen
<code>Ok</code>-Wert, der einen <code>String</code> enthält – den Benutzernamen, den diese
Funktion aus der Datei liest. Wenn diese Funktion auf Probleme stößt, erhält
der aufrufende Code einen <code>Err</code>-Wert, der eine Instanz von <code>io::Error</code> enthält,
mit weiteren Informationen darüber, was die Probleme waren. Wir wählten
<code>io::Error</code> als Rückgabetyp dieser Funktion, weil dies zufällig der Typ des
Fehlerwertes ist, der von beiden Operationen zurückgegeben wird, die wir im
Funktionsrumpf aufrufen und fehlschlagen könnten: Die Funktion <code>File::open</code> und
die Methode <code>read_to_string</code>.</p>
<p>Der Funktionsrumpf beginnt mit dem Aufruf der Funktion <code>File::open</code>. Dann
behandeln wir den <code>Result</code>-Wert, der von <code>match</code> zurückgegeben wird, auf
ähnliche Weise wie bei <code>match</code> in Codeblock 9-4. Wenn <code>File::open</code> erfolgreich
ist, erhält die Dateiressource in der Mustervariablen <code>file</code> den Wert in der
veränderbaren Variablen <code>username_file</code> und die Funktion wird fortgesetzt. Im
Fall von <code>Err</code> verwenden wir das Schlüsselwort <code>return</code>, anstatt <code>panic!</code>
aufzurufen, um die Funktion vorzeitig ganz zu verlassen und den Fehlerwert von
<code>File::open</code> in der Mustervariablen <code>e</code> als Fehlerwert dieser Funktion an den
aufrufenden Code zurückzugeben.</p>
<p>Wenn wir also eine Dateiressource in <code>username_file</code> haben, erzeugt die
Funktion einen neuen <code>String</code> in der Variablen <code>username</code> und ruft die Methode
<code>read_to_string</code> für die Dateiressource in <code>username_file</code> auf, um den Inhalt
der Datei in die Variable <code>username</code> zu lesen. Die Methode <code>read_to_string</code>
gibt ebenfalls ein <code>Result</code> zurück, weil sie fehlschlagen könnte, obwohl
<code>File::open</code> erfolgreich war. Wir brauchen also ein weiteres <code>match</code>, um dieses
<code>Result</code> zu verarbeiten: Wenn <code>read_to_string</code> erfolgreich ist, dann war unsere
Funktion erfolgreich und wir geben den Benutzernamen aus der Datei zurück, die
jetzt in <code>username</code> innerhalb <code>Ok</code> enthalten ist. Wenn <code>read_to_string</code>
fehlschlägt, geben wir den Fehlerwert auf die gleiche Weise zurück, wie wir den
Fehlerwert in <code>match</code> zurückgegeben haben, das den Rückgabewert von
<code>File::open</code> behandelt hat. Wir brauchen jedoch nicht ausdrücklich <code>return</code>
anzugeben, weil dies der letzte Ausdruck in der Funktion ist.</p>
<p>Der Code, der diesen Code aufruft, wird dann damit zurechtkommen, entweder
einen <code>Ok</code>-Wert zu erhalten, der einen Benutzernamen enthält, oder einen
<code>Err</code>-Wert, der einen <code>io::Error</code> enthält. Es ist Sache des aufrufenden Codes,
zu entscheiden, was mit diesen Werten geschehen soll. Wenn der aufrufende Code
einen <code>Err</code>-Wert erhält, könnte er <code>panic!</code> aufrufen und das Programm zum
Absturz bringen, einen Standardbenutzernamen verwenden oder den Benutzernamen
von irgendwo anders als z.B. einer Datei nachschlagen. Wir haben nicht genug
Informationen darüber, was der aufrufende Code tatsächlich versucht, also
propagieren wir alle Erfolgs- und Fehlerinformationen nach oben, damit sie
angemessen behandelt werden. Dieses Muster der Fehlerweitergabe ist in Rust so
verbreitet, dass Rust den Fragezeichen-Operator <code>?</code> bereitstellt, um dies zu
erleichtern.</p>
<h4 id="abkürzung-zum-weitergeben-von-fehlern-der-operator-"><a class="header" href="#abkürzung-zum-weitergeben-von-fehlern-der-operator-">Abkürzung zum Weitergeben von Fehlern: Der Operator <code>?</code></a></h4>
<p>Codeblock 9-7 zeigt eine Implementierung von <code>read_username_from_file</code>, die
dasselbe Verhalten wie Codeblock 9-6 hat, aber diese Implementierung verwendet
den <code>?</code>-Operator.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open(&quot;hallo.txt&quot;)?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username )?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 9-7: Eine Funktion, die Fehler an den
aufrufenden Code zurückgibt, indem sie den <code>?</code>-Operator verwendet</span></p>
<p>Das <code>?</code> hinter dem <code>Result</code>-Wert bewirkt fast das gleiche wie die
<code>match</code>-Ausdrücke, die wir zum Behandeln der <code>Result</code>-Werte in Codeblock 9-6
definiert haben. Wenn der Wert von <code>Result</code> ein <code>Ok</code> ist, wird der Wert
innerhalb <code>Ok</code> zurückgegeben und das Programm fortgesetzt. Wenn der Wert ein
<code>Err</code> ist, wird er als Funktionsergebnis zurückgegeben, als ob wir das
Schlüsselwort <code>return</code> verwendet hätten.</p>
<p>Es gibt einen Unterschied zwischen dem, was der <code>match</code>-Ausdruck aus Codeblock
9-6 tut, und dem, was der <code>?</code>-Operator tut: Fehlerwerte, bei denen der
<code>?</code>-Operator aufgerufen wird, durchlaufen die Funktion <code>from</code>, die im Merkmal
<code>From</code> der Standardbibliothek definiert ist und die zur Konvertierung von
Werten eines Typs in einen anderen verwendet wird. Wenn der <code>?</code>-Operator die
Funktion <code>from</code> aufruft, wird der empfangene Fehlertyp in den Fehlertyp
umgewandelt, der als Rückgabetyp der aktuellen Funktion definiert ist. Das ist
hilfreich, wenn eine Funktion einen einzigen Fehlertyp zurückgibt, um alle
möglichen Fehlerarten einer Funktion darzustellen, auch wenn Teile aus vielen
verschiedenen Gründen versagen könnten.</p>
<p>Wir könnten zum Beispiel die Funktion <code>read_username_from_file</code> in Codeblock
9-7 so ändern, dass sie einen von uns definierten Fehlertyp namens <code>OurError</code>
zurückgibt. Wenn wir auch <code>impl From&lt;io::Error&gt; for OurError</code> definieren, um
eine Instanz von <code>OurError</code> aus einem <code>io::Error</code> zu konstruieren, dann werden
die <code>?</code>-Operator-Aufrufe im Rumpf von <code>read_username_from_file</code> <code>from</code> aufrufen
und die Fehlertypen konvertieren, ohne dass weiterer Code zur Funktion
hinzugefügt werden muss.</p>
<p>Im Zusammenhang mit Codeblock 9-7 gibt das <code>?</code> am Ende des Aufrufs von
<code>File::open</code> den Wert innerhalb eines <code>Ok</code> an die Variable <code>username_file</code>
zurück. Wenn ein Fehler auftritt, beendet der Operator vorzeitig die gesamte
Funktion und gibt dem aufrufenden Code einen <code>Err</code>-Wert zurück. Dasselbe gilt
für das <code>?</code> am Ende des <code>read_to_string</code>-Aufrufs.</p>
<p>Der <code>?</code>-Operator eliminiert viel umständlichen Code und macht die
Implementierung dieser Funktion einfacher. Wir können diesen Code sogar noch
weiter verkürzen, indem wir die Methodenaufrufe unmittelbar nach dem <code>?</code>
verketten, wie in Codeblock 9-8 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open(&quot;hallo.txt&quot;)?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 9-8: Verketten von Methodenaufrufen nach dem
<code>?</code>-Operator</span></p>
<p>Wir haben das Erstellen des neuen <code>String</code> in <code>username</code> an den Anfang der
Funktion verlegt; dieser Teil hat sich nicht geändert. Anstatt eine Variable
<code>username_file</code> zu erzeugen, haben wir den Aufruf von <code>read_to_string</code> direkt
an das Ergebnis von <code>File::open(&quot;hallo.txt&quot;)?</code> gehängt. Wir haben immer noch
ein <code>?</code> am Ende des Aufrufs von <code>read_to_string</code>, und wir geben immer noch
einen <code>Ok</code>-Wert zurück, der <code>username</code> enthält, wenn sowohl <code>File::open</code> als
auch <code>read_to_string</code> erfolgreich sind, anstatt Fehler zurückzugeben. Die
Funktionalität ist wieder die gleiche wie in Codeblock 9-6 und Codeblock 9-7;
das ist nur eine andere, ergonomischere Schreibweise.</p>
<p>Codeblock 9-9 zeigt, dass es einen Weg gibt, diese Funktion noch kürzer zu
machen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hallo.txt&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 9-9: Verwenden von <code>fs::read_to_string</code>,
anstatt die Datei zu öffnen und dann zu lesen</span></p>
<p>Das Einlesen einer Datei in eine Zeichenkette ist eine ziemlich häufig
benötigte Operation, daher bringt die Standardbibliothek die praktische Funktion
<code>fs::read_to_string</code> mit, die die Datei öffnet, einen neuen <code>String</code> erzeugt,
den Inhalt der Datei einliest, den Inhalt in den <code>String</code> einfügt und ihn
zurückgibt. Natürlich gibt uns die Verwendung von <code>fs::read_to_string</code> nicht
die Möglichkeit, die ganze Fehlerbehandlung zu erklären, also haben wir es
zuerst auf dem längeren Weg gemacht.</p>
<h4 id="wo-der-operator--verwendet-werden-kann"><a class="header" href="#wo-der-operator--verwendet-werden-kann">Wo der Operator <code>?</code> verwendet werden kann</a></h4>
<p>Der Operator <code>?</code> kann nur in Funktionen verwendet werden, deren Rückgabetyp mit
dem Wert, auf den <code>?</code> angewendet wird, kompatibel ist. Das liegt daran, dass
der Operator <code>?</code> so definiert ist, dass er einen Wert frühzeitig aus der
Funktion zurückgibt, genauso wie der Ausdruck <code>match</code>, den wir in Codeblock 9-6
definiert haben. In Codeblock 9-6 verwendet <code>match</code> einen <code>Result</code>-Wert, und
der frühe Rückgabezweig liefert einen <code>Err(e)</code>-Wert. Der Rückgabetyp der
Funktion muss ein <code>Result</code> sein, damit er mit <code>return</code> kompatibel ist.</p>
<p>Schauen wir uns in Codeblock 9-10 an, was passiert, wenn wir den <code>?</code>-Operator
in einer <code>main</code>-Funktion verwenden, deren Rückgabetyp nicht mit dem Typ des
Wertes, für den wir &quot;?&quot; verwenden, kompatibel ist:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hallo.txt&quot;)?;
}</code></pre></pre>
<p><span class="caption">Codeblock 9-10: Der Versuch, das <code>?</code> in der
<code>main</code>-Funktion zu verwenden, die <code>()</code> zurückgibt, lässt sich nicht
kompilieren</span></p>
<p>Dieser Code öffnet eine Datei, was fehlschlagen kann. Der <code>?</code>-Operator folgt
dem <code>Result</code>-Wert, der von <code>File::open</code> zurückgegeben wird, aber diese
<code>main</code>-Funktion hat den Rückgabetyp <code>()</code>, nicht <code>Result</code>. Wenn wir diesen Code
kompilieren, erhalten wir folgende Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
   --&gt; src/main.rs:4:48
    |
3   | / fn main() {
4   | |     let f = File::open(&quot;hallo.txt&quot;)?;
    | |                                    ^ cannot use the `?` operator in a function that returns `()`
5   | | }
    | |_- this function should return `Result` or `Option` to accept `?`
    |
    = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
</code></pre>
<p>Dieser Fehler weist darauf hin, dass wir den <code>?</code>-Operator nur in einer Funktion
verwenden dürfen, die <code>Result</code> oder <code>Option</code> oder einen anderen Typ, der
<code>FromResidual</code> implementiert, zurückgibt.</p>
<p>Um den Fehler zu beheben, hast du zwei Möglichkeiten. Eine Möglichkeit besteht
darin, den Rückgabetyp deiner Funktion so zu ändern, dass er mit dem Wert
kompatibel ist, für den du den Operator <code>?</code> verwendest, wenn dem nichts
entgegensteht. Die andere Möglichkeit besteht darin, <code>match</code> oder eine der
Methoden von <code>Result&lt;T, E&gt;</code> zu verwenden, um <code>Result&lt;T, E&gt;</code> in geeigneter Weise
zu behandeln.</p>
<p>Die Fehlermeldung hat auch erwähnt, dass <code>?</code> ebenso mit <code>Option&lt;T&gt;</code>-Werten
verwendet werden kann. Wie bei der Verwendung von <code>?</code> für <code>Result</code>, kannst du
<code>?</code> für <code>Option</code> nur in einer Funktion verwenden, die eine <code>Option</code> zurückgibt.
Das Verhalten des <code>?</code>-Operators beim Aufruf auf eine <code>Option&lt;T&gt;</code> ist ähnlich
dem Verhalten, wenn er auf ein <code>Result&lt;T, E&gt;</code> aufgerufen wird: Wenn der Wert
<code>None</code> ist, wird <code>None</code> zu diesem Zeitpunkt von der Funktion zurückgegeben.
Wenn der Wert <code>Some</code> ist, ist der Wert innerhalb von <code>Some</code> der resultierende
Wert des Ausdrucks und die Funktion wird fortgesetzt. Codeblock 9-11 zeigt ein
Beispiel für eine Funktion, die das letzte Zeichen der ersten Zeile in einem
gegebenen Text findet:</p>
<pre><pre class="playground"><code class="language-rust">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line(&quot;Hallo Welt\nWie geht es dir heute?&quot;),
</span><span class="boring">        Some('t')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;\nhi&quot;), None);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 9-11: Verwenden des <code>?</code>-Operators auf einem
<code>Option&lt;T&gt;</code>-Wert</span></p>
<p>Diese Funktion gibt <code>Option&lt;char&gt;</code> zurück, weil es möglich ist, dass ein
Zeichen vorhanden ist, aber es ist auch möglich, dass keines vorhanden ist.
Dieser Code nimmt das Zeichenkettenanteilstyp-Argument <code>text</code> und ruft die
Methode <code>lines</code> darauf auf, die einen Iterator über die Zeilen der Zeichenkette
zurückgibt. Da diese Funktion die erste Zeile untersuchen will, ruft sie <code>next</code>
auf dem Iterator auf, um den ersten Wert vom Iterator zu erhalten. Wenn <code>text</code>
die leere Zeichenkette ist, gibt dieser Aufruf von <code>next</code> <code>None</code> zurück, und
hier können wir <code>?</code> benutzen, um zu stoppen und <code>None</code> von
<code>last_char_of_first_line</code> zurückgeben, wenn dies der Fall ist. Wenn <code>text</code>
nicht die leere Zeichenkette ist, gibt <code>next</code> einen <code>Some</code>-Wert zurück, der
einen Zeichenkettenanteilstyp der ersten Zeile in <code>text</code> enthält.</p>
<p>Das <code>?</code> extrahiert den Zeichenkettenanteilstyp, und wir können <code>chars</code> auf
diesem Zeichenkettenanteilstyp aufrufen, um einen Iterator für seine Zeichen zu
erhalten. Wir sind am letzten Zeichen in dieser ersten Zeile interessiert, also
rufen wir <code>last</code> auf, um das letzte Element im Iterator über die Zeichen
zurückzugeben. Dies ist eine <code>Option</code>, weil die erste Zeile die leere
Zeichenkette sein kann, wenn <code>text</code> mit einer Leerzeile beginnt, aber Zeichen
in anderen Zeilen enthält, wie in <code>&quot;\nhi&quot;</code>. Wenn es jedoch ein letztes Zeichen
in der ersten Zeile gibt, wird es in der Variante <code>Some</code> zurückgegeben. Der
<code>?</code>-Operator in der Mitte gibt uns eine prägnante Möglichkeit, diese Logik
auszudrücken, und diese Funktion kann in einer Zeile implementiert werden. Wenn
wir den <code>?</code>-Operator nicht auf <code>Option</code> verwenden könnten, müssten wir diese
Logik mit weiteren Methodenaufrufen oder einem Ausdruck implementieren.</p>
<p>Beachte, dass du den <code>?</code>-Operator auf ein <code>Result</code> in einer Funktion anwenden
kannst, die <code>Result</code> zurückgibt, und du kannst den <code>?</code>-Operator auf eine
<code>Option</code> in einer Funktion anwenden, die <code>Option</code> zurückgibt, aber du kannst
nicht beides mischen. Der Operator <code>?</code> konvertiert nicht automatisch ein
<code>Result</code> in eine <code>Option</code> oder umgekehrt; in diesen Fällen kannst du Methoden
wie <code>ok</code> für <code>Result</code> oder <code>ok_or</code> für <code>Option</code> verwenden, die die Umwandlung
explizit vornehmen.</p>
<p>Bis jetzt haben alle <code>main</code>-Funktionen, die wir benutzt haben, <code>()</code>
zurückgegeben. Die Funktion <code>main</code> ist etwas Besonderes, weil sie der Ein- und
Ausstiegspunkt von ausführbaren Programmen ist, und es gibt Einschränkungen
hinsichtlich ihres Rückgabetyps, damit sich die Programme wie erwartet
verhalten.</p>
<p>Glücklicherweise kann <code>main</code> auch ein <code>Result&lt;(), E&gt;</code> zurückgeben. Codeblock
9-12 enthält den Code aus Codeblock 9-10, aber wir haben den Rückgabetyp von
<code>main</code> in <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> geändert und am Ende einen Rückgabewert
<code>Ok(())</code> hinzugefügt. Dieser Code wird nun kompilieren:</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open(&quot;hallo.txt&quot;)?;

    Ok(())
}</code></pre>
<p><span class="caption">Codeblock 9-12: Die Änderung von <code>main</code> zur Rückgabe von
<code>Result&lt;(), E&gt;</code> erlaubt die Verwendung des <code>?</code>-Operators für
<code>Result</code>-Werte</span></p>
<p>Der Typ <code>Box&lt;dyn Error&gt;</code> ist ein <em>Merkmalsobjekt</em> (trait object), über das wir
im Abschnitt <a href="ch17-02-trait-objects.html">„Merkmalsobjekte (trait objects) die Werte unterschiedlicher
Typen erlauben“</a> in Kapitel 17 sprechen werden. Vorerst kannst
du <code>Box&lt;dyn Error&gt;</code> als „eine beliebige Fehlerart“ ansehen. Das Verwenden von
<code>?</code> auf einen <code>Result</code>-Wert in einer <code>main</code>-Funktion mit dem Fehlertyp <code>Box&lt;dyn Error&gt;</code> ist erlaubt, weil dadurch ein <code>Err</code>-Wert frühzeitig zurückgegeben
werden kann. Obwohl der Rumpf dieser <code>main</code>-Funktion nur Fehler des Typs
<code>std::io::Error</code> zurückgibt, ist diese Signatur durch die Angabe von
<code>Box&lt;dyn Error&gt;</code> auch dann noch korrekt, wenn weiterer Code, der andere Fehler
zurückgibt, dem Rumpf von <code>main</code> hinzugefügt wird.</p>
<p>Wenn eine <code>main</code>-Funktion ein <code>Result&lt;(), E&gt;</code> zurückgibt, beendet sich die
ausführbare Datei mit einem Wert von <code>0</code>, wenn <code>main</code> den Wert <code>Ok(())</code>
zurückgibt, und mit einem Wert ungleich Null, wenn <code>main</code> einen <code>Err</code>-Wert
zurückgibt. In C geschriebene ausführbare Programme geben beim Beenden ganze
Zahlen zurück: Programme, die erfolgreich beendet werden, geben die Zahl <code>0</code>
zurück, und Programme, die einen Fehler machen, geben eine Zahl ungleich <code>0</code>
zurück. Rust gibt ebenfalls ganze Zahlen aus ausführbaren Dateien zurück, um
mit dieser Konvention kompatibel zu sein.</p>
<p>Die Funktion <code>main</code> kann jeden Typ zurückgeben, der das <a href="https://doc.rust-lang.org/std/process/trait.Termination.html">Merkmal
<code>std::process::Termination</code></a> implementiert, das eine Funktion
<code>report</code> enthält, die einen <code>ExitCode</code> zurückgibt. Weitere Informationen zur
Implementierung des Merkmals <code>Termination</code> für deine eigenen Typen findest du
in der Dokumentation der Standardbibliothek.</p>
<p>Nachdem wir nun die Einzelheiten des Aufrufs von <code>panic!</code> und der Rückgabe von
<code>Result</code> besprochen haben, wollen wir zum Thema zurückkehren, wie wir
entscheiden können, was in welchen Fällen geeignet ist.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="wann-panic-aufrufen-und-wann-nicht"><a class="header" href="#wann-panic-aufrufen-und-wann-nicht">Wann <code>panic!</code> aufrufen und wann nicht?</a></h2>
<p>Wie entscheidest du also, wann du <code>panic!</code> aufrufen und wann <code>Result</code>
zurückgeben sollst? Wenn Code abbricht, gibt es keine Möglichkeit sich vom
Fehler zu erholen. Du könntest <code>panic!</code> in jeder Fehlersituation aufrufen,
unabhängig davon, ob es eine Möglichkeit zur Fehlerbehebung gibt oder nicht,
aber dann triffst du die Entscheidung für den aufrufenden Code, dass eine
Situation nicht rettbar ist. Wenn du dich dafür entscheidest, einen
<code>Result</code>-Wert zurückzugeben, überlässt du dem aufrufenden Code die
Wahlmöglichkeit, anstatt die Entscheidung für ihn zu treffen. Der aufrufende
Code könnte sich dafür entscheiden, sich vom Fehler auf eine sinnvolle Weise
zu erholen, oder er könnte sich dafür entscheiden, dass ein <code>Err</code>-Wert in
diesem Fall nicht behebbar ist und <code>panic!</code> aufrufen, und so deinen behebbaren
Fehler in einen nicht behebbaren verwandeln. Daher ist die Rückgabe von
<code>Result</code> eine gute Standardwahl, wenn du eine Funktion definierst, die
fehlschlagen könnte.</p>
<p>In Beispielen, Prototyp-Code und Tests ist es sinnvoller, Code zu schreiben,
der das Programm abbricht, anstatt ein <code>Result</code> zurückzugeben. Lass uns
herausfinden, warum das so ist, und dann Situationen besprechen, in denen der
Compiler nicht feststellen kann, dass ein Fehler unmöglich ist, du als Mensch
aber schon. Das Kapitel schließt mit einigen allgemeinen Richtlinien zur
Entscheidung, ob in Bibliothekscode ein Programm abgebrochen werden soll.</p>
<h3 id="beispiele-code-prototypen-und-tests"><a class="header" href="#beispiele-code-prototypen-und-tests">Beispiele, Code-Prototypen und Tests</a></h3>
<p>Wenn du ein Beispiel schreibst, um ein Konzept zu veranschaulichen, kann die
Einbeziehung von robustem Fehlerbehandlungscode das Beispiel unklarer machen.
In Beispielen wird davon ausgegangen, dass der Aufruf einer Methode wie
<code>unwrap</code>, die das Programm abbrechen könnte, als Platzhalter für die Art und
Weise gedacht ist, wie deine Anwendung mit Fehlern umgehen soll, die je
nachdem, was der Rest deines Codes tut, unterschiedlich sein können.</p>
<p>In ähnlicher Weise sind die Methoden <code>unwrap</code> und <code>expect</code> bei Prototypen sehr
praktisch, wenn du noch nicht entscheiden willst, wie mit Fehlern umzugehen
ist. Du hinterlässt klare Markierungen in deinem Code für später, wenn du dein
Programm robuster machst.</p>
<p>Wenn ein Methodenaufruf in einem Test fehlschlägt, würdest du wollen, dass der
gesamte Test fehlschlägt, auch wenn diese Methode nicht die zu testende
Funktionalität ist. Da ein Test mit <code>panic!</code> als fehlgeschlagen markiert wird,
ist der Aufruf von <code>unwrap</code> und <code>expect</code> genau das, was passieren sollte.</p>
<h3 id="fälle-in-denen-du-mehr-informationen-als-der-compiler-hast"><a class="header" href="#fälle-in-denen-du-mehr-informationen-als-der-compiler-hast">Fälle, in denen du mehr Informationen als der Compiler hast</a></h3>
<p>Es wäre auch sinnvoll, <code>unwrap</code> oder <code>expect</code> aufzurufen, wenn du eine andere
Logik hast, die sicherstellt, dass <code>Result</code> einen <code>Ok</code>-Wert hat, aber die Logik
kann vom Compiler nicht verstanden werden. Du wirst immer noch ein <code>Result</code>
haben, mit dem du umgehen musst: Welche Operation auch immer du aufrufst, es
besteht immer noch die Möglichkeit, dass sie im Allgemeinen scheitert, auch
wenn es in deiner speziellen Situation logischerweise unmöglich ist. Wenn du
durch manuelle Codeinspektion sicherstellen kannst, dass du niemals eine
<code>Err</code>-Variante haben wirst, ist es vollkommen akzeptabel, <code>unwrap</code> aufzurufen,
und noch besser ist es, den Grund, warum du glaubst, dass du niemals eine
<code>Err</code>-Variante haben wirst, im <code>expect</code>-Text zu dokumentieren. Hier ist ein
Beispiel:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::IpAddr;

let home: IpAddr = &quot;127.0.0.1&quot;
    .parse()
    .expect(&quot;Fest programmierte IP-Adresse sollte gültig sein&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Wir erstellen eine <code>IpAddr</code>-Instanz, indem wir eine hartkodierte Zeichenkette
parsen. Wir können sehen, dass <code>127.0.0.1</code> eine gültige IP-Adresse ist, sodass
es akzeptabel ist, hier <code>expect</code> zu verwenden. Eine hartkodierte, gültige
Zeichenkette ändert jedoch nicht den Rückgabetyp der <code>parse</code>-Methode: Wir
erhalten immer noch einen <code>Result</code>-Wert und der Compiler wird von uns
verlangen, <code>Result</code> so zu behandeln, als ob die <code>Err</code>-Variante möglich wäre,
weil der Compiler nicht klug genug ist, um zu erkennen, dass diese
Zeichenkette stets eine gültige IP-Adresse ist. Wenn die
IP-Adressen-Zeichenkette von einem Benutzer kam, anstatt fest im Programm
kodiert zu sein, und daher möglicherweise fehlschlagen könnte, würden wir
stattdessen definitiv <code>Result</code> auf eine robustere Weise behandeln wollen.</p>
<h3 id="richtlinien-zur-fehlerbehandlung"><a class="header" href="#richtlinien-zur-fehlerbehandlung">Richtlinien zur Fehlerbehandlung</a></h3>
<p>Es ist ratsam, dass dein Code abbricht, wenn es möglich ist, dass dein Code in
einem schlechten Zustand enden könnte. In diesem Zusammenhang ist ein
<em>schlechter Zustand</em> (bad state) dann gegeben, wenn eine Annahme, eine
Garantie, ein Vertrag oder eine Invariante gebrochen wurde, z.B. wenn ungültige
Werte, widersprüchliche Werte oder fehlende Werte an deinen Code übergeben
werden – sowie einer oder mehrere der folgenden Punkte zutreffen:</p>
<ul>
<li>Der schlechte Zustand ist etwas Unerwartetes, im Gegensatz zu etwas, das
wahrscheinlich gelegentlich vorkommt, wie die Eingabe von Daten in einem
falschen Format durch einen Benutzer.</li>
<li>Dein Code muss sich nach diesem Punkt darauf verlassen können, dass er sich
in keinem schlechten Zustand befindet, anstatt bei jedem Schritt auf das
Problem zu prüfen.</li>
<li>Es gibt keine gute Möglichkeit, diese Informationen in den von dir
verwendeten Typen zu kodieren. Wir werden im Abschnitt <a href="ch17-03-oo-design-patterns.html#kodieren-von-zust%C3%A4nden-und-verhalten-als-typen">„Kodieren von
Zuständen und Verhalten als Typen“</a> in Kapitel 17 ein Beispiel
dafür durcharbeiten.</li>
</ul>
<p>Wenn jemand deinen Code aufruft und Werte übergibt, die keinen Sinn ergeben,
ist es am besten, einen Fehler zurückzugeben, damit der Benutzer der Bibliothek
entscheiden kann, was er in diesem Fall tun möchte. In Fällen, in denen eine
Fortsetzung unsicher oder schädlich sein könnte, ist es jedoch am besten,
<code>panic!</code> aufzurufen und die Person, die deine Bibliothek verwendet, auf den
Fehler in ihrem Code hinzuweisen, damit sie ihn während der Entwicklung beheben
kann. In ähnlicher Weise ist <code>panic!</code> oft angebracht, wenn du externen Code
aufrufst, der sich deiner Kontrolle entzieht und einen ungültigen Zustand
zurückgibt, den du nicht beheben kannst.</p>
<p>Wenn jedoch ein Fehler erwartet wird, ist es sinnvoller, ein <code>Result</code>
zurückzugeben, als <code>panic!</code> aufzurufen. Beispiele hierfür sind ein Parser, dem
fehlerhafte Daten übergeben werden, oder eine HTTP-Anfrage, die einen Status
zurückgibt, der anzeigt, dass du ein Aufruflimit erreicht hast. In diesen
Fällen zeigt der Rückgabetyp <code>Result</code> an, dass ein Fehler eine erwartete
Möglichkeit ist, bei der der aufrufende Code entscheiden muss, wie er damit
umgeht.</p>
<p>Wenn dein Code einen Vorgang ausführt, der einen Benutzer gefährden könnte,
wenn er mit ungültigen Werten aufgerufen wird, sollte dein Code zuerst
überprüfen, ob die Werte gültig sind, und das Programm abbrechen, wenn die
Werte nicht gültig sind. Dies geschieht hauptsächlich aus Sicherheitsgründen:
Der Versuch, mit ungültigen Daten zu operieren, kann deinen Code Schwachstellen
aussetzen. Dies ist der Hauptgrund dafür, dass die Standardbibliothek <code>panic!</code>
aufruft, wenn du versuchst, einen unzulässigen Speicherzugriff durchzuführen:
Der Versuch, auf Speicher zuzugreifen, der nicht zur aktuellen Datenstruktur
gehört, ist ein häufiges Sicherheitsproblem. Funktionen haben oft <em>Verträge</em>
(contracts): Ihr Verhalten ist nur dann garantiert, wenn die Eingaben bestimmte
Anforderungen erfüllen. Abzubrechen, wenn der Vertrag verletzt wird, ist
sinnvoll, weil eine Vertragsverletzung immer auf einen Fehler auf der
Aufruferseite hinweist und es sich nicht um eine Fehlerart handelt, die der
aufgerufende Code explizit behandeln sollte. Tatsächlich gibt es keinen
vernünftigen Weg, wie sich der aufrufende Code vom Fehler erholen kann; die
aufrufenden <em>Programmierer</em> müssen den Code reparieren. Verträge zu einer
Funktion sollten in der API-Dokumentation der Funktion erläutert werden,
insbesondere wenn deren Verletzung zu einem Programmabbruch führt.</p>
<p>Zahlreiche Fehlerprüfungen in deinen Funktionen wären jedoch langatmig und
störend. Glücklicherweise kannst du das Typsystem von Rust (und damit die
Typprüfung durch den Compiler) verwenden, um viele Prüfungen für dich zu
übernehmen. Wenn deine Funktion einen besonderen Typ als Parameter hat, kannst
du mit der Logik deines Codes fortfahren, da du weißt, dass der Compiler
bereits sichergestellt hat, dass du einen gültigen Wert hast. Wenn du zum
Beispiel einen Typ anstatt einer <code>Option</code> hast, erwartet dein Programm <em>etwas</em>
statt <em>nichts</em>. Dein Code muss dann nicht zwei Fälle für die Varianten <code>Some</code>
und <code>None</code> behandeln: Er wird nur einen Fall mit definitiv einem Wert haben.
Code, der versucht, nichts an deine Funktion zu übergeben, lässt sich nicht
einmal kompilieren, sodass deine Funktion diesen Fall zur Laufzeit nicht prüfen
muss. Ein anderes Beispiel ist die Verwendung eines vorzeichenlosen
Ganzzahl-Typs wie <code>u32</code>, der sicherstellt, dass der Parameter niemals negativ
ist.</p>
<h3 id="benutzerdefinierte-typen-für-die-validierung-erstellen"><a class="header" href="#benutzerdefinierte-typen-für-die-validierung-erstellen">Benutzerdefinierte Typen für die Validierung erstellen</a></h3>
<p>Gehen wir noch einen Schritt weiter, indem wir das Typsystem von Rust verwenden,
um sicherzustellen, dass wir einen gültigen Wert haben, und betrachten wir die
Erstellung eines benutzerdefinierten Typs für die Validierung. Erinnere
dich an das Ratespiel in Kapitel 2, bei dem unser Code den Benutzer
aufforderte, eine Zahl zwischen 1 und 100 zu erraten. Wir haben nie überprüft,
ob die Schätzung des Benutzers zwischen diesen Zahlen lag, bevor wir sie mit
unserer Geheimzahl verglichen haben; wir haben nur überprüft, ob die Schätzung
richtig war. In diesem Fall waren die Folgen nicht sehr gravierend: Unsere
Ausgabe von „zu groß“ oder „zu klein“ wäre immer noch richtig. Aber es wäre
eine nützliche Erweiterung, um den Benutzer zu gültigen Rateversuchen zu führen
und ein unterschiedliches Verhalten zu zeigen, wenn ein Benutzer eine Zahl
eingibt, die außerhalb des Bereichs liegt, als wenn ein Benutzer stattdessen
z.B. Buchstaben eingibt.</p>
<p>Eine Möglichkeit, dies zu tun, wäre, die Eingabe als <code>i32</code> statt nur als <code>u32</code>
zu parsen, um potenziell negative Zahlen zuzulassen, und dann eine
Bereichsprüfung der Zahl zu ergänzen, etwa so:</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate eine Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span>    loop {
        // --abschneiden--

<span class="boring">        println!(&quot;Bitte gib deine Vermutung ein.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!(&quot;Die geheime Zahl wird zwischen 1 und 100 liegen.&quot;);
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --abschneiden--
<span class="boring">            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Du hast gewonnen!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
<p>Der <code>if</code>-Ausdruck prüft, ob unser Wert außerhalb des Bereichs liegt, informiert
den Benutzer über das Problem und ruft <code>continue</code> auf, um die nächste Iteration
der Schleife zu starten und um eine weitere Schätzung zu bitten. Nach dem
<code>if</code>-Ausdruck können wir mit dem Vergleich zwischen <code>guess</code> und der Geheimzahl
fortfahren, wobei wir wissen, dass <code>guess</code> zwischen 1 und 100 liegt.</p>
<p>Dies ist jedoch keine ideale Lösung: Wenn es zwingend erforderlich wäre, dass das
Programm nur mit Werten zwischen 1 und 100 arbeitet, und wir viele Funktionen
mit dieser Anforderung haben, wäre eine solche Prüfung in jeder Funktion mühsam
(und könnte die Leistung beeinträchtigen).</p>
<p>Stattdessen können wir einen neuen Typ erstellen und die Validierungen in eine
Funktion geben, um eine Instanz des Typs zu erzeugen, anstatt die Validierungen
überall zu wiederholen. Auf diese Weise ist es für die Funktionen sicher, den
neuen Typ in ihren Signaturen zu verwenden und die erhaltenen Werte
bedenkenlos zu nutzen. Codeblock 9-13 zeigt eine Möglichkeit, einen Typ
<code>Guess</code> zu definieren, der nur dann eine Instanz von <code>Guess</code> erzeugt, wenn die
Funktion <code>new</code> einen Wert zwischen 1 und 100 erhält.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Der Schätzwert muss zwischen 1 und 100 liegen, ist jedoch {}.&quot;,
                   value);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 9-13: Ein Typ <code>Guess</code>, der nur bei Werten
zwischen 1 und 100 fortsetzt</span></p>
<p>Zuerst definieren wir eine Struktur <code>Guess</code>, die ein Feld <code>value</code> hat, das
einen <code>i32</code> enthält. Hier wird die Nummer gespeichert.</p>
<p>Dann implementieren wir die zugehörige Funktion <code>new</code> für <code>Guess</code>, die
Instanzen von <code>Guess</code> erzeugt. Die Funktion <code>new</code> ist so definiert, dass sie
einen Parameter <code>value</code> vom Typ <code>i32</code> entgegen nimmt und eine <code>Guess</code>-Instanz
zurückgibt. Der Code im Funktionsrumpf von <code>new</code> testet den Wert in <code>value</code>, um
sicherzustellen, dass er zwischen 1 und 100 liegt. Wenn <code>value</code> diesen Test
nicht besteht, rufen wir <code>panic!</code> auf, was den Programmierer des aufrufenden
Codes darauf aufmerksam macht, dass er einen Fehler hat, den er beheben muss,
denn ein <code>Guess</code> mit einem Wert außerhalb dieses Bereichs zu erzeugen, würde
den Vertrag verletzen, auf den sich <code>Guess::new</code> verlässt. Die Bedingungen,
unter denen <code>Guess::new</code> das Programm abbricht, sollten in der öffentlich
zugänglichen API-Dokumentation genannt werden; wir werden die
Dokumentationskonventionen, die auf die Möglichkeit eines <code>panic!</code>-Aufrufs
hinweisen, in der API-Dokumentation behandeln, die du in Kapitel 14 erstellst. 
Wenn <code>value</code> den Test besteht, erstellen wir eine neue <code>Guess</code>-Instanz, deren
Feld <code>value</code> den Parameterwert <code>value</code> erhält, und geben die Instanz zurück.</p>
<p>Als nächstes implementieren wir eine Methode namens <code>value</code>, die <code>self</code>
ausleiht, keine anderen Parameter hat und ein <code>i32</code> zurückgibt. Diese
Methodenart wird manchmal als <em>Abfragemethode</em> (getter) bezeichnet, weil ihr
Zweck darin besteht, Daten aus ihren Feldern zurückzugeben. Diese öffentliche
Methode ist notwendig, weil das Feld <code>value</code> der Struktur <code>Guess</code> privat ist.
Es ist wichtig, dass das Feld <code>value</code> privat ist, damit Code, der die Struktur
<code>Guess</code> verwendet, <code>value</code> nicht direkt setzen kann: Code außerhalb des Moduls
<em>muss</em> die Funktion <code>Guess::new</code> verwenden, um eine Instanz von <code>Guess</code> zu
erzeugen, wodurch sichergestellt wird, dass es keine Möglichkeit gibt, dass
<code>Guess</code> einen <code>Wert</code> hat, der nicht durch die Bedingungen in der Funktion
<code>Guess::new</code> überprüft wurde.</p>
<p>Eine Funktion, die einen Parameter hat oder nur Zahlen zwischen 1 und 100
zurückgibt, könnte dann in ihrer Signatur angeben, dass sie ein <code>Guess</code>
anstelle eines <code>i32</code> entgegennimmt oder zurückgibt und bräuchte dann in ihrem
Rumpf keine zusätzlichen Prüfungen durchzuführen.</p>
<h2 id="zusammenfassung-8"><a class="header" href="#zusammenfassung-8">Zusammenfassung</a></h2>
<p>Die Fehlerbehandlungsfunktionen von Rust sollen dir helfen, robusteren Code zu
schreiben. Das Makro <code>panic!</code> signalisiert, dass sich dein Programm in einem
Zustand befindet, mit dem es nicht umgehen kann, und ermöglicht es dir, den
Prozess anzuhalten, anstatt zu versuchen, mit ungültigen oder falschen Werten
fortzufahren. Die Aufzählung <code>Result</code> verwendet das Typsystem von Rust, um
anzuzeigen, dass Operationen so fehlschlagen könnten, dass dein Code sich davon
wieder erholen könnte. Du kannst <code>Result</code> verwenden, um dem Code, der deinen
Code aufruft, mitzuteilen, dass er auch mit potentiellem Erfolg und Misserfolg
umgehen muss. Das Verwenden von <code>panic!</code> und <code>Result</code> in den entsprechenden
Situationen wird deinen Code angesichts unvermeidlicher Probleme zuverlässiger
machen.</p>
<p>Nachdem du nun nützliche Möglichkeiten gesehen hast, wie die Standardbibliothek
generische Datentypen mit den Enums <code>Option</code> und <code>Result</code> verwendet, werden wir
darüber sprechen, wie generische Datentypen funktionieren und wie du sie in
deinem Code verwenden kannst.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generische-typen-merkmale-traits-und-lebensdauer"><a class="header" href="#generische-typen-merkmale-traits-und-lebensdauer">Generische Typen, Merkmale (traits) und Lebensdauer</a></h1>
<p>Jede Programmiersprache verfügt über Werkzeuge, mit denen die Duplizierung von
Konzepten (duplication of concepts) effektiv gehandhabt werden kann. In Rust
ist ein solches Werkzeug der <em>generische Datentyp</em> (generics): Abstrakte
Stellvertreter für konkrete Typen oder andere Eigenschaften. Wir können das
Verhalten generischer Datentypen oder ihre Beziehung zu anderen generischen
Datentypen ausdrücken, ohne zu wissen, was an ihrer Stelle beim Kompilieren und
Ausführen des Codes stehen wird.</p>
<p>Funktionen können Parameter eines generischen Typs anstelle eines konkreten
Typs wie <code>i32</code> oder <code>String</code> annehmen, so wie eine Funktion Parameter mit
unbekannten Werten annimmt, um denselben Code auf mehrere konkrete Werte
anzuwenden. Tatsächlich haben wir generische Datentypen bereits in Kapitel 6
mit <code>Option&lt;T&gt;</code>, in Kapitel 8 mit <code>Vec&lt;T&gt;</code> und <code>HashMap&lt;K, V&gt;</code> und in Kapitel
9 mit <code>Result&lt;T, E&gt;</code> verwendet. In diesem Kapitel erfährst du, wie du deine
eigenen Typen, Funktionen und Methoden mit generischen Datentypen definieren
kannst!</p>
<p>Zunächst werden wir uns anschauen, wie eine Funktion extrahiert werden kann, um
Code-Duplizierung zu reduzieren. Danach verwenden wir dieselbe Technik, um aus
zwei Funktionen, die sich nur im Datentyp ihrer Parameter unterscheiden, eine
generische Funktion zu machen. Wir werden auch erklären, wie generische Typen
in Struktur- (struct) und Aufzählungsdefinitionen (enum) verwendet werden
können.</p>
<p>Dann wirst du lernen, wie man <em>Merkmale</em> (traits) verwendet, um Verhalten auf
generische Weise zu definieren. Du kannst Merkmale mit generischen Typen
kombinieren, um einen generischen Typ auf solche Typen einzuschränken, die ein
bestimmtes Verhalten aufweisen, im Gegensatz zu einem beliebigen Typ.</p>
<p>Schließlich werden wir die <em>Lebensdauer</em> (lifetimes) besprechen: Eine Spielart
generischer Typen, die dem Compiler Informationen darüber gibt, wie
Referenzen zueinander in Beziehung stehen. Lebensdauern ermöglichen es uns, dem
Compiler genügend Informationen über ausgeliehene Werte zu geben, sodass er
sicherstellen kann, dass Referenzen in mehr Situationen gültig sind, als er es
ohne unsere Hilfe könnte.</p>
<h2 id="duplikate-entfernen-durch-extrahieren-einer-funktion"><a class="header" href="#duplikate-entfernen-durch-extrahieren-einer-funktion">Duplikate entfernen durch Extrahieren einer Funktion</a></h2>
<p>Mit Hilfe von generischen Typen können wir spezifische Typen durch einen
Platzhalter ersetzen, der mehrere Typen repräsentiert, um Code-Duplizierung zu
vermeiden. Bevor wir uns mit der generischen Syntax befassen, wollen wir uns
zunächst ansehen, wie man Duplikate auf eine Weise entfernt, die keine
generischen Typen erfordert, indem man eine Funktion extrahiert, die
spezifische Werte durch einen Platzhalter ersetzt, der mehrere Werte
repräsentiert. Dann wenden wir die gleiche Technik an, um eine generische
Funktion zu extrahieren! Wenn du dir ansiehst, wie du doppelten Code
erkennst, den du in eine Funktion extrahieren kannst, wirst du beginnen,
doppelten Code zu erkennen, der generische Typen verwenden kann.</p>
<p>Wir beginnen mit dem kurzen Programm in Codeblock 10-1, das die größte Zahl in
einer Liste findet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;Die größte Zahl ist {}&quot;, largest);
<span class="boring">    assert_eq!(largest, 100);
</span>}</code></pre></pre>
<p><span class="caption">Codeblock 10-1: Finden der größten Zahl in einer Liste
von Zahlen</span></p>
<p>Wir speichern eine Liste von ganzen Zahlen in der Variablen <code>number_list</code> und
weisen eine Referenz der ersten Zahl der Liste einer Variablen namens <code>largest</code>
zu. Dann iterieren wir über alle Zahlen in der Liste und wenn die aktuelle Zahl
größer als die in <code>largest</code> gespeicherte Zahl ist, ersetzen wir die Referenz in
dieser Variablen. Wenn die aktuelle Zahl jedoch kleiner oder gleich der größten
bisher gefundenen Zahl ist, ändert sich die Variable nicht, und der Code geht
zur nächsten Zahl in der Liste weiter. Nach dem Durchlaufen aller Zahlen in der
Liste sollte <code>largest</code> auf die größte Zahl referenzieren, in diesem Fall 100.</p>
<p>Wir haben nun die Aufgabe bekommen, die größte Zahl in zwei verschiedenen
Zahlenlisten zu finden. Zu diesem Zweck können wir den Code in Codeblock 10-1
duplizieren und dieselbe Logik an zwei verschiedenen Stellen im Programm
verwenden, wie in Codeblock 10-2 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;Die größte Zahl ist {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;Die größte Zahl ist {}&quot;, largest);
}</code></pre></pre>
<p><span class="caption">Codeblock 10-2: Code zum Auffinden der größten Zahl in
<em>zwei</em> Zahlenlisten</span></p>
<p>Obwohl dieser Code funktioniert, ist das Duplizieren von Code mühsam und
fehleranfällig. Außerdem müssen wir daran denken, den Code an mehreren Stellen
zu aktualisieren, wenn wir ihn ändern wollen.</p>
<p>Um diese Redundanz zu eliminieren, können wir eine Abstraktion schaffen, indem
wir eine Funktion definieren, die auf einer beliebigen Liste ganzer Zahlen
operiert, die ihr als Parameter übergeben wird. Diese Lösung macht unseren Code
klarer und lässt uns das Konzept, die größte Zahl in einer Liste zu finden,
abstrakter ausdrücken.</p>
<p>In Codeblock 10-3 extrahieren wir den Code, der die größte Zahl findet, in eine
Funktion namens <code>largest</code>. Dann rufen wir die Funktion auf, um die größte Zahl
in den beiden Listen aus Codeblock 10-2 zu finden. Wir könnten die Funktion
auch auf jede andere Liste von <code>i32</code>-Werten anwenden, die wir in Zukunft haben
könnten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);
<span class="boring">    assert_eq!(result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);
<span class="boring">    assert_eq!(result, 6000);
</span>}</code></pre></pre>
<p><span class="caption">Codeblock 10-3: Abstrahierter Code, um die größte Zahl in
zwei Listen zu finden</span></p>
<p>Die Funktion <code>largest</code> hat einen Parameter <code>list</code>, der einen beliebigen
Anteilstyp von <code>i32</code>-Werten repräsentiert, die wir an die Funktion übergeben
könnten. Wenn wir die Funktion aufrufen, läuft der Code also auf den
spezifischen Werten, die wir übergeben.</p>
<p>Zusammenfassend hier die Schritte, die wir unternommen haben, um den Code aus
Codeblock 10-2 in Codeblock 10-3 zu überführen:</p>
<ol>
<li>Identifiziere doppelten Code.</li>
<li>Extrahiere den doppelten Code in den Funktionskörper und spezifiziere die
Eingabe- und Rückgabewerte dieses Codes in der Funktionssignatur.</li>
<li>Aktualisiere die beiden Instanzen des doppelten Codes, um stattdessen die
Funktion aufzurufen.</li>
</ol>
<p>Als Nächstes werden wir dieselben Schritte auf generische Datentypen anwenden,
um doppelten Code zu reduzieren. Ähnlich wie der Funktionsrumpf auf einer
abstrakten Liste anstelle spezifischer Werte arbeiten kann, erlauben es
generische Datentypen, auf abstrakten Typen zu arbeiten.</p>
<p>Nehmen wir zum Beispiel an, wir hätten zwei Funktionen: Eine, die das größte
Element in einem Anteilstyp mit <code>i32</code>-Werten findet, und eine, die das größte
Element in einem Anteilstyp mit <code>char</code>-Werten findet. Wie würden wir diese
Duplizierung beseitigen? Lass es uns herausfinden!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="generische-datentypen"><a class="header" href="#generische-datentypen">Generische Datentypen</a></h2>
<p>Wir verwenden generische Datentypen (generics), um Definitionen für Elemente
wie Funktionssignaturen oder Strukturen (structs) zu erstellen, die wir dann
mit vielen verschiedenen konkreten Datentypen verwenden können. Sehen wir uns
zunächst an, wie Funktionen, Strukturen, Aufzählungen und Methoden mithilfe von
generischen Datentypen definiert werden können. Danach werden wir uns ansehen,
wie generische Datentypen die Code-Performanz beeinflussen.</p>
<h3 id="in-funktionsdefinitionen"><a class="header" href="#in-funktionsdefinitionen">In Funktionsdefinitionen</a></h3>
<p>Bei der Definition einer Funktion, die generische Datentypen verwendet,
platzieren wir die generischen Datentypen in der Signatur der Funktion, wo wir
normalerweise die Datentypen der Parameter und des Rückgabewerts angeben
würden. Dadurch wird unser Code flexibler und bietet den Aufrufern unserer
Funktion mehr Funktionalität, während gleichzeitig Code-Duplikate verhindert
werden.</p>
<p>Um mit unserer Funktion <code>largest</code> fortzufahren, zeigt Codeblock 10-4 zwei
Funktionen, die beide den größten Wert in einem Anteilstyp finden. Wir werden
diese dann in einer einzigen Funktion kombinieren, die generische Typen
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);
<span class="boring">    assert_eq!(result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;Das größte Zeichen ist {}&quot;, result);
<span class="boring">    assert_eq!(result, 'y');
</span>}</code></pre></pre>
<p><span class="caption">Codeblock 10-4: Zwei Funktionen, die sich nur in ihren
Namen und den Typen in ihren Signaturen unterscheiden</span></p>
<p>Die Funktion <code>largest_i32</code> ist diejenige, die wir in Codeblock 10-3 extrahiert
haben und die den größten <code>i32</code> in einem Anteilstyp findet. Die Funktion
<code>largest_char</code> findet das größte <code>char</code> in einem Anteilstyp. Die
Funktionsrümpfe haben den gleichen Code, also lass uns die Duplizierung
eliminieren, indem wir einen generischen Typparameter in einer einzigen
Funktion einführen.</p>
<p>Um die Typen in einer neuen, einzigen Funktion zu parametrisieren, müssen wir
den Typparameter benennen, so wie wir es für die Wertparameter einer Funktion
tun. Du kannst jeden beliebigen Bezeichner als Typparametername verwenden. Aber
wir werden <code>T</code> verwenden, weil die Typparameternamen gemäß Konvention in Rust
kurz sind, oft nur ein Buchstabe, und Rusts Typbezeichnungskonvention verwendet
Binnenmajuskel (UpperCamelCase). Als Abkürzung für „Typ“ ist <code>T</code> die
Standardwahl der meisten Rust-Programmierer.</p>
<p>Wenn wir einen Parameter im Funktionsrumpf verwenden, müssen wir den
Parameternamen in der Signatur deklarieren, damit der Compiler weiß, was
dieser Name bedeutet. In ähnlicher Weise müssen wir den Typ-Parameternamen
deklarieren, bevor wir ihn in einer Funktionssignatur verwenden können. Um die
generische Funktion <code>largest</code> zu definieren, platzieren wir die
Typnamen-Deklarationen innerhalb spitzer Klammern <code>&lt;&gt;</code>, zwischen dem
Funktionsnamen und der Parameterliste, so wie hier:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>Wir lesen diese Definition wie folgt: Die Funktion <code>largest</code> ist generisch über
einen Typ <code>T</code>. Sie hat einen Parameter namens <code>list</code>, der ein Anteilstyp von
Werten des Typs <code>T</code> ist. Die Funktion <code>largest</code> gibt eine Referenz auf denn
Wert des gleichen Typs <code>T</code> zurück.</p>
<p>Codeblock 10-5 zeigt die kombinierte Funktionsdefinition <code>largest</code>, die den
generischen Datentyp in ihrer Signatur verwendet. Der Codeblock zeigt auch, wie
wir die Funktion entweder mit einem Anteilstyp von <code>i32</code>-Werten oder
<code>char</code>-Werten aufrufen können. Beachte, dass sich dieser Code noch nicht
kompilieren lässt, aber wir werden das Problem später in diesem Kapitel
beheben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;Das größte Zeichen ist {}&quot;, result);
}</code></pre></pre>
<p><span class="caption">Codeblock 10-5: Die Funktion <code>largest</code> mit generischen
Typparametern; diese kompiliert aber noch nicht</span></p>
<p>Wenn wir diesen Code kompilieren, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Der Hilfetext erwähnt <code>std::cmp::PartialOrd</code>, was ein <em>Merkmal</em> (trait) ist,
und wir werden im nächsten Abschnitt über Merkmale sprechen. Vorerst bedeutet
dieser Fehler, dass der Rumpf von <code>largest</code> nicht für alle möglichen Typen
funktioniert, die <code>T</code> sein könnten. Da wir Werte des Typs <code>T</code> im Rumpf
vergleichen wollen, können wir nur Typen verwenden, deren Werte sortiert werden
können. Um Vergleiche zu ermöglichen, hat die Standardbibliothek das Merkmal
<code>std::cmp::PartialOrd</code>, das du auf Typen implementieren kannst (siehe Anhang C
für weitere Informationen zu diesem Merkmal). Indem wir dem Vorschlag des
Hilfetextes folgen, schränken wir die für <code>T</code> gültigen Typen auf diejenigen
ein, die <code>PartialOrd</code> implementieren und dieses Beispiel kompiliert, weil die
Standardbibliothek <code>PartialOrd</code> sowohl auf <code>i32</code> als auch auf <code>char</code>
implementiert.</p>
<h3 id="in-struktur-definitionen"><a class="header" href="#in-struktur-definitionen">In Struktur-Definitionen</a></h3>
<p>Wir können auch Strukturen definieren, um einen generischen Typparameter in
einem oder mehreren Feldern mit der <code>&lt;&gt;</code> Syntax zu verwenden. Codeblock 10-6
definiert eine Struktur <code>Point&lt;T&gt;</code>, um Koordinatenwerte <code>x</code> und <code>y</code> eines
beliebigen Typs aufzunehmen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Codeblock 10-6: Eine Struktur <code>Point&lt;T&gt;</code>, die Werte <code>x</code>
und <code>y</code> vom Typ <code>T</code> enthält</span></p>
<p>Die Syntax zum Verwenden von generischen Datentypen in Strukturdefinitionen
ähnelt der Syntax, die in Funktionsdefinitionen verwendet wird. Zuerst
deklarieren wir den Namen des Typparameters innerhalb spitzer Klammern direkt
nach dem Namen der Struktur. Dann verwenden wir den generischen Typ in der
Strukturdefinition, wo wir sonst konkrete Datentypen angeben würden.</p>
<p>Beachte, da wir nur einen generischen Typ zur Definition von <code>Point&lt;T&gt;</code>
verwendet haben, besagt diese Definition, dass die Struktur <code>Point&lt;T&gt;</code>
generisch über einen Typ <code>T</code> ist, und die beiden Felder <code>x</code> und <code>y</code> <em>denselben</em>
Typ haben, welcher Typ das auch immer sein mag. Wenn wir eine Instanz von
<code>Point&lt;T&gt;</code> erzeugen, die Werte unterschiedlichen Typs hat, wie in Codeblock
10-7, wird sich unser Code nicht kompilieren lassen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Codeblock 10-7: Die Felder <code>x</code> und <code>y</code> müssen vom
gleichen Typ sein, da beide den gleichen generischen Datentyp <code>T</code> haben.</span></p>
<p>Wenn wir in diesem Beispiel <code>x</code> den Integer-Wert 5 zuweisen, lassen wir den
Compiler wissen, dass der generische Typ <code>T</code> für diese Instanz von
<code>Point&lt;T&gt;</code> ein Integer sein wird. Wenn wir dann 4.0 für <code>y</code> angeben, das wir so
definiert haben, dass es den gleichen Typ wie <code>x</code> hat, erhalten wir einen
Typfehler wie diesen:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Um eine Struktur <code>Point</code> zu definieren, bei der <code>x</code> und <code>y</code> generische, aber
unterschiedliche, Typen haben können, können wir mehrere generische
Typparameter verwenden. Zum Beispiel ändern wir in Codeblock 10-8 die
Definition von <code>Point</code> so, dass sie über den Typen <code>T</code> und <code>U</code> generisch ist,
wobei <code>x</code> vom Typ <code>T</code> und <code>y</code> vom Typ <code>U</code> ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Codeblock 10-8: <code>Point&lt;T, U&gt;</code> ist generisch über zwei
Typen, sodass <code>x</code> und <code>y</code> Werte unterschiedlichen Typs haben können</span></p>
<p>Jetzt sind alle gezeigten Instanzen von <code>Point</code> erlaubt! Du kannst so viele
generische Typparameter in einer Definition verwenden, wie du willst, aber das
Verwenden von mehr als einigen wenigen macht deinen Code schwer lesbar. Wenn du
denkst, dass du in deinem Code viele generische Typen benötigst, könnte dies
darauf hinweisen, dass dein Code in kleinere Teile zerlegt werden muss.</p>
<h3 id="in-aufzählungsdefinitionen"><a class="header" href="#in-aufzählungsdefinitionen">In Aufzählungsdefinitionen</a></h3>
<p>Wie wir es bei Strukturen gemacht haben, können wir Aufzählungen definieren, um
generische Datentypen in ihren Varianten zu verwenden. Werfen wir noch einmal
einen Blick auf die Aufzählung <code>Option&lt;T&gt;</code>, die die Standardbibliothek bietet
und die wir in Kapitel 6 verwendet haben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>Diese Definition dürfte für dich jetzt mehr Sinn machen. Wie du sehen kannst,
ist die Aufzählung <code>Option&lt;T&gt;</code> über dem Typ <code>T</code> generisch und hat zwei
Varianten: <code>Some</code>, die einen Wert vom Typ <code>T</code> enthält, und <code>None</code>, die keinen
Wert enthält. Durch das Verwenden der Aufzählung <code>Option&lt;T&gt;</code> können wir das
abstrakte Konzept eines optionalen Wertes ausdrücken und da <code>Option&lt;T&gt;</code>
generisch ist, können wir diese Abstraktion unabhängig vom Typ des
optionalen Wertes verwenden.</p>
<p>Aufzählungen können auch mehrere generische Typen verwenden. Die Definition der
Aufzählung <code>Result</code>, die wir in Kapitel 9 verwendet haben, ist ein Beispiel
dafür:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>Die Aufzählung <code>Result</code> ist generisch über zwei Typen <code>T</code> und <code>E</code> und hat zwei
Varianten: <code>Ok</code>, die einen Wert vom Typ <code>T</code> enthält, und <code>Err</code>, die einen Wert
vom Typ <code>E</code> enthält. Diese Definition macht es bequem, die Aufzählung <code>Result</code>
überall dort zu verwenden, wo wir eine Operation haben, die erfolgreich sein
(gibt einen Wert vom Typ <code>T</code> zurück) oder fehlschlagen (gibt einen Fehler vom
Typ <code>E</code> zurück) könnte. Tatsächlich haben wir dies beim Öffnen einer Datei in
Codeblock 9-3 verwendet, wobei für <code>T</code> der Typ <code>std::fs::File</code> verwendet wurde,
wenn die Datei erfolgreich geöffnet wurde, und für <code>E</code> der Typ
<code>std::io::Error</code>, wenn es Probleme beim Öffnen der Datei gab.</p>
<p>Wenn du in deinem Code Situationen mit mehreren Struktur- oder
Aufzählungsdefinitionen erkennst, die sich nur in den Typen der darin
enthaltenen Werte unterscheiden, kannst du doppelten Code vermeiden, indem du
stattdessen generische Typen verwendest.</p>
<h3 id="in-methodendefinitionen"><a class="header" href="#in-methodendefinitionen">In Methodendefinitionen</a></h3>
<p>Wir können Methoden auf Strukturen und Aufzählungen implementieren (wie wir es
in Kapitel 5 getan haben) und auch generische Typen in ihren Definitionen
verwenden. Codeblock 10-9 zeigt die Struktur <code>Point&lt;T&gt;</code>, die wir in Codeblock
10-6 definiert haben, mit einer darauf implementierten Methode namens <code>x</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}</code></pre></pre>
<p><span class="caption">Codeblock 10-9: Implementierung einer Methode <code>x</code> auf der
Struktur <code>Point&lt;T&gt;</code>, die eine Referenz auf das Feld <code>x</code> vom Typ <code>T</code>
zurückgibt</span></p>
<p>Hier haben wir eine Methode <code>x</code> auf <code>Point&lt;T&gt;</code> definiert, die eine Referenz auf
den Wert im Feld <code>x</code> zurückgibt.</p>
<p>Beachte, dass wir <code>T</code> direkt nach <code>impl</code> deklarieren müssen, damit wir Methoden
zum Typ <code>Point&lt;T&gt;</code> implementieren können. Durch das Deklarieren von <code>T</code> als
generischen Typ hinter <code>impl</code> kann Rust erkennen, dass der Typ in spitzen
Klammern in <code>Point</code> ein generischer und kein konkreter Typ ist. Wir hätten
einen anderen Namen für den generischen Parameter wählen können als den in der
Strukturdefinition deklarierten generischen Parameter, aber die Verwendung
desselben Namens ist üblich. Methoden, die innerhalb eines <code>impl</code> geschrieben
werden, das den generischen Typ deklariert, werden auf jeder Instanz des Typs
definiert, unabhängig davon, welcher konkrete Typ am Ende den generischen Typ
ersetzt.</p>
<p>Wir können auch Einschränkungen für generische Typen angeben, wenn wir Methoden
auf dem Typ definieren. Wir könnten zum Beispiel Methoden nur auf
<code>Point&lt;f32&gt;</code>-Instanzen implementieren und nicht auf <code>Point&lt;T&gt;</code>-Instanzen mit
einem beliebigen generischen Typ. In Codeblock 10-10 verwenden wir den
konkreten Typ <code>f32</code>, d.h. wir deklarieren keinen Typ hinter <code>impl</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-10: Ein <code>impl</code>-Block, der nur für eine
Struktur mit einem bestimmten konkreten Typ für den generischen Typparameter
<code>T</code> gilt</span></p>
<p>Dieser Code bedeutet, dass der Typ <code>Point&lt;f32&gt;</code> eine Methode
<code>distance_from_origin</code> hat und andere Instanzen von <code>Point&lt;T&gt;</code>, bei denen <code>T</code>
nicht vom Typ <code>f32</code> ist, haben diese Methode nicht. Die Methode misst, wie weit
unser Punkt vom Punkt mit den Koordinaten (0,0, 0,0) entfernt ist, und
verwendet mathematische Operationen, die nur für Fließkomma-Typen zur Verfügung
stehen.</p>
<p>Generische Typparameter in einer Strukturdefinition sind nicht immer die
gleichen wie die, die du in denselben Methodensignaturen für diese Struktur
verwendest. In Codeblock 10-11 werden die generischen Typen <code>X1</code> und <code>Y1</code> für
die Struktur <code>Point</code> und <code>X2</code> und <code>Y2</code> für die Signatur der Methode <code>mixup</code>
verwendet, um das Beispiel zu verdeutlichen. Die Methode erzeugt eine neue
<code>Point</code>-Instanz mit dem Wert <code>x</code> aus <code>self</code> (vom Typ <code>X1</code>) und dem Wert <code>y</code> aus
dem übergebenen <code>Point</code> (vom Typ <code>Y2</code>).</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hallo&quot;, y: 'c' };

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}</code></pre></pre>
<p><span class="caption">Codeblock 10-11: Eine Methode, die generische Typen aus
der Definition ihrer Struktur anders verwendet</span></p>
<p>In <code>main</code> haben wir einen <code>Point</code> definiert, bei dem <code>x</code> den Typ <code>i32</code> (mit dem
Wert <code>5</code>) und <code>y</code> den Typ <code>f64</code> (mit dem Wert <code>10.4</code>) hat. Die Variable <code>p2</code>
ist eine Struktur <code>Point</code>, bei der <code>x</code> einen Zeichenkettenanteilstyp (mit dem
Wert <code>&quot;Hallo&quot;</code>) und <code>y</code> den Typ <code>char</code> (mit dem Wert <code>c</code>) hat. Wenn wir <code>mixup</code>
auf <code>p1</code> mit dem Argument <code>p2</code> aufrufen, erhalten wir <code>p3</code>, das ein <code>i32</code> für
<code>x</code> haben wird, weil <code>x</code> von <code>p1</code> kam. Die Variable <code>p3</code> wird ein <code>char</code> für
<code>y</code> haben, weil <code>y</code> von <code>p2</code> stammt. Der Makroaufruf <code>println!</code> gibt
<code>p3.x = 5, p3.y = c</code> aus.</p>
<p>Der Zweck dieses Beispiels ist es, eine Situation zu demonstrieren, in der
einige generische Parameter mit <code>impl</code> und einige mit der Methodendefinition
deklariert werden. Hier werden die generischen Parameter <code>X1</code> und <code>Y1</code> nach
<code>impl</code> deklariert, weil sie zur Strukturdefinition gehören. Die generischen
Parameter <code>X2</code> und <code>Y2</code> werden nach <code>fn mixup</code> deklariert, da sie nur für die
Methode relevant sind.</p>
<h3 id="code-performanz-beim-verwenden-generischer-datentypen"><a class="header" href="#code-performanz-beim-verwenden-generischer-datentypen">Code-Performanz beim Verwenden generischer Datentypen</a></h3>
<p>Du fragst dich vielleicht, ob beim Verwenden generischer Typparameter
Laufzeitkosten anfallen. Die gute Nachricht ist, dass die Verwendung
generischer Typen die Ausführung deines Programms nicht langsamer macht als bei
konkreten Typen.</p>
<p>Rust erreicht dies durch Duplizierung von Code mit generischen Datentypen zur
Kompilierzeit. <em>Codeduplizierung</em> (monomorphization) ist der Vorgang der
Umwandlung von generischem Code in spezifischen Code durch Ausfüllen der
konkreten Typen, die bei der Kompilierung verwendet werden. Bei diesem Vorgang
führt der Compiler das Gegenteil der Schritte aus, die wir beim Erstellen der
generischen Funktion in Codeblock 10-5 angewendet haben: Der Compiler schaut
sich alle Stellen an, an denen generischer Code aufgerufen wird, und generiert
Code für die konkreten Typen, mit denen der generische Code aufgerufen wird.</p>
<p>Betrachten wir die Funktionsweise bei der Aufzählung <code>Option&lt;T&gt;</code> der
Standardbibliothek:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>Wenn Rust diesen Code kompiliert, führt es eine Codeduplizierung durch. Während
dieses Vorgangs liest der Compiler die Werte ein, die in
<code>Option&lt;T&gt;</code>-Instanzen verwendet wurden, und identifiziert zwei Arten von
<code>Option&lt;T&gt;</code>: Eine verwendet den Typ <code>i32</code> und die andere <code>f64</code>. Als solches
erweitert es die allgemeine Definition von <code>Option&lt;T&gt;</code> in zwei auf <code>i32</code> und
<code>f64</code> spezialisierte Definitionen, wodurch die allgemeine Definition durch die
spezifische ersetzt wird.</p>
<p>Die duplizierte Codeversion sieht ähnlich aus wie die folgende (der Compiler
verwendet andere Namen als die, die wir hier zur Veranschaulichung verwenden):</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
<p>Der generische Typ <code>Option&lt;T&gt;</code> wird durch die vom Compiler erstellten
spezifischen Definitionen ersetzt. Da Rust generischen Code in Code kompiliert,
der den Typ in jedem Fall spezifiziert, zahlen wir keine Laufzeitkosten beim
Verwenden von generischen Datentypen. Wenn der Code läuft, verhält er sich
genauso, wie wenn wir jede Definition von Hand dupliziert hätten. Der Vorgang
der Codeduplizierung macht Rusts generische Datentypen zur Laufzeit äußerst
effizient.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="merkmale-traits-gemeinsames-verhalten-definieren"><a class="header" href="#merkmale-traits-gemeinsames-verhalten-definieren">Merkmale (traits): Gemeinsames Verhalten definieren</a></h2>
<p>Ein <em>Merkmal</em> (trait) definiert Funktionalität, den ein bestimmter Typ hat und
mit anderen Typen teilen kann. Wir können Merkmale verwenden, um gemeinsames
Verhalten auf abstrakte Weise zu definieren. Wir können Merkmalsabgrenzungen
(trait bounds) verwenden, um anzugeben, dass ein generischer Typ jeder Typ sein
kann, der ein bestimmtes Verhalten aufweist.</p>
<blockquote>
<p>Anmerkung: Merkmale sind einer Funktionalität recht ähnlich, die in anderen
Sprachen oft <em>Schnittstelle</em> (interface) genannt wird, wenn auch mit einigen
Unterschieden.</p>
</blockquote>
<h3 id="ein-merkmal-definieren"><a class="header" href="#ein-merkmal-definieren">Ein Merkmal definieren</a></h3>
<p>Das Verhalten eines Typs besteht aus den Methoden, die wir auf diesen Typ
anwenden können. Verschiedene Typen haben das gleiche Verhalten, wenn wir bei
allen die gleichen Methoden aufrufen können. Merkmalsdefinitionen sind eine
Möglichkeit, Methodensignaturen zu gruppieren, um eine Reihe von
Verhaltensweisen zu definieren, die zum Erreichen eines bestimmten Zwecks
erforderlich sind.</p>
<p>Nehmen wir zum Beispiel an, wir haben mehrere Strukturen (structs), die
verschiedene Arten und Mengen von Text enthalten: Eine Struktur <code>NewsArticle</code>,
die eine Nachricht enthält, die sich auf einen bestimmten Ort bezieht, und ein
<code>Tweet</code>, der maximal 280 Zeichen umfassen kann, sowie Metadaten, die angeben,
ob es sich um eine neue Kurznachricht, eine Wiederholung oder eine Antwort auf
eine andere Kurznachricht handelt.</p>
<p>Wir wollen eine Medienaggregator-Bibliothekskiste namens <code>aggregator</code>
erstellen, die Zusammenfassungen von Daten anzeigen kann, die in einer
<code>NewsArticle</code>- oder <code>Tweet</code>-Instanz gespeichert sein könnten. Dazu brauchen wir
eine Zusammenfassung von jedem Typ, und wir werden diese Zusammenfassung
anfordern, indem wir eine Methode <code>summarize</code> auf einer Instanz aufrufen.
Codeblock 10-12 zeigt die Definition eines öffentlichen <code>Summary</code>-Merkmals, das
dieses Verhalten zum Ausdruck bringt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-12: Ein Merkmal <code>Summary</code>, dessen Verhalten
aus der Methode <code>summarize</code> besteht</span></p>
<p>Hier deklarieren wir ein Merkmal mit dem Schlüsselwort <code>trait</code> und dann den
Namen des Merkmals, der in diesem Fall <code>Summary</code> lautet. Wir haben das Merkmal
auch als <code>pub</code> deklariert, sodass Kisten, die von dieser Kiste abhängen, dieses
Merkmal ebenfalls nutzen können, wie wir in einigen Beispielen sehen werden.
Innerhalb der geschweiften Klammern deklarieren wir die Methodensignaturen, die
das Verhalten der Typen beschreiben, die dieses Merkmal implementieren, was in
diesem Fall <code>fn summarize(&amp;self) -&gt; String</code> ist.</p>
<p>Nach der Methodensignatur verwenden wir statt einer Implementierung in
geschweiften Klammern ein Semikolon. Jeder Typ, der dieses Merkmal
implementiert, muss sein eigenes benutzerdefiniertes Verhalten für den
Methodenrumpf bereitstellen. Der Compiler wird sicherstellen, dass jeder
Typ, der das Merkmal <code>Summary</code> hat, die Methode <code>summarize</code> mit genau dieser
Signatur hat.</p>
<p>Ein Merkmal kann mehrere Methoden umfassen: Die Methodensignaturen werden
zeilenweise aufgelistet und jede Zeile endet mit einem Semikolon.</p>
<h3 id="ein-merkmal-für-einen-typ-implementieren"><a class="header" href="#ein-merkmal-für-einen-typ-implementieren">Ein Merkmal für einen Typ implementieren</a></h3>
<p>Nachdem wir nun die gewünschten Signaturen der Methoden des Merkmals <code>Summary</code>
definiert haben, können wir sie für die Typen in unserem Medienaggregator
implementieren. Codeblock 10-13 zeigt eine Implementierung des Merkmals
<code>Summary</code> für die Struktur <code>NewsArticle</code>, die die Überschrift, den Autor und
den Ort verwendet, um den Rückgabewert von <code>summarize</code> zu erzeugen. Für die
Struktur <code>Tweet</code> definieren wir <code>summarize</code> als den Benutzernamen, gefolgt vom
gesamten Text der Kurznachricht, wobei wir davon ausgehen, dass der Inhalt der
Kurznachricht bereits auf 280 Zeichen begrenzt ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, von {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-13: Implementierung des Merkmals <code>Summary</code>
für die Typen <code>NewsArticle</code> und <code>Tweet</code></span></p>
<p>Die Implementierung eines Merkmals für einen Typ ist ähnlich zur
Implementierung regulärer Methoden. Der Unterschied besteht darin, dass wir
nach <code>impl</code> den Namen des Merkmals schreiben, das wir implementieren wollen
und dann das Schlüsselwort <code>for</code> gefolgt vom Namen des Typs, für den wir
das Merkmal implementieren wollen. Innerhalb des <code>impl</code>-Blocks geben wir die
Methodensignaturen an, die das Merkmal vorgibt. Anstatt nach jeder Signatur ein
Semikolon zu schreiben, verwenden wir geschweifte Klammern und füllen den
Methodenrumpf mit dem spezifischen Verhalten, das die Methoden des Merkmals für
den jeweiligen Typ haben sollen.</p>
<p>Da die Bibliothek nun das Merkmal <code>Summary</code> auf <code>NewsArticle</code> und <code>Tweet</code>
implementiert hat, können Benutzer der Kiste die Merkmals-Methoden auf
Instanzen von <code>NewsArticle</code> und <code>Tweet</code> auf die gleiche Weise aufrufen, wie wir
reguläre Methoden aufrufen. Der einzige Unterschied besteht darin, dass der
Benutzer das Merkmal sowie die Typen in den Gültigkeitsbereich bringen muss, um
die zusätzlichen Merkmals-Methoden zu erhalten. Hier ist ein Beispiel dafür,
wie eine binäre Kiste unsere <code>aggregator</code>-Bibliothekskiste verwenden könnte:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;natürlich, wie du wahrscheinlich schon weißt&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 neue Kurznachricht: {}&quot;, tweet.summarize());
<span class="boring">}</span></code></pre>
<p>Dieser Code gibt <code>1 neue Kurznachricht: horse_ebooks: natürlich, wie du wahrscheinlich schon weißt</code> aus.</p>
<p>Andere Kisten, die von der <code>aggregator</code>-Kiste abhängen, können auch das Merkmal
<code>Summary</code> in den Gültigkeitsbereich bringen, um <code>Summary</code> auf ihren eigenen
Typen zu implementieren. Eine Einschränkung ist, dass wir ein Merkmal für einen
Typ nur dann implementieren können, wenn entweder das Merkmal oder der Typ
lokal in unserer Kiste vorhanden ist. Zum Beispiel können wir
Standard-Bibliotheksmerkmale wie <code>Display</code> auf einem benutzerdefinierten Typ
wie <code>Tweet</code> als Teil unserer <code>aggregator</code>-Kistenfunktionalität implementieren,
weil der Typ <code>Tweet</code> lokal zu unserer <code>aggregator</code>-Kiste gehört. Wir können
auch <code>Summary</code> auf <code>Vec&lt;T&gt;</code> in unserer <code>aggregator</code>-Kiste implementieren, weil
das Merkmal <code>Summary</code> lokal zu unserer <code>aggregator</code>-Kiste gehört.</p>
<p>Aber wir können externe Merkmale nicht auf externe Typen anwenden. Zum Beispiel
können wir das Merkmal <code>Display</code> auf <code>Vec&lt;T&gt;</code> in unserer <code>aggregator</code>-Kiste
nicht implementieren, weil <code>Display</code> und <code>Vec&lt;T&gt;</code> in der Standardbibliothek
definiert sind und nicht lokal zu unserer <code>aggregator</code>-Kiste gehören. Diese
Beschränkung ist Teil einer Eigenschaft von Programmen namens <em>Kohärenz</em>
(coherence), genauer gesagt der <em>Waisenregel</em> (orphan rule), die so genannt
wird, weil der übergeordnete Typ nicht vorhanden ist. Diese Regel stellt
sicher, dass der Code anderer Personen deinen Code nicht brechen kann und
umgekehrt. Ohne diese Regel könnten zwei Kisten dasselbe Merkmal für denselben
Typ implementieren und Rust wüsste nicht, welche Implementierung es verwenden
sollte.</p>
<h3 id="standard-implementierungen"><a class="header" href="#standard-implementierungen">Standard-Implementierungen</a></h3>
<p>Manchmal ist es nützlich, ein Standardverhalten für einige oder alle Methoden
eines Merkmals zu haben, anstatt Implementierungen für alle Methoden für jeden
Typ zu verlangen. Wenn wir dann das Merkmal für einen bestimmten Typ
implementieren, können wir das Standardverhalten jeder Methode beibehalten oder
überschreiben.</p>
<p>In Codeblock 10-14 geben wir eine Standard-Zeichenkette für die Methode
<code>summarize</code> des Merkmals <code>Summary</code> an, anstatt nur die Methodensignatur zu
definieren, wie wir es in Codeblock 10-12 getan haben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Lies mehr ...)&quot;)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-14: Definieren eines Merkmals <code>Summary</code> mit
einer Standard-Implementierung der Methode <code>summarize</code></span></p>
<p>Um eine Standard-Implementierung zu verwenden, um Instanzen von <code>NewsArticle</code>
zusammenzufassen, geben wir einen leeren <code>impl</code>-Block mit <code>impl Summary for NewsArticle {}</code> an.</p>
<p>Auch wenn wir die Methode <code>summarize</code> nicht mehr direkt für <code>NewsArticle</code>
definieren, haben wir eine Standard-Implementierung bereitgestellt und
festgelegt, dass <code>NewsArticle</code> das Merkmal <code>Summary</code> implementiert.
Infolgedessen können wir immer noch die Methode <code>summarize</code> einer
<code>NewsArticle</code>-Instanz aufrufen, etwa so:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from(&quot;Pinguine gewinnen die Stanley-Cup-Meisterschaft!&quot;),
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        author: String::from(&quot;Iceburgh&quot;),
        content: String::from(&quot;Die Pittsburgh Penguins sind erneut die beste \
                               Eishockeymannschaft in der NHL.&quot;,
        ),
    };

    println!(&quot;Neuer Artikel verfügbar! {}&quot;, article.summarize());
<span class="boring">}</span></code></pre>
<p>Dieser Code gibt <code>Neuer Artikel verfügbar! (Lies mehr ...)</code> aus.</p>
<p>Das Erstellen einer Standard-Implementierung erfordert nicht, dass wir an der
Implementierung von <code>Summary</code> für <code>Tweet</code> in Codeblock 10-13 etwas ändern. Der
Grund dafür ist, dass die Syntax für das Überschreiben einer
Standard-Implementierung die gleiche ist wie die Syntax für die Implementierung
einer Merkmalsmethode, die keine Standard-Implementierung hat.</p>
<p>Standard-Implementierungen können andere Methoden desselben Merkmals aufrufen,
selbst wenn diese anderen Methoden keine Standard-Implementierung haben. Auf
diese Weise kann ein Merkmal eine Menge nützlicher Funktionalität bereitstellen
und von den Implementierern nur die Angabe eines kleinen Teils verlangen. Zum
Beispiel könnten wir das Merkmal <code>Summary</code> so definieren, dass wir eine Methode
<code>summarize_author</code> haben, deren Implementierung erforderlich ist, und dann eine
Methode <code>summarize</code> definieren, die eine Standard-Implementierung hat und die
Methode <code>summarize_author</code> aufruft:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Lies mehr von {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Um diese Version von <code>Summary</code> zu verwenden, müssen wir <code>summarize_author</code> nur
dann definieren, wenn wir das Merkmal für einen Typ implementieren:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Lies mehr von {}...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Nachdem wir <code>summarize_author</code> definiert haben, können wir <code>summarize</code> auf
Instanzen der <code>Tweet</code>-Struktur aufrufen, und die Standard-Implementierung von
<code>summarize</code> wird die Definition von <code>summarize_author</code> aufrufen, die wir
bereitgestellt haben. Da wir <code>summarize_author</code> implementiert haben, hat uns
das Merkmal <code>Summary</code> das Verhalten der <code>summarize</code>-Methode mitgeliefert, ohne
dass wir weiteren Code schreiben müssen. </p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;natürlich, wie du wahrscheinlich schon weißt&quot;),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 neue Kurznachricht: {}&quot;, tweet.summarize());
<span class="boring">}</span></code></pre>
<p>Dieser Code gibt <code>1 neue Kurznachricht: (Lies mehr von @horse_ebooks...)</code> aus.</p>
<p>Beachte, dass es nicht möglich ist, die Standardimplementierung von einer
übergeordneten Implementierung derselben Methode aus aufzurufen.</p>
<h3 id="merkmale-als-parameter"><a class="header" href="#merkmale-als-parameter">Merkmale als Parameter</a></h3>
<p>Da du jetzt weißt, wie man Merkmale definiert und implementiert, können wir
untersuchen, wie man Merkmale zur Definition von Funktionen verwendet, die
viele verschiedene Typen akzeptieren. Wir verwenden das Merkmal <code>Summary</code>, das
wir für die Typen <code>NewsArticle</code> und <code>Tweet</code> in Codeblock 10-13 implementiert
haben, um eine Funktion <code>notify</code> zu definieren, die die Methode <code>summarize</code> für
ihren Parameter <code>item</code> aufruft, der von einem Typ ist, der das Merkmal
<code>Summary</code> implementiert. Um dies zu tun, können wir die Syntax <code>impl Trait</code>
verwenden, etwa so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: impl Summary) {
    println!(&quot;Eilmeldung! {}&quot;, item.summarize());
}
<span class="boring">}</span></code></pre></pre>
<p>Anstelle eines konkreten Typs für den Parameter <code>item</code> geben wir das
Schlüsselwort <code>impl</code> und den Merkmalsnamen an. Dieser Parameter akzeptiert
jeden Typ, der das angegebene Merkmal implementiert. Im Rumpf von <code>notify</code>
können wir alle Methoden von <code>item</code> aufrufen, die vom Merkmal <code>Summary</code>
herrühren, zum Beispiel <code>summarize</code>. Wir können <code>notify</code> aufrufen und jede
Instanz von <code>NewsArticle</code> und <code>Tweet</code> angeben. Code, der die Funktion mit einem
anderen Typ aufruft, z.B. <code>String</code> oder <code>i32</code>, lässt sich nicht kompilieren, da
diese Typen kein <code>Summary</code> implementieren.</p>
<h4 id="merkmalsabgrenzungs-syntax"><a class="header" href="#merkmalsabgrenzungs-syntax">Merkmalsabgrenzungs-Syntax</a></h4>
<p>Die Syntax <code>impl Trait</code> funktioniert für einfache Fälle, ist aber eigentlich
syntaktischer Zucker für eine längere Form, die <em>Merkmalsabgrenzung</em> (trait
bound) genannt wird; sie sieht so aus:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Eilmeldung! {}&quot;, item.summarize());
}
<span class="boring">}</span></code></pre></pre>
<p>Diese längere Form entspricht dem Beispiel im vorigen Abschnitt, ist aber
wortreicher. Wir platzieren Merkmalsabgrenzungen in der Deklaration des
generischen Typparameters nach einem Doppelpunkt und innerhalb spitzer
Klammern.</p>
<p>Die Syntax <code>impl Trait</code> ist bequem und ermöglicht in einfachen Fällen einen
prägnanteren Code, während die umfassendere Merkmalsabgrenzungs-Syntax mehr
Komplexität ausdrücken kann. Zum Beispiel können wir zwei Parameter haben, die
<code>Summary</code> implementieren. Das Verwenden der Syntax <code>impl Trait</code> sieht
folgendermaßen aus:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p>Die Verwendung von <code>impl Trait</code> ist angemessen, wenn wir wollten, dass diese
Funktion bei <code>item1</code> und <code>item2</code> unterschiedliche Typen haben kann (solange
beide Typen <code>Summary</code> implementieren). Wenn beide Parameter aber den gleichen
Typ haben sollen, müssen wir eine Merkmalsabgrenzung verwenden, so wie hier:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p>Der als Parametertyp für <code>item1</code> und <code>item2</code> angegebene generische Typ <code>T</code>
schränkt die Funktion so ein, dass der konkrete Typ der als Argument für
<code>item1</code> und <code>item2</code> übergebenen Werte derselbe sein muss.</p>
<h4 id="angeben-mehrerer-merkmalsabgrenzungen-mit-der-syntax-"><a class="header" href="#angeben-mehrerer-merkmalsabgrenzungen-mit-der-syntax-">Angeben mehrerer Merkmalsabgrenzungen mit der Syntax <code>+</code></a></h4>
<p>Wir können auch mehr als eine Merkmalsabgrenzung angeben. Nehmen wir an, wir
wollen, dass sowohl <code>notify</code> als auch die Methode <code>summarize</code> die
Bildschirmausgabe für <code>item</code> formatieren: Spezifizieren wir in der
<code>notify</code>-Definition, dass <code>item</code> sowohl <code>Display</code> als auch <code>Summary</code>
implementieren muss. Wir können dies mit der Syntax <code>+</code> tun:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p>Die Syntax <code>+</code> ist auch bei Merkmalsabgrenzungen mit generischen Typen gültig:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>Mit den beiden angegebenen Merkmalsabgrenzungen kann der Rumpf von <code>notify</code> die
Methode <code>summarize</code> aufrufen und <code>{}</code> verwenden, um <code>item</code> zu formatieren.</p>
<h4 id="klarere-merkmalsabgrenzungen-mit-where-klauseln"><a class="header" href="#klarere-merkmalsabgrenzungen-mit-where-klauseln">Klarere Merkmalsabgrenzungen mit <code>where</code>-Klauseln</a></h4>
<p>Zu viele Merkmalsabgrenzungen zu verwenden, hat seine Schattenseiten. Jeder
generische Datentyp hat seine eigenen Merkmalsabgrenzungen, sodass Funktionen
mit mehreren generischen Typparametern viele Merkmalsabgrenzungsangaben
zwischen Funktionsname und Parameterliste enthalten können, wodurch die
Funktionssignatur schwer lesbar wird. Aus diesem Grund hat Rust für die Angabe
von Merkmalsabgrenzungen eine alternative Syntax in Form einer <code>where</code>-Klausel
nach der Funktionssignatur. Anstatt das hier zu schreiben:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>können wir eine <code>where</code>-Klausel wie folgt verwenden:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{</code></pre>
<p>Die Signatur dieser Funktion ist übersichtlicher: Der Funktionsname, die
Parameterliste und der Rückgabetyp liegen nahe beieinander, ähnlich wie bei
einer Funktion ohne viele Merkmalsabgrenzungen.</p>
<h3 id="rückgabetypen-die-merkmale-implementieren"><a class="header" href="#rückgabetypen-die-merkmale-implementieren">Rückgabetypen, die Merkmale implementieren</a></h3>
<p>Wir können die Syntax <code>impl Trait</code> auch für den Rückgabetyp verwenden, wie hier
gezeigt:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;natürlich, wie du wahrscheinlich schon weißt&quot;),
        reply: false,
        retweet: false,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Durch Verwenden von <code>impl Summary</code> für den Rückgabetyp legen wir fest, dass die
Funktion <code>returns_summarizable</code> einen Typ zurückgibt, der das Merkmal <code>Summary</code>
implementiert, ohne den konkreten Typ zu nennen. In diesem Fall gibt
<code>returns_summarizable</code> einen <code>Tweet</code> zurück, aber der Code, der diese Funktion
aufruft, muss das nicht wissen.</p>
<p>Die Fähigkeit, einen Rückgabetyp nur durch das Merkmal, das er implementiert,
zu spezifizieren, ist besonders nützlich im Zusammenhang mit
Funktionsabschlüssen und Iteratoren, die wir in Kapitel 13 behandeln.
Funktionsabschlüsse und Iteratoren erzeugen Typen, die nur der Compiler
kennt oder deren Spezifikation sehr lang ist. Mit der Syntax <code>impl Trait</code>
kannst du prägnant angeben, dass eine Funktion einen Typ zurückgibt, der das
Merkmal <code>Iterator</code> implementiert, ohne dass du einen sehr langen Typ schreiben
musst.</p>
<p>Du kannst <code>impl Trait</code> jedoch nur verwenden, wenn du einen einzigen Typ
zurückgibst. Beispielsweise würde dieser Code, der entweder einen <code>NewsArticle</code>
oder einen <code>Tweet</code> mit dem Rückgabetyp <code>impl Summary</code> zurückgibt, nicht
funktionieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, von {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Pinguine gewinnen die Stanley-Cup-Meisterschaft!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;Die Pittsburgh Penguins sind erneut die beste \
                 Eishockeymannschaft in der NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;natürlich, wie du wahrscheinlich schon weißt&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Die Rückgabe entweder eines <code>NewsArticle</code> oder eines <code>Tweet</code> ist aufgrund von
Einschränkungen hinsichtlich der Implementierung der Syntax <code>impl Trait</code> im
Compiler nicht erlaubt. Wie man eine Funktion mit diesem Verhalten schreibt,
wird im Abschnitt <a href="ch17-02-trait-objects.html">„Merkmalsobjekte (trait objects) die Werte unterschiedlicher
Typen erlauben“</a>
in Kapitel 17 behandelt.</p>
<h3 id="verwenden-von-merkmalsabgrenzungen-zur-bedingten-implementierung-von-methoden"><a class="header" href="#verwenden-von-merkmalsabgrenzungen-zur-bedingten-implementierung-von-methoden">Verwenden von Merkmalsabgrenzungen zur bedingten Implementierung von Methoden</a></h3>
<p>Durch Verwenden einer Merkmalsabgrenzung mit einem <code>impl</code>-Block, der generische
Typparameter verwendet, können wir Methoden bedingt für Typen implementieren,
die das angegebene Merkmal implementieren. Beispielsweise implementiert der Typ
<code>Pair&lt;T&gt;</code> in Codeblock 10-15 immer die Funktion <code>new</code>, um eine neue Instanz von
<code>Pair&lt;T&gt;</code> zurückzugeben (erinnere dich an den Abschnitt <a href="ch05-03-method-syntax.html#definieren-von-methoden">„Definieren von
Methoden“</a> in Kapitel 5, dass <code>Self</code> ein Typ-Alias für den Typ des
<code>impl</code>-Blocks ist, der in diesem Fall <code>Pair&lt;T&gt;</code> ist). Aber im nächsten
<code>impl</code>-Block implementiert <code>Pair&lt;T&gt;</code> die Methode <code>cmp_display</code> nur, wenn ihr
innerer Typ <code>T</code> die Merkmale <code>PartialOrd</code> <em>und</em> <code>Display</code> implementiert, die
den Vergleich bzw. eine Ausgabe ermöglichen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;Das größte Element ist x = {}&quot;, self.x);
        } else {
            println!(&quot;Das größte Element ist y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-15: Bedingte Implementierung von Methoden
für einen generischen Typ in Abhängigkeit von Merkmalsabgrenzungen</span></p>
<p>Wir können auch ein Merkmal für beliebige Typen bedingt implementieren, die ein
anderes Merkmal implementieren. Implementierungen eines Merkmals für Typen, die
Merkmalsabgrenzungen erfüllen, werden als <em>Pauschal-Implementierungen</em> (blanket
implementations) bezeichnet und kommen in der Rust-Standardbibliothek ausgiebig
zur Anwendung. Beispielsweise implementiert die Standardbibliothek das Merkmal
<code>ToString</code> für jeden Typ, der das Merkmal <code>Display</code> implementiert. Der
<code>impl</code>-Block in der Standardbibliothek sieht in etwa so aus:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --abschneiden--
}</code></pre>
<p>Da die Standardbibliothek diese Pauschal-Implementierungen hat, können wir die
<code>to_string</code>-Methode, die durch das Merkmal <code>ToString</code> definiert ist, bei jedem
Typ aufrufen, der das Merkmal <code>Display</code> implementiert. Zum Beispiel können wir
ganze Zahlen in ihre entsprechenden <code>String</code>-Werte umwandeln, weil ganze
Zahlen <code>Display</code> implementieren:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>Pauschal-Implementierungen erscheinen in der Dokumentation des Merkmals im
Abschnitt „Implementierer“ (implementors).</p>
<p>Mithilfe von Merkmalen und Merkmalsabgrenzungen können wir Code schreiben, der
generische Typparameter verwendet, um Duplikationen zu reduzieren, aber auch
dem Compiler gegenüber angeben, dass der generische Typ ein bestimmtes
Verhalten haben soll. Der Compiler kann dann die Merkmalsabgrenzungen
verwenden, um zu überprüfen, ob alle konkreten Typen, die von unserem Code
verwendet werden, das richtige Verhalten aufweisen. In dynamisch typisierten
Sprachen würden wir einen Laufzeitfehler erhalten, wenn wir eine Methode bei
einem Typ aufrufen, der die Methode nicht definiert hat. Rust verschiebt diese
Fehler jedoch in die Kompilierzeit und verlangt damit, dass wir die Probleme
beheben, bevor unser Code überhaupt lauffähig ist. Außerdem müssen wir keinen
Code schreiben, der das Verhalten zur Laufzeit überprüft, da wir es bereits zur
Kompilierzeit überprüft haben. Auf diese Weise wird die Performanz verbessert,
ohne die Flexibilität der generischen Datentypen aufgeben zu müssen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referenzen-validieren-mit-lebensdauern"><a class="header" href="#referenzen-validieren-mit-lebensdauern">Referenzen validieren mit Lebensdauern</a></h2>
<p><em>Lebensdauer</em> (lifetimes) sind eine weitere generische Funktionalität, die wir
bereits verwendet haben. Anstatt sicherzustellen, dass ein Typ das von uns
gewünschte Verhalten hat, stellen wir durch die Lebensdauer sicher, dass
Referenzen so lange gültig sind, wie wir sie brauchen.</p>
<p>Ein Detail, das wir im Abschnitt <a href="ch04-02-references-and-borrowing.html">„Referenzen und Ausleihen
(borrowing)“</a> in Kapitel 4 nicht erörtert haben, ist,
dass jede Referenz in Rust eine <em>Lebensdauer</em> (lifetime) hat, d.h. einen
Gültigkeitsbereich, in dem diese Referenz gültig ist. In den meisten Fällen
sind Lebensdauern implizit und abgeleitet, ebenso wie in den meisten Fällen
Typen abgeleitet werden. Wir müssen Typen mit Annotationen versehen, wenn
mehrere Typen möglich sind. In ähnlicher Weise müssen wir Lebensdauern
annotieren, wenn die Lebensdauern von Referenzen auf verschiedene Weise
miteinander in Beziehung gesetzt werden könnten. Rust verlangt von uns, die
Beziehungen mit generischen Lebensdauerparametern zu annotieren, um
sicherzustellen, dass die tatsächlich zur Laufzeit verwendeten Referenzen
definitiv gültig sind.</p>
<p>Das Vermerken von Lebensdauern ist ein Konzept, das die meisten anderen
Programmiersprachen nicht kennen, sodass es sich ungewohnt anfühlen wird. Auch
wenn wir in diesem Kapitel die Lebensdauern nicht in ihrer Gesamtheit behandeln
werden, so werden wir doch allgemeine Möglichkeiten erörtern, mit denen du dich
mit der Syntax der Lebensdauer und den Konzepten vertraut machen kannst.</p>
<h3 id="verhindern-hängender-referenzen-mit-lebensdauern"><a class="header" href="#verhindern-hängender-referenzen-mit-lebensdauern">Verhindern hängender Referenzen mit Lebensdauern</a></h3>
<p>Das Hauptziel der Lebensdauer ist es, <em>hängende Referenzen</em> (dangling
references) zu verhindern, die dazu führen, dass ein Programm auf andere
Daten referenziert als die, auf die es referenzieren soll. Betrachte das
Programm in Codeblock 10-16, das einen äußeren und einen inneren
Gültigkeitsbereich hat.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    {
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!(&quot;r: {}&quot;, r);
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 10-16: Ein Versuch, eine Referenz zu verwenden,
deren Wert außerhalb des Gültigkeitsbereichs liegt</span></p>
<blockquote>
<p>Hinweis: Die Beispiele in den Codeblöcken 10-16, 10-17 und 10-23 deklarieren
Variablen ohne Initialwert, sodass der Variablenname im äußeren
Gültigkeitsbereich existiert. Auf den ersten Blick mag dies im Widerspruch
dazu stehen, dass Rust keine Nullwerte hat. Wenn wir jedoch versuchen, eine
Variable zu verwenden, bevor wir ihr einen Wert geben, erhalten wir einen
Kompilierfehler, der zeigt, dass Rust tatsächlich keine Nullwerte zulässt.</p>
</blockquote>
<p>Der äußere Gültigkeitsbereich deklariert eine Variable <code>r</code> ohne Initialwert und
der innere Gültigkeitsbereich deklariert eine Variable <code>x</code> mit dem Initialwert
5. Im inneren Gültigkeitsbereich versuchen wir, den Wert von <code>r</code> als Referenz
auf <code>x</code> zu setzen. Dann endet der innere Gültigkeitsbereich und wir versuchen,
den Wert in <code>r</code> auszugeben. Dieser Code lässt sich nicht kompilieren, weil der
Wert, auf den sich <code>r</code> bezieht, den Gültigkeitsbereich verlassen hat, bevor wir
versuchen, ihn zu verwenden. Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!(&quot;r: {}&quot;, r);
   |                           - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Die Variable <code>x</code> lebt nicht „lange genug“. Der Grund dafür ist, dass <code>x</code> den
Gültigkeitsbereich verlässt, da der innere Gültigkeitsbereich bei Zeile 7
endet. Aber <code>r</code> ist im äußeren Gültigkeitsbereich immer noch gültig; da sein
Gültigkeitsbereich größer ist, sagen wir, dass es „länger lebt“. Wenn Rust
diesen Code funktionieren ließe, würde <code>r</code> auf Speicher verweisen, der
freigegeben wurde, als <code>x</code> den Gültigkeitsbereich verlassen hat, und alles, was
wir mit <code>r</code> tun würden, würde nicht korrekt funktionieren. Wie stellt Rust also
fest, dass dieser Code ungültig ist? Es verwendet einen Ausleihenprüfer (borrow
checker).</p>
<h3 id="der-ausleihenprüfer"><a class="header" href="#der-ausleihenprüfer">Der Ausleihenprüfer</a></h3>
<p>Der Rust-Compiler verfügt über einen <em>Ausleihenprüfer</em> (borrow checker), der
Gültigkeitsbereiche vergleicht, um festzustellen, ob alle Ausleihen gültig
sind. Codeblock 10-17 zeigt den gleichen Code wie Codeblock 10-16, jedoch mit
Annotationen, die die Lebensdauer der Variablen angeben.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-17: Annotationen der Lebensdauern von <code>r</code>
und <code>x</code>, genannt <code>'a</code> bzw. <code>'b</code></span></p>
<p>Hier haben wir die Lebensdauer von <code>r</code> mit <code>'a</code> und die Lebensdauer von <code>x</code> mit
<code>'b</code> vermerkt. Wie du sehen kannst, ist der innere <code>'b</code>-Block viel kleiner als
der äußere <code>'a</code>-Lebensdauer-Block. Zur Kompilierzeit vergleicht Rust die Größe
der beiden Lebensdauern und stellt fest, dass <code>r</code> eine Lebensdauer von <code>'a</code>
hat, jedoch auf einen Speicherbereich mit Lebensdauern <code>'b</code> referenziert. Das
Programm wird abgelehnt, weil <code>'b</code> kürzer als <code>'a</code> ist: Der Referenzinhalt lebt
nicht so lange wie die Referenz selbst.</p>
<p>Mit Codeblock 10-18 wird der Code so korrigiert, dass er keine hängende
Referenz hat und fehlerfrei kompiliert werden kann.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
}</code></pre></pre>
<p><span class="caption">Codeblock 10-18: Eine gültige Referenz, da die Daten eine
längere Lebensdauer als die Referenz haben</span></p>
<p>Hier hat <code>x</code> die Lebensdauer <code>'b</code>, die in diesem Fall größer ist als <code>'a</code>. Das
bedeutet, dass <code>r</code> auf <code>x</code> referenzieren kann, weil Rust weiß, dass die
Referenz in <code>r</code> immer gültig sein wird, solange <code>x</code> gültig ist.</p>
<p>Da du nun weißt, wo die Lebensdauern von Referenzen sind und wie Rust die
Lebensdauer analysiert, um sicherzustellen, dass Referenzen immer gültig sind,
lass uns die generischen Lebensdauern von Parametern und Rückgabewerten im
Kontext von Funktionen untersuchen.</p>
<h3 id="generische-lebensdauern-in-funktionen"><a class="header" href="#generische-lebensdauern-in-funktionen">Generische Lebensdauern in Funktionen</a></h3>
<p>Wir schreiben eine Funktion, die den längeren von zwei
Zeichenkettenanteilstypen zurückgibt. Diese Funktion nimmt zwei
Zeichenkettenanteilstypen entgegen und gibt einen einzigen
Zeichenkettenanteilstyp zurück. Nachdem wir die Funktion <code>longest</code>
implementiert haben, sollte der Code in Codeblock 10-19 <code>Die längere Zeichenkette ist abcd</code> ausgeben.</p>
<p><span class="filename">Datei: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
}</code></pre>
<p><span class="caption">Codeblock 10-19: Eine Funktion <code>main</code>, die die Funktion
<code>longest</code> aufruft, um die längere von zwei Zeichenkettenanteilstypen zu
bestimmen</span></p>
<p>Beachte, dass wir wollen, dass die Funktion Zeichenkettenanteilstypen nimmt,
die Referenzen sind und keine Zeichenketten, weil wir nicht wollen, dass die
Funktion <code>longest</code> die Eigentümerschaft ihrer Parameter übernimmt. Lies den
Abschnitt <a href="ch04-03-slices.html#zeichenkettenanteilstypen-als-parameter">„Zeichenkettenanteilstypen als
Parameter“</a> in Kapitel 4, um mehr darüber zu
erfahren, warum die Parameter, die wir in Codeblock 10-19 verwenden, die von
uns gewünschten sind.</p>
<p>Wenn wir versuchen, die Funktion <code>longest</code>, wie in Codeblock 10-20 gezeigt, zu
implementieren, wird sie sich nicht kompilieren lassen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 10-20: Eine Implementierung der Funktion
<code>longest</code>, die die längere von zwei Zeichenkettenanteilstypen zurückgibt, aber
noch nicht kompiliert</span></p>
<p>Stattdessen erhalten wir folgenden Fehler, der von Lebensdauern spricht:</p>
<pre><code class="language-console">$ cargo run
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ^^^^    ^^^^^^^     ^^^^^^^     ^^^

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Aus dem Hilfetext geht hervor, dass der Rückgabetyp einen generischen
Lebensdauer-Parameter benötigt, da Rust nicht sagen kann, ob sich die
zurückgegebene Referenz auf <code>x</code> oder auf <code>y</code> bezieht. Eigentlich wissen wir es
auch nicht, weil der <code>if</code>-Zweig im Funktionsrumpf eine Referenz auf <code>x</code> und der
<code>else</code>-Zweig eine Referenz auf <code>y</code> zurückgibt!</p>
<p>Wenn wir diese Funktion definieren, kennen wir die konkreten Werte nicht, die
an diese Funktion übergeben werden, also wissen wir nicht, ob der <code>if</code>-Zweig
oder der <code>else</code>-Zweig ausgeführt wird. Wir kennen auch nicht die konkreten
Lebensdauern der Referenzen, die weitergegeben werden, sodass wir nicht wie in
den Codeblöcken 10-17 und 10-18 die Gültigkeitsbereiche betrachten können, um
festzustellen, ob die von uns zurückgegebene Referenz immer gültig sein wird.
Der Ausleihenprüfer kann dies auch nicht feststellen, weil er nicht weiß, wie
die Lebensdauer von <code>x</code> und <code>y</code> mit der Lebensdauer des Rückgabewertes
zusammenhängt. Um diesen Fehler zu beheben, geben wir generische
Lebensdauerparameter an, die die Beziehung zwischen den Referenzen definieren,
damit der Ausleihenprüfer seine Analyse durchführen kann.</p>
<h3 id="lebensdauer-annotationssyntax"><a class="header" href="#lebensdauer-annotationssyntax">Lebensdauer-Annotationssyntax</a></h3>
<p>Lebensdauer-Annotationen ändern nichts daran, wie lange eine Referenz lebt.
Vielmehr beschreiben sie die Beziehungen der Lebensdauern mehrerer Referenzen
zueinander, ohne die Lebensdauern zu beeinflussen. Genauso wie Funktionen jeden
Typ entgegennehmen können, wenn die Signatur einen generischen Typparameter
angibt, können Funktionen Referenzen mit beliebiger Lebensdauer akzeptieren,
indem sie einen generischen Lebensdauerparameter angeben.</p>
<p>Lebensdauer-Annotationen haben eine etwas ungewöhnliche Syntax: Die Namen der
Lebensdauer-Parameter müssen mit einem Apostroph (<code>'</code>) beginnen und sind
normalerweise kleingeschrieben und sehr kurz, wie generische Typen. Die meisten
Menschen verwenden den Namen <code>'a</code> für die erste Lebensdauer-Annotationen. Wir
platzieren Lebensdauer-Parameter-Annotationen hinter dem <code>&amp;</code> einer Referenz,
wobei wir ein Leerzeichen verwenden, um die Annotation vom Typ der Referenz zu
trennen.</p>
<p>Hier sind einige Beispiele: Eine Referenz auf einen <code>i32</code> ohne
Lebensdauer-Parameter, eine Referenz auf einen <code>i32</code>, die einen
Lebensdauer-Parameter namens <code>'a</code> hat, und eine veränderbarer Referenz auf
einen <code>i32</code>, die ebenfalls die Lebensdauer <code>'a</code> hat.</p>
<pre><code class="language-rust ignore">&amp;i32        // eine Referenz
&amp;'a i32     // eine Referenz mit expliziter Lebensdauer
&amp;'a mut i32 // eine veränderbare Referenz mit expliziter Lebensdauer</code></pre>
<p>Eine Lebensdauer-Annotation an sich hat nicht viel Bedeutung, da die
Annotationen Rust mitteilen sollen, wie sich generische
Lebensdauer-Parameter mehrerer Referenzen zueinander verhalten. Untersuchen
wir, wie sich die Lebensdauer-Annotationen im Zusammenhang mit der Funktion
<code>longest</code> zueinander verhalten.</p>
<h3 id="lebensdauer-annotationen-in-funktionssignaturen"><a class="header" href="#lebensdauer-annotationen-in-funktionssignaturen">Lebensdauer-Annotationen in Funktionssignaturen</a></h3>
<p>Um Lebensdauer-Annotationen in Funktionssignaturen zu verwenden, müssen wir die
generischen <em>Lebensdauer</em>-Parameter in spitzen Klammern zwischen dem
Funktionsnamen und der Parameterliste deklarieren, genau wie wir es mit den
generischen <em>Typ</em>-Parametern gemacht haben.</p>
<p>Wir möchten, dass die Signatur die folgende Bedingung ausdrückt: Die
zurückgegebene Referenz ist gültig, solange die beiden Parameter gültig sind.
Dies ist die Beziehung zwischen den Lebensdauern der Parameter und des
Rückgabewerts. Wir nennen die Lebensdauer <code>'a</code> und fügen sie dann jeder
Referenz hinzu, wie in Codeblock 10-21 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 10-21: Die Funktionsdefinition <code>longest</code> gibt
an, dass alle Referenzen in der Signatur die gleiche Lebensdauer <code>'a</code> haben
müssen</span></p>
<p>Dieser Code sollte kompilierbar sein und das gewünschte Ergebnis liefern, wenn
wir ihn mit der Funktion <code>main</code> in Codeblock 10-19 verwenden.</p>
<p>Die Funktionssignatur sagt Rust, dass die Funktion für eine gewisse Lebensdauer
<code>'a</code> zwei Parameter benötigt, die beide den Zeichenkettenanteilstyp haben und
mindestens so lange leben wie die Lebensdauer <code>'a</code>. Die Funktionssignatur sagt
Rust auch, dass der von der Funktion zurückgegebene Zeichenkettenanteilstyp
mindestens so lange leben wird wie die Lebensdauer <code>'a</code>. In der Praxis bedeutet
dies, dass die Lebensdauer der Referenz, die von der Funktion <code>longest</code>
zurückgegeben wird, der kleineren der Lebensdauern der Werte entspricht, auf
die sich die Funktionsargumente beziehen. Diese Beziehungen sollen von Rust
verwendet werden, wenn es diesen Code analysiert.</p>
<p>Denke daran, indem wir die Lebensdauerparameter in dieser Funktionssignatur
angeben, ändern wir nicht die Lebensdauer der übergebenen oder zurückgegebenen
Werte. Vielmehr legen wir fest, dass der Ausleihenprüfer alle Werte ablehnen
soll, die sich nicht an diese Bedingung halten. Beachte, dass die Funktion
<code>longest</code> nicht genau wissen muss, wie lange <code>x</code> und <code>y</code> leben werden, nur dass
ein gewisser Gültigkeitsbereich für <code>'a</code> eingesetzt werden kann, der dieser
Signatur genügt.</p>
<p>Wenn Funktionen mit Lebensdauern annotiert werden, gehören die Annotationen zur
Funktionssignatur, nicht zum Funktionsrumpf. Die Lebensdauer-Annotationen werden
Teil des Funktionsvertrags, ähnlich wie die Typen in der Signatur. Wenn
Funktionssignaturen den Lebensdauervertrag enthalten, kann die Analyse des
Rust-Compilers einfacher sein. Wenn es ein Problem mit der Art und Weise gibt,
wie eine Funktion annotiert ist oder wie sie aufgerufen wird, können die
Compilerfehler auf den Teil unseres Codes und die Beschränkungen genauer
hinweisen. Wenn der Rust-Compiler stattdessen mehr Rückschlüsse auf die von uns
beabsichtigten Beziehungen der Lebensdauern ziehen würde, könnte der Compiler
nur auf eine Verwendung unseres Codes hinweisen, die viele Schritte von der
Ursache des Problems entfernt ist.</p>
<p>Wenn wir der Funktion <code>longest</code> konkrete Referenzen übergeben, ist die konkrete
Lebensdauer, die an die Stelle von <code>'a</code> tritt, der Teil des Gültigkeitsbereichs
von <code>x</code>, der sich mit dem Gültigkeitsbereich von <code>y</code> überschneidet. Mit anderen
Worten bekommt die generische Lebensdauer <code>'a</code> die konkrete Lebensdauer, die
der kürzeren der Lebensdauern von <code>x</code> und <code>y</code> entspricht. Da wir die
zurückgegebene Referenz mit dem gleichen Lebensdauer-Parameter <code>'a</code> annotiert
haben, wird die zurückgegebene Referenz auch für die Dauer der kürzeren
Lebensdauer von <code>x</code> und <code>y</code> gültig sein.</p>
<p>Schauen wir uns an, wie die Lebensdauer-Annotationen die Funktion <code>longest</code>
beschränken, indem wir Referenzen mit unterschiedlichen konkreten Lebensdauern
übergeben. Codeblock 10-22 ist ein einfaches Beispiel.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;lange Zeichenkette ist lang&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-22: Verwenden der Funktion <code>longest</code> mit
Referenzen auf Zeichenketten, die unterschiedliche konkrete Lebensdauern
haben</span></p>
<p>In diesem Beispiel ist <code>string1</code> bis zum Ende des äußeren Gültigkeitsbereichs
gültig, <code>string2</code> ist bis zum Ende des inneren Gültigkeitsbereichs gültig, und
<code>result</code> referenziert auf etwas, das bis zum Ende des inneren
Gültigkeitsbereichs gültig ist. Führe diesen Code aus und du wirst sehen, dass
der Ausleihenprüfer diesen Code akzeptiert; er kompiliert und gibt <code>Die längere Zeichenkette ist lange Zeichenkette ist lang</code> aus.</p>
<p>Versuchen wir als nächstes ein Beispiel, das zeigt, dass die Lebensdauer der
Referenz in <code>result</code> die kürzere Lebensdauer der beiden Argumente sein muss. 
Wir verschieben die Deklaration der Variable <code>result</code> oberhalb des inneren
Gültigkeitsbereichs, lassen aber die Zuweisung des Wertes an die Variable
<code>result</code> innerhalb des Gültigkeitsbereichs mit <code>string2</code>. Dann verschieben wir
<code>println!</code>, das <code>result</code> verwendet, unterhalb des inneren Gültigkeitsbereichs.
Der Code in Codeblock 10-23 lässt sich nicht kompilieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let string1 = String::from(&quot;lange Zeichenkette ist lang&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-23: Der Versuch, <code>result</code> zu verwenden,
nachdem <code>string2</code> den Gültigkeitsbereich verlassen hat</span></p>
<p>Wenn wir versuchen, diesen Code zu kompilieren, erhalten wir folgenden Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
  |                                                 ------ borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Der Fehler zeigt, dass <code>string2</code> bis zum Ende des äußeren Gültigkeitsbereichs
gültig sein müsste, damit <code>result</code> in der Anweisung <code>println!</code> noch gültig ist. 
Rust weiß das, weil wir die Lebensdauer der Funktionsparameter und
Rückgabewerte mit dem gleichen Lebensdauerparameter <code>'a</code> annotiert haben.</p>
<p>Als Menschen können wir uns diesen Code ansehen und erkennen, dass <code>string1</code>
länger als <code>string2</code> ist und deshalb wird <code>result</code> eine Referenz auf <code>string1</code>
enthalten. Da <code>string1</code> den Gültigkeitsbereich noch nicht verlassen hat, wird
eine Referenz auf <code>string1</code> in der <code>println!</code>-Anweisung noch gültig sein. Der
Compiler kann jedoch nicht sehen, dass die Referenz in diesem Fall gültig
ist. Wir haben Rust gesagt, dass die Lebensdauer der Referenz, die von der
Funktion <code>longest</code> zurückgegeben wird, die gleiche ist wie die kürzere der
Lebensdauern der entgegengenommenen Referenzen. Daher lehnt der Ausleihenprüfer
den Code in Codeblock 10-23 als möglicherweise ungültige Referenz ab.</p>
<p>Versuche, dir weitere Experimente auszudenken, die die Werte und die
Lebensdauern der an die Funktion <code>longest</code> übergebenen Referenzen variieren und
wie die zurückgegebene Referenz verwendet wird. Stelle Hypothesen darüber auf,
ob deine Experimente den Ausleihenprüfer bestehen oder nicht, bevor du
kompilierst; prüfe dann, ob du Recht hast!</p>
<h3 id="denken-in-lebensdauern"><a class="header" href="#denken-in-lebensdauern">Denken in Lebensdauern</a></h3>
<p>Die Art und Weise, in der du Lebensdauerparameter angeben musst, hängt davon
ab, was deine Funktion tut. Wenn wir zum Beispiel die Implementierung der
Funktion <code>longest</code> so ändern würden, dass sie immer den ersten Parameter
zurückgibt und nicht den längsten Zeichenkettenanteilstyp, bräuchten wir keine
Lebensdauer für den Parameter <code>y</code> anzugeben. Der folgende Code wird
kompilieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
<p>Wir haben einen Lebensdauer-Parameter <code>'a</code> für den Parameter <code>x</code> und den
Rückgabetyp angegeben, aber nicht für den Parameter <code>y</code>, weil die Lebensdauer
von <code>y</code> in keiner Beziehung zur Lebensdauer von <code>x</code> oder dem Rückgabewert
steht.</p>
<p>Wenn eine Funktion eine Referenz zurückgibt, muss der Lebensdauerparameter für
den Rückgabetyp mit dem Lebensdauerparameter für einen der Parameter
übereinstimmen. Wenn sich die zurückgegebene Referenz <em>nicht</em> auf einen der
Parameter bezieht, muss er sich auf einen innerhalb dieser Funktion erzeugten
Wert beziehen. Dies wäre jedoch eine hängende Referenz, da der Wert am Ende der
Funktion den Gültigkeitsbereich verlässt. Betrachte diesen Versuch einer
Implementierung der Funktion <code>longest</code>, die sich nicht kompilieren lässt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;wirklich lange Zeichenkette&quot;);
    result.as_str()
}</code></pre></pre>
<p>Auch wenn wir hier einen Lebensdauer-Parameter <code>'a</code> für den Rückgabetyp
angegeben haben, wird diese Implementierung nicht kompilieren, weil die
Lebensdauer des Rückgabewerts überhaupt nicht mit der Lebensdauer der Parameter
zusammenhängt. Hier ist die Fehlermeldung, die wir erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return reference to local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Das Problem ist, dass <code>result</code> den Gültigkeitsbereich verlässt und am Ende der
Funktion <code>longest</code> aufgeräumt wird. Wir versuchen auch, eine Referenz auf den
Wert in <code>result</code> zurückzugeben. Es gibt keine Möglichkeit, Lebensdauerparameter
so anzugeben, dass die hängende Referenz beseitigt wird, Rust lässt uns also
keine hängende Referenz erstellen. In diesem Fall wäre die beste Lösung, einen
eigenen Datentyp statt einer Referenz zurückzugeben, sodass die aufrufende
Funktion dann für das Aufräumen des Wertes verantwortlich ist.</p>
<p>Letztlich geht es bei der Lebensdauersyntax darum, die Lebensdauern
verschiedener Parameter und Rückgabewerte von Funktionen miteinander zu
verbinden. Sobald sie verbunden sind, verfügt Rust über genügend Informationen,
um speichersichere Operationen zu ermöglichen und Operationen zu unterbinden,
die hängende Zeiger erzeugen oder anderweitig die Speichersicherheit verletzen
würden.</p>
<h3 id="lebensdauer-annotationen-in-struktur-definitionen"><a class="header" href="#lebensdauer-annotationen-in-struktur-definitionen">Lebensdauer-Annotationen in Struktur-Definitionen</a></h3>
<p>Bisher haben wir nur Strukturen (structs) definiert, die aneigenbare Typen
enthalten. Es ist möglich, dass Strukturen Referenzen enthalten, aber in diesem
Fall müssten wir Lebensdauer-Annotationen zu jeder Referenz in der
Strukturdefinition angeben. Codeblock 10-24 hat eine Struktur namens
<code>ImportantExcerpt</code>, die einen Zeichenkettenanteilstyp enthält.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Nennen Sie mich Ishmael. Vor einigen Jahren ...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Konnte keinen '.' finden.&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
<p><span class="caption">Codeblock 10-24: Eine Struktur, die eine Referenz
enthält, sodass ihre Definition eine Lebensdauer-Annotationen benötigt</span></p>
<p>Diese Struktur hat das einzige Feld <code>part</code>, das einen Zeichenkettenanteilstyp
enthält, der eine Referenz ist. Wie bei generischen Datentypen deklarieren wir
den Namen des generischen Lebensdauerparameters innerhalb spitzer Klammern
hinter dem Strukturnamen, damit wir den Lebensdauerparameter im Rumpf der
Strukturdefinition verwenden können. Diese Annotation bedeutet, dass eine
Instanz von <code>ImportantExcerpt</code> die Referenz, die sie in ihrem Feld <code>part</code>
enthält, nicht überleben kann.</p>
<p>Die Funktion <code>main</code> erzeugt hier eine Instanz der Struktur <code>ImportantExcerpt</code>,
die eine Referenz auf den ersten Satz des <code>String</code> enthält, der der Variablen
<code>novel</code> gehört. Die Daten in <code>novel</code> existieren, bevor die Instanz
<code>ImportantExcerpt</code> erzeugt wird. Darüber hinaus verlässt <code>novel</code> den
Gültigkeitsbereich erst, nachdem <code>ImportantExcerpt</code> den Gültigkeitsbereich
verlassen hat, sodass die Referenz in der <code>ImportantExcerpt</code>-Instanz gültig
ist.</p>
<h3 id="lebensdauer-elision"><a class="header" href="#lebensdauer-elision">Lebensdauer-Elision</a></h3>
<p>Du hast gelernt, dass jede Referenz eine Lebensdauer hat und dass du
Lebensdauerparameter für Funktionen oder Strukturen angeben musst, die
Referenzen verwenden. In Kapitel 4 hatten wir jedoch eine Funktion in Codeblock
4-9, die wiederum in Codeblock 10-25 gezeigt wird, die ohne
Lebensdauer-Annotationen kompiliert.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;Hallo Welt&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word funktioniert mit Anteilstypen von `String`
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;Hallo Welt&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word funktioniert mit Anteilstypen von Zeichenkettenliteralen
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
</span><span class="boring">    // funktioniert dies auch ohne die Anteilstypensyntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 10-25: Eine Funktion, die wir in Codeblock 4-9
definiert haben und die ohne Lebensdauer-Annotationen kompiliert, obwohl
Parameter und Rückgabetyp Referenzen sind</span></p>
<p>Der Grund, warum diese Funktion ohne Lebensdauer-Annotationen kompiliert, ist
historisch bedingt: In frühen Versionen (vor 1.0) von Rust hätte sich dieser
Code nicht kompilieren lassen, da jede Referenz eine explizite Lebensdauer
benötigte. Damals wäre die Funktionssignatur so geschrieben worden:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Nachdem jede Menge Rust-Code geschrieben wurde, stellte das Rust-Team fest,
dass die Rust-Programmierer in bestimmten Situationen immer wieder die gleichen
Lebensdauer-Annotationen angaben. Diese Situationen waren vorhersehbar und
folgten einigen wenigen deterministischen Mustern. Die Entwickler
programmierten diese Muster in den Code des Compilers, sodass der
Ausleihenprüfer in diesen Situationen auf die Lebensdauer schließen konnte und
keine expliziten Annotationen benötigte.</p>
<p>Dieses Stück Rust-Geschichte ist relevant, weil es möglich ist, dass weitere
deterministische Muster auftauchen und dem Compiler hinzugefügt werden. In
Zukunft könnten noch weniger Lebensdauer-Annotationen erforderlich sein.</p>
<p>Die Muster, die in Rusts Referenzanalyse programmiert sind, werden die
<em>Lebensdauer-Elisionsregeln</em> (lifetime elision rules) genannt. Dies sind keine
Regeln, die Programmierer befolgen müssen; es handelt sich um eine Reihe
besonderer Fälle, die der Compiler berücksichtigt, und wenn dein Code zu
einem dieser Fälle passt, brauchst du die Lebensdauer nicht explizit anzugeben.</p>
<p>Die Elisionsregeln bieten keine vollständige Schlussfolgerung. Wenn Rust die
Regeln deterministisch anwendet, aber immer noch Unklarheit darüber besteht,
welche Lebensdauer die Referenzen haben, wird der Compiler nicht erraten,
wie lang die Lebensdauer der verbleibenden Referenzen sein sollte. Statt einer
Vermutung gibt dir der Compiler einen Fehler an, den du beheben kannst, indem
du die Lebensdauer-Annotationen angibst, die festlegen, wie sich die Referenzen
zueinander verhalten.</p>
<p>Die Lebensdauern der Funktions- oder Methodenparameter werden als
<em>Eingangslebensdauern</em> (input lifetimes) bezeichnet, und die Lebensdauern der
Rückgabewerte als <em>Ausgangslebensdauern</em> (output lifetimes) bezeichnet.</p>
<p>Der Compiler verwendet drei Regeln, um herauszufinden, welche Lebensdauer
Referenzen haben, wenn keine expliziten Annotationen vorhanden sind. Die erste
Regel gilt für Eingangslebensdauern und die zweite und dritte Regel gelten für
Ausgangslebensdauern. Wenn der Compiler das Ende der drei Regeln erreicht
und es immer noch Referenzen gibt, für die er keine Lebensdauern ermitteln
kann, bricht der Compiler mit einem Fehler ab. Diese Regeln gelten sowohl
für <code>fn</code>-Definitionen als auch für <code>impl</code>-Blöcke.</p>
<p>Die erste Regel ist, dass der Compiler jedem Parameter, der eine Referenz ist,
seinen eigenen Lebensdauerparameter zuweist. Mit anderen Worten, eine Funktion
mit einem Parameter erhält einen Lebensdauerparameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; eine Funktion mit zwei Parametern erhält zwei separate
Lebensdauerparameter: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; und so weiter.</p>
<p>Die zweite Regel lautet: Wenn es genau einen Eingangslebensdauer-Parameter
gibt, wird diese Lebensdauer allen Ausgangslebensdauer-Parametern zugewiesen:
<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>Die dritte Regel lautet: Wenn es mehrere Eingangslebensdauer-Parameter gibt,
aber einer davon <code>&amp;self</code> oder <code>&amp;mut self</code> ist, weil dies eine Methode ist, wird
die Lebensdauer von <code>self</code> allen Ausgangslebensdauer-Parametern zugewiesen.
Diese dritte Regel macht Methoden viel angenehmer zu lesen und zu schreiben,
weil weniger Symbole erforderlich sind.</p>
<p>Tun wir so, als wären wir der Compiler. Wir werden diese Regeln anwenden, um
herauszufinden, wie lang die Lebensdauer der Referenzen in der Signatur der
Funktion <code>first_word</code> in Codeblock 10-26 ist. Die Signatur beginnt ohne
Lebensdauern:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>Dann wendet der Compiler die erste Regel an, die festlegt, dass jeder
Parameter seine eigene Lebensdauer erhält. Wir nennen sie wie üblich <code>'a</code>, also
sieht die Signatur jetzt so aus:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>Die zweite Regel trifft zu, weil es genau eine Eingangslebensdauer gibt. Die
zweite Regel legt fest, dass die Lebensdauer des einen Eingabeparameters der
Ausgangslebensdauer zugeordnet wird, sodass die Signatur nun wie folgt
aussieht:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Jetzt haben alle Referenzen in dieser Funktionssignatur eine Lebensdauer und
der Compiler kann seine Analyse fortsetzen, ohne dass der Programmierer die
Lebensdauer in dieser Funktionssignatur annotieren muss.</p>
<p>Schauen wir uns ein anderes Beispiel an, diesmal mit der Funktion <code>longest</code>,
die keine Lebensdauerparameter hatte, als wir in Codeblock 10-20 mit ihr zu
arbeiten begannen:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>Wenden wir die erste Regel an: Jeder Parameter erhält seine eigene Lebensdauer.
Diesmal haben wir zwei Parameter anstelle von einem, also haben wir zwei
Lebensdauern:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>Du siehst, dass die zweite Regel nicht gilt, weil es mehr als eine
Eingangslebensdauer gibt. Auch die dritte Regel trifft nicht zu, weil <code>longest</code>
eine Funktion ist, keine Methode, sodass keiner der Parameter <code>self</code> ist.
Nachdem wir alle drei Regeln durchgearbeitet haben, haben wir immer noch nicht
herausgefunden, wie lang die Lebensdauer des Rückgabetyps ist. Aus diesem Grund
haben wir beim Versuch, den Code in Codeblock 10-20 zu kompilieren, einen
Fehler erhalten: Der Compiler arbeitete die Lebensdauer-Elisionsregeln
durch, konnte aber immer noch nicht alle Lebensdauern der Referenzen in der
Signatur ermitteln.</p>
<p>Da die dritte Regel eigentlich nur für Methodensignaturen gilt, werden wir uns
als nächstes die Lebensdauern in diesem Zusammenhang ansehen, um zu sehen,
warum die dritte Regel bedeutet, dass wir die Lebensdauer in Methodensignaturen
nicht sehr oft annotieren müssen.</p>
<h3 id="lebensdauer-annotationen-in-methodendefinitionen"><a class="header" href="#lebensdauer-annotationen-in-methodendefinitionen">Lebensdauer-Annotationen in Methodendefinitionen</a></h3>
<p>Wenn wir Methoden auf einer Struktur mit Lebensdauer implementieren, verwenden
wir die gleiche Syntax wie die in Codeblock 10-11 gezeigten generischen
Typparameter. Wo wir die Lebensdauerparameter deklarieren und verwenden, hängt
davon ab, ob sie sich auf die Strukturfelder oder auf die Methodenparameter und
Rückgabewerte beziehen.</p>
<p>Lebensdauer-Namen für Struktur-Felder müssen immer nach dem
<code>impl</code>-Schlüsselwort deklariert und dann hinter dem Namen der Struktur verwendet
werden, da diese Lebensdauern Teil des Typs der Struktur sind.</p>
<p>In Methodensignaturen innerhalb des <code>impl</code>-Blocks können Referenzen an die
Lebensdauern der Referenzen in den Feldern der Struktur gebunden sein oder sie
können unabhängig sein. Darüber hinaus sorgen die Lebensdauer-Elisionsregeln
oft dafür, dass Lebensdauer-Annotationen in Methodensignaturen nicht
erforderlich sind. Betrachten wir einige Beispiele mit der Struktur
<code>ImportantExcerpt</code>, die wir in Codeblock 10-24 definiert haben.</p>
<p>Zuerst werden wir eine Methode namens <code>level</code> verwenden, deren einziger
Parameter eine Referenz auf <code>self</code> ist und deren Rückgabewert ein <code>i32</code> ist,
was keine Referenz ist:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Bitte um Aufmerksamkeit: {}&quot;, announcement);
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Nennen Sie mich Ishmael. Vor einigen Jahren ...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Konnte keinen '.' finden.&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>Die Lebensdauer-Parameter-Deklaration nach <code>impl</code> und ihre Verwendung hinter dem
Typnamen sind erforderlich, aber wir sind nicht verpflichtet, die Lebensdauer der
Referenz auf <code>self</code> wegen der ersten Elisionsregel zu annotieren.</p>
<p>Hier ist ein Beispiel, bei dem die dritte Lebensdauer-Elisionsregel gilt:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Bitte um Aufmerksamkeit: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Nennen Sie mich Ishmael. Vor einigen Jahren ...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Konnte keinen '.' finden.&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>Es gibt zwei Eingangslebensdauern, sodass Rust die erste
Lebensdauer-Elisionsregel anwendet und sowohl <code>&amp;self</code> als auch <code>announcement</code>
ihre eigene Lebensdauer gibt. Da einer der Parameter <code>&amp;self</code> ist, erhält der
Rückgabetyp die Lebensdauer von <code>&amp;self</code>, und alle Lebensdauern sind
berücksichtigt worden.</p>
<h3 id="statische-lebensdauer"><a class="header" href="#statische-lebensdauer">Statische Lebensdauer</a></h3>
<p>Eine besondere Lebensdauer, die wir besprechen müssen, ist <code>'static</code>, was
bedeutet, dass diese Referenz während der gesamten Dauer des Programms bestehen
kann. Alle Zeichenkettenliterale haben die Lebensdauer <code>'static</code>. Sie wird wie
folgt annotiert:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;Ich habe eine statische Lebensdauer.&quot;;
<span class="boring">}</span></code></pre></pre>
<p>Der Text dieser Zeichenkette wird direkt in der Binärdatei des Programms
gespeichert, die immer verfügbar ist. Daher ist die Lebensdauer aller
Zeichenkettenliterale <code>'static</code>.</p>
<p>Möglicherweise siehst du Hinweise zur Verwendung der Lebensdauer <code>'static</code> in
Fehlermeldungen. Aber bevor du <code>'static</code> als Lebensdauer für eine Referenz
angibst, denke darüber nach, ob deine Referenz tatsächlich während der gesamten
Lebensdauer deines Programms lebt oder nicht, und ob du das so willst. In den
meisten Fällen resultiert eine Fehlermeldung, die auf die Lebensdauer <code>'static</code>
hindeutet, aus dem Versuch, eine hängende Referenz zu erstellen, oder aus einer
Nichtübereinstimmung der verfügbaren Lebensdauern. In solchen Fällen besteht
die Lösung darin, diese Probleme zu beheben und nicht darin, die Lebensdauer
als <code>'static</code> festzulegen.</p>
<h2 id="generische-typparameter-merkmalsabgrenzungen-und-lebensdauern-zusammen"><a class="header" href="#generische-typparameter-merkmalsabgrenzungen-und-lebensdauern-zusammen">Generische Typparameter, Merkmalsabgrenzungen und Lebensdauern zusammen</a></h2>
<p>Schauen wir uns kurz die Syntax zu Angabe generischer Typparameter,
Merkmalsabgrenzungen und Lebensdauern in einer Funktion an!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Heute hat jemand Geburtstag!&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;Bekanntmachung! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>Dies ist die Funktion <code>longest</code> aus Codeblock 10-21, die die längere von zwei
Zeichenkettenanteilstypen zurückgibt. Aber jetzt hat sie einen zusätzlichen
Parameter namens <code>ann</code> vom generischen Typ <code>T</code>, der jeder beliebige Typ sein
kann, der das Merkmal <code>Display</code> implementiert, wie in der <code>where</code>-Klausel
spezifiziert ist. Dieser zusätzliche Parameter wird unter Verwendung von <code>{}</code>
ausgegeben, weshalb die Merkmalsabgrenzung <code>Display</code> erforderlich ist. Da die
Lebensdauer ein generischer Typ ist, stehen die Deklarationen des
Lebensdauer-Parameters <code>'a</code> und des generischen Typ-Parameters <code>T</code> in der
gleichen Liste innerhalb spitzer Klammern hinter dem Funktionsnamen.</p>
<h2 id="zusammenfassung-9"><a class="header" href="#zusammenfassung-9">Zusammenfassung</a></h2>
<p>Wir haben in diesem Kapitel viel behandelt! Jetzt, da du über generische
Typparameter, Merkmale und Merkmalsabgrenzungen sowie generische
Lebensdauerparameter Bescheid weißt, bist du bereit, Code ohne Wiederholungen
zu schreiben, der in vielen verschiedenen Situationen funktioniert. Merkmale
und Merkmalsabgrenzungen stellen sicher, dass die Typen, auch wenn sie
generisch sind, das Verhalten haben, das der Code benötigt. Du hast gelernt,
wie man Lebensdauer-Annotationen verwendet, um sicherzustellen, dass dieser
flexible Code keine hängenden Referenzen hat. Und all diese Analysen finden zur
Kompilierzeit statt, was die Laufzeitperformanz nicht beeinträchtigt!</p>
<p>Ob du es glaubst oder nicht, es gibt zu den Themen, die wir in diesem Kapitel
besprochen haben, noch viel mehr zu sagen: In Kapitel 17 werden Merkmalsobjekte
erörtert, die eine weitere Möglichkeit zur Verwendung von Merkmalen darstellen.
Es gibt auch komplexere Szenarien mit Lebensdauer-Annotationen, die du nur in
sehr fortgeschrittenen Szenarien benötigst; für diese solltest du die
<a href="https://doc.rust-lang.org/reference/index.html">Rust-Referenz</a> lesen. Aber als Nächstes wirst du lernen, wie man
Tests in Rust schreibt, damit du sicherstellen kannst, dass dein Code so
funktioniert, wie er es soll.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatisierte-tests-schreiben"><a class="header" href="#automatisierte-tests-schreiben">Automatisierte Tests schreiben</a></h1>
<p>In seinem Essay „Der bescheidene Programmierer“ von 1972 sagte Edsger W.
Dijkstra, dass „Programmtests eine sehr effektive Methode sein können, das
Vorhandensein von Fehlern zu zeigen, aber sie sind hoffnungslos unzureichend,
um deren Abwesenheit zu zeigen“. Das bedeutet nicht, dass wir nicht versuchen
sollten, so viel wie möglich zu testen!</p>
<p>Korrektheit unserer Programme ist das Maß, inwieweit unser Code das tut, was
wir beabsichtigen. Bei der Entwicklung von Rust wird der Korrektheit von
Programmen große Bedeutung beigemessen, aber Korrektheit ist komplex und nicht
leicht zu beweisen. Das Typsystem von Rust trägt einen großen Teil dieser Last,
aber das Typsystem kann nicht alles erkennen. Rust beinhaltet Unterstützung für
das Schreiben automatisierter Softwaretests.</p>
<p>Nehmen wir an, wir schreiben eine Funktion namens <code>add_two</code>, die 2 zu jeder
Zahl addiert, die ihr übergeben wird. Die Signatur dieser Funktion akzeptiert
eine ganze Zahl als Parameter und gibt als Ergebnis eine ganze Zahl zurück.
Wenn wir diese Funktion implementieren und kompilieren, führt Rust die gesamte
Typ- und Ausleihenprüfung durch, die du bisher kennengelernt hast, um
sicherzustellen, dass wir z.B. keinen <code>String</code>-Wert oder eine ungültige
Referenz an diese Funktion übergeben. Aber Rust kann <em>nicht</em> überprüfen, ob
diese Funktion genau das tut, was wir beabsichtigen, nämlich den Parameter plus
2 zurückzugeben und nicht etwa den Parameter plus 10 oder den Parameter minus
50! Hier kommen Tests ins Spiel.</p>
<p>Wir können Tests schreiben, die zum Beispiel sicherstellen, dass der
Rückgabewert <code>5</code> ist, wenn wir <code>3</code> an die Funktion <code>add_two</code> übergeben. Wir
können diese Tests immer dann durchführen, wenn wir Änderungen an unserem Code
vornehmen, um sicherzustellen, dass sich ein bestehendes korrektes Verhalten
nicht geändert hat.</p>
<p>Testen ist eine komplexe Fähigkeit: Obwohl wir nicht jedes Detail darüber, wie
man gute Tests schreibt, in einem Kapitel behandeln können, werden wir die
Mechanismen der Rust-Testmöglichkeiten besprechen. Wir werden über Annotationen
und Makros sprechen, die dir beim Schreiben deiner Tests zur Verfügung stehen,
über das Standardverhalten und die Optionen, die es bei der Ausführung deiner
Tests gibt, und darüber, wie du Tests in Modultests (unit tests) und
Integrationstests organisieren kannst.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tests-schreiben"><a class="header" href="#tests-schreiben">Tests schreiben</a></h2>
<p>Tests sind Funktionen in Rust, die überprüfen, ob der zu testende Code in der
erwarteten Weise funktioniert. Der Rumpf von Testfunktionen führt in der Regel
diese drei Aktionen aus:</p>
<ol>
<li>Bereite die benötigten Daten und Zustände vor.</li>
<li>Führe den Code aus, den du testen möchtest.</li>
<li>Stelle sicher, dass die Ergebnisse das sind, was du erwartest.</li>
</ol>
<p>Schauen wir uns die Funktionalität an, die Rust speziell für das Schreiben von
Tests bereitstellt, die diese Aktionen ausführen. Dazu gehören das Attribut
<code>test</code>, einige Makros und das Attribut <code>should_panic</code>.</p>
<h3 id="anatomie-einer-testfunktion"><a class="header" href="#anatomie-einer-testfunktion">Anatomie einer Testfunktion</a></h3>
<p>Im einfachsten Fall ist ein Test in Rust eine Funktion, die mit dem Attribut
<code>test</code> annotiert wird. Attribute sind Metadaten über Teile des Rust-Codes; ein
Beispiel ist das Attribut <code>derive</code>, das wir in Kapitel 5 bei Strukturen
verwendet haben. Um eine Funktion in eine Testfunktion zu verwandeln, füge
<code>#[test]</code> oberhalb der Zeile mit <code>fn</code> ein. Wenn du deine Tests mit dem Befehl
<code>cargo test</code> ausführst, erstellt Rust eine Testausführungs-Binärdatei (test
runner binary), die die annotierte Funktionen ausführt und darüber berichtet,
ob jede Testfunktion erfolgreich war oder nicht.</p>
<p>Wann immer wir ein neues Bibliotheksprojekt mit Cargo durchführen, wird für uns
automatisch ein Testmodul mit einer Testfunktion darin generiert. Dieses Modul
gibt dir eine Vorlage, um deine Tests zu schreiben, sodass du nicht jedes Mal,
wenn du ein neues Projekt startest, die genaue Struktur und Syntax nachschlagen
musst. Du kannst so viele zusätzliche Testfunktionen und Testmodule hinzufügen,
wie du möchtest!</p>
<p>Wir werden einige Aspekte der Funktionsweise von Tests untersuchen, indem wir
mit der Testvorlage experimentieren, bevor wir tatsächlich Code testen. Dann
schreiben wir einige Tests aus der realen Welt, die einen von uns geschriebenen
Code aufrufen und sicherstellen, dass sein Verhalten korrekt ist.</p>
<p>Lass uns ein neues Bibliotheksprojekt namens <code>adder</code> erstellen, das zwei Zahlen
addiert:</p>
<pre><code class="language-console noplayground">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>Der Inhalt der Datei <em>src/lib.rs</em> in deiner Bibliothek <code>adder</code> sollte wie
Codeblock 11-1 aussehen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 11-1: Das Testmodul und die Funktion, die
automatisch von <code>cargo new</code> generiert werden</span></p>
<p>Ignorieren wir vorerst die beiden oberen Zeilen und konzentrieren uns auf die
Funktion. Beachte die Annotation <code>#[test]</code>: Dieses Attribut zeigt an, dass es
sich um eine Testfunktion handelt, sodass die Testausführung weiß, dass es
diese Funktion als einen Test behandeln soll. Wir könnten auch
Nicht-Test-Funktionen im Modul <code>tests</code> haben, um gängige Szenarien aufzusetzen
oder gängige Operationen durchzuführen, daher müssen wir immer angeben, welche
Funktionen Tests sind.</p>
<p>Der Beispiel-Funktionsrumpf verwendet das Makro <code>assert_eq!</code>, um
sicherzustellen, dass 2 + 2 gleich 4 ist. Diese Prüfung dient als Beispiel für
den Aufbau eines typischen Tests. Lassen wir ihn laufen, um zu sehen, dass
dieser Test erfolgreich ist.</p>
<p>Das Kommando <code>cargo test</code> führt alle Tests in unserem Projekt aus, wie in
Codeblock 11-2 zu sehen ist.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><span class="caption">Codeblock 11-2: Ergebnis der Ausführung des automatisch
generierten Tests</span></p>
<p>Cargo hat den Test kompiliert und ausgeführt. Nach den Zeilen <code>Compiling</code>,
<code>Finished</code> und <code>Running</code> folgt die Zeile <code>running 1 test</code>. Die nächste Zeile
zeigt den Namen der generierten Testfunktion <code>it_works</code> und das Ergebnis der
Testausführung: <code>ok</code>. Als nächstes wird die Gesamtzusammenfassung der
Testausführung angegeben. Der Text <code>test result: ok.</code> bedeutet, dass alle Tests
bestanden wurden, und der Teil <code>1 passed; 0 failed</code> gibt die Anzahl der Tests
an, die bestanden oder nicht bestanden wurden.</p>
<p>Es ist möglich, einen Test als ignoriert zu markieren, sodass er in einer
bestimmten Instanz nicht ausgeführt wird; wir werden dies im Abschnitt <a href="ch11-02-running-tests.html#tests-ignorieren-die-nicht-ausdr%C3%BCcklich-verlangt-werden">„Tests
ignorieren, die nicht ausdrücklich verlangt werden“</a> später in
diesem Kapitel behandeln. Da wir das hier nicht getan haben, zeigt die
Zusammenfassung <code>0 ignored</code>. Wir können auch ein Argument an den Befehl
<code>cargo test</code> übergeben, um nur Tests auszuführen, deren Name mit einer
Zeichenkette übereinstimmt; dies wird <em>Filtern</em> genannt und wir werden dies im
Abschnitt <a href="ch11-02-running-tests.html#ausf%C3%BChren-einer-test-teilmenge-mittels-name">„Ausführen einer Test-Teilmenge mittels Name“</a> behandeln.
Außerdem haben wir die durchgeführten Tests nicht gefiltert, sodass am Ende der
Zusammenfassung <code>0 filtered out</code> steht.</p>
<p>Die Statistik <code>0 measured</code> ist für Benchmark-Tests, die die Performanz messen.
Benchmark-Tests sind zum Zeitpunkt, als dieser Text verfasst wurde, nur im
nächtlichen (nightly) Rust verfügbar. Siehe <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">„Dokumentation über
Benchmark-Tests“</a>, um mehr zu erfahren.</p>
<p>Der nächste Teil der Testausgabe, der mit <code>Doc-tests adder</code> beginnt, ist für
die Ergebnisse von Dokumentationstests. Wir haben noch keine
Dokumentationstests, aber Rust kann alle Code-Beispiele kompilieren, die in
unserer API-Dokumentation erscheinen. Diese Funktionalität hilft dabei,
deine Dokumentation und deinen Code synchron zu halten! Wie man
Dokumentationstests schreibt, werden wir im Abschnitt
<a href="ch14-02-publishing-to-crates-io.html#dokumentationskommentare-als-tests">„Dokumentationskommentare als Tests“</a> in Kapitel 14 besprechen.
Vorerst ignorieren wir die Ausgabe von <code>Doc-tests</code>.</p>
<p>Beginnen wir damit, den Test an unsere eigenen Bedürfnisse anzupassen. Ändere
zunächst den Namen der Funktion <code>it_works</code> in einen anderen Namen, z.B.
<code>exploration</code>, wie folgt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}</code></pre>
<p>Dann führe <code>cargo test</code> erneut aus. Die Ausgabe zeigt nun <code>exploration</code>
anstelle von <code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Fügen wir einen weiteren Test hinzu, aber dieses Mal machen wir einen Test, der
fehlschlägt! Tests schlagen fehl, wenn etwas die Testfunktion zum Abbrechen
bringt. Jeder Test wird in einem neuen Strang (thread) ausgeführt und wenn der
Hauptstrang (main thread) sieht, dass ein Teststrang (test thread) abgebrochen
wurde, wird der Test als fehlgeschlagen markiert. Über den einfachsten Weg, ein
Programm abzubrechen, sprachen wir in Kapitel 9, und zwar durch den Aufruf des
Makros <code>panic!</code>. Erstelle einen neuen Test <code>another</code>, sodass deine Datei
<em>src/lib.rs</em> wie in Codeblock 11-3 aussieht.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;Lasse diesen Test fehlschlagen&quot;);
    }
}</code></pre>
<p><span class="caption">Codeblock 11-3: Hinzufügen eines zweiten Tests, der
fehlschlägt, weil wir das Makro <code>panic!</code> aufrufen</span></p>
<p>Führe die Tests erneut mit <code>cargo test</code> aus. Die Ausgabe sollte wie in
Codeblock 11-4 aussehen, was zeigt, dass unser Test <code>exploration</code> bestanden und
<code>another</code> fehlgeschlagen ist.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at 'Lasse diesen Test fehlschlagen', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p><span class="caption">Codeblock 11-4: Testergebnisse, wenn ein Test bestanden
und ein Test nicht bestanden wird</span></p>
<p>Statt <code>ok</code> zeigt die Zeile <code>test tests::another</code> das Ergebnis <code>FAILED</code>.
Zwischen den Einzelergebnissen und der Zusammenfassung erscheinen zwei neue
Abschnitte: Der erste zeigt die detaillierte Ursache für jeden fehlgeschlagenen
Test an. In diesem Fall erhalten wir Details, dass <code>another</code> scheiterte mit der
Meldung <code>panicked at 'Lasse diesen Test fehlschlagen'</code> in Zeile 10 der Datei
<em>src/lib.rs</em>. Der nächste Abschnitt listet nur die Namen aller fehlgeschlagenen
Tests auf, was nützlich ist, wenn es viele Tests und viele detaillierte
Ausgaben von fehlgeschlagenen Tests gibt. Wir können den Namen eines
fehlgeschlagenen Tests verwenden, um genau diesen Test auszuführen, um ihn
leichter zu debuggen; wir werden im Abschnitt <a href="ch11-02-running-tests.html">„Steuern wie Tests ausgeführt
werden“</a> mehr über Möglichkeiten zur Ausführung
von Tests sprechen.</p>
<p>Die Zusammenfassungszeile zeigt am Ende an: Insgesamt ist unser Testergebnis
<code>FAILED</code>. Wir hatten einen Test bestanden und einen Test nicht bestanden.</p>
<p>Da du nun gesehen hast, wie die Testergebnisse in verschiedenen Szenarien
aussehen, wollen wir uns einige Makros neben <code>panic!</code> ansehen, die bei Tests
nützlich sind.</p>
<h3 id="ergebnisse-überprüfen-mit-dem-makro-assert"><a class="header" href="#ergebnisse-überprüfen-mit-dem-makro-assert">Ergebnisse überprüfen mit dem Makro <code>assert!</code></a></h3>
<p>Das Makro <code>assert!</code>, das von der Standardbibliothek bereitgestellt wird, ist
nützlich, wenn du sicherstellen willst, dass eine Bedingung in einem Test als
wahr (true) bewertet wird. Wir geben dem Makro <code>assert!</code> ein Argument, das
boolesch ausgewertet wird. Wenn der Wert <code>true</code> ist, passiert nichts und der
Test ist bestanden. Wenn der Wert <code>false</code> ist, ruft das Makro <code>assert!</code> das
Makro <code>panic!</code> auf, um den Test fehlschlagen zu lassen. Das Verwenden des
Makros <code>assert!</code> hilft uns zu überprüfen, ob unser Code so funktioniert, wie
wir es beabsichtigen.</p>
<p>In Codeblock 5-15 in Kapitel 5 haben wir eine Struktur <code>Rectangle</code> und eine
Methode <code>can_hold</code> verwendet, die hier in Codeblock 11-5 wiederholt werden.
Lass uns diesen Code in die Datei <em>src/lib.rs</em> packen und dann einige Tests
dafür mit dem Makro <code>assert!</code> schreiben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
<p><span class="caption">Codeblock 11-5: Verwenden der Struktur <code>Rectangle</code> und
ihrer Methode <code>can_hold</code> aus Kapitel 5</span></p>
<p>Die Methode <code>can_hold</code> gibt ein Boolean zurück, was bedeutet, dass es ein
perfekter Anwendungsfall für das Makro <code>assert!</code> ist. In Codeblock 11-6
schreiben wir einen Test, der die Methode <code>can_hold</code> überprüft, indem wir eine
<code>Rectangle</code>-Instanz mit einer Breite von 8 und einer Höhe von 7 erstellen und
sicherstellen, dass es eine weitere <code>Rectangle</code>-Instanz mit einer Breite von 5
und einer Höhe von 1 enthalten kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
<span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
<p><span class="caption">Codeblock 11-6: Ein Test für <code>can_hold</code>, der prüft, ob in
ein größeres Rechteck tatsächlich ein kleineres Rechteck passt</span></p>
<p>Beachte, dass wir eine neue Zeile innerhalb des Moduls <code>tests</code> hinzugefügt
haben: <code>use super::*;</code>. Das Modul <code>tests</code> ist ein reguläres Modul, das den
üblichen Sichtbarkeitsregeln folgt, die wir in Kapitel 7 im Abschnitt <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit
Pfaden auf ein Element im Modulbaum
verweisen“</a> behandelt haben.
Da das Modul <code>tests</code> ein inneres Modul ist, müssen wir den Code, der im äußeren
Modul getestet wird, in den Gültigkeitsbereich des inneren Moduls bringen. Wir
verwenden hier einen Stern (glob), sodass alles, was wir im äußeren Modul
definieren, auch in diesem Modul <code>tests</code> zur Verfügung steht.</p>
<p>Wir haben unseren Test <code>larger_can_hold_smaller</code> genannt und wir haben die
beiden <code>Rectangle</code>-Instanzen erzeugt, die wir benötigen. Dann haben wir das
Makro <code>assert!</code> aufgerufen und ihm das Aufrufergebnis von
<code>larger.can_hold(&amp;smaller)</code> übergeben. Dieser Ausdruck soll <code>true</code> zurückgeben,
also sollte unser Test erfolgreich sein. Lass es uns herausfinden!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Es funktioniert! Fügen wir noch einen weiteren Test hinzu, diesmal mit der
Zusicherung, dass ein kleineres Rechteck nicht in ein größeres Rechteck passt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --abschneiden--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>Da das korrekte Ergebnis der Funktion <code>can_hold</code> in diesem Fall <code>false</code> ist,
müssen wir dieses Ergebnis negieren, bevor wir es an das Makro <code>assert!</code>
übergeben. Als Ergebnis wird unser Test bestehen, wenn <code>can_hold</code> den
Rückgabewert <code>false</code> hat:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Zwei Tests, die erfolgreich sind! Nun wollen wir sehen, was mit unseren
Testergebnissen passiert, wenn wir einen Fehler in unseren Code einbringen.
Wir ändern die Implementierung der Methode <code>can_hold</code>, indem wir das
größer-als-Zeichen durch ein kleiner-als-Zeichen ersetzen, wenn sie die Breiten
vergleicht:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Das Ausführen der Tests ergibt nun Folgendes:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'main' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Unsere Tests haben den Fehler entdeckt! Da <code>larger.width</code> gleich 8 ist und
<code>smaller.width</code> gleich 5, ergibt der Vergleich der Breiten in <code>can_hold</code> jetzt
<code>false</code>: 8 ist nicht weniger als 5.</p>
<h3 id="prüfung-auf-gleichheit-mit-den-makros-assert_eq-und-assert_ne"><a class="header" href="#prüfung-auf-gleichheit-mit-den-makros-assert_eq-und-assert_ne">Prüfung auf Gleichheit mit den Makros <code>assert_eq!</code> und <code>assert_ne!</code></a></h3>
<p>Eine übliche Methode zum Verifizieren von Funktionalität besteht darin, das
Ergebnis des zu testenden Codes auf Gleichheit mit dem Wert zu testen, den du
vom Code erwartest, um sicherzustellen. Du könntest dies mit dem Makro
<code>assert!</code> tun und ihm einen Ausdruck mit dem Operator <code>==</code> übergeben. Dies ist
jedoch ein so häufiger Testfall, dass die Standardbibliothek zwei Makros zur
Verfügung stellt, um diesen Test bequemer durchzuführen: <code>assert_eq!</code> und
<code>assert_ne!</code>. Diese Makros vergleichen zwei Argumente auf Gleichheit bzw.
Ungleichheit. Sie geben auch die beiden Werte aus, wenn die Zusicherung
fehlschlägt, was es einfacher macht zu erkennen, <em>warum</em> der Test
fehlgeschlagen ist; umgekehrt zeigt das Makro <code>assert!</code> nur an, dass der
Ausdruck <code>==</code> den Wert <code>false</code> ergeben hat, ohne die Werte auszugeben, die zum
falschen Testergebnis geführt haben.</p>
<p>In Codeblock 11-7 schreiben wir eine Funktion namens <code>add_two</code>, die zu ihrem
Parameter <code>2</code> addiert, dann testen wir diese Funktion mit dem Makro
<code>assert_eq!</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}</code></pre>
<p><span class="caption">Codeblock 11-7: Testen der Funktion <code>add_two</code> mit dem
Makro <code>assert_eq!</code></span></p>
<p>Lass uns prüfen, ob sie den Test besteht!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Wir übergeben <code>4</code> als Argument an <code>assert_eq!</code>, was identisch mit dem Ergebnis
des Aufrufs <code>add_two(2)</code> ist. Die Zeile für diesen Test
lautet <code>test tests::it_adds_two ... ok</code>, und der Text <code>ok</code> zeigt an, dass unser
Test bestanden wurde!</p>
<p>Lass uns einen Fehler in unseren Code einbringen, um zu sehen, wie <code>assert_eq!</code>
aussieht, wenn es fehlschlägt. Ändern wir die Implementierung der Funktion
<code>add_two</code>, sodass sie stattdessen <code>3</code> addiert:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}

<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        assert_eq!(4, add_two(2));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Führe die Tests erneut aus:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Unser Test hat den Fehler entdeckt! Der Test <code>it_adds_two</code> schlug fehl und die
Meldung sagt uns, dass die fehlgeschlagene Zusicherung <code>assertion failed: `(left == right)` </code> war und welche Werte <code>left</code> und <code>right</code> hatten. Diese
Nachricht hilft uns, mit der Fehlersuche zu beginnen: Das Argument <code>left</code> war
<code>4</code>, aber das Argument <code>right</code> mit dem Ergebnis von <code>add_two(2)</code> war <code>5</code>. Du
kannst dir vorstellen, dass dies besonders hilfreich ist, wenn wir viele Tests
durchführen.</p>
<p>Beachte, dass in einigen Sprachen und Test-Bibliotheken die Parameter der
Gleichheitszusicherung <code>expected</code> und <code>actual</code> genannt werden und deren
Reihenfolge wichtig ist. In Rust werden sie jedoch <code>left</code> und <code>right</code> genannt
und die Reihenfolge, in der wir den erwarteten Wert und den vom Code
produzierten Wert angeben, spielt keine Rolle. Wir könnten die Zusicherung in
diesem Test als <code>assert_eq!(add_two(2), 4)</code> schreiben, was zur gleichen
Fehlermeldung <code>assertion failed: `(left == right)` </code> führen würde.</p>
<p>Das Makro <code>assert_ne!</code> prüft, ob die beiden Werte, die wir ihm übergeben,
ungleich sind und scheitert, wenn sie gleich sind. Dieses Makro ist am
nützlichsten in Fällen, in denen wir nicht sicher sind, <em>welchen</em> Wert wir
bekommen werden, aber wir wissen, welcher Wert es definitiv <em>nicht</em> sein sollte.
Wenn wir zum Beispiel eine Funktion testen, die ihre Eingabe garantiert in
irgendeiner Weise verändert, aber die Art und Weise, wie die Eingabe verändert
wird, vom Wochentag abhängt, an dem wir unsere Tests ausführen, ist es
vielleicht am besten sicherzustellen, dass die Ausgabe der Funktion nicht
gleich der Eingabe ist.</p>
<p>Unter der Haube verwenden die Makros <code>assert_eq!</code> und <code>assert_ne!</code> die
Operatoren <code>==</code> bzw. <code>!=</code>. Wenn die Zusicherungen fehlschlagen, geben diese
Makros ihre Argumente unter Verwendung der Debug-Formatierung aus, was
bedeutet, dass die zu vergleichenden Werte die Merkmale <code>PartialEq</code> und
<code>Debug</code> implementieren müssen. Alle primitiven Typen und die meisten
Standardbibliothekstypen implementieren diese Merkmale. Für Strukturen und
Aufzählungen, die du definierst, musst du <code>PartialEq</code> implementieren, um
die Gleichheit dieser Typen sicherzustellen. Du musst auch <code>Debug</code>
implementieren, um die Werte auszugeben, wenn die Zusicherung fehlschlägt. Da
es sich bei beiden Merkmalen um ableitbare Merkmale handelt, wie in Codeblock
5-12 in Kapitel 5 erwähnt, genügt normalerweise das Ergänzen der Annotation
<code>#[derive(PartialEq, Debug)]</code> bei deiner Struktur- und Aufzählungsdefinition.
Siehe Anhang C <a href="appendix-03-derivable-traits.html">„Ableitbare Merkmale (traits)“</a> für weitere
Einzelheiten über diese und andere ableitbare Merkmale.</p>
<h3 id="benutzerdefinierte-fehlermeldungen-angeben"><a class="header" href="#benutzerdefinierte-fehlermeldungen-angeben">Benutzerdefinierte Fehlermeldungen angeben</a></h3>
<p>Du kannst den Makros <code>assert!</code>, <code>assert_eq!</code> und <code>assert_ne!</code> optional auch
eine benutzerdefinierte Nachricht mitgeben, die mit der Fehlermeldungen
ausgegeben wird. Alle Argumente, die nach den erforderlichen Argumenten
angegeben werden, werden an das Makro <code>format!</code> übergeben (siehe Kapitel 8,
Abschnitt <a href="ch08-02-strings.html#aneinanderh%C3%A4ngen-mit-dem-operator--und-dem-makro-format">„Aneinanderhängen mit dem Operator <code>+</code> und dem Makro
<code>format!</code>“</a>), sodass du
eine Formatierungs-Zeichenkette übergeben kannst, die Platzhalter <code>{}</code> und
Werte enthält, die in diese Platzhalter gehören. Benutzerdefinierte Nachrichten
sind nützlich, um zu dokumentieren, was eine Zusicherung bedeutet; wenn ein
Test fehlschlägt, hast du eine bessere Vorstellung davon, wo das Problem im
Code liegt.</p>
<p>Nehmen wir zum Beispiel an, wir haben eine Funktion, die Leute mit Namen
begrüßt, und wir wollen testen, ob der Name, den wir an die Funktion übergeben,
in der Ausgabe auftaucht:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hallo {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}</code></pre>
<p>Die Anforderungen für dieses Programm sind noch nicht abgestimmt worden und wir
sind ziemlich sicher, dass sich der Text <code>Hallo</code> zu Beginn der Begrüßung ändern
wird. Wir haben beschlossen, dass wir den Test nicht aktualisieren wollen, wenn
sich die Anforderungen ändern. Anstatt also zu prüfen, ob der Test exakt dem
von der Funktion <code>greeting</code> zurückgegebenen Wert entspricht, stellen wir
einfach sicher, dass die Ausgabe den Text des Eingabeparameters enthält.</p>
<p>Lass uns nun einen Fehler in diesen Code einbringen, indem wir <code>greeting</code> so
ändern, dass <code>name</code> nicht enthalten ist, um zu sehen, wie das
Standard-Testversagen aussieht:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hallo!&quot;)
}

<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting(&quot;Carol&quot;);
</span><span class="boring">        assert!(result.contains(&quot;Carol&quot;));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Das Ausführen dieses Tests führt zu folgender Ausgabe:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'assertion failed: result.contains(&quot;Carol&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Dieses Ergebnis zeigt nur an, dass die Zusicherung fehlgeschlagen ist und in
welcher Zeile die Zusicherung steht. Eine nützlichere Fehlermeldung würde den
Wert der Funktion <code>greeting</code> ausgeben. Fügen wir eine benutzerdefinierte
Fehlermeldung hinzu, die aus einer Formatierungszeichenkette mit einem
Platzhalter besteht, der mit dem tatsächlichen Wert aus der Funktion <code>greeting</code>
gefüllt ist:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Hallo!&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(
            result.contains(&quot;Carol&quot;),
            &quot;Begrüßung enthielt nicht den Namen, Wert war `{}`&quot;,
            result
        );
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Wenn wir jetzt den Test ausführen, erhalten wir eine aussagekräftigere
Fehlermeldung:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'Begrüßung enthielt nicht den Namen, Wert war `Hallo!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Wir können den Wert, den wir tatsächlich erhalten haben, in der Testausgabe
sehen, was uns helfen wird, das zu debuggen, was passiert ist, anstatt das,
was wir erwartet hatten.</p>
<h3 id="mit-should_panic-auf-programmabbrüche-prüfen"><a class="header" href="#mit-should_panic-auf-programmabbrüche-prüfen">Mit <code>should_panic</code> auf Programmabbrüche prüfen</a></h3>
<p>Neben der Prüfung von Rückgabewerten ist es auch wichtig zu prüfen, ob unser
Code Fehlerbedingungen so behandelt, wie wir es erwarten. Denke zum Beispiel an
den Typ <code>Guess</code>, den wir in Kapitel 9 in Codeblock 9-13 erstellt haben. Anderer
Code, der <code>Guess</code> verwendet, hängt von der Garantie ab, dass <code>Guess</code>-Instanzen
nur Werte zwischen 1 und 100 enthalten. Wir können einen Test schreiben, der
sicherstellt, dass der Versuch, eine <code>Guess</code>-Instanz mit einem Wert außerhalb
dieses Bereichs zu erzeugen, zum Programmabbrucht führt.</p>
<p>Wir tun dies, indem wir das Attribut <code>should_panic</code> zu unserer Testfunktion
hinzufügen. Der Test gilt als bestanden, wenn der Code innerhalb der Funktion
abbricht; der Test schlägt fehl, wenn der Code innerhalb der Funktion nicht
abbricht.</p>
<p>Codeblock 11-8 zeigt einen Test, der prüft, ob die Fehlerbedingungen von
<code>Guess::new</code> eintreten, wenn wir dies erwarten.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Schätzwert muss zwischen 1 und 100 liegen, ist {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<p><span class="caption">Codeblock 11-8: Testet, dass eine Bedingung zum
Programmabbruch führt</span></p>
<p>Wir setzen das Attribut <code>#[should_panic]</code> hinter das Attribut <code>#[test]</code> und vor
die Testfunktion, auf die sie sich bezieht. Schauen wir uns das Ergebnis an,
wenn dieser Test bestanden ist:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Sieht gut aus! Lass uns nun einen Fehler in unseren Code einbringen, indem wir
die Bedingung entfernen, bei der die Funktion <code>new</code> das Programm abbricht, wenn
der Wert größer als 100 ist:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Schätzwert muss zwischen 1 und 100 liegen, ist {}.&quot;, value);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Wenn wir den Test in Codeblock 11-8 ausführen, wird er fehlschlagen:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Wir erhalten in diesem Fall keine sehr hilfreiche Meldung, aber wenn wir uns
die Testfunktion ansehen, sehen wir, dass sie mit <code>#[should_panic]</code> annotiert
ist. Der Fehler, den wir erhielten, bedeutet, dass der Code in der Testfunktion
keinen Programmabbruch verursacht hat.</p>
<p>Tests, die <code>should_panic</code> verwenden, können ungenau sein. Ein Test mit
<code>should_panic</code> würde auch dann bestanden werden, wenn der Test aus einem
anderen Grund zum Programmabbrucht führt als dem, den wir erwartet haben. Um
Tests mit <code>should_panic</code> präziser zu machen, können wir beim
<code>should_panic</code>-Attribut einen optionalen Parameter <code>expected</code> ergänzen. Das
Testsystem stellt sicher, dass die Fehlermeldung den angegebenen Text enthält.
Betrachte zum Beispiel den modifizierten Code für <code>Guess</code> in Codeblock 11-9, wo
die Funktion <code>new</code> mit unterschiedlichen Meldungen das Programm abbricht, je
nachdem, ob der Wert zu klein oder zu groß ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Schätzwert muss größer oder gleich 1 sein, ist {}.&quot;, value);
        } else if value &gt; 100 {
            panic!(&quot;Schätzwert muss kleiner oder gleich 100 sein, ist {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Schätzwert muss kleiner oder gleich 100 sein&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<p><span class="caption">Codeblock 11-9: Testen eines Programmabbruchs mit einer
bestimmten Teilzeichenkette in der Meldung</span></p>
<p>Dieser Test wird bestanden werden, weil der Wert, den wir beim Parameter
<code>expected</code> des <code>should_panic</code>-Attributs angeben, eine Teilzeichenkette der
Nachricht ist, mit der die Funktion <code>Guess::new</code> das Programm abbricht. Wir
hätten die gesamte erwartete Abbruchsnachricht angeben können, in diesem Fall
also <code>Schätzwert muss kleiner oder gleich 100 sein, ist 200</code>. Was du angibst,
hängt davon ab, wie viel von der Abbruchsnachricht eindeutig oder dynamisch ist
und wie präzise dein Test sein soll. In diesem Fall reicht eine
Teilzeichenkette der Abbruchsnachricht aus, um sicherzustellen, dass der Code
in der Testfunktion den Fall <code>else if value &gt; 100</code> ausführt.</p>
<p>Um zu sehen, was passiert, wenn ein Test mit <code>should_panic</code> und einer
<code>expected</code>-Nachricht fehlschlägt, wollen wir wieder einen Fehler in unseren
Code einbringen, indem wir die Zweige <code>if value &lt; 1</code>  und <code>else if value &gt; 100</code>
vertauschen:</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(&quot;Schätzwert muss kleiner oder gleich 100 sein, ist {}.&quot;,
                   value);
        } else if value &gt; 100 {
            panic!(&quot;Schätzwert muss größer oder gleich 1 sein, ist {}.&quot;,
                   value);
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Wenn wir diesmal den <code>should_panic</code>-Test ausführen, wird er fehlschlagen:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'main' panicked at 'Schätzwert muss größer oder gleich 1 sein, ist 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;Schätzwert muss größer oder gleich 1 sein, ist 200.&quot;`,
 expected substring: `&quot;Schätzwert muss kleiner oder gleich 100 sein&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Die Fehlermeldung zeigt an, dass dieser Test tatsächlich wie erwartet das
Programm abgebrochen hat, aber die Abbruchsmeldung enthielt nicht die erwartete
Zeichenfolge <code>'Schätzwert muss kleiner oder gleich 100 sein'</code>. Die
Abbruchsmeldung, die wir in diesem Fall erhielten, lautete: <code>Schätzwert muss größer oder gleich 1 sein, ist 200.</code> Jetzt können wir anfangen herauszufinden,
wo unser Fehler liegt!</p>
<h3 id="verwenden-von-resultt-e-in-tests"><a class="header" href="#verwenden-von-resultt-e-in-tests">Verwenden von <code>Result&lt;T, E&gt;</code> in Tests</a></h3>
<p>Bei unseren bisherigen Tests sind alle abgebrochen, wenn sie fehlgeschlagen
sind. Wir können auch Tests schreiben, die <code>Result&lt;T, E&gt;</code> verwenden! Hier ist
der Test aus Codeblock 11-1 so umgeschrieben, dass er <code>Result&lt;T, E&gt;</code> verwendet
und <code>Err</code> zurückgibt, anstatt das Programm abzubrechen:</p>
<pre><code class="language-rust noplayground"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;zwei plus zwei ist nicht gleich vier&quot;))
        }
    }
}</code></pre>
<p>Die Funktion <code>it_works</code> hat jetzt den Rückgabetyp <code>Result&lt;(), String&gt;</code>. Anstatt
das Makro <code>assert_eq!</code> aufzurufen, geben wir im Funktionsrumpf <code>Ok(())</code> zurück,
wenn der Test bestanden ist, und ein <code>Err</code> mit einem <code>String</code> im Inneren, wenn
der Test fehlschlägt.</p>
<p>Wenn du Tests so schreibst, dass sie ein <code>Result&lt;T, E&gt;</code> zurückgeben, kannst du
den Fragezeichen-Operator im Testrumpf verwenden, was eine bequeme Möglichkeit
sein kann, Tests zu schreiben, die fehlschlagen sollten, wenn irgendeine
Operation darin eine <code>Err</code>-Variante zurückgibt.</p>
<p>Du kannst die Annotation <code>#[should_panic]</code> nicht für Tests verwenden, die
<code>Result&lt;T, E&gt;</code> verwenden. Um sicherzustellen, dass eine Operation eine
<code>Err</code>-Variante zurückgibt, verwende <em>nicht</em> den Fragezeichen-Operator auf den
<code>Result&lt;T, E&gt;</code>-Wert. Verwende stattdessen <code>assert!(value.is_err())</code>.</p>
<p>Da du nun verschiedene Möglichkeiten kennst, Tests zu schreiben, lass uns einen
Blick darauf werfen, was passiert, wenn wir unsere Tests ausführen, und die
verschiedenen Optionen untersuchen, die wir mit <code>cargo test</code> verwenden können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="steuern-wie-tests-ausgeführt-werden"><a class="header" href="#steuern-wie-tests-ausgeführt-werden">Steuern wie Tests ausgeführt werden</a></h2>
<p>So wie <code>cargo run</code> deinen Code kompiliert und dann die resultierende Binärdatei
ausführt, kompiliert <code>cargo test</code> deinen Code im Testmodus und führt die
resultierende Testbinärdatei aus. Das Standardverhalten der von <code>cargo test</code>
erzeugten Binärdatei besteht darin, alle Tests parallel auszuführen und die
während der Testläufe generierte Ausgabe zu erfassen, wodurch verhindert wird,
dass die Ausgabe angezeigt wird, und das Lesen der Ausgabe bezüglich der
Testergebnisse erleichtert wird. Du kannst jedoch Kommandozeilen-Optionen
angeben, um dieses Standardverhalten zu ändern.</p>
<p>Einige Kommandozeilen-Optionen betreffen <code>cargo test</code> und einige betreffen die
resultierende Testbinärdatei. Um diese beiden Argumentarten
auseinanderzuhalten, gibst du zuerst die Argumente für <code>cargo test</code>, gefolgt
vom Trennzeichen <code>--</code>, und danach die der Testbinärdatei an. Wenn du <code>cargo test --help</code> ausführst, werden die Optionen angezeigt, die du für <code>cargo test</code>
verwenden kannst, und wenn du <code>cargo test -- --help</code> ausführst, werden die
Optionen angezeigt, die du nach dem Trennzeichen verwenden kannst.</p>
<h3 id="tests-parallel-oder-nacheinander-ausführen"><a class="header" href="#tests-parallel-oder-nacheinander-ausführen">Tests parallel oder nacheinander ausführen</a></h3>
<p>Wenn du mehrere Tests ausführst, werden diese standardmäßig parallel in
Strängen (threads) ausgeführt, das bedeutet, dass die Tests schneller
abgeschlossen werden und du schneller Rückmeldung erhältst. Da die Tests
gleichzeitig ausgeführt werden, musst du sicherstellen, dass deine Tests nicht
voneinander oder von einem gemeinsam genutzten Zustand abhängen, einschließlich
einer gemeinsam genutzten Umgebung, z.B. dem aktuellen Arbeitsverzeichnis oder
Umgebungsvariablen.</p>
<p>Angenommen, jeder deiner Tests führt einen Code aus, der eine Datei auf der
Festplatte mit dem Namen <em>test-output.txt</em> erstellt und einige Daten in diese
Datei schreibt. Dann liest jeder Test Daten aus dieser Datei und stellt fest,
dass die Datei einen bestimmten Wert enthält, der bei jedem Test anders ist. Da
die Tests zur gleichen Zeit laufen, kann es vorkommen, dass ein Test die Datei
überschreibt, während ein anderer Test die Datei schreibt und liest. Der zweite
Test wird dann fehlschlagen, nicht weil der Code falsch ist, sondern weil sich
die Tests bei der parallelen Ausführung gegenseitig beeinflusst haben. Eine
Lösung besteht darin, dafür zu sorgen, dass jeder Test in eine eigene Datei
schreibt; eine andere Lösung besteht darin, die Tests einzeln nacheinander
auszuführen.</p>
<p>Wenn du die Tests nicht parallel ausführen möchtest oder wenn du eine
feingranularere Kontrolle über die Anzahl der verwendeten Stränge haben willst,
kannst du den Schalter <code>--test-threads</code> mit der Anzahl der Stränge, die du
verwenden möchtest, an die Testbinärdatei übergeben. Sieh dir das folgende
Beispiel an:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>Wir setzen die Anzahl der Teststränge auf <code>1</code> und weisen das Programm an, keine
Parallelität zu verwenden. Die Ausführung der Tests mit einem Strang dauert
länger als die parallele Ausführung, aber die Tests stören sich nicht
gegenseitig, wenn sie den gleichen Zustand verwenden.</p>
<h3 id="anzeigen-der-funktionsausgabe"><a class="header" href="#anzeigen-der-funktionsausgabe">Anzeigen der Funktionsausgabe</a></h3>
<p>Standardmäßig erfasst die Testbibliothek von Rust bei einem bestandenen Test
alles, was in die Standardausgabe ausgegeben wurde. Wenn wir beispielsweise
<code>println!</code> in einem Test aufrufen und der Test erfolgreich ist, sehen wir die
Ausgabe von <code>println!</code> im Terminal nicht; wir sehen nur die Zeile, die den
bestandenen Test anzeigt. Wenn ein Test fehlschlägt, sehen wir das, was in die
Standardausgabe ausgegeben wurde, mit dem Rest der Fehlermeldung.</p>
<p>Als Beispiel hat Codebock 11-10 eine dumme Funktion, die den Wert ihres
Parameters ausgibt und 10 zurückgibt, sowie einen Test, der bestanden wird, und
einen Test, der fehlschlägt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground"><span class="boring">fn main() {}
</span><span class="boring">
</span>fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;Ich habe den Wert {} erhalten.&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}</code></pre>
<p><span class="caption">Codebock 11-10: Tests einer Funktion, die <code>println!</code>
aufruft</span></p>
<p>Wenn wir diese Tests mit <code>cargo test</code> ausführen, werden wir folgende Ausgabe
sehen:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
Ich habe den Wert 8 erhalten.
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Beachte, dass wir nirgendwo in dieser Ausgabe <code>Ich habe den Wert 4 erhalten.</code>
sehen, was beim erfolgreichen Testlauf ausgegeben wird. Diese Ausgabe wurde
aufgefangen. Die Ausgabe <code>Ich habe den Wert 8 erhalten.</code> des fehlgeschlagenen
Tests erscheint im Abschnitt der Testzusammenfassung, der auch die Ursache des
Testfehlers anzeigt.</p>
<p>Wenn wir auch die ausgegebenen Werte der bestandenen Tests sehen wollen, können
wir Rust mit <code>--show-output</code> anweisen, die Ausgabe erfolgreicher Tests mit
anzuzeigen.</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>Wenn wir die Tests in Codeblock 11-10 mit dem Schalter <code>--show-output</code> erneut
ausführen, sehen wir folgende Ausgabe:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
Ich habe den Wert 4 erhalten.

successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
Ich habe den Wert 8 erhalten.
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<h3 id="ausführen-einer-test-teilmenge-mittels-name"><a class="header" href="#ausführen-einer-test-teilmenge-mittels-name">Ausführen einer Test-Teilmenge mittels Name</a></h3>
<p>Manchmal kann die Ausführung einer vollständigen Testsammlung sehr lange
dauern. Wenn du an Code in einem bestimmten Bereich arbeitest, solltest du
vielleicht nur die Tests ausführen, die diesen Code betreffen. Du kannst
wählen, welche Tests ausgeführt werden sollen, indem du <code>cargo test</code> den oder
die Namen der Tests, die du ausführen willst, als Argument übergibst.</p>
<p>Um zu demonstrieren, wie man eine Teilmenge von Tests ausführt, werden wir
zuerst drei Tests für unsere Funktion <code>add_two</code> erstellen, wie in Codeblock
11-11 zu sehen ist, und auswählen, welche wir ausführen wollen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 11-11: Drei Tests mit drei verschiedenen
Namen</span></p>
<p>Wenn wir die Tests ohne Argumente durchführen, wie vorhin gesehen, werden alle
Tests parallel laufen:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h4 id="ausführen-einzelner-tests"><a class="header" href="#ausführen-einzelner-tests">Ausführen einzelner Tests</a></h4>
<p>Wir können den Namen einer beliebigen Testfunktion an <code>cargo test</code> übergeben,
um nur diesen Test auszuführen:</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>Nur der Test mit dem Namen <code>one_hundred</code> lief; die beiden anderen Tests passten
nicht zu diesem Namen. Die Testausgabe lässt uns wissen, dass wir mehrere Tests
hatten, als dieser Befehl ausgeführt wurde, indem am Ende der
Zusammenfassungszeile <code>2 filtered out</code> angezeigt wird.</p>
<p>Wir können die Namen mehrerer Tests nicht auf diese Weise angeben; es wird nur
der erste Wert verwendet, der bei <code>cargo test</code> angegeben wird. Aber es gibt
eine Möglichkeit, mehrere Tests auszuführen.</p>
<h4 id="filtern-um-mehrerer-tests-auszuführen"><a class="header" href="#filtern-um-mehrerer-tests-auszuführen">Filtern um mehrerer Tests auszuführen</a></h4>
<p>Wir können einen Teil eines Testnamens angeben und jeder Test, dessen Name zu
diesem Wert passt, wird ausgeführt. Da zum Beispiel zwei der Namen unserer
Tests <code>add</code> enthalten, können wir diese beiden Tests ausführen, indem wir
<code>cargo test add</code> ausführen:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>Dieser Befehl führte alle Tests mit <code>add</code> im Namen aus und filterte den Test
mit dem Namen <code>one_hundred</code> heraus. Beachte auch, dass das Modul, in dem sich
ein Test befindet, Teil des Testnamens wird, sodass wir alle Tests in einem
Modul ausführen können, indem wir nach dem Namen des Moduls filtern.</p>
<h3 id="tests-ignorieren-die-nicht-ausdrücklich-verlangt-werden"><a class="header" href="#tests-ignorieren-die-nicht-ausdrücklich-verlangt-werden">Tests ignorieren, die nicht ausdrücklich verlangt werden</a></h3>
<p>Manchmal kann die Ausführung einiger spezifischer Tests sehr zeitaufwendig
sein, sodass du diese bei den meisten <code>cargo test</code>-Aufrufen ausschließen
solltest. Anstatt alle Tests, die du ausführen möchtest, als Argumente
aufzulisten, kannst du die zeitaufwendigen Tests stattdessen mit dem Attribut
<code>ignore</code> annotieren, um sie auszuschließen, wie hier gezeigt: </p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // Code, dessen Ausführung eine Stunde dauert
}</code></pre>
<p>Unterhalb <code>#[test]</code> fügen wir die Zeile <code>#[ignore]</code> beim Test ein, den wir
ausschließen wollen. Wenn wir nun unsere Tests ausführen, läuft <code>it_works</code>,
aber <code>expensive_test</code> nicht:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Die Funktion <code>expensive_test</code> wird als <code>ignored</code> aufgeführt. Wenn wir nur die
ignorierten Tests ausführen wollen, können wir <code>cargo test -- --ignored</code>
angeben:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Indem du kontrollierst, welche Tests durchgeführt werden, kannst du
sicherstellen, dass dein <code>cargo test</code>-Aufruf schnell zu Ergebnissen führt. Wenn
du an einem Punkt angelangt bist, an dem es sinnvoll ist, die Ergebnisse der
<code>ignored</code>-Tests zu überprüfen, und du Zeit hast, auf die Ergebnisse zu warten,
kannst du stattdessen <code>cargo test -- --ignored</code> ausführen. Wenn du alle Tests
ausführen willst, egal ob sie ignoriert werden oder nicht, kannst du <code>cargo test -- --include-ignored</code> ausführen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="testverwaltung"><a class="header" href="#testverwaltung">Testverwaltung</a></h2>
<p>Wie zu Beginn des Kapitels erwähnt, ist das Testen eine komplexe Disziplin, und
verschiedene Personen verwenden unterschiedliche Terminologien und
Organisationen. Die Rust-Gemeinschaft teilt Tests in zwei Hauptkategorien ein:
Modultests und Integrationstests. <em>Modultests</em> (unit tests) sind klein und
zielgerichteter, testen jeweils ein Modul isoliert und können private
Schnittstellen testen. <em>Integrationstests</em> (integration tests) sind völlig
außerhalb deiner Bibliothek und verwenden deinen Code auf die gleiche Weise wie
jeder andere externe Code, wobei nur die öffentliche Schnittstelle verwendet
wird und möglicherweise mehrere Module pro Test ausgeführt werden.</p>
<p>Es ist wichtig, beide Testarten zu schreiben, um sicherzustellen, dass die
Teile deiner Bibliothek einzeln und zusammen das tun, was du von ihnen
erwartest.</p>
<h3 id="modultests"><a class="header" href="#modultests">Modultests</a></h3>
<p>Der Zweck von Modultests besteht darin, jede Code-Einheit isoliert vom Rest des
Codes zu testen, um schnell herauszufinden, welcher Code wie erwartet
funktioniert und welcher nicht. Modultests befinden sich im Verzeichnis <em>src</em>
in den Quellcodedateien, den sie testen. Die Konvention besteht darin, in jeder
Datei ein Modul namens <code>tests</code> zu erstellen, das die Testfunktionen enthält,
und das Modul mit <code>cfg(test)</code> zu annotieren.</p>
<h4 id="das-testmodul-und-cfgtest"><a class="header" href="#das-testmodul-und-cfgtest">Das Testmodul und <code>#[cfg(test)]</code></a></h4>
<p>Die Annotation <code>#[cfg(test)]</code> am Testmodul weist Rust an, den Testcode nur dann
zu kompilieren und auszuführen, wenn du <code>cargo test</code> ausführst, nicht aber,
wenn du <code>cargo build</code> ausführst. Dies spart Kompilierzeit, wenn du nur die
Bibliothek erstellen möchtest, und spart Platz im resultierenden, kompilierten
Artefakt, da die Tests nicht enthalten sind. Du wirst feststellen, dass
Integrationstests die Annotation <code>#[cfg(test)]</code> nicht benötigen, weil sie in
einem anderen Verzeichnis liegen. Da Modultests jedoch in den gleichen Dateien
wie der Code sind, wirst du <code>#[cfg(test)]</code> verwenden, um anzugeben, dass sie
nicht im kompilierten Ergebnis enthalten sein sollen.</p>
<p>Erinnere dich daran, dass Cargo diesen Code für uns generiert hat, als wir das
neue Projekt <code>adder</code> im ersten Abschnitt dieses Kapitels erstellt haben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Dieser Code ist das automatisch generierte Testmodul. Das Attribut <code>cfg</code> steht
für <em>Konfiguration</em> und teilt Rust mit, dass das folgende Element nur bei einer
bestimmten Konfigurationsoption eingebunden werden soll. In diesem Fall ist die
Konfigurationsoption <code>test</code>, die von Rust beim Kompilieren und Ausführen von
Tests verwendet wird. Durch das Verwenden des Attributs <code>cfg</code> kompiliert Cargo
unseren Testcode nur dann, wenn wir die Tests aktiv mit <code>cargo test</code> ausführen.
Dies schließt alle Hilfsfunktionen ein, die sich innerhalb dieses Moduls
befinden könnten, zusätzlich zu den mit <code>#[test]</code> annotierten Funktionen.</p>
<h4 id="testen-privater-funktionen"><a class="header" href="#testen-privater-funktionen">Testen privater Funktionen</a></h4>
<p>In der Testgemeinschaft wird darüber diskutiert, ob private Funktionen direkt
getestet werden sollten oder nicht, und andere Sprachen machen es schwierig
oder gar unmöglich, private Funktionen zu testen. Unabhängig davon, an welcher
Testideologie du festhältst, erlauben dir Rusts Datenschutzregeln, private
Funktionen zu testen. Betrachte den Code in Codeblock 11-12 mit der privaten
Funktion <code>internal_adder</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}</code></pre>
<p><span class="caption">Codeblock 11-12: Testen einer privaten Funktion</span></p>
<p>Beachte, dass die Funktion <code>internal_adder</code> nicht mit <code>pub</code> markiert ist. Tests
sind einfach nur Rust-Code, und das Modul <code>tests</code> ist nur ein weiteres Modul.
Wie im Abschnitt <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit Pfaden auf ein Element im Modulbaum verweisen“</a>
beschrieben, können Elemente in Kind-Modulen die Elemente ihrer Eltern-Module
verwenden. In diesem Test bringen wir alle Elemente des Eltern-Moduls von
<code>test</code> mit <code>use super::*</code> in den Gültigkeitsbereich, und dann kann der Test
<code>internal_adder</code> aufrufen. Wenn du der Meinung bist, dass private Funktionen
nicht getestet werden sollten, gibt es in Rust nichts, was dich dazu zwingen
würde.</p>
<h3 id="integrationstests"><a class="header" href="#integrationstests">Integrationstests</a></h3>
<p>In Rust sind Integrationstests völlig außerhalb deiner Bibliothek angesiedelt.
Du verwendest deine Bibliothek auf die gleiche Weise wie jeder andere Code,
d.h. es können nur Funktionen aufgerufen werden, die Teil der öffentlichen
Programmierschnittstelle (API) deiner Bibliothek sind. Ihr Zweck ist es, zu
testen, ob viele Teile deiner Bibliothek korrekt zusammenarbeiten.
Code-Einheiten, die alleine korrekt funktionieren, könnten Probleme nach deren
Integration haben, daher ist auch die Testabdeckung des integrierten Codes
wichtig. Um Integrationstests zu erstellen, benötigst du zunächst ein
Verzeichnis <em>tests</em>.</p>
<h4 id="das-verzeichnis-tests"><a class="header" href="#das-verzeichnis-tests">Das Verzeichnis <em>tests</em></a></h4>
<p>Wir erstellen ein Verzeichnis <em>tests</em> auf der obersten Ebene unseres
Projektverzeichnisses, neben <em>src</em>. Cargo weiß, dass es in diesem Verzeichnis
nach Integrationstestdateien suchen soll. Wir können dann so viele Testdateien
erstellen, wie wir wollen, und Cargo wird jede dieser Dateien als eine
individuelle Kiste (crate) kompilieren.</p>
<p>Lass uns einen Integrationstest erstellen. Wenn sich der Code in Codeblock
11-12 noch in der Datei <em>src/lib.rs</em> befindet, erstelle ein Verzeichnis
<em>tests</em> und eine neue Datei mit dem Namen <em>tests/integration_test.rs</em>. Deine
Verzeichnisstruktur sollte folgendermaßen aussehen:</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>Gib den Code in Codeblock 11-13 in die Datei <em>tests/integration_test.rs</em> ein:</p>
<p><span class="filename">Dateiname: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}</code></pre>
<p><span class="caption">Codeblock 11-13: Integrationstest einer Funktion in der
Kiste <code>adder</code></span></p>
<p>Jede Datei im Verzeichnis <code>tests</code> ist eine separate Kiste, also müssen wir
unsere Bibliothek in den Gültigkeitsbereich jeder Test-Kiste bringen. Aus
diesem Grund fügen wir <code>use adder</code> am Anfang des Codes hinzu, was wir in den
Modultests nicht brauchten.</p>
<p>Wir brauchen den Code in <em>tests/integration_test.rs</em> nicht mit <code>#[cfg(test)]</code>
zu annotieren. Cargo behandelt das Verzeichnis <code>tests</code> speziell und kompiliert
Dateien in diesem Verzeichnis nur dann, wenn wir <code>cargo test</code> ausführen. Führe
<code>cargo test</code> jetzt aus:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.73s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running unittests (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Die drei Abschnitte der Ausgabe umfassen die Modultests, den Integrationstest
und die Dokumentationstests. Beachte, wenn ein Test in einem Abschnitt
fehlschlägt, dann werden die folgenden Abschnitte nicht ausgeführt. Wenn zum
Beispiel ein Modultest fehlschlägt, gibt es keine Ausgabe für Integrations- und
Dokumentations-Tests, da diese Tests nur ausgeführt werden, wenn alle
Modultests erfolgreich sind.</p>
<p>Der erste Abschnitt für die Modultests ist derselbe, wie wir ihn gesehen haben:
Eine Zeile für jeden Modultest (eine Zeile mit der Bezeichnung <code>internal</code>, die
wir in Codeblock 11-12 hinzugefügt haben) und dann eine zusammenfassende Zeile
für die Modultests.</p>
<p>Der Abschnitt zu den Integrationstests beginnt mit der Zeile <code>Running tests/integration_test.rs</code>. Als nächstes kommt eine Zeile für jede Testfunktion
in diesem Integrationstest und eine Zusammenfassung für die Ergebnisse des
Integrationstests, kurz bevor der Abschnitt <code>Doc-tests adder</code> beginnt.</p>
<p>Jede Integrationstestdatei hat ihren eigenen Abschnitt, wenn wir also weitere
Dateien im Verzeichnis <em>tests</em> hinzufügen, wird es mehr
Integrationstest-Abschnitte geben.</p>
<p>Wir können immer noch eine bestimmte Integrationstestfunktion ausführen, indem
wir den Namen der Testfunktion als Argument bei <code>cargo test</code> angeben. Um alle
Tests in einer bestimmten Integrationstestdatei auszuführen, verwenden bei
<code>cargo test</code> das Argument <code>--test</code>, gefolgt vom Namen der Datei:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running unittests (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Dieses Kommando führt nur die Tests in der Datei <em>tests/integration_test.rs</em>
aus.</p>
<h4 id="untermodule-in-integrationstests"><a class="header" href="#untermodule-in-integrationstests">Untermodule in Integrationstests</a></h4>
<p>Wenn du weitere Integrationstests hinzufügst, möchtest du vielleicht mehr als
eine Datei im Verzeichnis <em>tests</em> erstellen, um sie besser organisieren zu
können; beispielsweise kannst du die Testfunktionen nach der Funktionalität
gruppieren, die sie testen. Wie bereits erwähnt, wird jede Datei im Verzeichnis
<em>tests</em> als eigene Kiste kompiliert, was nützlich ist, um getrennte Bereiche zu
erstellen, um die Art und Weise, wie die Endbenutzer deine Kiste verwenden
werden, besser zu imitieren. Das bedeutet jedoch, dass Dateien im Verzeichnis
<em>tests</em> nicht dasselbe Verhalten aufweisen wie Dateien im Verzeichnis <em>src</em>,
wie du in Kapitel 7 über die Trennung von Code in Module und Dateien gelernt
hast.</p>
<p>Das unterschiedliche Verhalten von Dateien im Verzeichnis <em>tests</em> ist am
deutlichsten, wenn du eine Reihe Hilfsfunktionen hast, die bei mehreren
Integrationstestdateien verwendest, und du versuchst, die Schritte im
Abschnitt <a href="ch07-05-separating-modules-into-different-files.html">„Module in verschiedene Dateien
aufteilen“</a> in Kapitel 7 zu befolgen, um sie in
ein gemeinsames Modul zu extrahieren. Wenn wir zum Beispiel <em>tests/common.rs</em>
erstellen und eine Funktion namens <code>setup</code> darin platzieren, können wir <code>setup</code>
etwas Code hinzufügen, den wir von mehreren Testfunktionen in mehreren
Testdateien aufrufen wollen:</p>
<p><span class="filename">Dateiname: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // Vorbereitungscode speziell für die Tests deiner Bibliothek
}</code></pre>
<p>Wenn wir die Tests erneut ausführen, werden wir für die Datei <em>common.rs</em> einen
neuen Abschnitt in der Testausgabe sehen, obwohl diese Datei keine
Testfunktionen enthält und wir die Funktion <code>setup</code> nicht von irgendwo
aufgerufen haben:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running unittests (target/debug/deps/common-7064e1b6d2e271be)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running unittests (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Dass in den Testergebnissen <code>common</code> erscheint und dabei <code>running 0 tests</code>
angezeigt wird, ist nicht das, was wir wollten. Wir wollten nur etwas Code mit
den anderen Integrationstestdateien teilen.</p>
<p>Um zu vermeiden, dass <code>common</code> in der Testausgabe erscheint, werden wir statt
<em>tests/common.rs</em> die Datei <em>tests/common/mod.rs</em> erstellen. Das
Projektverzeichnis sieht nun wie folgt aus:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
</code></pre>
<p>Dies ist die ältere Namenskonvention, die auch Rust versteht, die wir im
Abschnitt <a href="ch07-05-separating-modules-into-different-files.html#alternative-dateipfade">„Alternative Dateipfade“</a> in Kapitel 7 erwähnt haben.
Durch diese Benennung der Datei wird Rust angewiesen, das Modul <code>common</code> nicht
als Integrationstestdatei zu behandeln. Wenn wir den Funktionscode <code>setup</code> in
<em>tests/common/mod.rs</em> verschieben und die Datei <em>tests/common.rs</em> löschen,
erscheint der Abschnitt in der Testausgabe nicht mehr. Dateien in
Unterverzeichnissen des Verzeichnisses <em>tests</em> werden nicht als separate Kisten
kompiliert und erzeugen keine Abschnitte in der Testausgabe.</p>
<p>Nachdem wir <em>tests/common/mod.rs</em> erstellt haben, können wir es von jeder der
Integrationstestdateien als Modul verwenden. Hier ist ein Beispiel für den
Aufruf der Funktion <code>setup</code> aus dem Test <code>it_adds_two</code> in
<em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Dateiname: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}</code></pre>
<p>Beachte, dass die Deklaration <code>mod common;</code> die gleiche ist wie die
Moduldeklaration, die wir in Codeblock 7-21 gezeigt haben. In der Testfunktion
können wir dann die Funktion <code>common::setup()</code> aufrufen.</p>
<h4 id="integrationstests-für-binäre-kisten"><a class="header" href="#integrationstests-für-binäre-kisten">Integrationstests für binäre Kisten</a></h4>
<p>Wenn unser Projekt eine binäre Kiste ist, die nur eine Datei <em>src/main.rs</em>
enthält und keine Datei <em>src/lib.rs</em>, können wir keine Integrationstests im
<em>tests</em>-Verzeichnis erstellen und Funktionen, die in der <em>src/main.rs</em>-Datei
definiert sind, mit einer <code>use</code>-Anweisung in den Gültigkeitsbereich bringen.
Nur Bibliothekskisten stellen Funktionen zur Verfügung, die auch von anderen
Kisten verwendet werden können; binäre Kisten sind für den eigenständigen
Betrieb gedacht.</p>
<p>Dies ist einer der Gründe, warum Rust-Projekte, die eine Binärdatei
bereitstellen, eine einfache <em>src/main.rs</em>-Datei haben, die Logik aufruft, die
in der <em>src/lib.rs</em>-Datei lebt. Unter Verwendung dieser Struktur können
Integrationstests die Bibliothekskiste mit <code>use</code> testen, um wichtige
Funktionalität verfügbar zu machen. Wenn die Hauptfunktionalität korrekt ist,
funktionieren auch die kleinen Codestücke in der Datei <em>src/main.rs</em>, und diese
kleinen Codestücke müssen nicht getestet werden.</p>
<h2 id="zusammenfassung-10"><a class="header" href="#zusammenfassung-10">Zusammenfassung</a></h2>
<p>Die Testfunktionalitäten von Rust bieten eine Möglichkeit, zu spezifizieren,
wie der Code funktionieren soll, um sicherzustellen, dass er weiterhin so
funktioniert, wie du es erwartest, auch wenn du Änderungen vornimmst. Modultests prüfen
verschiedene Teile einer Bibliothek separat und können private
Implementierungsdetails testen. Integrationstests prüfen, ob viele Teile der
Bibliothek korrekt zusammenarbeiten, und sie verwenden die öffentliche
Programmierschnittstelle (API) der Bibliothek, um den Code auf die gleiche
Weise zu testen, wie externer Code ihn verwenden wird. Auch wenn das Typsystem
und die Eigentümerschaftsregeln von Rust dazu beitragen, einige Fehlerarten zu
verhindern, sind Tests immer noch wichtig, um Logikfehler zu reduzieren, die
damit zu tun haben, wie sich dein Code voraussichtlich verhalten wird.</p>
<p>Lass uns das Wissen, das du in diesem und in den vorhergehenden Kapiteln
gelernt hast, für die Arbeit an einem Projekt einsetzen!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ein-ea-projekt-ein-kommandozeilenprogramm-erstellen"><a class="header" href="#ein-ea-projekt-ein-kommandozeilenprogramm-erstellen">Ein E/A-Projekt: Ein Kommandozeilenprogramm erstellen</a></h1>
<p>Dieses Kapitel ist eine Zusammenfassung der vielen Fähigkeiten, die du bisher
gelernt hast, und eine Erkundung einiger weiterer
Standard-Bibliotheks-Funktionalitäten. Wir werden ein Kommandozeilenwerkzeug
erstellen, das mit Datei- und Kommandozeilen-Ein- und -Ausgabe interagiert, um
einige der Rust-Konzepte zu üben, die du bereits gelernt hast.</p>
<p>Rusts Geschwindigkeit, Sicherheit, Ausgabe in eine einzelne Binärdatei und
plattformübergreifende Unterstützung machen es zu einer idealen Sprache zum
Erstellen von Kommandozeilenwerkzeugen. Für unser Projekt werden wir daher eine
eigene Version des klassischen Kommandozeilenwerkzeugs <code>grep</code> (<strong>g</strong>lobally
search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint) erstellen. Im einfachsten
Anwendungsfall durchsucht <code>grep</code> eine angegebene Datei nach einer bestimmten
Zeichenkette. Dazu nimmt <code>grep</code> als Argumente einen Dateipfad und eine
Zeichenkette. Dann liest es die Datei, findet Zeilen in dieser Datei, die das
Zeichenketten-Argument enthalten, und gibt diese Zeilen aus.</p>
<p>Auf dem Weg dorthin werden wir zeigen, wie wir unser Kommandozeilenwerkzeug
dazu bringen können, Funktionalitäten des Terminals zu nutzen, die viele
Kommandozeilenwerkzeuge nutzen. Wir werden den Wert einer Umgebungsvariablen
lesen, die es dem Benutzer ermöglicht, das Verhalten unseres Werkzeugs zu
konfigurieren. Wir werden Fehlermeldungen auch auf der Standardfehlerausgabe
(<code>stderr</code>) statt auf der Standardausgabe (<code>stdout</code>) ausgeben, sodass der
Benutzer z.B. eine erfolgreiche Ausgabe in eine Datei umleiten kann, während er
weiterhin Fehlermeldungen auf dem Bildschirm sieht.</p>
<p>Ein Mitglied der Rust-Gemeinschaft, Andrew Gallant, hat bereits eine voll
ausgestattete, sehr schnelle Version von <code>grep</code>, genannt <code>ripgrep</code>, erstellt.
Im Vergleich dazu wird unsere Version von <code>grep</code> ziemlich einfach sein, aber
dieses Kapitel wird dir einiges an Hintergrundwissen vermitteln, das du
benötigst, um ein reales Projekt wie <code>ripgrep</code> zu verstehen.</p>
<p>Unser <code>grep</code>-Projekt wird eine Reihe von Konzepten kombinieren, die du bisher
gelernt hast:</p>
<ul>
<li>Code organisieren (unter Verwendung dessen, was du über Module in <a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Kapitel
7</a> gelernt hast)</li>
<li>Verwenden von Vektoren und Zeichenketten (Kollektionen, <a href="ch08-00-common-collections.html">Kapitel 8</a>)</li>
<li>Fehlerbehandlung (<a href="ch09-00-error-handling.html">Kapitel 9</a>)</li>
<li>Verwenden von Merkmalen (traits) und Lebensdauer (lifetimes) soweit möglich
(<a href="ch10-00-generics.html">Kapitel 10</a>)</li>
<li>Schreiben von Tests (<a href="ch11-00-testing.html">Kapitel 11</a>)</li>
</ul>
<p>Wir werden auch kurz Funktionsabschlüsse (closures), Iteratoren und
Merkmalsobjekte (trait objects) vorstellen, die in den Kapiteln [13][ch13] und
[17][ch17] ausführlich behandelt werden.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kommandozeilenargumente-entgegennehmen"><a class="header" href="#kommandozeilenargumente-entgegennehmen">Kommandozeilenargumente entgegennehmen</a></h2>
<p>Lass uns ein neues Projekt, wie immer, mit <code>cargo new</code> erstellen. Wir werden
unser Projekt <code>minigrep</code> nennen, um es vom <code>grep</code>-Werkzeug zu unterscheiden,
das du vielleicht schon auf deinem System hast.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>Die erste Aufgabe besteht darin, <code>minigrep</code> dazu zu bringen, seine beiden
Kommandozeilenargumente entgegennehmen: Den Dateipfad und eine Zeichenkette,
nach der gesucht werden soll. Das heißt, wir wollen in der Lage sein, unser
Programm mit <code>cargo run</code>, einer zu suchenden Zeichenkette und einem Pfad zu
einer Datei, in der gesucht werden soll, auszuführen:</p>
<pre><code class="language-console">$ cargo run searchstring example-filename.txt
</code></pre>
<p>Im Moment kann das von <code>cargo new</code> generierte Programm die Argumente, die wir
ihm geben, nicht verarbeiten. Einige vorhandene Bibliotheken auf
<a href="https://crates.io/">crates.io</a> können beim Schreiben eines Programms, das
Kommandozeilenargumente akzeptiert, helfen, aber da du dieses Konzept gerade
erst erlernst, sollten wir diese Fähigkeit selbst implementieren.</p>
<h3 id="lesen-der-argumentwerte"><a class="header" href="#lesen-der-argumentwerte">Lesen der Argumentwerte</a></h3>
<p>Um <code>minigrep</code> in die Lage zu versetzen, die Werte der Kommandozeilenargumente
zu lesen, die wir ihm übergeben, benötigen wir die Funktion <code>std::env::args</code>,
die in der Standardbibliothek von Rust bereitgestellt wird. Diese Funktion gibt
einen Iterator der Befehlszeilenargumente zurück, die an <code>minigrep</code> übergeben
wurden. Iteratoren werden wir in <a href="ch13-00-functional-features.html">Kapitel 13</a> ausführlich behandeln. Im
Moment brauchst du nur zwei Details über Iteratoren zu wissen: Iteratoren
erzeugen eine Reihe von Werten und wir können die Methode <code>collect</code> auf einem
Iterator aufrufen, um ihn in eine Kollektion, z.B. einen Vektor, zu verwandeln,
der alle Elemente enthält, die der Iterator erzeugt.</p>
<p>Der Code in Codeblock 12-1 ermöglicht deinem <code>minigrep</code>-Programm, alle ihm
übergebenen Befehlszeilenargumente zu lesen und die Werte dann in einem Vektor
zu sammeln.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}</code></pre></pre>
<p><span class="caption">Codeblock 12-1: Sammeln der Befehlszeilenargumente in
einem Vektor und Ausgeben dieser Werte</span></p>
<p>Zuerst bringen wir das Modul <code>std::env</code> mit einer <code>use</code>-Anweisung in den
Gültigkeitsbereich, damit wir seine <code>args</code>-Funktion verwenden können. Beachte,
dass die Funktion <code>std::env::args</code> in zwei Modulebenen verschachtelt ist. Wie
wir in <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#idiomatische-use-pfade-erstellen">Kapitel 7</a> besprochen haben, haben wir in Fällen, in
denen die gewünschte Funktion in mehr als einem Modul verschachtelt ist,
das übergeordnete Modul in den Gültigkeitsbereich gebracht, anstatt nur die
Funktion. Auf diese Weise können wir leicht andere Funktionen aus <code>std::env</code>
verwenden. Es ist auch weniger mehrdeutig als das Hinzufügen von
<code>use std::env::args</code> und dem anschließenden Aufrufen der Funktion nur mit
<code>args</code>, weil <code>args</code> leicht mit einer Funktion verwechselt werden könnte, die im
aktuellen Modul definiert ist.</p>
<blockquote>
<h3 id="die-args-funktion-und-ungültiger-unicode"><a class="header" href="#die-args-funktion-und-ungültiger-unicode">Die <code>args</code>-Funktion und ungültiger Unicode</a></h3>
<p>Beachte, dass <code>std::env::args</code> abstürzt, wenn ein Argument einen ungültigen
Unicode enthält. Wenn dein Programm Argumente mit ungültigem Unicode
akzeptieren muss, verwende stattdessen <code>std::env::args_os</code>. Diese Funktion
gibt einen Iterator zurück, der <code>OsString</code>-Werte anstelle von <code>String</code>-Werten
erzeugt. Wir haben uns hier aus Gründen der Einfachheit für die Verwendung
von <code>std::env::args</code> entschieden, weil <code>OsString</code>-Werte sich je nach
Plattform unterscheiden und die Arbeit mit ihnen komplexer ist als mit
<code>String</code>-Werten.</p>
</blockquote>
<p>In der ersten Zeile von <code>main</code> rufen wir <code>env::args</code> auf und wir verwenden
sofort <code>collect</code>, um den Iterator in einen Vektor zu verwandeln, der alle vom
Iterator erzeugten Werte enthält. Wir können die Funktion <code>collect</code> verwenden,
um viele Arten von Kollektionen zu erstellen, also vermerken wir explizit den
Typ von <code>args</code>, um anzugeben, dass wir einen Vektor mit Zeichenketten wollen.
Obwohl wir in Rust nur sehr selten Typen mit Annotationen versehen müssen, ist
<code>collect</code> eine Funktion, die du häufig mit Annotationen versehen musst, da Rust
nicht in der Lage ist, auf die Art der gewünschten Kollektion zu schließen.</p>
<p>Zum Schluss geben wir den Vektor mit dem Debug-Makro aus. Versuchen wir, den
Code zuerst ohne Argumente und dann mit zwei Argumenten laufen zu lassen:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5] args = [
    &quot;target/debug/minigrep&quot;,
]
</code></pre>
<pre><code class="language-console">$ cargo run -- Nadel Heuhaufen
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5] args = [
    &quot;target/debug/minigrep&quot;,
    &quot;Nadel&quot;,
    &quot;Heuhaufen&quot;,
]
</code></pre>
<p>Beachte, dass der erste Wert im Vektor <code>&quot;target/debug/minigrep&quot;</code> ist, was der
Name unserer Binärdatei ist. Dies entspricht dem Verhalten der Argumentliste in
C, sodass Programme bei ihrer Ausführung den Namen verwenden können, unter dem
sie aufgerufen wurden. Es ist oft praktisch, Zugriff auf den Programmnamen zu
haben, falls du ihn in Meldungen ausgeben oder das Verhalten des Programms
ändern möchtest, je nachdem, welcher Befehlszeilen-Alias zum Aufruf des
Programms verwendet wurde. Aber für die Zwecke dieses Kapitels ignorieren wir
ihn und speichern nur die beiden Argumente, die wir brauchen.</p>
<h3 id="speichern-der-argumentwerte-in-variablen"><a class="header" href="#speichern-der-argumentwerte-in-variablen">Speichern der Argumentwerte in Variablen</a></h3>
<p>Das Programm ist derzeit in der Lage, auf die als Kommandozeilenargumente
angegebenen Werte zuzugreifen. Jetzt müssen wir die Werte der beiden Argumente
in Variablen speichern, damit wir die Werte im restlichen Programm verwenden
können. Das tun wir in Codeblock 12-2.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!(&quot;Suche nach {}&quot;, query);
    println!(&quot;In Datei {}&quot;, file_path);
}</code></pre></pre>
<p><span class="caption">Codeblock 12-2: Erstellen von Variablen zur Aufnahme des
Such-Arguments und des Dateipfad-Arguments</span></p>
<p>Wie wir gesehen haben, als wir den Vektor ausgegeben haben, nimmt der
Programmname den ersten Wert im Vektor bei <code>args[0]</code> ein, also beginnen wir
beim Index <code>1</code>. Das erste Argument, das <code>minigrep</code> annimmt, ist die
Zeichenkette, nach der wir suchen, also setzen wir eine Referenz auf das erste
Argument in die Variable <code>query</code>. Das zweite Argument wird der Dateipfad sein,
also setzen wir eine Referenz auf das zweite Argument in die Variable
<code>file_path</code>.</p>
<p>Wir geben vorübergehend die Werte dieser Variablen aus, um zu belegen, dass der
Code so funktioniert, wie wir es beabsichtigen. Lassen wir dieses Programm mit
den Argumenten <code>test</code> und <code>sample.txt</code> noch einmal laufen:</p>
<pre><code class="language-console">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Suche nach test
In Datei sample.txt
</code></pre>
<p>Toll, das Programm funktioniert! Die Werte der Argumente, die wir brauchen,
werden in den richtigen Variablen gespeichert. Später fügen wir eine
Fehlerbehandlung hinzu, um mit bestimmten potentiellen Fehlersituationen
umzugehen, z.B. wenn der Benutzer keine Argumente angibt; für den Moment
ignorieren wir diese Situation und arbeiten stattdessen daran, die
Datei-Lesefunktion hinzuzufügen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="eine-datei-einlesen"><a class="header" href="#eine-datei-einlesen">Eine Datei einlesen</a></h2>
<p>Jetzt fügen wir Funktionalität zum Lesen der Datei hinzu, die im
Befehlszeilenargument <code>file_path</code> angegeben ist. Zuerst brauchen wir eine
Beispieldatei, um sie zu testen: Die beste Art von Datei, die wir benutzen
können, um sicherzustellen, dass <code>minigrep</code> funktioniert, ist eine Datei mit
einer kleinen Menge Text über mehrere Zeilen mit einigen sich wiederholenden
Wörtern. In Codeblock 12-3 ist ein Gedicht von Emily Dickinson, das gut
funktionieren wird! Erstelle eine Datei namens <em>poem.txt</em> im Hauptverzeichnis
deines Projekts und gib das Gedicht „I'm Nobody! Who are you?“ ein.</p>
<p><span class="filename">Dateiname: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Codeblock 12-3: Ein Gedicht von Emily Dickinson ist ein
guter Testfall</span></p>
<p>Wenn der Text vorhanden ist, editiere <em>src/main.rs</em> und füge Code zum Lesen der
Datei hinzu, wie in Codeblock 12-4 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::env;
use std::fs;

fn main() {
    // --abschneiden--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let file_path = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, query);
</span>    println!(&quot;In Datei {}&quot;, file_path);

    let contents = fs::read_to_string(file_path)
        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);

    println!(&quot;Mit text:\n{contents}&quot;);
}</code></pre></pre>
<p><span class="caption">Codeblock 12-4: Lesen des Inhalts der Datei, die durch
das zweite Argument angegeben wurde</span></p>
<p>Zuerst fügen wir eine weitere <code>use</code>-Anweisung hinzu, um einen relevanten Teil
der Standardbibliothek einzubringen: Wir brauchen <code>std::fs</code>, um Dateien zu
verwenden.</p>
<p>In <code>main</code> haben wir eine neue Anweisung hinzugefügt: <code>fs::read_to_string</code> nimmt
den <code>file_path</code>, öffnet diese Datei und gibt ein <code>Result&lt;String&gt;</code> mit dem
Inhalt der Datei zurück.</p>
<p>Nach dieser Anweisung haben wir wieder eine temporäre <code>println!</code>-Anweisung
hinzugefügt, die den Wert von <code>contents</code> ausgibt, nachdem die Datei eingelesen
wurde, sodass wir überprüfen können, ob das Programm soweit funktioniert.</p>
<p>Lassen wir diesen Code mit einer beliebigen Zeichenkette als erstes
Kommandozeilenargument laufen (weil wir den Suchteil noch nicht implementiert
haben) und die Datei <em>poem.txt</em> als zweites Argument:</p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Suche nach the
In Datei poem.txt
Mit text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Großartig! Der Code wurde eingelesen und dann der Inhalt der Datei ausgegeben.
Aber der Code hat ein paar Mängel. Die Funktion <code>main</code> hat momentan mehrere
Verantwortlichkeiten: Im Allgemeinen sind Funktionen klarer und einfacher zu
warten, wenn jede Funktion nur für eine Idee verantwortlich ist. Das andere
Problem ist, dass wir mit Fehlern nicht so gut umgehen, wie wir es könnten. Das
Programm ist noch klein, sodass diese Fehler kein großes Problem darstellen,
aber je größer das Programm wird, desto schwieriger wird es, sie sauber zu
beheben. Es ist eine gute Praxis, schon früh mit dem Umformen (refactor) zu
beginnen, wenn man ein Programm entwickelt, denn es ist viel einfacher,
kleinere Code-Mengen umzuformen. Das werden wir als Nächstes tun.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refaktorierung-um-die-modularität-und-fehlerbehandlung-zu-verbessern"><a class="header" href="#refaktorierung-um-die-modularität-und-fehlerbehandlung-zu-verbessern">Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern</a></h2>
<p>Um unser Programm zu verbessern, werden wir vier Probleme beheben, die mit der
Struktur des Programms und dem Umgang mit potenziellen Fehlern zu tun haben.</p>
<p>Erstens erfüllt unsere Funktion <code>main</code> jetzt zwei Aufgaben: Sie parst Argumente
und liest Dateien. Für eine so kleine Funktion ist dies kein großes Problem.
Wenn wir jedoch unser Programm innerhalb der Funktion <code>main</code> weiter ausbauen,
wird die Anzahl der einzelnen Aufgaben, die die Funktion <code>main</code> bearbeitet,
zunehmen. In dem Maße, wie eine Funktion an Verantwortung hinzugewinnt, wird es
schwieriger sie zu verstehen, schwieriger sie zu testen und schwieriger sie zu
ändern, ohne dass eines ihrer Teile kaputtgeht. Am besten ist es, die
Funktionalität so aufzuteilen, dass jede Funktion für eine Aufgabe zuständig
ist.</p>
<p>Diese Frage hängt auch mit dem zweiten Problem zusammen: Obwohl <code>query</code> und
<code>file_path</code> Konfigurationsvariablen unseres Programms sind, werden Variablen
wie <code>contents</code> verwendet, um die Logik des Programms umzusetzen. Je länger
<code>main</code> wird, desto mehr Variablen müssen wir in den Gültigkeitsbereich bringen;
je mehr Variablen wir im Gültigkeitsbereich haben, desto schwieriger wird es,
den Zweck der einzelnen Variablen im Auge zu behalten. Es ist am besten, die
Konfigurationsvariablen in einer Struktur zu gruppieren, um ihren Zweck zu
verdeutlichen.</p>
<p>Das dritte Problem ist, dass wir <code>expect</code> benutzt haben, um eine Fehlermeldung
auszugeben, wenn das Lesen der Datei fehlschlägt, aber die Fehlermeldung gibt
nur <code>Sollte die Datei lesen können</code> aus. Das Lesen einer Datei kann
auf verschiedene Arten fehlschlagen: Zum Beispiel könnte die Datei fehlen oder
wir haben keine Berechtigung, sie zu öffnen. Im Moment würden wir unabhängig
von der Situation die Fehlermeldung „Etwas ging beim Lesen der Datei schief“
ausgeben, die dem Benutzer keinerlei Informationen geben würde!</p>
<p>Viertens verwenden wir <code>expect</code> erneut, um verschiedene Fehler zu behandeln,
und wenn der Benutzer unser Programm ausführt, ohne genügend Argumente
anzugeben, erhält er einen <code>Index out of bounds</code>-Fehler von Rust, der das
Problem nicht eindeutig erklärt. Am besten wäre es, wenn sich der gesamte
Fehlerbehandlungscode an einer Stelle befände, sodass zukünftige Betreuer nur
eine Stelle im Code konsultieren bräuchten, falls sich die
Fehlerbehandlungslogik ändern sollte. Wenn sich der gesamte
Fehlerbehandlungscode an einer Stelle befindet, wird auch sichergestellt, dass
wir Meldungen ausgeben, die für unsere Endbenutzer aussagekräftig sind.</p>
<p>Lass uns diese vier Probleme angehen, indem wir unser Projekt refaktorieren.</p>
<h3 id="trennen-der-zuständigkeiten-bei-binärprojekten"><a class="header" href="#trennen-der-zuständigkeiten-bei-binärprojekten">Trennen der Zuständigkeiten bei Binärprojekten</a></h3>
<p>Das organisatorische Problem der Zuweisung der Verantwortung für mehrere
Aufgaben an die Funktion <code>main</code> ist vielen Binärprojekten gemein.
Infolgedessen hat die Rust-Gemeinschaft eine Richtlinie für die Aufteilung der
einzelnen Aufgaben eines Binärprogramms entwickelt, wenn die Funktion <code>main</code>
groß wird. Dieser Prozess umfasst die folgenden Schritte:</p>
<ul>
<li>Teile dein Programm in eine <em>main.rs</em> und eine <em>lib.rs</em> auf und verschiebe
die Logik deines Programms in die <em>lib.rs</em>.</li>
<li>Solange deine Kommandozeilen-Parselogik klein ist, kann sie in <em>main.rs</em>
bleiben.</li>
<li>Wenn die Kommandozeilen-Parselogik anfängt, kompliziert zu werden, extrahiere
sie aus <em>main.rs</em> und verschiebe sie in <em>lib.rs</em>.</li>
</ul>
<p>Die Verantwortlichkeiten, die nach diesem Prozess in der Funktion <code>main</code>
verbleiben, sollten sich auf Folgendes beschränken:</p>
<ul>
<li>Aufrufen der Kommandozeilen-Parselogik mit den Argumentwerten</li>
<li>Aufbauen weiterer Konfiguration</li>
<li>Aufrufen einer Funktion <code>run</code> in <em>lib.rs</em></li>
<li>Behandeln des Fehlers, wenn <code>run</code> einen Fehler zurückgibt</li>
</ul>
<p>Bei diesem Muster geht es darum, Verantwortlichkeiten zu trennen: <em>main.rs</em>
kümmert sich um die Ausführung des Programms und <em>lib.rs</em> kümmert sich um die
gesamte Logik der anstehenden Aufgabe. Da du die Funktion <code>main</code> nicht direkt
testen kannst, kannst du mit dieser Struktur die gesamte Logik deines Programms
testen, indem du sie in Funktionen in <em>lib.rs</em> verschiebst. Der Code, der in
<em>main.rs</em> verbleibt, wird klein genug sein, um seine Korrektheit durch Lesen zu
überprüfen. Lass uns unser Programm überarbeiten, indem wir diesem Prozess
folgen.</p>
<h4 id="extrahieren-des-argument-parsers"><a class="header" href="#extrahieren-des-argument-parsers">Extrahieren des Argument-Parsers</a></h4>
<p>Wir werden die Funktionalität für das Parsen von Argumenten in eine Funktion
extrahieren, die von <code>main</code> aufgerufen wird, um das Verschieben der
Kommandozeilen-Parselogik nach <em>src/lib.rs</em> vorzubereiten. Codeblock 12-5 zeigt
den neuen Anfang von <code>main</code>, der eine neue Funktion <code>parse_config</code> aufruft, die
wir vorerst in <em>src/main.rs</em> definieren werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --abschneiden--
<span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{contents}&quot;);
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre></pre>
<p><span class="caption">Codeblock 12-5: Extrahieren einer Funktion <code>parse_config</code>
aus <code>main</code></span></p>
<p>Wir sammeln immer noch die Kommandozeilenargumente in einem Vektor, aber
anstatt den Argumentwert am Index 1 der Variablen <code>query</code> und den Argumentwert
am Index 2 der Variablen <code>file_path</code> innerhalb der <code>main</code>-Funktion zuzuweisen,
übergeben wir den gesamten Vektor an die Funktion <code>parse_config</code>. Die Funktion
<code>parse_config</code> enthält dann die Logik, die bestimmt, welches Argument in welche
Variable geht und die Werte an <code>main</code> zurückgibt. Wir erstellen immer noch die
Variablen <code>query</code> und <code>file_path</code> in <code>main</code>, aber <code>main</code> hat nicht mehr die
Verantwortung zu bestimmen, wie die Kommandozeilenargumente und Variablen
zusammenpassen.</p>
<p>Dieses Überarbeiten mag für unser kleines Programm übertrieben erscheinen, aber
wir führen die Refactoring-Maßnahmen in kleinen, inkrementellen Schritten
durch. Nachdem du diese Änderung vorgenommen hast, führe das Programm erneut
aus, um zu überprüfen, ob das Argumentparsen noch funktioniert. Es ist gut, den
Fortschritt oft zu überprüfen, um die Ursache von Problemen zu erkennen, wenn
sie auftreten.</p>
<h4 id="gruppieren-von-konfigurationswerten"><a class="header" href="#gruppieren-von-konfigurationswerten">Gruppieren von Konfigurationswerten</a></h4>
<p>Wir können einen weiteren kleinen Schritt tun, um die Funktion <code>parse_config</code>
weiter zu verbessern. Im Moment geben wir ein Tupel zurück, aber dann zerlegen
wir dieses Tupel sofort wieder in einzelne Teile. Das ist ein Zeichen dafür,
dass wir vielleicht noch nicht die richtige Abstraktion haben.</p>
<p>Ein weiterer Indikator, der zeigt, dass es Raum für Verbesserungen gibt, ist
der <code>config</code>-Teil von <code>parse_config</code>, der impliziert, dass die beiden von uns
zurückgegebenen Werte miteinander in Beziehung stehen und beide Teil eines
Konfigurationswertes sind. Diese Bedeutung vermitteln wir derzeit in der
Struktur der Daten nur durch die Gruppierung der beiden Werte in einem Tupel;
wir werden stattdessen die beiden Werte in eine Struktur setzen und jedem der
Strukturfelder einen aussagekräftigen Namen geben. Auf diese Weise wird es
künftigen Betreuern dieses Codes leichter fallen, zu verstehen, wie die
verschiedenen Werte miteinander in Beziehung stehen und was ihr Zweck ist.</p>
<p>Codeblock 12-6 zeigt die Verbesserungen der Funktion <code>parse_config</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Suche nach {}&quot;, config.query);
    println!(&quot;In Datei {}&quot;, config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);

    // --abschneiden--
<span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{contents}&quot;);
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre></pre>
<p><span class="caption">Codeblock 12-6: Refactorieren von <code>parse_config</code> zur
Rückgabe einer Instanz einer <code>Config</code>-Struktur</span></p>
<p>Wir haben eine Struktur namens <code>Config</code> hinzugefügt, die so definiert ist, dass
sie Felder mit den Namen <code>query</code> und <code>file_path</code> enthält. Die Signatur von
<code>parse_config</code> zeigt nun an, dass sie einen <code>Config</code>-Wert zurückgibt. Im
Rumpf von <code>parse_config</code>, wo wir früher Zeichenkettenanteilstypen (string
slices) zurückgegeben haben, die auf <code>String</code>-Werte in <code>args</code> referenzieren,
definieren wir <code>Config</code> jetzt so, dass es aneigenbare (owned) <code>String</code>-Werte
enthält. Die <code>args</code>-Variable in <code>main</code> ist der Eigentümer der Argumentwerte und
lässt die Funktion <code>parse_config</code> diese nur ausleihen, was bedeutet, dass wir
Rusts Regeln für das Ausleihen verletzen würden, wenn <code>Config</code> versucht, die
Eigentümerschaft für die Werte in <code>args</code> zu nehmen.</p>
<p>Wir könnten die <code>String</code>-Daten auf verschiedene Weise verwalten, aber der
einfachste, wenn auch etwas ineffiziente Weg ist es, die <code>clone</code>-Methode der
Werte aufzurufen. Dadurch wird eine vollständige Kopie der Daten erstellt, die
die <code>Config</code>-Instanz besitzen soll, was mehr Zeit und Speicherplatz in Anspruch
nimmt als das Speichern einer Referenz auf die Zeichenkettendaten. Das Klonen
der Daten macht unseren Code jedoch auch sehr unkompliziert, weil wir die
Lebensdauer der Referenzen nicht verwalten müssen; unter diesen Umständen ist
es ein lohnender Kompromiss, ein wenig Leistung aufzugeben, um Einfachheit zu
bekommen.</p>
<blockquote>
<h3 id="die-kompromisse-beim-verwenden-von-clone"><a class="header" href="#die-kompromisse-beim-verwenden-von-clone">Die Kompromisse beim Verwenden von <code>clone</code></a></h3>
<p>Viele Rust-Entwickler neigen dazu, das Verwenden von <code>clone</code> zur Lösung von
Eigentümerschaftsproblemen wegen der Laufzeitkosten zu vermeiden. In <a href="ch13-00-functional-features.html">Kapitel
13</a> erfährst du, wie du in solchen Situationen effizientere Methoden
einsetzen kannst. Aber für den Moment ist es in Ordnung, ein paar
Zeichenketten zu kopieren, um weiter voranzukommen, da du diese Kopien nur
einmal erstellen wirst und dein Dateipfad und deine Suchzeichenkette sehr
klein sind. Es ist besser, ein funktionierendes Programm zu haben, das ein
bisschen ineffizient ist, als zu versuchen, den Code beim ersten Durchgang zu
hyperoptimieren. Je mehr Erfahrung du mit Rust sammelst, desto einfacher wird
es, mit der effizientesten Lösung zu beginnen, aber im Moment ist es völlig
akzeptabel, <code>clone</code> aufzurufen.</p>
</blockquote>
<p>Wir haben <code>main</code> aktualisiert, sodass es die Instanz von <code>Config</code>, die von
<code>parse_config</code> zurückgegeben wird, in eine Variable namens <code>config</code> setzt, und
wir haben den Code aktualisiert, der vorher die separaten Variablen <code>query</code> und
<code>file_path</code> verwendet hat, sodass er jetzt stattdessen die Felder der
<code>Config</code>-Struktur verwendet.</p>
<p>Nun vermittelt unser Code deutlicher, dass <code>query</code> und <code>file_path</code> zueinander
gehören und dass ihr Zweck darin besteht, die Funktionsweise des Programms zu
konfigurieren. Jeder Code, der diese Werte verwendet, weiß, dass er sie in der
<code>config</code>-Instanz in den für ihren Zweck benannten Feldern findet.</p>
<h4 id="erstellen-eines-konstruktors-für-config"><a class="header" href="#erstellen-eines-konstruktors-für-config">Erstellen eines Konstruktors für <code>Config</code></a></h4>
<p>Bisher haben wir die Logik, die für das Parsen der Kommandozeilenargumente
verantwortlich ist, aus <code>main</code> extrahiert und in die Funktion <code>parse_config</code>
verschoben. Dies half uns zu erkennen, dass die Werte <code>query</code> und <code>file_path</code>
miteinander in Beziehung stehen und diese Beziehung in unserem Code vermittelt
werden sollte. Wir fügten dann eine <code>Config</code>-Struktur hinzu, um das
Zusammengehören von <code>query</code> und <code>file_path</code> zu benennen und um die Namen der
Werte als Feldnamen der Struktur von der <code>parse_config</code>-Funktion zurückgeben zu
können.</p>
<p>Da nun der Zweck der <code>parse_config</code>-Funktion darin besteht, eine
<code>Config</code>-Instanz zu erzeugen, können wir <code>parse_config</code> von einer einfachen
Funktion in eine Funktion namens <code>new</code> ändern, die mit der <code>Config</code>-Struktur
assoziiert ist. Durch diese Änderung wird der Code idiomatischer. Wir können
Instanzen von Typen in der Standardbibliothek erstellen, wie bei <code>String</code>,
indem wir <code>String::new</code> aufrufen. In ähnlicher Weise können wir durch Ändern
von <code>parse_config</code> in eine Funktion <code>new</code>, die mit <code>Config</code> assoziiert ist,
Instanzen von <code>Config</code> durch Aufrufen von <code>Config::new</code> erzeugen. Codeblock
12-7 zeigt die Änderungen, die wir vornehmen müssen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

<span class="boring">    println!(&quot;Suche nach {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{contents}&quot;);
</span><span class="boring">
</span>    // --abschneiden--
}

// --abschneiden--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 12-7: Ändern von <code>parse_config</code> in
<code>Config::new</code></span></p>
<p>Wir haben <code>main</code> aktualisiert, wo wir <code>parse_config</code> aufgerufen haben, um
stattdessen <code>Config::new</code> aufzurufen. Wir haben den Namen von <code>parse_config</code> in
<code>new</code> geändert und ihn innerhalb eines <code>impl</code>-Blocks verschoben, der die
<code>new</code>-Funktion mit <code>Config</code> assoziiert. Versuche, diesen Code erneut zu
kompilieren, um sicherzustellen, dass er funktioniert.</p>
<h3 id="korrigieren-der-fehlerbehandlung"><a class="header" href="#korrigieren-der-fehlerbehandlung">Korrigieren der Fehlerbehandlung</a></h3>
<p>Jetzt werden wir daran arbeiten, unsere Fehlerbehandlung zu korrigieren.
Erinnere dich, dass der Versuch, auf die Werte im <code>args</code>-Vektor bei Index 1
oder Index 2 zuzugreifen, das Programm zum Absturz bringt, wenn der Vektor
weniger als drei Elemente enthält. Versuche, das Programm ohne irgendwelche
Argumente laufen zu lassen; es wird so aussehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Die Zeile <code>index out of bounds: the len is 1 but the index is 1</code> ist eine für
Programmierer bestimmte Fehlermeldung. Sie wird unseren Endbenutzern nicht
helfen zu verstehen, was sie stattdessen tun sollten. Lass uns das jetzt
korrigieren.</p>
<h4 id="verbessern-der-fehlermeldung"><a class="header" href="#verbessern-der-fehlermeldung">Verbessern der Fehlermeldung</a></h4>
<p>In Codeblock 12-8 fügen wir eine Prüfung in der Funktion <code>new</code> hinzu, die
überprüft, ob der Anteilstyp lang genug ist, bevor auf Index 1 und 2
zugegriffen wird. Wenn der Anteilstyp nicht lang genug ist, stürzt das Programm
ab und zeigt eine bessere Fehlermeldung an.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --abschneiden--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;Nicht genügend Argumente&quot;);
        }
        // --abschneiden--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-8: Hinzufügen einer Prüfung für die Anzahl
der Argumente</span></p>
<p>Dieser Code ähnelt <a href="ch09-03-to-panic-or-not-to-panic.html#benutzerdefinierte-typen-f%C3%BCr-die-validierung-erstellen">der Funktion <code>Guess::new</code>, die wir in Codeblock
9-13</a> geschrieben haben, wo wir <code>panic!</code> aufgerufen haben,
wenn das Argument <code>value</code> außerhalb des gültigen Wertebereichs lag. Anstatt
hier auf einen Wertebereich zu prüfen, prüfen wir, ob die Länge von <code>args</code>
mindestens 3 beträgt und der Rest der Funktion unter der Annahme arbeiten kann,
dass diese Bedingung erfüllt ist. Wenn <code>args</code> weniger als drei Elemente hat,
ist diese Bedingung wahr und wir rufen das Makro <code>panic!</code> auf, um das Programm
sofort zu beenden.</p>
<p>Mit diesen zusätzlichen wenigen Zeilen Code in <code>new</code> lassen wir das Programm
ohne Argumente erneut laufen, um zu sehen, wie der Fehler jetzt aussieht:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'Nicht genügend Argumente', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Diese Ausgabe ist besser: Wir haben jetzt eine vernünftige Fehlermeldung. Wir
haben jedoch auch irrelevante Informationen, die wir unseren Benutzern nicht
geben wollen. Vielleicht ist die Technik, die wir in Codeblock 9-13 verwendet
haben, hier nicht die beste: Das Aufrufen von <code>panic!</code> ist für ein
Programmierproblem besser geeignet als für ein Nutzungsproblem, <a href="ch09-03-to-panic-or-not-to-panic.html#richtlinien-zur-fehlerbehandlung">wie in Kapitel
9 besprochen</a>. Stattdessen können wir die andere Technik
verwenden, über die du in Kapitel 9 gelernt hast – <a href="ch09-02-recoverable-errors-with-result.html">Rückgabe eines
<code>Result</code></a> um entweder Erfolg oder einen Fehler anzuzeigen.</p>
<h4 id="zurückgeben-eines-result-anstatt-panic-aufzurufen"><a class="header" href="#zurückgeben-eines-result-anstatt-panic-aufzurufen">Zurückgeben eines <code>Result</code> anstatt <code>panic!</code> aufzurufen</a></h4>
<p>Wir können stattdessen einen <code>Result</code>-Wert zurückgeben, der im erfolgreichen
Fall eine <code>Config</code>-Instanz enthält und im Fehlerfall das Problem beschreibt.
Wir werden auch den Namen der Funktion von <code>new</code> in <code>build</code> ändern, weil viele
Programmierer erwarten, dass <code>new</code>-Funktionen niemals fehlschlagen. Wenn
<code>Config::build</code> mit <code>main</code> kommuniziert, können wir den <code>Result</code>-Typ verwenden,
um zu signalisieren, dass ein Problem aufgetreten ist. Dann können wir <code>main</code>
ändern, um eine <code>Err</code>-Variante in einen praktikableren Fehler für unsere
Benutzer umzuwandeln, ohne den umgebenden Text über <code>thread 'main'</code> und
<code>RUST_BACKTRACE</code>, den ein Aufruf von <code>panic!</code> verursacht.</p>
<p>Codeblock 12-9 zeigt die Änderungen, die wir am Rückgabewert der Funktion, die
nun <code>Config::build</code> aufruft, und am Funktionsrumpf vornehmen müssen, um ein
<code>Result</code> zurückzugeben. Beachte, dass dies nicht kompiliert werden kann, bis
wir auch <code>main</code> aktualisieren, was wir im nächsten Codeblock tun werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;Nicht genügend Argumente&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
<p><span class="caption">Codeblock 12-9: Rückgabe eines <code>Result</code> von
<code>Config::build</code></span></p>
<p>Unsere Funktion <code>build</code> liefert ein <code>Result</code> mit einer <code>Config</code>-Instanz im
Erfolgsfall und ein <code>&amp;'static str</code> im Fehlerfall. Unsere Fehlerwerte werden
immer Zeichenketten-Literale sein, die eine <code>'static</code> Lebensdauer haben.</p>
<p>Wir haben zwei Änderungen im Rumpf der Funktion vorgenommen: Anstatt <code>panic!</code>
aufzurufen, wenn der Benutzer nicht genug Argumente übergibt, geben wir jetzt
einen <code>Err</code>-Wert zurück, und wir haben den <code>Config</code>-Rückgabewert in ein <code>Ok</code>
verpackt. Diese Änderungen machen die Funktion konform mit ihrer neuen
Typsignatur.</p>
<p>Die Rückgabe eines <code>Err</code>-Wertes aus <code>Config::build</code> erlaubt es der Funktion
<code>main</code>, den von der <code>build</code>-Funktion zurückgegebenen <code>Result</code>-Wert zu verarbeiten
und den Prozess im Fehlerfall sauberer zu beenden.</p>
<h4 id="aufrufen-von-configbuild-und-behandeln-von-fehlern"><a class="header" href="#aufrufen-von-configbuild-und-behandeln-von-fehlern">Aufrufen von <code>Config::build</code> und Behandeln von Fehlern</a></h4>
<p>Um den Fehlerfall zu behandeln und eine benutzerfreundliche Meldung auszugeben,
müssen wir <code>main</code> aktualisieren, um das von <code>Config::build</code> zurückgegebene
<code>Result</code> zu behandeln, wie in Codeblock 12-10 gezeigt. Wir werden auch die
Verantwortung dafür übernehmen, das Kommandozeilenwerkzeug mit einem Fehlercode
ungleich Null wie bei <code>panic!</code> zu beenden und es von Hand zu implementieren.
Ein Exit-Status ungleich Null ist eine Konvention, um dem Prozess, der unser
Programm aufgerufen hat, zu signalisieren, dass das Programm mit einem
Fehlerstatus beendet wurde.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Fehler beim Parsen der Argumente: {err}&quot;);
        process::exit(1);
    });

    // --abschneiden--
<span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-10: Beenden mit einem Fehlercode, wenn das
Erstellen einer <code>Config</code> fehlschlägt</span></p>
<p>In diesem Codeblock haben wir eine Methode verwendet, die wir bisher noch
nicht behandelt haben: <code>unwrap_or_else</code>, die in der Standardbibliothek unter
<code>Result&lt;T, E&gt;</code> definiert ist. Das Verwenden von <code>unwrap_or_else</code> erlaubt es
uns, eine benutzerdefinierte nicht-<code>panic!</code>-Fehlerbehandlung zu definieren.
Wenn das <code>Result</code> ein <code>Ok</code>-Wert ist, verhält sich diese Methode ähnlich wie
<code>unwrap</code>: Sie gibt den inneren Wert von <code>Ok</code> zurück. Wenn der Wert jedoch ein
<code>Err</code>-Wert ist, ruft diese Methode den Code im <em>Funktionsabschluss</em> (closure)
auf, die eine anonyme Funktion ist, die wir definieren und als Argument an
<code>unwrap_or_else</code> übergeben. Auf Funktionsabschlüsse gehen wir ausführlicher in
<a href="ch13-00-functional-features.html">Kapitel 13</a> ein. Im Moment musst du nur wissen, dass <code>unwrap_or_else</code>
den inneren Wert des <code>Err</code>, in diesem Fall die statische Zeichenkette <code>Nicht genügend Argumente</code>, die wir in Codeblock 12-9 hinzugefügt haben, an unseren
Funktionsabschluss im Argument <code>err</code>, das zwischen den senkrechten Strichen
erscheint, weitergibt. Der Code im Funktionsabschluss kann dann den <code>err</code>-Wert
verwenden, wenn sie ausgeführt wird.</p>
<p>Wir haben eine neue Zeile <code>use</code> hinzugefügt, um <code>process</code> aus der
Standardbibliothek in den Gültigkeitsbereich zu bringen. Der Code im
Funktionsabschluss, der im Fehlerfall ausgeführt wird, besteht nur aus zwei
Zeilen: Wir geben den <code>err</code>-Wert aus und rufen dann <code>process::exit</code> auf. Die
Funktion <code>process::exit</code> stoppt das Programm sofort und gibt die Zahl zurück,
die als Exit-Statuscode übergeben wurde. Dies ähnelt der <code>panic!</code>-basierten
Behandlung, die wir in Codeblock 12-8 verwendet haben, aber wir erhalten nicht
mehr die gesamte zusätzliche Ausgabe. Lass es uns versuchen:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Fehler beim Parsen der Argumente: Nicht genügend Argumente
</code></pre>
<p>Großartig! Diese Ausgabe ist viel benutzerfreundlicher.</p>
<h3 id="extrahieren-von-logik-aus-main"><a class="header" href="#extrahieren-von-logik-aus-main">Extrahieren von Logik aus <code>main</code></a></h3>
<p>Da wir mit dem Refaktorieren des Konfigurations-Parsers nun fertig sind, wollen
wir uns der Logik des Programms zuwenden. Wie wir in <a href="ch12-03-improving-error-handling-and-modularity.html#trennen-der-zust%C3%A4ndigkeiten-bei-bin%C3%A4rprojekten">„Trennen der
Zuständigkeiten bei
Binärprojekten“</a> erklärt
haben, werden wir eine Funktion namens <code>run</code> extrahieren, die die gesamte Logik
enthält, die sich derzeit in der Funktion <code>main</code> befindet und nicht mit dem
Aufsetzen der Konfiguration oder dem Behandeln von Fehlern zu tun hat. Wenn wir
fertig sind, wird <code>main</code> prägnant und leicht durch Inspektion zu verifizieren
sein, und wir werden in der Lage sein, Tests für all die andere Logik zu
schreiben.</p>
<p>Codeblock 12-11 zeigt die extrahierte Funktion <code>run</code>. Im Moment machen wir nur
die kleine, inkrementelle Verbesserung durch Extrahieren der Funktion. Wir sind
immer noch dabei, die Funktion in <em>src/main.rs</em> zu definieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --abschneiden--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Fehler beim Parsen der Argumente: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Suche nach {}&quot;, config.query);
    println!(&quot;In Datei {}&quot;, config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);

    println!(&quot;Mit text:\n{contents}&quot;);
}

// --abschneiden--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-11: Extrahieren einer Funktion <code>run</code>, die
den Rest der Programmlogik enthält</span></p>
<p>Die Funktion <code>run</code> enthält nun die gesamte restliche Logik von <code>main</code>,
beginnend mit dem Lesen der Datei. Die Funktion <code>run</code> nimmt die
<code>Config</code>-Instanz als Argument.</p>
<h4 id="rückgabe-von-fehlern-aus-der-funktion-run"><a class="header" href="#rückgabe-von-fehlern-aus-der-funktion-run">Rückgabe von Fehlern aus der Funktion <code>run</code></a></h4>
<p>Wenn die verbleibende Programmlogik in die Funktion <code>run</code> separiert wird,
können wir die Fehlerbehandlung verbessern, wie wir es mit <code>Config::build</code> in
Codeblock 12-9 getan haben. Anstatt das Programm durch den Aufruf von <code>expect</code>
abstürzen zu lassen, gibt die Funktion <code>run</code> ein <code>Result&lt;T, E&gt;</code> zurück, wenn
etwas schief läuft. Auf diese Weise können wir in <code>main</code> die Logik rund um den
Umgang mit Fehlern auf benutzerfreundliche Weise weiter konsolidieren.
Codeblock 12-12 zeigt die Änderungen, die wir an der Signatur und dem Rumpf von
<code>run</code> vornehmen müssen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --abschneiden--

<span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Fehler beim Parsen der Argumente: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!(&quot;Mit text:\n{contents}&quot;);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-12: Ändern der Funktion <code>run</code>, um ein
<code>Result</code> zurückzugeben</span></p>
<p>Wir haben hier drei wesentliche Änderungen vorgenommen. Erstens haben wir den
Rückgabetyp der Funktion <code>run</code> in <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> geändert. Diese
Funktion gab zuvor den Einheitstyp <code>()</code> zurück und wir behalten diesen als
Rückgabewert im Fall <code>Ok</code> bei.</p>
<p>Für den Fehlertyp haben wir das <em>Merkmalsobjekt</em> (trait object) <code>Box&lt;dyn Error&gt;</code> verwendet (und wir haben <code>std::error::Error</code> mit einer <code>use</code>-Anweisung
am Anfang des Gültigkeitsbereichs eingebunden). Wir werden Merkmalsobjekte in
<a href="ch17-00-oop.html">Kapitel 17</a> behandeln. Für den Moment solltest du nur wissen, dass
<code>Box&lt;dyn Error&gt;</code> bedeutet, dass die Funktion einen Typ zurückgibt, der das
Merkmal <code>Error</code> implementiert, aber wir müssen nicht angeben, welcher bestimmte
Typ der Rückgabewert sein wird. Das gibt uns die Flexibilität, Fehlerwerte
zurückzugeben, die in verschiedenen Fehlerfällen von unterschiedlichem Typ sein
können. Das Schlüsselwort <code>dyn</code> ist die Abkürzung für „dynamisch“.</p>
<p>Zweitens haben wir den Aufruf von <code>expect</code> zugunsten des <code>?</code>-Operators
entfernt, wie wir in <a href="ch09-02-recoverable-errors-with-result.html#abk%C3%BCrzung-zum-weitergeben-von-fehlern-der-operator-">Kapitel 9</a> besprochen haben. Statt
<code>panic!</code> bei einem Fehler aufzurufen gibt <code>?</code> den Fehlerwert aus der aktuellen
Funktion zurück, den der Aufrufer behandeln muss.</p>
<p>Drittens gibt die Funktion <code>run</code> jetzt im Erfolgsfall einen <code>Ok</code>-Wert zurück.
Wir haben den Erfolgstyp der Funktion <code>run</code> mit <code>()</code> in der Signatur
deklariert, was bedeutet, dass wir den Wert des Einheitstyps in den Wert <code>Ok</code>
einpacken müssen. Diese Syntax <code>Ok((())</code> mag zunächst etwas merkwürdig
aussehen, aber wenn wir <code>()</code> so verwenden, ist das der idiomatische Weg, um
anzuzeigen, dass wir <code>run</code> nur wegen seiner Nebenwirkungen aufrufen; es gibt
keinen Wert zurück, den wir brauchen.</p>
<p>Wenn du diesen Code ausführst, wird er kompiliert, aber es wird eine Warnung
angezeigt:</p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Rust sagt uns, dass unser Code den <code>Result</code>-Wert ignoriert hat, und der
<code>Result</code>-Wert könnte darauf hinweisen, dass ein Fehler aufgetreten ist. Aber
wir überprüfen nicht, ob ein Fehler aufgetreten ist oder nicht, und der
Compiler erinnert uns daran, dass wir wahrscheinlich gemeint haben, hier etwas
Fehlerbehandlungscode zu haben! Lass uns dieses Problem jetzt beheben.</p>
<h4 id="behandeln-von-fehlern-die-von-run-in-main-zurückgegeben-wurden"><a class="header" href="#behandeln-von-fehlern-die-von-run-in-main-zurückgegeben-wurden">Behandeln von Fehlern, die von <code>run</code> in <code>main</code> zurückgegeben wurden</a></h4>
<p>Wir werden nach Fehlern suchen und sie mit einer Technik behandeln, die ähnlich
der Technik ist, die wir mit <code>Config::build</code> in Codeblock 12-10 verwendet
haben, aber mit einem kleinen Unterschied:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --abschneiden--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Fehler beim Parsen der Argumente: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Suche nach {}&quot;, config.query);
    println!(&quot;In Datei {}&quot;, config.file_path);

    if let Err(e) = run(config) {
        println!(&quot;Anwendungsfehler: {e}&quot;);

        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>Wir benutzen <code>if let</code> statt <code>unwrap_or_else</code>, um zu prüfen, ob <code>run</code> einen
<code>Err</code>-Wert zurückgibt und rufen <code>process::exit(1)</code> auf, wenn dies der Fall ist.
Die Funktion <code>run</code> gibt keinen Wert zurück, den wir mit <code>unwrap</code> auspacken
wollen, auf die gleiche Weise, wie <code>Config::build</code> die <code>Config</code>-Instanz
zurückgibt. Da <code>run</code> im Erfolgsfall <code>()</code> zurückgibt, geht es uns nur darum,
einen Fehler zu entdecken, wir brauchen also nicht <code>unwrap_or_else</code>, um den
ausgepackten Wert zurückzugeben, der nur <code>()</code> wäre.</p>
<p>Die Rümpfe von <code>if let</code> und der <code>unwrap_or_else</code>-Funktionen sind in beiden
Fällen gleich: Wir geben den Fehler aus und beenden.</p>
<h3 id="code-in-eine-bibliothekskiste-aufteilen"><a class="header" href="#code-in-eine-bibliothekskiste-aufteilen">Code in eine Bibliothekskiste aufteilen</a></h3>
<p>Unser <code>minigrep</code>-Projekt sieht soweit gut aus! Jetzt teilen wir die Datei
<em>src/main.rs</em> auf und fügen etwas Code in die Datei <em>src/lib.rs</em> ein. Auf
diese Weise können wir den Code testen und haben eine Datei <em>src/main.rs</em> mit
weniger Verantwortlichkeiten.</p>
<p>Lass uns den ganzen Code, der nicht die Funktion <code>main</code> ist, von <em>src/main.rs</em>
nach <em>src/lib.rs</em> verschieben:</p>
<ul>
<li>Die Definition der Funktion <code>run</code></li>
<li>Die relevanten <code>use</code>-Anweisungen</li>
<li>Die Definition von <code>Config</code></li>
<li>Die Funktionsdefinition <code>Config::build</code></li>
</ul>
<p>Der Inhalt von <em>src/lib.rs</em> sollte die in Codeblock 12-13 gezeigten Signaturen
haben (wir haben die Rümpfe der Funktionen der Kürze halber weggelassen).
Beachte, dass dies nicht kompiliert werden kann, bis wir <em>src/main.rs</em> in
Codeblock 12-14 modifiziert haben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --abschneiden--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --abschneiden--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Codeblock 12-13: Verschieben von <code>Config</code> und <code>run</code> in
<em>src/lib.rs</em></span></p>
<p>Wir haben das Schlüsselwort <code>pub</code> großzügig verwendet: Bei <code>Config</code>, bei seinen
Feldern und seiner Methode <code>build</code> und bei der Funktion <code>run</code>. Wir haben jetzt
eine Bibliothekskiste, die eine öffentliche API hat, die wir testen können!</p>
<p>Jetzt müssen wir den Code, den wir nach <em>src/lib.rs</em> verschoben haben, in den
Gültigkeitsbereich der Binärkiste in <em>src/main.rs</em> bringen, wie in Codeblock
12-14 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --abschneiden--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Fehler beim Parsen der Argumente: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --abschneiden--
<span class="boring">        println!(&quot;Anwendungsfehler: {e}&quot;);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span>    }
}</code></pre>
<p><span class="caption">Codeblock 12-14: Verwenden der
<code>minigrep</code>-Bibliothekskiste in <em>src/main.rs</em></span></p>
<p>Wir fügen eine Zeile <code>use minigrep::Config</code> hinzu, um den Typ <code>Config</code> aus der
Bibliothekskiste in den Gültigkeitsbereich der Binärkiste zu bringen, und wir
stellen der Funktion <code>run</code> unseren Kistennamen voran. Nun sollte die gesamte
Funktionalität verbunden sein und funktionieren. Starte das Programm mit <code>cargo run</code> und stelle sicher, dass alles korrekt funktioniert.</p>
<p>Puh! Das war eine Menge Arbeit, aber wir haben uns für den Erfolg in der
Zukunft gerüstet. Jetzt ist es viel einfacher, mit Fehlern umzugehen, und wir
haben den Code modularer gestaltet. Fast unsere gesamte Arbeit wird von nun an
in <em>src/lib.rs</em> durchgeführt.</p>
<p>Lass uns diese neu gewonnene Modularität nutzen, indem wir etwas tun, was mit
dem alten Code schwierig gewesen wäre, mit dem neuen Code aber einfach ist: Wir
schreiben ein paar Tests!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="bibliotheksfunktionalität-mit-testgetriebener-entwicklung-erstellen"><a class="header" href="#bibliotheksfunktionalität-mit-testgetriebener-entwicklung-erstellen">Bibliotheksfunktionalität mit testgetriebener Entwicklung erstellen</a></h2>
<p>Jetzt, da wir die Logik nach <em>src/lib.rs</em> extrahiert haben und die
Argumentkollektion und Fehlerbehandlung in <em>src/main.rs</em> belassen haben, ist es
viel einfacher, Tests für die Kernfunktionalität unseres Codes zu schreiben.
Wir können Funktionen direkt mit verschiedenen Argumenten aufrufen und
Rückgabewerte überprüfen, ohne unsere Binärdatei von der Kommandozeile aus
aufrufen zu müssen.</p>
<p>In diesem Abschnitt fügen wir dem <code>minigrep</code>-Programm die Suchlogik hinzu,
indem wir die Methode der testgetriebenen Entwicklung (TDD) verwenden. Diese
Softwareentwicklungstechnik folgt diesen Schritten:</p>
<ol>
<li>Schreibe einen Test, der fehlschlägt, und führe ihn aus, um sicherzustellen,
dass er aus dem von dir erwarteten Grund fehlschlägt.</li>
<li>Schreibe oder modifiziere gerade genug Code, um den neuen Test zu bestehen.</li>
<li>Refaktoriere den Code, den du gerade hinzugefügt oder geändert hast, und
stelle sicher, dass die Tests weiterhin bestanden werden.</li>
<li>Wiederhole ab Schritt 1!</li>
</ol>
<p>Obwohl es nur eine von vielen Möglichkeiten ist, Software zu schreiben, kann
TDD auch beim Code-Design helfen. Das Schreiben der Tests vor dem Schreiben des
Codes, der den Test bestehen lässt, trägt dazu bei, während des gesamten
Entwicklungsprozesses eine hohe Testabdeckung aufrechtzuerhalten.</p>
<p>Wir werden die Implementierung der Funktionalität testen, die tatsächlich die
Suche nach der Suchzeichenkette im Dateiinhalt durchführt und eine Liste von
Zeilen erzeugt, die der Suchabfrage entsprechen. Wir werden diese
Funktionalität in einer Funktion namens <code>search</code> hinzufügen.</p>
<h3 id="schreiben-eines-fehlschlagenden-tests"><a class="header" href="#schreiben-eines-fehlschlagenden-tests">Schreiben eines fehlschlagenden Tests</a></h3>
<p>Da wir sie nicht mehr benötigen, entfernen wir die <code>println!</code> -Anweisungen aus
<em>src/lib.rs</em> und <em>src/main.rs</em>, die wir zum Überprüfen des Programmverhaltens
verwendet haben. Dann füge in <em>src/lib.rs</em> ein Modul <code>tests</code> mit einer
Testfunktion hinzu, wie wir es in <a href="ch11-01-writing-tests.html#anatomie-einer-testfunktion">Kapitel 11</a> getan haben. Die
Testfunktion spezifiziert das Verhalten, das die Funktion <code>search</code> haben soll:
Sie nimmt eine Suchabfrage und den Text, in dem gesucht werden soll, entgegen
und gibt nur die Zeilen aus dem Text zurück, die die Suchabfrage enthalten.
Codeblock 12-15 zeigt diesen Test, der sich noch nicht kompilieren lässt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;dukt&quot;;
        let contents = &quot;\
Rust:
sicher, schnell, produktiv.
Nimm drei.&quot;;

        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-15: Erstellen eines fehlschlagenden Tests
für die Funktion <code>search</code>, die wir uns wünschen</span></p>
<p>Dieser Test sucht nach der Zeichenkette <code>&quot;dukt&quot;</code>. Der Text, den wir
durchsuchen, besteht aus drei Zeilen, von denen nur eine <code>&quot;dukt&quot;</code> enthält.
(Beachte, dass der Backslash nach dem öffnenden doppelten Anführungszeichen
Rust anweist, keinen Zeilenumbruch an den Anfang des Zeichenkettenliterals zu
setzen.) Wir verlangen, dass der von der Funktion <code>search</code> zurückgegebene Wert
nur die Zeile enthält, die wir erwarten.</p>
<p>Wir sind noch nicht in der Lage, diesen Test auszuführen und zuzusehen, wie er
fehlschlägt, weil der Test noch nicht mal kompiliert: Die Funktion <code>search</code>
existiert noch nicht! In Übereinstimmung mit den TDD-Prinzipien werden wir
jetzt gerade genug Code hinzufügen, um den Test zum Kompilieren und Ausführen
zu bringen, indem wir eine Definition der Funktion <code>search</code> hinzufügen, die
immer einen leeren Vektor zurückgibt, wie in Codeblock 12-16 gezeigt. Dann
sollte der Test kompiliert werden können und fehlschlagen, weil ein leerer
Vektor nicht mit einem Vektor übereinstimmt, der die Zeile <code>&quot;sicher, schnell, produktiv.&quot;</code> enthält.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-16: Definiere gerade genug von der Funktion
<code>search</code>, damit unser Test kompiliert</span></p>
<p>Beachte, dass wir eine explizite Lebensdauer <code>'a</code> in der Signatur von <code>search</code>
definieren müssen und diese Lebensdauer beim Argument <code>contents</code> und dem
Rückgabewert verwenden. Erinnere dich in <a href="ch10-03-lifetime-syntax.html">Kapitel 10</a> daran,
dass die Lebensdauer-Parameter angeben, welche Argument-Lebensdauer mit der
Lebensdauer des Rückgabewertes verbunden ist. In diesem Fall geben wir an, dass
der zurückgegebene Vektor Zeichenkettenanteilstypen enthalten sollte, die auf
Anteilstypen des Arguments <code>contents</code> (und nicht auf das Argument <code>query</code>)
referenzieren.</p>
<p>Mit anderen Worten sagen wir Rust, dass die von der Funktion <code>search</code>
zurückgegebenen Daten so lange leben, wie die Daten, die im Argument <code>contents</code>
an die Funktion <code>search</code> übergeben werden. Das ist wichtig! Die Daten, auf die
durch einen Anteilstyp <em>referenziert</em> wird, müssen gültig sein, damit die
Referenz gültig ist; wenn der Compiler annimmt, dass wir
Zeichenkettenanteilstypen aus <code>query</code> statt aus <code>contents</code> erstellen, wird er
seine Sicherheitsprüfung falsch durchführen.</p>
<p>Wenn wir die Lebensdauer-Annotationen vergessen und versuchen, diese Funktion
zu kompilieren, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` due to previous error
</code></pre>
<p>Rust kann unmöglich wissen, welches der beiden Argumente wir brauchen, also
müssen wir es ihm explizit sagen. Da <code>contents</code> das Argument ist, das unseren
gesamten Text enthält, und wir diejenigen Teile dieses Textes zurückgeben
wollen, die passen, wissen wir, dass <code>contents</code> das Argument ist, das mit dem
Rückgabewert unter Verwendung der Lebensdauer-Syntax verbunden werden sollte.</p>
<p>Bei anderen Programmiersprachen ist es nicht erforderlich, Argumente zu
verbinden, um Werte in der Signatur zurückzugeben, aber dieses Vorgehen wird
mit der Zeit einfacher werden. Vergleiche dieses Beispiel mit dem Abschnitt
<a href="ch10-03-lifetime-syntax.html">„Referenzen validieren mit Lebensdauern“</a>
in Kapitel 10.</p>
<p>Lass uns jetzt den Test ausführen:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running target/debug/deps/minigrep-4672b652f7794785

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;safe, fast, productive.&quot;]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Toll, der Test schlägt fehl, genau wie wir erwartet haben. Bringen wir den Test
zum Bestehen!</p>
<h3 id="code-schreiben-um-den-test-zu-bestehen"><a class="header" href="#code-schreiben-um-den-test-zu-bestehen">Code schreiben, um den Test zu bestehen</a></h3>
<p>Derzeit scheitert unser Test, weil wir immer einen leeren Vektor zurückgeben.
Um dies zu korrigieren und <code>search</code> zu implementieren, muss unser Programm die
folgenden Schritte befolgen:</p>
<ul>
<li>Iteriere über jede Zeile des Inhalts.</li>
<li>Prüfe, ob die Zeile unseren Abfragetext enthält.</li>
<li>Wenn ja, füge sie der Liste der Werte hinzu, die wir zurückgeben.</li>
<li>Wenn nicht, tue nichts.</li>
<li>Gib die Liste der passenden Ergebnisse zurück.</li>
</ul>
<p>Lass uns jeden Schritt durcharbeiten, beginnend mit dem Iterieren über die
Zeilen.</p>
<h4 id="iterieren-über-zeilen-mit-der-methode-lines"><a class="header" href="#iterieren-über-zeilen-mit-der-methode-lines">Iterieren über Zeilen mit der Methode <code>lines</code></a></h4>
<p>Rust hat eine hilfreiche Methode zum zeilenweisen Iterieren von Zeichenketten,
bequemerweise <code>lines</code> genannt, die wie in Codeblock 12-17 gezeigt funktioniert.
Beachte, dass dies noch nicht kompiliert.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // mache etwas mit line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-17: Iteriere über jede Zeile in
<code>contents</code></span></p>
<p>Die Methode <code>lines</code> gibt einen Iterator zurück. Wir werden in <a href="ch13-02-iterators.html">Kapitel
13</a> ausführlich über Iteratoren sprechen, aber erinnere dich
daran, dass du diese Art der Verwendung eines Iterators in <a href="ch03-05-control-flow.html#wiederholen-anhand-einer-kollektion-mit-for">Codeblock
3-5</a> gesehen hast, wo wir eine <code>for</code>-Schleife mit einem Iterator
benutzt haben, um etwas Code für jedes Element in einer Kollektion auszuführen.</p>
<h4 id="durchsuchen-aller-zeilen-nach-dem-abfragetext"><a class="header" href="#durchsuchen-aller-zeilen-nach-dem-abfragetext">Durchsuchen aller Zeilen nach dem Abfragetext</a></h4>
<p>Als nächstes prüfen wir, ob die aktuelle Zeile unsere Abfragezeichenkette
enthält. Glücklicherweise haben Zeichenketten eine hilfreiche Methode namens
<code>contains</code>, die dies für uns erledigt! Füge einen Aufruf der <code>contains</code>-Methode
in der Funktion <code>search</code> hinzu, wie in Codeblock 12-18 gezeigt. Beachte, dass
dies noch nicht kompiliert werden kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // mache etwas mit line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-18: Hinzufügen von Funktionalität, um zu
sehen, ob die Zeile die Zeichenkette in <code>query</code> enthält</span></p>
<p>Im Moment bauen wir die Funktionalität auf. Damit sie kompiliert werden kann,
müssen wir einen Wert aus dem Rumpf zurückgeben, wie wir es in der
Funktionssignatur angegeben haben.</p>
<h4 id="speichern-passender-zeilen"><a class="header" href="#speichern-passender-zeilen">Speichern passender Zeilen</a></h4>
<p>Um diese Funktion zu vervollständigen, brauchen wir auch eine Möglichkeit, die
passenden Zeilen zu speichern, die wir zurückgeben wollen. Dafür können wir
einen veränderbaren Vektor vor der <code>for</code>-Schleife erstellen und die
<code>push</code>-Methode aufrufen, um eine <code>line</code> im Vektor zu speichern. Nach der
<code>for</code>-Schleife geben wir den Vektor zurück, wie in Codeblock 12-19 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-19: Speichern der passenden Zeilen, damit
wir sie zurückgeben können</span></p>
<p>Jetzt sollte die Funktion <code>search</code> nur noch die Zeilen zurückgeben, die <code>query</code>
enthalten, und unser Test sollte erfolgreich sein. Lass uns den Test ausführen:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running target/debug/deps/minigrep-4672b652f7794785

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/minigrep-caf9dbee196c78b9

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Unser Test war erfolgreich, also wissen wir, dass es funktioniert!</p>
<p>An diesem Punkt könnten wir Möglichkeiten für eine Refaktorierung der
Implementierung der Suchfunktion in Betracht ziehen, während die Tests
weiterlaufen, um die gleiche Funktionalität zu erhalten. Der Code in der
Suchfunktion ist nicht allzu schlecht, aber er macht sich einige nützliche
Funktionen der Iteratoren nicht zunutze. Wir kehren zu diesem Beispiel in
<a href="ch13-02-iterators.html">Kapitel 13</a> zurück, wo wir Iteratoren im Detail untersuchen
und uns ansehen, wie man sie verbessern kann.</p>
<h4 id="verwenden-der-funktion-search-in-der-funktion-run"><a class="header" href="#verwenden-der-funktion-search-in-der-funktion-run">Verwenden der Funktion <code>search</code> in der Funktion <code>run</code></a></h4>
<p>Da die Funktion <code>search</code> nun funktioniert und getestet ist, müssen wir <code>search</code>
von unserer Funktion <code>run</code> aus aufrufen. Wir müssen den Wert <code>config.query</code> und
den Wert <code>contents</code>, den <code>run</code> aus der Datei liest, an die Funktion <code>search</code>
übergeben. Dann wird <code>run</code> jede von <code>search</code> zurückgegebene Zeile ausgeben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{line}&quot;);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Wir benutzen immer noch eine <code>for</code>-Schleife, um jede Zeile von <code>search</code>
zurückzugeben und auszugeben.</p>
<p>Jetzt sollte das gesamte Programm funktionieren! Lass es uns ausprobieren,
zunächst mit einem Wort, das genau eine Zeile aus dem Emily-Dickinson-Gedicht
wiedergeben sollte: „frog“</p>
<pre><code class="language-console">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Cool! Versuchen wir nun ein Wort, das zu mehreren Zeilen passt, wie „body“:</p>
<pre><code class="language-console">$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Und schließlich sollten wir sicherstellen, dass wir keine Zeilen bekommen, wenn
wir nach einem Wort suchen, das nirgendwo im Gedicht vorkommt, zum Beispiel
„monomorphization“:</p>
<pre><code class="language-console">$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Ausgezeichnet! Wir haben unsere eigene Miniversion eines klassischen Tools
gebaut und viel darüber gelernt, wie man Anwendungen strukturiert. Wir haben
auch ein wenig über Dateieingabe und -ausgabe, Lebensdauer, Testen und
Kommandozeilen-Parsen gelernt.</p>
<p>Um dieses Projekt abzurunden, werden wir kurz demonstrieren, wie man mit
Umgebungsvariablen arbeitet und wie man Standardfehler ausgibt, beides ist
nützlich, wenn du Kommandozeilenprogramme schreibst.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mit-umgebungsvariablen-arbeiten"><a class="header" href="#mit-umgebungsvariablen-arbeiten">Mit Umgebungsvariablen arbeiten</a></h2>
<p>Wir werden <code>minigrep</code> verbessern, indem wir eine zusätzliche Funktionalität
hinzufügen: Eine Option für die Suche unabhängig von der Groß-/Kleinschreibung,
die der Benutzer über eine Umgebungsvariable einschalten kann. Wir könnten
diese Funktion zu einer Kommandozeilenoption machen und verlangen, dass die
Benutzer sie jedes Mal eingeben müssen, wenn sie angewendet werden soll, aber
stattdessen werden wir eine Umgebungsvariable verwenden. Auf diese Weise können
unsere Benutzer die Umgebungsvariable einmal setzen und alle Suchvorgänge in
dieser Terminalsitzung ohne Berücksichtigung der Groß-/Kleinschreibung
durchführen.</p>
<h3 id="schreiben-eines-fehlschlagenden-tests-für-die-suche-unabhängig-von-der-groß-kleinschreibung"><a class="header" href="#schreiben-eines-fehlschlagenden-tests-für-die-suche-unabhängig-von-der-groß-kleinschreibung">Schreiben eines fehlschlagenden Tests für die Suche unabhängig von der Groß-/Kleinschreibung</a></h3>
<p>Wir fügen zuerst eine neue Funktion <code>search_case_insensitive</code> hinzu, die
aufgerufen wird, wenn die Umgebungsvariable einen Wert hat. Wir werden die
TDD-Methode weiter verfolgen, sodass der erste Schritt wieder darin besteht,
einen fehlschlagenden Test zu schreiben. Wir werden einen neuen Test für die
neue Funktion <code>search_case_insensitive</code> hinzufügen und unseren alten Test von
<code>one_result</code> in <code>case_sensitive</code> umbenennen, um die Unterschiede zwischen den
beiden Tests zu verdeutlichen, wie in Codeblock 12-20 gezeigt wird.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;dukt&quot;;
        let contents = &quot;\
Rust:
sicher, schnell, produktiv.
Nimm drei.
PRODUKTION.&quot;;

        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
sicher, schnell, produktiv.
Nimm drei.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
<p><span class="caption">Codeblock 12-20: Hinzufügen eines neuen fehlschlagenden
Tests für die Funktion <code>search_case_insensitive</code>, die wir gleich hinzufügen
werden</span></p>
<p>Beachte, dass wir auch den Inhalt des alten Tests bearbeitet haben. Wir haben
eine neue Zeile mit dem Text <code>&quot;PRODUKTION.&quot;</code> in Großbuchstaben hinzugefügt,
die nicht mit dem Abfragetext <code>&quot;dukt&quot;</code> übereinstimmen sollte, wenn wir bei der
Suche die Groß-/Kleinschreibung beachten. Wenn wir den alten Test auf diese
Weise ändern, stellen wir sicher, dass wir nicht versehentlich die bereits
implementierte Suchfunktionalität unter Berücksichtigung der
Groß-/Kleinschreibung kaputt machen. Dieser Test sollte jetzt erfolgreich sein
und er sollte es auch bleiben, während wir an der Suche unabhängig von der
Groß-/Kleinschreibung arbeiten.</p>
<p>Der neue Test <code>case_insensitive</code> verwendet <code>&quot;rUsT&quot;</code> als Suchabfrage. In der
Funktion <code>search_case_insensitive</code>, die wir gerade hinzufügen wollen, sollte
der Abfragetext <code>&quot;rUsT&quot;</code> zur Zeile, die <code>&quot;Rust:&quot;</code> mit einem großen R enthält,
passen und zur Zeile <code>&quot;Trust me.&quot;</code>, obwohl beide eine andere Schreibweise haben
als der Abfragetext. Dies ist unser fehlschlagender Test und er wird sich nicht
kompilieren lassen, weil wir die Funktion <code>search_case_insensitive</code> noch nicht
definiert haben. Es steht dir frei, eine Skelett-Implementierung hinzuzufügen,
die immer einen leeren Vektor zurückgibt, ähnlich wie wir es für die Funktion
<code>search</code> in Codeblock 12-16 getan haben, um zu sehen, wie der Test kompilieren
wird und fehlschlägt.</p>
<h3 id="implementieren-der-funktion-search_case_insensitive"><a class="header" href="#implementieren-der-funktion-search_case_insensitive">Implementieren der Funktion <code>search_case_insensitive</code></a></h3>
<p>Die Funktion <code>search_case_insensitive</code>, die in Codeblock 12-21 gezeigt wird,
wird fast die gleiche sein wie die Funktion <code>search</code>. Der einzige Unterschied
besteht darin, dass wir <code>query</code> und <code>line</code> in Kleinbuchstaben umwandeln, sodass
sie unabhängig von der Groß-/Kleinschreibung der Eingabe-Argumente sind, wenn
wir prüfen, ob die Zeile die Abfrage enthält.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 12-21: Definieren der Funktion
<code>search_case_insensitive</code>, um den Abfragetext und die Zeile vor dem Vergleich
in Kleinbuchstaben umzuwandeln</span></p>
<p>Zuerst wandeln wir die Zeichenkette <code>query</code> in Kleinbuchstaben um und speichern
ihn in einer verschatteten Variablen mit dem gleichen Namen. Der Aufruf von
<code>to_lowercase</code> beim Abfragetext ist notwendig, sodass wir unabhängig davon, ob
die Abfrage des Benutzers <code>&quot;rust&quot;</code>, <code>&quot;RUST&quot;</code>, <code>&quot;RUST&quot;</code> oder <code>&quot;rUsT&quot;</code> ist, die
Abfrage so behandeln, als ob sie <code>&quot;rust&quot;</code> wäre, und die Groß-/Kleinschreibung
nicht beachten. Obwohl <code>to_lowercase</code> mit einfachem Unicode umgehen kann, wird
es nicht 100% genau sein. Wenn wir eine echte Anwendung schreiben würden,
würden wir hier etwas mehr Arbeit spendieren wollen, aber in diesem Abschnitt
geht es um Umgebungsvariablen, nicht um Unicode, also belassen wir es hier
dabei.</p>
<p>Beachte, dass <code>query</code> jetzt ein <code>String</code> und nicht mehr ein
Zeichenkettenanteilstyp ist, weil der Aufruf von <code>to_lowercase</code> neue Daten
erzeugt, anstatt auf bestehende Daten zu referenzieren. Nehmen wir als Beispiel
an, der Abfragetext sei <code>&quot;rUsT&quot;</code>, dieser Zeichenkettenanteilstyp enthält kein
kleingeschriebenes <code>u</code> oder <code>t</code>, das wir verwenden könnten, also müssen wir
einen neuen <code>String</code> zuweisen, der <code>&quot;rust&quot;</code> enthält. Wenn wir nun <code>query</code> als
Argument an die <code>contains</code>-Methode übergeben, müssen wir ein <code>&amp;</code>-Zeichen
angeben, weil die Signatur von <code>contains</code> so definiert ist, dass sie einen
Zeichenkettenanteilstyp nimmt.</p>
<p>Als nächstes fügen wir einen Aufruf von <code>to_lowercase</code> für jede <code>line</code> ein,
um alle Zeichen kleinzuschreiben. Da wir nun <code>line</code> und <code>query</code> in
Kleinbuchstaben umgewandelt haben, werden wir passende Zeilen finden, egal wie
die Groß-/Kleinschreibung der Abfrage ist.</p>
<p>Warten wir ab, ob diese Implementierung die Tests besteht:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running target/debug/deps/minigrep-4672b652f7794785

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/minigrep-caf9dbee196c78b9

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Großartig! Sie haben bestanden. Lass uns nun die neue Funktion
<code>search_case_insensitive</code> von der Funktion <code>run</code> aufrufen. Zuerst fügen wir
eine Konfigurationsoption zur <code>Config</code>-Struktur hinzu, um zwischen der Suche
mit und ohne Berücksichtigung der Groß- und Kleinschreibung umzuschalten. Das
Hinzufügen dieses Feldes führt zu Kompilierfehlern, da wir dieses Feld noch
nirgendwo initialisiert haben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub case_sensitive: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.case_sensitive {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Wir haben das Feld <code>ignore_case</code> hinzugefügt, das ein Boolean enthält. Als
Nächstes benötigen wir die Funktion <code>run</code>, um den Wert des Feldes <code>ignore_case</code>
auszuwerten, und verwenden diese, um zu entscheiden, ob die Funktion <code>search</code>
oder die Funktion <code>search_case_insensitive</code> aufgerufen werden soll, wie in
Codeblock 12-22 gezeigt. Dies kompiliert noch immer nicht.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{line}&quot;);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 12-22: Aufruf von entweder <code>search</code> oder
<code>search_case_insensitive</code> basierend auf dem Wert in <code>config.ignore_case</code></span></p>
<p>Schließlich müssen wir nach der Umgebungsvariablen suchen. Die Funktionen zum
Arbeiten mit Umgebungsvariablen befinden sich im Modul <code>env</code> in der
Standardbibliothek, daher bringen wir dieses Modul am Anfang von <em>src/lib.rs</em>
in den Gültigkeitsbereich. Dann werden wir die Funktion <code>var</code> aus dem Modul
<code>env</code> verwenden, um zu prüfen ob eine Umgebungsvariable namens <code>IGNORE_CASE</code>
einen Wert hat, wie in Codeblock 12-23 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::env;
// --abschneiden--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;Nicht genügend Argumente&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config {
            query,
            file_path,
            case_sensitive,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.case_sensitive {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 12-23: Prüfen, ob eine Umgebungsvariable namens
<code>IGNORE_CASE</code> einen Wert hat</span></p>
<p>Hier erstellen wir eine neue Variable <code>ignore_case</code>. Um ihren Wert zu setzen,
rufen wir die Funktion <code>env::var</code> auf und übergeben ihr den Namen der
Umgebungsvariablen <code>IGNORE_CASE</code>. Die Funktion <code>env::var</code> gibt ein <code>Result</code>
zurück, das die erfolgreiche <code>Ok</code>-Variante ist, die den Wert der
Umgebungsvariablen enthält, wenn die Umgebungsvariable einen Wert hat. Sie gibt
die Variante <code>Err</code> zurück, wenn die Umgebungsvariable nicht gesetzt ist.</p>
<p>Wir benutzen die Methode <code>is_ok</code> auf <code>Result</code>, um zu prüfen, ob die
Umgebungsvariable gesetzt ist, was bedeutet, dass das Programm die Suche
ohne Berücksichtigung der Groß-/Kleinschreibung durchführen soll. Wenn
die Umgebungsvariable <code>IGNORE_CASE</code> keinen Wert hat, gibt <code>is_ok</code> false zurück
und das Programm führt eine Suche mit Berücksichtigung der
Groß-/Kleinschreibung durch. Wir kümmern uns nicht um den <em>Wert</em> der
Umgebungsvariablen, nur darum, ob sie gesetzt ist oder nicht, also prüfen wir
mit <code>is_ok</code>, anstatt mit <code>unwrap</code>, <code>expect</code> oder einer der anderen Methoden,
die wir bei <code>Result</code> gesehen haben.</p>
<p>Wir übergeben den Wert in der Variablen <code>ignore_case</code> an die
<code>Config</code>-Instanz, sodass die Funktion <code>run</code> diesen Wert lesen und entscheiden
kann, ob sie <code>search_case_insensitive</code> oder <code>search</code> aufrufen soll, wie wir es
in Codeblock 12-22 implementiert haben.</p>
<p>Lass es uns versuchen! Zuerst führen wir unser Programm ohne die gesetzte
Umgebungsvariable und mit dem Abfragetext <code>to</code> aus, die zu den Zeilen passen
sollte, die das Wort <code>to</code> in Kleinbuchstaben enthalten:</p>
<pre><code class="language-console">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Sieht so aus, als ob das immer noch funktioniert! Lass uns nun das Programm mit
<code>IGNORE_CASE</code> auf <code>1</code> gesetzt ausführen, aber mit dem gleichen Abfragetext
<code>to</code>.</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>Wenn du die PowerShell verwendest, sind das Setzen der Umgebungsvariable und
das Ausführen des Programms separate Befehle:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run to poem.txt
</code></pre>
<p>Dadurch bleibt <code>IGNORE_CASE</code> für den Rest deiner Shell-Sitzung bestehen. Sie
kann mit <code>Remove-Item</code> zurückgesetzt werden:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>Wir sollten Zeilen erhalten, die „to“ enthalten, die Großbuchstaben haben
könnten:</p>
<pre><code class="language-console">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Ausgezeichnet, wir haben auch Zeilen mit „to“! Unser <code>minigrep</code>-Programm kann
jetzt ohne Berücksichtigung von Groß-/Kleinschreibung suchen, gesteuert durch
eine Umgebungsvariable. Jetzt weißt du, wie man Optionen verwaltet, die
entweder mit Kommandozeilenargumenten oder Umgebungsvariablen gesetzt werden.</p>
<p>Einige Programme erlauben Argumente <em>und</em> Umgebungsvariablen für die gleiche
Konfiguration. In diesen Fällen entscheiden die Programme, dass das eine oder
das andere Vorrang hat. Versuche für eine weitere eigene Übung, die Steuerung,
ob die Groß-/Kleinschreibung berücksichtigt werden soll, entweder über ein
Kommandozeilenargument oder eine Umgebungsvariable zu ermöglichen. Entscheide,
ob das Kommandozeilenargument oder die Umgebungsvariable Vorrang haben soll,
wenn das Programm mit widersprüchlichen Optionen ausgeführt wird.</p>
<p>Das Modul <code>std::env</code> enthält viele weitere nützliche Funktionalitäten für den
Umgang mit Umgebungsvariablen: Schaue in seine Dokumentation, um zu sehen, was
verfügbar ist.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fehlermeldungen-in-die-standardfehlerausgabe-anstatt-der-standardausgabe-schreiben"><a class="header" href="#fehlermeldungen-in-die-standardfehlerausgabe-anstatt-der-standardausgabe-schreiben">Fehlermeldungen in die Standardfehlerausgabe anstatt der Standardausgabe schreiben</a></h2>
<p>Im Moment schreiben wir unsere gesamte Ausgabe mit dem Makro <code>println!</code> auf das
Terminal. In den meisten Terminals gibt es zwei Arten von Ausgaben:
Die <em>Standardausgabe</em> (<code>stdout</code>) für allgemeine Informationen und die
<em>Standardfehlerausgabe</em> (<code>stderr</code>) für Fehlermeldungen. Diese Unterscheidung
ermöglicht es dem Benutzer, die erfolgreiche Ausgabe eines Programms in eine
Datei zu leiten, aber dennoch Fehlermeldungen auf dem Bildschirm auszugeben.</p>
<p>Das Makro <code>println!</code> ist nur in der Lage, auf die Standardausgabe zu schreiben,
also müssen wir etwas anderes verwenden, um auf die Standardfehlerausgabe zu
schreiben.</p>
<h3 id="prüfen-wo-fehler-ausgegeben-werden"><a class="header" href="#prüfen-wo-fehler-ausgegeben-werden">Prüfen, wo Fehler ausgegeben werden</a></h3>
<p>Lass uns zunächst beobachten, wie der von <code>minigrep</code> ausgegebene Inhalt derzeit
in die Standardausgabe geschrieben wird, einschließlich aller Fehlermeldungen,
die wir stattdessen in die Standardfehlerausgabe schreiben wollen. Wir tun
dies, indem wir die Standardausgabe in eine Datei umleiten und dabei
absichtlich einen Fehler verursachen. Wir werden die Standardfehlerausgabe
nicht umleiten, sodass alle Inhalte, die an die Standardfehlerausgabe gesendet
werden, weiterhin auf dem Bildschirm angezeigt werden.</p>
<p>Von Kommandozeilenprogrammen wird erwartet, dass sie Fehlermeldungen an die
Standardfehlerausgabe senden, sodass wir Fehlermeldungen auch dann noch auf dem
Bildschirm sehen können, wenn wir die Standardausgabe in eine Datei umleiten.
Unser Programm ist zur Zeit nicht sehr brav: Wir werden gleich sehen, dass es
die ausgegebenen Fehlermeldungen stattdessen in eine Datei speichert!</p>
<p>Der Weg, dieses Verhalten zu demonstrieren, besteht darin, das Programm mit <code>&gt;</code>
und dem Dateipfad <em>output.txt</em> laufen zu lassen, zu dem wir die
Standardausgabe umleiten wollen. Wir werden keine Argumente übergeben, was
einen Fehler verursachen sollte:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p>Die Syntax <code>&gt;</code> weist die Shell an, den Inhalt der Standardausgabe anstelle des
Bildschirms in <em>output.txt</em> zu schreiben. Wir haben die erwartete Fehlermeldung
nicht gesehen, die auf den Bildschirm ausgegeben werden sollte, also muss sie
in der Datei gelandet sein. Dies ist der Inhalt von <em>output.txt</em>:</p>
<pre><code class="language-text">Fehler beim Parsen der Argumente: Nicht genügend Argumente
</code></pre>
<p>Ja, unsere Fehlermeldung wird in die Standardausgabe geschrieben. Es ist viel
nützlicher, wenn Fehlermeldungen wie diese auf der Standardfehlerausgabe
ausgegeben werden, sodass nur Daten aus einem erfolgreichen Lauf in der Datei
landen. Das werden wir ändern.</p>
<h3 id="fehler-auf-der-standardfehlerausgabe-ausgeben"><a class="header" href="#fehler-auf-der-standardfehlerausgabe-ausgeben">Fehler auf der Standardfehlerausgabe ausgeben</a></h3>
<p>Wir werden den Code in Codeblock 12-24 verwenden, um zu ändern, wie
Fehlermeldungen ausgegeben werden. Aufgrund der Refaktorierung, die wir früher
in diesem Kapitel vorgenommen haben, befindet sich der gesamte Code, der
Fehlermeldungen ausgibt, in einer einzigen Funktion, nämlich der Funktion
<code>main</code>. Die Standardbibliothek stellt das Makro <code>eprintln!</code> zur Verfügung, das
in die Standardfehlerausgabe schreibt. Lass uns also die beiden Stellen, an
denen wir <code>println!</code> aufgerufen haben, um Fehler auszugeben, ändern und
stattdessen <code>eprintln!</code> verwenden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Fehler beim Parsen der Argumente: {err}&quot;);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Anwendungsfehler: {e}&quot;);

        process::exit(1);
    }
}</code></pre>
<p><span class="caption">Codeblock 12-24: Schreiben von Fehlermeldungen auf die
Standardfehlerausgabe anstelle der Standardausgabe durch Verwenden von
<code>eprintln!</code></span></p>
<p>Lassen wir das Programm nun auf die gleiche Art und Weise erneut laufen, ohne
Argumente und mit Umleitung der Standardausgabe mit <code>&gt;</code>:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Fehler beim Parsen der Argumente: Nicht genügend Argumente
</code></pre>
<p>Jetzt sehen wir den Fehler auf dem Bildschirm und <em>output.txt</em> enthält nichts,
was dem Verhalten entspricht, das wir von Kommandozeilenprogrammen erwarten.</p>
<p>Lassen wir das Programm erneut mit Argumenten laufen, die keinen Fehler
verursachen, aber dennoch die Standardausgabe in eine Datei umleiten, etwa so:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>Wir werden keine Ausgabe auf dem Terminal sehen und <em>output.txt</em> wird unsere
Ergebnisse enthalten:</p>
<p><span class="filename">Dateiname: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Dies zeigt, dass wir jetzt die Standardausgabe für die erfolgreiche Ausgabe und
gegebenenfalls die Standardfehlerausgabe für die Fehlerausgabe verwenden.</p>
<h2 id="zusammenfassung-11"><a class="header" href="#zusammenfassung-11">Zusammenfassung</a></h2>
<p>Dieses Kapitel rekapituliert einige der wichtigsten Konzepte, die du bisher
gelernt hast, und behandelt das Durchführen gängiger E/A-Operationen in Rust.
Durch das Verwenden von Kommandozeilenargumenten, Dateien, Umgebungsvariablen
und des Makros <code>eprintln!</code> für die Fehlerausgabe bist du jetzt bereit,
Kommandozeilenanwendungen zu schreiben. Wenn du die Konzepte mit denen in den
vorhergehenden Kapiteln kombinierst, wird dein Code gut organisiert sein, Daten
effektiv in den entsprechenden Datenstrukturen speichern, Fehler gut behandeln
und gut getestet sein.</p>
<p>Als Nächstes werden wir einige Rust-Funktionalitäten untersuchen, die von
funktionalen Sprachen beeinflusst wurden: Funktionsabschlüsse (closures) und
Iteratoren.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funktionale-sprachelemente-iteratoren-und-funktionsabschlüsse-closures"><a class="header" href="#funktionale-sprachelemente-iteratoren-und-funktionsabschlüsse-closures">Funktionale Sprachelemente: Iteratoren und Funktionsabschlüsse (closures)</a></h1>
<p>Das Design von Rust wurde von einer Vielzahl von vorhandenen Programmiersprachen
und Techniken beeinflusst und einen signifikanter Einfluss hat die <em>funktionale
Programmierung</em>. Programmieren im funktionalen Stil beinhaltet oft das
Verwenden von Funktionen als Werte, die in Argumenten übergeben, von anderen
Funktionen zurückgegeben, Variablen zur späteren Ausführung zugewiesen werden
und so weiter.</p>
<p>In diesem Kapitels soll nicht erörtert werden, was funktionale
Programmierung ist oder nicht, stattdessen werden wir einige Funktionalitäten von
Rust besprechen, die denen vieler anderer Sprachen ähneln und häufig als
funktional bezeichnet werden. </p>
<p>Im Einzelnen wird Folgendes behandelt:</p>
<ul>
<li><em>Funktionsabschlüsse</em>, ein Konstrukt, das einer Funktion ähnelt und in einer
Variable gespeichert werden kann.</li>
<li><em>Iteratoren</em>, ein Mechanismus, eine Reihe von Elementen abzuarbeiten.</li>
<li>Wie wir Funktionsabschlüsse und Iteratoren einsetzen, um unser E/A-Projekt
aus Kapitel 12 zu verbessern</li>
<li>Die Performanz von Funktionsabschlüssen und Iteratoren (Spoiler-Alarm: Sie
sind schneller, als du vielleicht denken magst!)</li>
</ul>
<p>Wir haben uns bereits andere Rust-Funktionalitäten wie Aufzählungen (enums) und
Musterabgleich (pattern matching) angesehen, die ebenfalls vom funktionalen
Stil beeinflusst sind. Da das Beherrschen von Funktionsabschlüssen und
Iteratoren ein wichtiger Bestandteil für das Schreiben von idiomatischem,
schnellem Rust-Programmcode ist, wird ihnen das gesamte Kapitel gewidmet.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="funktionsabschlüsse-closures-anonyme-funktionen-die-ihre-umgebung-erfassen"><a class="header" href="#funktionsabschlüsse-closures-anonyme-funktionen-die-ihre-umgebung-erfassen">Funktionsabschlüsse (closures): Anonyme Funktionen, die ihre Umgebung erfassen</a></h2>
<p>Rusts Funktionsabschlüsse sind anonyme Funktionen, die du in einer Variable
speichern oder anderen Funktionen als Argument übergeben kannst. Du kannst einen 
Funktionsabschluss erstellen und dann in einem anderen Zusammenhang aufrufen
und auswerten. Im Gegensatz zu Funktionen können Funktionsabschlüsse auf Werte 
(values) im Gültigkeitsbereich (scope) zugreifen, in dem sie erstellt wurden.
Wir werden im Folgenden zeigen, wie die Funktionalität von Funktionsabschlüssen
die Wiederverwendung von Code erlaubt und sein Verhalten anpassen kann.</p>
<h3 id="erfassen-der-umgebung-mit-funktionsabschlüssen"><a class="header" href="#erfassen-der-umgebung-mit-funktionsabschlüssen">Erfassen der Umgebung mit Funktionsabschlüssen</a></h3>
<p>Wir werden zunächst untersuchen, wie wir Funktionsabschlüsse verwenden können,
um Werte aus der Umgebung, in der sie definiert sind, zur späteren Verwendung
zu erfassen. Hier ist das Szenario: Von Zeit zu Zeit verschenkt unsere
T-Shirt-Firma ein exklusives T-Shirt in limitierter Auflage an jemanden aus
unserer Mailingliste als Werbeaktion. Die Personen auf der Mailingliste können
optional ihre Lieblingsfarbe zu ihrem Profil hinzufügen. Wenn die Person, die
das kostenlose Shirt erhalten soll, ihre Lieblingsfarbe in ihrem Profil
angegeben hat, erhält sie das Hemd in dieser Farbe. Wenn die Person keine
Lieblingsfarbe angegeben hat, erhält sie die Farbe, in der das Unternehmen
derzeit die meisten Exemplare hat.</p>
<p>Es gibt viele Möglichkeiten, dies zu implementieren. Für dieses Beispiel werden
wir eine Aufzählung namens <code>ShirtColor</code> verwenden, die die Varianten <code>Red</code> und
<code>Blue</code> hat (der Einfachheit halber wird die Anzahl der verfügbaren Farben
begrenzt). Das Inventar des Unternehmens wird durch eine Struktur <code>Inventory</code>
repräsentiert, die ein Feld mit dem Namen <code>shirts</code> hat, das ein
<code>Vec&lt;ShirtColor&gt;</code> mit den derzeit vorrätigen Hemden enthält. Die Methode
<code>giveaway</code>, die auf <code>Inventory</code> definiert ist, erhält die optionale
Shirtfarbe der Person, die das kostenlose Shirt erhält, und gibt die Shirtfarbe
zurück, die die Person erhalten wird. Dies wird in Codeblock 13-1 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        &quot;Der Benutzer mit Präferenz {:?} erhält {:?}&quot;,
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        &quot;Der Benutzer mit Präferenz {:?} erhält {:?}&quot;,
        user_pref2, giveaway2
    );
}</code></pre>
<p><span class="caption">Codeblock 13-1: Werbegeschenk der Shirtfirma</span></p>
<p>Der in <code>main</code> definierte <code>store</code> hat zwei blaue Shirts und ein rotes Shirt
übrig, die für diese limitierte Aktion verteilt werden sollen. Wir rufen die
Methode <code>giveaway</code> für einen Benutzer mit einer Präferenz für ein rotes Hemd
und einen Benutzer ohne jegliche Präferenz auf.</p>
<p>Auch dieser Code könnte auf viele Arten implementiert werden. Um uns auf
Funktionsabschlüsse zu konzentrieren, haben wir uns an die Konzepte gehalten,
die du bereits gelernt hast, mit Ausnahme des Methodenrumpfs von <code>giveaway</code>,
der einen Funktionsabschluss verwendet. In der Methode <code>giveaway</code> erhalten wir
die Benutzerpräferenz als einen Parameter vom Typ <code>Option&lt;ShirtColor&gt;</code> und
rufen die Methode <code>unwrap_or_else</code> auf <code>user_preference</code> auf. Die <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else">Methode
<code>unwrap_or_else</code> auf <code>Option&lt;T&gt;</code></a> ist in der Standardbibliothek
definiert. Sie nimmt ein Argument entgegen: Einen Funktionsabschluss ohne
Argument, der einen Wert <code>T</code> zurückgibt (denselben Typ, der in der Variante
<code>Some</code> von <code>Option&lt;T&gt;</code> gespeichert ist, in diesem Fall <code>ShirtColor</code>). Wenn
<code>Option&lt;T&gt;</code> die Variante <code>Some</code> ist, gibt <code>unwrap_or_else</code> den Wert aus <code>Some</code>
zurück. Wenn <code>Option&lt;T&gt;</code> die Variante <code>None</code> ist, ruft <code>unwrap_or_else</code> den
Funktionsabschluss auf und gibt den Wert zurück, der vom Funktionsabschluss
zurückgegeben wurde.</p>
<p>Wir geben den Funktionsabschluss-Ausdruck <code>|| self.most_stocked()</code> als Argument
bei <code>unwrap_or_else</code> an. Dies ist ein Funktionsabschluss, die selbst keine
Parameter hat (wenn der Funktionsabschluss Parameter hätte, würden sie zwischen
den beiden vertikalen Strichen erscheinen). Der Rumpf des Funktionsabschlusses
ruft <code>self.most_stocked()</code> auf. Wir definieren den Funktionsabschluss hier, und
die Implementierung von <code>unwrap_or_else</code> wird den Funktionsabschluss später
auswerten, wenn das Ergebnis benötigt wird.</p>
<p>Die Ausführung dieses Codes gibt aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
Der Benutzer mit Präferenz Some(Red) erhält Red
Der Benutzer mit Präferenz None erhält Blue
</code></pre>
<p>Ein interessanter Aspekt ist hier, dass wir einen Funktionsabschluss übergeben
haben, der <code>self.most_stocked()</code> für die aktuelle <code>Inventory</code>-Instanz aufruft.
Die Standardbibliothek musste nichts über die von uns definierten Typen
<code>Inventory</code> oder <code>ShirtColor</code> oder die Logik, die wir in diesem Szenario
verwenden wollen, wissen. Der Funktionsabschluss hat eine unveränderbare
Referenz auf die <code>self</code>-Instanz von <code>Inventory</code> erfasst und sie mit dem von uns
angegebenen Code an die Methode <code>unwrap_or_else</code> übergeben. Funktionen sind
andererseits nicht in der Lage, ihre Umgebung auf diese Weise zu erfassen.</p>
<h3 id="funktionsabschluss-typinferenz-und-annotation"><a class="header" href="#funktionsabschluss-typinferenz-und-annotation">Funktionsabschluss-Typinferenz und Annotation</a></h3>
<p>Es gibt weitere Unterschiede zwischen Funktionen und Funktionsabschlüssen. Bei
Funktionsabschlüssen ist es normalerweise nicht erforderlich, die Typen der
Parameter oder des Rückgabewertes zu annotieren, wie es bei <code>fn</code>-Funktionen der
Fall ist. Typ-Annotationen sind bei Funktionen erforderlich, weil die Typen
Teil einer expliziten Schnittstelle sind, die für deine Benutzer sichtbar ist.
Die strikte Definition dieser Schnittstelle ist wichtig, um sicherzustellen,
dass alle Beteiligten sich darüber einig sind, welche Arten von Werten eine
Funktion verwendet und zurückgibt. Funktionsabschlüsse werden hingegen nicht in
einer offengelegten Schnittstelle wie dieser verwendet: Sie werden in Variablen
gespeichert und verwendet, ohne sie zu benennen und den Benutzern unserer
Bibliothek offenzulegen.</p>
<p>Funktionsabschlüsse sind in der Regel kurz und nur in einem engen Kontext und
nicht in jedem beliebigen Szenario relevant. Innerhalb dieser begrenzten
Kontexte kann der Compiler die Typen der Parameter und des Rückgabetyps
ableiten, ähnlich wie er die Typen der meisten Variablen ableiten kann (es gibt
seltene Fälle, in denen der Compiler auch Funktionsabschluss-Typannotationen
benötigt).</p>
<p>Wie bei Variablen können wir Typ-Annotationen hinzufügen, wenn wir die
Explizitheit und Klarheit erhöhen wollen, auch wenn wir dafür ausführlicher
sind als unbedingt nötig. Die Annotation der Typen für einen Funktionsabschluss
würde wie die in Codeblock 13-2 gezeigte Definition aussehen. In diesem
Beispiel definieren wir einen Funktionsabschluss und speichern ihn in einer
Variablen, anstatt den Funktionsabschluss an der Stelle zu definieren, an der
wir ihn als Argument übergeben, wie wir es in Codeblock 13-1 getan haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Heute, {} Minuten Lauftraining!&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-2: Hinzufügen optionaler Datentypangabe der
Parameter- und Rückgabewert-Typen im Funktionsabschluss</span></p>
<p>Mit Typ-Annotationen ähnelt die Syntax eines Funktionsabschlusses sehr der
Syntax einer Funktion. Hier definieren wir eine Funktion, die zu ihrem
Parameter den Wert 1 addiert, und zum Vergleich einen Funktionsabschluss mit
identischem Verhalten. Zur besseren Darstellung der relevanten Teile haben wir
einige Leerzeichen eingefügt. Dies zeigt, wie ähnlich die Syntax von Funktionen
der von Funktionsabschlüssen ist, abgesehen von den senkrechten Strichen und
der Möglichkeit, einen Teil der Syntax wegzulassen:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>Die erste Zeile zeigt eine Funktionsdefinition und die zweite eine Definition
eines Funktionsabschlusses mit allen Datentypangaben. In der dritten Zeile
werden die Datentypangaben aus der Funktionsabschlusses-Definition entfernt,
und in der vierten Zeile werden die geschweiften Klammern weggelassen, die
optional sind, da der Funktionsabschlusses-Rumpf nur einen Ausdruck beinhaltet.
Alle diese Ausdrücke sind gültig und verhalten sich beim Aufruf gleich. Von
<code>add_one_v3</code> und <code>add_one_v4</code> wird ein Aufruf zum Kompilieren des Codes
benötigt, da hier die Typen abhängig von der Verwendung abgeleitet werden. Dies
ist vergleichbar mit <code>let v = Vec::new();</code>, bei dem entweder Typ-Annotationen
oder Werte eines bestimmten Typs in den <code>Vec</code> eingefügt werden müssen, damit
Rust den Typ ableiten kann.</p>
<p>Bei Funktionsabschlussdefinitionen wird für jeden Parameter und für den
Rückgabewert ein konkreter Typ abgeleitet. Codeblock 13-3 zeigt zum Beispiel
die Definition eines kurzen Funktionsabschlusses, der nur den Wert des
übergebenen Parameters zurückgibt. Dieser Funktionsabschluss ist außer für
dieses Beispiel nicht weiter nützlich. Beachte, dass wir der Definition keine
Datentypangaben hinzugefügt haben. Da es keine Typ-Annotationen gibt, können
wir den Funktionsabschluss mit einem beliebigen Typ aufrufen, was wir hier mit
<code>String</code> das erste Mal getan haben. Wenn wir dann versuchen, <code>example_closure</code>
mit einer Ganzzahl aufzurufen, erhalten wir einen Fehler.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let example_closure = |x| x;

let s = example_closure(String::from(&quot;hallo&quot;));
let n = example_closure(5);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-3: Versuchter Aufruf eines
Funktionsabschlusses, dem zwei unterschiedliche Typen übergeben wurden</span></p>
<p>Der Compiler gibt diesen Fehler aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected struct `String`, found integer
  |             arguments to this function are incorrect
  |
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
</code></pre>
<p>Beim ersten Aufruf von <code>example_closure</code> wird dem Typ von <code>x</code> und dem
Rückgabewert des Funktionsabschlusses der Typ <code>String</code> zugewiesen. Diese Typen
sind dann für den Funktionsabschluss <code>example_closure</code> festgeschrieben. Daher
bekommen wir eine Fehlermeldung, wenn wir versuchen einen anderen Typ mit dem
gleichen Funktionsabschluss zu benutzen.</p>
<h3 id="erfassen-von-referenzen-oder-verschieben-der-eigentümerschaft"><a class="header" href="#erfassen-von-referenzen-oder-verschieben-der-eigentümerschaft">Erfassen von Referenzen oder Verschieben der Eigentümerschaft</a></h3>
<p>Funktionsabschlüsse können Werte aus ihrer Umgebung auf drei Arten erfassen,
die direkt den drei Möglichkeiten entsprechen, wie eine Funktion einen
Parameter aufnehmen kann: Unveränderbare Ausleihen (borrowing immutably),
veränderbare Ausleihen (borrowing mutably) und Eigentümerschaft übernehmen
(taking ownership). Der Funktionsabschluss entscheidet, welche dieser
Möglichkeiten verwendet wird, je nachdem, was der Rumpf der Funktion mit den
erfassten Werten macht.</p>
<p>In Codeblock 13-4 definieren wir einen Funktionsabschluss, der eine
unveränderbare Referenz an den Vektor mit dem Namen <code>list</code> erfasst, weil er
nur eine unveränderbare Referenz benötigt, um den Wert auszugeben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Vor der Funktionsabschlussdefinition: {:?}&quot;, list);

    let only_borrows = || println!(&quot;Im Funktionsabschluss: {:?}&quot;, list);

    println!(&quot;Vor dem Funktionsabschluss-Aufruf: {:?}&quot;, list);
    only_borrows();
    println!(&quot;Nach dem Funktionsabschluss-Aufruf: {:?}&quot;, list);
}</code></pre></pre>
<p><span class="caption">Codeblock 13-4: Definieren und Aufrufen eines
Funktionsabschlusses, der eine unveränderbare Referenz erfasst</span></p>
<p>Dieses Beispiel veranschaulicht auch, dass eine Variable an eine
Funktionsabschlussdefinition gebunden werden kann, und wir den
Funktionsabschluss später aufrufen können, indem wir den Variablennamen und die
Klammern verwenden, als ob der Variablenname ein Funktionsname wäre.</p>
<p>Da wir mehrere unveränderbare Referenzen auf <code>list</code> zur gleichen Zeit haben
können, ist <code>list</code> immer noch vom Code vor der Funktionsabschlussdefinition
zugreifbar, sowie nach der Funktionsabschlussdefinition und vor dem Aufruf des
Funktionsabschlusses, und nach dem Aufruf des Funktionsabschlusses. Dieser Code
kompiliert, läuft und gibt folgendes aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Vor der Funktionsabschlussdefinition: [1, 2, 3]
Vor dem Funktionsabschluss-Aufruf: [1, 2, 3]
Im Funktionsabschluss: [1, 2, 3]
Nach dem Funktionsabschluss-Aufruf: [1, 2, 3]
</code></pre>
<p>In Codeblock 13-5 wird die Definition des Funktionsabschlusses so geändert,
dass er ein Element zum Vektor <code>list</code> hinzufügt. Der Funktionsabschluss erfasst
nun eine veränderbare Referenz:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;Vor der Funktionsabschlussdefinition: {:?}&quot;, list);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!(&quot;Nach dem Funktionsabschluss-Aufruf: {:?}&quot;, list);
}</code></pre></pre>
<p><span class="caption">Codeblock 13-5: Definieren und Aufrufen eines
Funktionsabschlusses, der eine veränderbare Referenz erfasst</span></p>
<p>Dieser Code kompiliert, läuft und gibt aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Vor der Funktionsabschlussdefinition: [1, 2, 3]
Nach dem Funktionsabschluss-Aufruf: [1, 2, 3, 7]
</code></pre>
<p>Beachte, dass es kein <code>println!</code> mehr zwischen der Definition und dem Aufruf
des Funktionsabschlusses <code>borrows_mutably</code> gibt: Wenn <code>borrows_mutably</code>
definiert ist, erfasst es eine veränderbare Referenz auf <code>list</code>. Der
Funktionsabschluss wird nicht mehr verwendet, nachdem er aufgerufen wurde,
daher endet die veränderbare Ausleihe. Zwischen der
Funktionsabschlussdefinition und dem Funktionsabschluss-Aufruf ist eine
unveränderbare Ausleihe für die Ausgabe nicht erlaubt, weil keine anderen
Ausleihen erlaubt sind, wenn es eine veränderbare Ausleihe gibt. Versuche,
dort ein <code>println!</code> hinzuzufügen, um zu sehen, welche Fehlermeldung du
erhältst!</p>
<p>Wenn du den Funktionsabschluss zwingen willst, die Eigentümerschaft der Werte,
die er in der Umgebung verwendet, zu übernehmen, obwohl der Rumpf des
Funktionsabschlusses nicht unbedingt Eigentümer sein muss, kannst du das
Schlüsselwort <code>move</code> vor der Parameterliste verwenden.</p>
<p>Diese Technik ist vor
allem nützlich, wenn ein Funktionsabschluss an einen neuen Strang (thread)
übergeben wird, um die Daten zu verschieben, sodass sie dem neuen Strang
gehören. Wir werden in Kapitel 16, wenn wir über Nebenläufigkeit (concurrency)
sprechen, detailliert auf Stränge eingehen und erläutern, warum man sie
verwenden sollte, aber jetzt wollen wir uns kurz mit dem Erzeugen eines neuen
Strangs mithilfe eines Funktionsabschlusses befassen, der das Schlüsselwort
<code>move</code> benötigt. Codeblock 13-6 zeigt Codeblock 13-4 modifiziert, um den Vektor
in einem neuen Strang statt im Hauptstrang auszugeben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    thread::spawn(move || println!(&quot;From thread: {:?}&quot;, list))
        .join()
        .unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 13-6: Verwenden von <code>move</code>, um den
Funktionsabschluss des Strangs zu erzwingen, die Eigentümerschaft an <code>list</code> zu
übernehmen</span></p>
<p>Wir starten einen neuen Strang und geben ihm einen Funktionsabschluss als
Argument mit. Der Rumps des Funktionsabschlusses gibt die Liste aus. In
Codeblock 13-4 hat der Funktionsabschluss nur <code>list</code> mit einer unveränderbaren
Referenz erfasst, weil das die kleinste Zugriffmenge auf <code>list</code> ist, die
benötigt wird, um sie auszugeben. In diesem Beispiel müssen wir, obwohl der
Funktionsabschluss-Rumpf nur eine unveränderbare Referenz benötigt, angeben,
dass <code>list</code> in den Funktionsabschluss verschoben werden soll, indem wir das
Schlüsselwort <code>move</code> an den Anfang der Funktionsabschlussdefinition setzen.
Der neue Strang könnte beendet werden, bevor der Rest des Hauptstrangs beendet
wird, oder der Hauptstrang könnte zuerst beendet werden. Wenn der Hauptstrang
die Eigentümerschaft von <code>list</code> beibehält, aber vor dem neuen Strang endet und
<code>list</code> aufräumt, wäre die unveränderbare Referenz im Strang ungültig. Daher
verlangt der Compiler, dass <code>list</code> in den Funktionsabschluss im neuen Strang
verschoben wird, damit die Referenz gültig bleibt. Versuche, das Schlüsselwort
<code>move</code> zu entfernen oder <code>list</code> im Hauptstrang zu verwenden, nachdem der
Funktionsabschluss definiert wurde, um zu sehen, welche Compilerfehler du
erhältst!</p>
<h3 id="verschieben-erfasster-werte-aus-funktionsabschlüssen-und-fn-merkmalen"><a class="header" href="#verschieben-erfasster-werte-aus-funktionsabschlüssen-und-fn-merkmalen">Verschieben erfasster Werte aus Funktionsabschlüssen und <code>Fn</code>-Merkmalen</a></h3>
<p>Sobald ein Funktionsabschluss eine Referenz oder die Eigentümerschaft eines
Werts aus der Umgebung, in der der Funktionsabschluss definiert ist, erfasst
hat (und damit beeinflusst, was <em>in</em> den Funktionsabschluss verschoben wird),
definiert der Code im Rumpf des Funktionsabschlusses, was mit den Referenzen
oder Werten passiert, wenn der Funktionsabschluss später ausgewertet wird (und
damit beeinflusst, was <em>aus</em> dem Funktionsabschluss verschoben wird). Ein
Funktionsabschluss-Rumpf kann eine der folgenden Aktionen ausführen: Einen
erfassten Wert aus dem Funktionsabschluss herausbewegen, den erfassten Wert
verändern, den Wert weder bewegen noch verändern oder zunächst nichts aus der
Umgebung erfassen.</p>
<p>Die Art und Weise, wie ein Funktionsabschluss Werte aus der Umgebung erfasst
und verarbeitet, wirkt sich darauf aus, welche Merkmale (traits) der
Funktionsabschluss implementiert, und mit Hilfe von Merkmalen können Funktionen
und Strukturen angeben, welche Arten von Funktionsabschlüssen sie verwenden
können. Funktionsabschlüsse implementieren automatisch eine, zwei oder alle
drei dieser <code>Fn</code>-Merkmale, und zwar in additiver Weise, je nachdem, wie der
Rumpf des Funktionsabschlusses die Werte behandelt:</p>
<ol>
<li><code>FnOnce</code> gilt für Funktionsabschlüsse, die einmal aufgerufen
werden können. Alle Funktionsabschlüsse implementieren zumindest dieses
Merkmal, weil alle Funktionsabschlüsse aufgerufen werden können. Ein
Funktionsabschluss, der erfasste Werte aus seinem Rumpf herausverschiebt,
implementiert nur <code>FnOnce</code> und keine der anderen <code>Fn</code>-Merkmale, weil er nur
einmal aufgerufen werden kann.</li>
<li><code>FnMut</code> gilt für Funktionsabschlüsse, die die erfassten Werte nicht aus
ihrem Rumpf herausverschieben, aber die erfassten Werte möglicherweise
verändern. Diese Funktionsabschlüsse können mehr als einmal aufgerufen
werden.</li>
<li><code>Fn</code> gilt für Funktionsabschlüsse, die die erfassten Werte nicht aus ihrem
Rumpf herausverschieben und die erfassten Werte nicht verändern, sowie
Funktionsabschlüsse, die nichts aus ihrer Umgebung erfassen. Diese
Funktionsabschlüsse können mehr als einmal aufgerufen werden, ohne ihre
Umgebung zu verändern, was wichtig ist, wenn z.B. ein Funktionsabschluss
mehrere Male gleichzeitig aufgerufen wird.</li>
</ol>
<p>Schauen wir uns die Definition der Methode <code>unwrap_or_else</code> auf <code>Option&lt;T&gt;</code> an,
die wir in Codeblock 13-1 verwendet haben:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Erinnere dich, dass <code>T</code> der generische Typ ist, der den Typ des Wertes in der
<code>Some</code>-Variante einer <code>Option</code> darstellt. Dieser Typ <code>T</code> ist auch der
Rückgabetyp der Funktion <code>unwrap_or_else</code>: Code, der <code>unwrap_or_else</code> auf einer
<code>Option&lt;String&gt;</code> aufruft, erhält zum Beispiel einen <code>String</code>.</p>
<p>Als Nächstes ist zu beachten, dass die Funktion <code>unwrap_or_else</code> den
zusätzlichen generischen Typ-Parameter <code>F</code> hat. Der Typ <code>F</code> ist der Typ des
Parameters namens <code>f</code>, der der Funktionsabschluss ist, den wir beim Aufruf von
<code>unwrap_or_else</code> bereitstellen.</p>
<p>Die für den generischen Typ <code>F</code> spezifizierte Merkmalsabgrenzung ist <code>FnOnce() -&gt; T</code>, was bedeutet, dass <code>F</code> mindestens einmal aufgerufen werden können muss,
keine Argumente annimmt und ein <code>T</code> zurückgeben muss. Die Verwendung von
<code>FnOnce</code> in der Merkmalsabgrenzung drückt die Einschränkung aus, dass
<code>unwrap_or_else</code> <code>f</code> höchstens ein Mal aufrufen wird. Im Rumpf von
<code>unwrap_or_else</code> können wir sehen, dass, wenn die <code>Option</code> <code>Some</code> ist, <code>f</code>
nicht aufgerufen wird. Wenn die <code>Option</code> <code>None</code> ist, wird <code>f</code> einmal
aufgerufen. Da alle Funktionsabschlüsse <code>FnOnce</code> implementieren, akzeptiert
<code>unwrap_or_else</code> die unterschiedlichsten Arten von Funktionsabschlüssen und ist
so flexibel wie nur möglich.</p>
<blockquote>
<p>Anmerkung: Funktionen können auch alle drei <code>Fn</code>-Merkmale implementieren.
Wenn das, was wir tun wollen, keine Erfassung eines Wertes aus der Umgebung
erfordert, können wir den Namen einer Funktion anstelle eines
Funktionsabschlüsses verwenden, bei dem wir etwas brauchen, das eine der
<code>Fn</code>-Markmale implementiert. Zum Beispiel könnten wir bei einem
<code>Option&lt;Vec&lt;T&gt;&gt;</code>-Wert <code>unwrap_or_else(Vec::new)</code> aufrufen, um einen neuen,
leeren Vektor zu erhalten, wenn der Wert <code>None</code> ist.</p>
</blockquote>
<p>Schauen wir uns nun die Standard-Bibliotheksmethode <code>sort_by_key</code> an, die auf
Anteilstypen (slices) definiert ist, um zu sehen, wie sie sich <code>unwrap_or_else</code>
unterscheidet und warum <code>sort_by_key</code> <code>FnMut</code> statt <code>FnOnce</code> für die
Mermalsabgrenzung verwendet. Der Funktionsabschluss erhält ein Argument, eine
Referenz auf das aktuelle Element im betrachteten Anteilstyp, und gibt einen
Wert vom Typ <code>K</code> zurück, der geordnet werden kann. Diese Funktion ist nützlich,
wenn man einen Anteilstyp nach einem bestimmten Attribut der einzelnen Elemente
sortieren will. In Codeblock 13-7 haben wir eine Liste von
<code>Rectangle</code>-Instanzen und benutzen <code>sort_by_key</code>, um sie nach ihrem
<code>width</code>-Attribut von niedrig nach hoch zu sortieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!(&quot;{:#?}&quot;, list);
}</code></pre></pre>
<p><span class="caption">Codeblock 13-7: Verwenden von <code>sort_by_key</code> um Rechtecke
nach ihrer Breite zu sortieren</span></p>
<p>Dieser Code gibt aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>Der Grund, warum <code>sort_by_key</code> so definiert ist, dass es einen
<code>FnMut</code>-Funktionsabschluss nimmt, ist, dass es den Funktionsabschluss mehrfach
aufruft: Einmal für jedes Element im Anteilstyp. Der Funktionsabschluss <code>|r| r.width</code> erfasst, verändert oder verschiebt nichts aus seiner Umgebung, sodass
er die Anforderungen der Merkmalsabgrenzung erfüllt.</p>
<p>Im Gegensatz dazu zeigt Codeblock 13-8 ein Beispiel für einen
Funktionsabschluss, der nur das Merkmal <code>FnOnce</code> implementiert, weil er einen
Wert aus der Umgebung verschiebt. Der Compiler lässt uns diesen
Funktionsabschluss nicht mit <code>sort_by_key</code> verwenden:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from(&quot;sort_by_key aufgerufen&quot;);

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!(&quot;{:#?}&quot;, list);
}</code></pre></pre>
<p><span class="caption">Listing 13-8: Versuch, einen <code>FnOnce</code>-Funktionsabschluss
mit <code>sort_by_key</code> zu verwenden</span></p>
<p>Dies ist ein ausgeklügelter, verworrener Weg (der nicht funktioniert), um zu
versuchen, die Anzahl der Aufrufe von <code>sort_by_key</code> beim Sortieren von <code>list</code>
zu zählen. Dieser Code versucht, diese Zählung durchzuführen, indem er <code>value</code>,
einen <code>String</code> aus der Umgebung des Funktionsabschlusses, in den
<code>sort_operations</code>-Vektor schiebt. Der Funktionsabschluss erfasst <code>value</code> und
verschiebt dann <code>value</code> aus dem Funktionsabschluss heraus, indem er die
Eigentümerschaft von <code>value</code> an den Vektor <code>sort_operations</code> überträgt. Dieser
Funktionsabschluss kann einmal aufgerufen werden; ein zweiter Aufruf würde nicht
funktionieren, da <code>value</code> nicht mehr in der Umgebung wäre, um erneut in
<code>sort_operations</code> verschoben zu werden! Daher implementiert dieser
Funktionsabschluss nur <code>FnOnce</code>. Wenn wir versuchen, diesen Code zu
kompilieren, erhalten wir die Fehlermeldung, dass <code>value</code> nicht aus dem
Funktionsabschluss verschoben werden kann, weil der Funktionsabschluss <code>FnMut</code>
implementieren muss:</p>
<pre><code class="language-console">$ cargo run
   Compiling playground v0.0.1 (/playground)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from(&quot;sort_by_key aufgerufen&quot;);
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
error: could not compile `playground` due to previous error
</code></pre>
<p>Der Fehler bezieht sich auf die Zeile im Funktionsabschluss-Rumpf, die <code>value</code>
aus der Umgebung verschiebt. Um dies zu beheben, müssen wir den Rumpf des
Funktionsabschlusses so ändern, dass er keine Werte aus der Umgebung
verschiebt. Um zu zählen, wie oft <code>sort_by_key</code> aufgerufen wird, ist es
einfacher, einen Zähler in der Umgebung zu halten und seinen Wert im
Funktionsabschluss-Rumpf zu erhöhen, um das zu berechnen. Der
Funktionsabschluss in Codeblock 13-9 funktioniert mit <code>sort_by_key</code>, weil er
nur eine veränderbare Referenz auf den <code>num_sort_operations</code>-Zähler erfasst
und daher mehr als einmal aufgerufen werden kann:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!(&quot;{:#?}, sortiert in {num_sort_operations} Operationen&quot;, list);
}</code></pre></pre>
<p><span class="caption">Listing 13-9: Verwenden eines
<code>FnMut</code>-Funktionsabschlusses mit <code>sort_by_key</code> ist erlaubt</span></p>
<p>Die <code>Fn</code>-Merkmale sind wichtig bei der Definition oder Verwendung von
Funktionen oder Typen, die Funktionsabschlüsse verwenden. Im nächsten Abschnitt
besprechen wir Iteratoren. Viele Iterator-Methoden nehmen
Funktionsabschluss-Argumente entgegen, also behalte diese Details von
Funktionsabschlüssen im Kopf, wenn wir weitermachen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="eine-reihe-von-elementen-verarbeiten-mit-iteratoren"><a class="header" href="#eine-reihe-von-elementen-verarbeiten-mit-iteratoren">Eine Reihe von Elementen verarbeiten mit Iteratoren</a></h2>
<p>Iteratoren ermöglichen dir, nacheinander eine Aufgabe für eine Folge von
Elementen auszuführen. Der Iterator ist für die Logik verantwortlich, die
Elemente zu durchlaufen und zu bestimmen, wann eine Sequenz beendet ist.
Durch die Verwendung von Iteratoren ist es nicht notwendig, diese Logik selbst
neu zu implementieren.</p>
<p>Die Iteratoren in Rust sind <em>faul</em> (lazy), das bedeutet, dass sie erst durch
Methodenaufrufe konsumiert werden müssen, um einen Effekt zu haben. Der
Programmcode in Codeblock 13-10 erstellt beispielsweise einen Iterator über die
Elemente im Vektor <code>v1</code> indem die in <code>Vec&lt;T&gt;</code> definierte Methode <code>iter</code>
aufgerufen wird. Dieser Programmcode macht nichts Sinnvolles.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-10: Einen Iterator erstellen</span></p>
<p>Der Iterator wird in der Variable <code>v1_iter</code> gespeichert. Sobald wir einen
Iterator erstellt haben, können wir ihn auf verschiedene Weise verwenden.
In Codeblock 3-5 in Kapitel 3 haben wir über ein Array iteriert, indem wir eine
<code>for</code>-Schleife verwendet haben, um einen Code für jedes Element auszuführen.
Unter der Haube wird dabei implizit ein Iterator erzeugt und dann konsumiert,
aber wir haben bis jetzt übersehen, wie das genau funktioniert.</p>
<p>In Codeblock 13-11 wird die Erstellung des Iterators von dessen Verwendung in
der <code>for</code>-Schleife getrennt. Wenn die <code>for</code>-Schleife unter Verwendung des
Iterators in <code>v1_iter</code> aufgerufen wird, wird jedes Element des Iterators in
einer Iteration der Schleife verwendet, die den jeweiligen Wert ausgibt.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Erhalten: {}&quot;, val);
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-11: Verwendung eines Iterators in einer
<code>for</code>-Schleife</span></p>
<p>In Sprachen, deren Standardbibliotheken Iteratoren nicht bereitstellen, würde
man diese Funktionalität bereitstellen, indem man eine Variable bei Index 0
startet und diese zum Indizieren im Vektor verwendet und den Wert der 
Indexvariable bei jedem Schleifendurchlauf erhöht bis die Gesamtzahl der
Elemente im Vektor erreicht ist.</p>
<p>Iteratoren übernehmen derartige Logik für dich und reduzieren dadurch sich
wiederholenden Code, der zusätzliche Fehlerquellen beinhalten kann. Iteratoren
geben dir mehr Flexibilität bei der Verwendung derselben Logik für viele
verschiedene Arten von Sequenzen, nicht nur für Datenstrukturen, die du wie
Vektoren indizieren kannst. Lass uns herausfinden, wie Iteratoren das
bewerkstelligen.</p>
<h3 id="das-merkmal-trait-iterator-und-die-methode-next"><a class="header" href="#das-merkmal-trait-iterator-und-die-methode-next">Das Merkmal (trait) <code>Iterator</code> und die Methode <code>next</code></a></h3>
<p>Alle Iteratoren implementieren ein Merkmal namens <code>Iterator</code> das in der
Standardbibliothek definiert ist. Die Definition dieses Merkmals sieht wie folgt
aus:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // Methoden mit Standardimplementierung wurden elidiert
}
<span class="boring">}</span></code></pre></pre>
<p>Beachte, dass in der Definition eine neue Syntax verwendet wird: <code>type Item</code> und
<code>Self::Item</code> die einen <em>zugeordneten Typ</em> (associated type) mit diesem Merkmal 
definieren. Wir werden zugeordnete Typen im Kapitel 19 besprechen. Im Moment
musst du nur wissen, dass dieser Programmcode bedeutet, dass die Implementierung
des <code>Iterator</code>-Merkmals erfordert, dass du auch einen <code>Item</code>-Typ definierst und
dieser <code>Item</code>-Typ im Rückgabetyp der <code>next</code>-Methode benutzt wird. Mit anderen
Worten wird der <code>Item</code>-Typ der vom Iterator zurückgegebene Typ sein.</p>
<p>Für das <code>Iterator</code>-Merkmal muss man bei der Implementierung nur eine Methode
definieren: Die <code>next</code>-Methode, die jeweils ein Element des Iterators verpackt
in <code>Some</code> zurückgibt und nach Beendigung der Iteration <code>None</code> zurückgibt.</p>
<p>Wir können für Iteratoren die <code>next</code>-Methode direkt aufrufen. Codeblock 13-12
zeigt, welche Werte bei wiederholten Aufrufen von <code>next</code> auf einen aus einem
Vektor erstellten Iterator zurückgegeben werden:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-12: Iterator mit der <code>next</code>-Methode
aufrufen</span></p>
<p>Beachte, dass wir <code>v1_iter</code> veränderbar (mutable) machen mussten: Beim Aufrufen
der <code>next</code>-Methode auf einen Iterator wird dessen interner Status geändert, der
verwendet wird, um festzustellen, wo sich der Iterator in der Sequenz befindet.
Mit anderen Worten <em>verbraucht</em> dieser Programmcode den Iterator. Jeder Aufruf
von <code>next</code> isst ein Element des Iterators auf. Als wir die <code>for</code>-Schleife
benutzten, mussten wir <code>v1_iter</code> nicht veränderbar machen, da dies schon hinter
den Kulissen geschah, als die Schleife die Eigentümerschaft (ownership) von
<code>v1_iter</code> übernahm.</p>
<p>Merke auch, dass die Werte, die wir von den Aufrufen von <code>next</code> erhalten,
unveränderbare Referenzen (immutable references) auf die Werte im Vektor sind.
Die <code>iter</code>-Methode erzeugt einen Iterator über unveränderbare Referenzen. Wenn
wir einen Iterator erzeugen möchten der die Eigentümerschaft von <code>v1</code> übernimmt
und angeeignete Werte (owned values) zurückgibt, können wir die
<code>into_iter</code>-Methode anstelle von <code>iter</code> benutzen, und wenn wir über veränderbare
Referenzen iterieren möchten, können wir <code>iter_mut</code> statt <code>iter</code> aufrufen.</p>
<h3 id="methoden-die-den-iterator-verbrauchen"><a class="header" href="#methoden-die-den-iterator-verbrauchen">Methoden die den Iterator verbrauchen</a></h3>
<p>Das <code>Iterator</code>-Merkmal verfügt über eine Vielzahl von Methoden, die in der
Standardbibliothek bereitgestellt werden. Du kannst dich über diese Methoden
informieren, indem du in der Standardbibliothek-API-Dokumentation (standard
library API documentation) nach dem <code>Iterator</code>-Merkmal suchst. Einige dieser
Methoden rufen in ihrer Definition die <code>next</code>-Methode auf, daher musst du die
<code>next</code>-Methode bei der Implementierung des <code>Iterator</code>-Merkmals einbauen.</p>
<p>Methoden die <code>next</code> aufrufen werden als <em>konsumierende Adapter</em> (consuming
adaptors) bezeichnet, da deren Aufruf den Iterator verbraucht. Ein Beispiel ist
die Methode <code>sum</code>, sie übernimmt die Eigentümerschaft des Iterators und
durchläuft die Elemente durch wiederholtes Aufrufen von <code>next</code>, wodurch der
Iterator verbraucht wird. Jedes Element wird während der Iteration zu einer
Summe hinzugefügt, die zurückgegeben wird, sobald die Iteration abgeschlossen
ist. Codeblock 13-13 enthält einen Test, der die <code>sum</code>-Methode veranschaulicht:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-13: Aufruf der <code>sum</code>-Methode um den Wert der
Summe aller Elemente zu erhalten</span></p>
<p>Man kann <code>v1_iter</code> nach dem Aufruf von <code>sum</code> nicht verwenden, da <code>sum</code> die
Eigentümerschaft des Iterators übernimmt, auf dem sie aufgerufen wird.</p>
<h3 id="methoden-die-andere-iteratoren-erzeugen"><a class="header" href="#methoden-die-andere-iteratoren-erzeugen">Methoden die andere Iteratoren erzeugen</a></h3>
<p><em>Iterator-Adaptoren</em> sind Methoden, die auf dem Merkmal <code>Iterator</code> definiert
sind und den Iterator nicht verbrauchen. Stattdessen erzeugen sie andere
Iteratoren, indem sie einen Aspekt des ursprünglichen Iterators verändern.</p>
<p>Codeblock 13-14 zeigt ein Beispiel für den Aufruf der Iterator-Adaptor-Methode
<code>map</code>, die einen Funktionsabschluss für jedes Element aufruft, während die
Elemente durchlaufen werden. Die Methode <code>map</code> gibt einen neuen Iterator
zurück, der die geänderten Elemente erzeugt. Der Funktionsabschluss erzeugt
hier einen neuen Iterator, der jedes Element des Vektors um 1 erhöht:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-14: Aufruf des Iteratoradapters <code>map</code> um
einen neuen Iterator zu erzeugen</span></p>
<p>Dieser Code führt jedoch zu einer Warnung:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

warning: `iterators` (bin &quot;iterators&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>Der Programmcode in Codeblock 13-14 hat keine Wirkung, der Funktionsabschluss
wird nie aufgerufen. Die Warnung erinnert uns daran, dass Iteratoradapter faul
sind und dass wir den Iterator verwenden müssen, um etwas zu bewirken.</p>
<p>Um das zu beheben, werden wir die <code>collect</code>-Methode verwenden, die wir im Kapitel
12 mit <code>env::args</code> im Codeblock 12-1 benutzt haben. Diese Methode konsumiert den
Iterator und sammelt die Ergebniswerte in einen Kollektionsdatentyp (collection
data type).</p>
<p>In Codeblock 13-15 sammeln wir die Resultate der Iterationen über den Iterator,
der vom Aufruf der <code>map</code>-Methode zurückgegeben wird, in einem Vektor. Dieser
Vektor wird dann alle Elemente vom Originalvektor erhöht um 1 beinhalten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-15: Aufruf der <code>map</code>-Methode um einen
Iterator zu erzeugen und anschließend der <code>collect</code>-Methode um den
Iterator zu verbrauchen und einen Vektor zu erzeugen</span></p>
<p>Da <code>map</code> einen Funktionsabschluss als Parameter annimmt, können wir eine
beliebige Operation spezifizieren, die wir auf jedes Element anwenden wollen.
Dies ist ein gutes Beispiel dafür, wie man mit Funktionsabschlüssen ein
Verhalten anpassen kann, während das vom <code>Iterator</code>-Merkmal bereitgestellte 
Iterationsverhalten wiederverwendet wird.</p>
<p>Du kannst mehrere Aufrufe von Iterator-Adaptoren verketten, um komplexe
Aktionen auf lesbare Weise durchzuführen. Da jedoch alle Iteratoren faul sind,
musst du eine der konsumierenden Adaptermethoden aufrufen, um Ergebnisse aus
Aufrufen von Iteratoradaptern zu erhalten.</p>
<h3 id="verwendung-von-funktionsabschlüssen-die-ihre-umgebung-erfassen"><a class="header" href="#verwendung-von-funktionsabschlüssen-die-ihre-umgebung-erfassen">Verwendung von Funktionsabschlüssen die ihre Umgebung erfassen</a></h3>
<p>Viele Iterator-Adapter nehmen Funktionsabschlüsse als Argumente, und in der
Regel werden diese Funktionsabschlüsse solche sein, die ihre Umgebung erfassen.</p>
<p>In diesem Beispiel verwenden wir die Methode <code>filter</code>, die einen
Funktionsabschluss entgegennimmt. Der Funktionsabschluss holt ein Element aus
dem Iterator und gibt ein <code>bool</code> zurück. Wenn der Funktionsabschluss <code>true</code>
zurückgibt, wird der Wert in die von <code>filter</code> erzeugte Iteration aufgenommen.
Wenn der Funktionsabschluss <code>false</code> zurückgibt, wird der Wert nicht
aufgenommen.</p>
<p>Im Codeblock 13-16 benutzen wir <code>filter</code> mit einem Funktionsabschluss, der die
Variable <code>shoe_size</code> aus seiner Umgebung erfasst, um über eine Kollektion von
<code>shoe</code>-Strukturinstanzen zu iterieren. Er wird nur Schuhe (shoes) einer
bestimmten Größe zurückgeben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from(&quot;sneaker&quot;),
            },
            Shoe {
                size: 13,
                style: String::from(&quot;sandal&quot;),
            },
            Shoe {
                size: 10,
                style: String::from(&quot;boot&quot;),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from(&quot;sneaker&quot;)
                },
                Shoe {
                    size: 10,
                    style: String::from(&quot;boot&quot;)
                },
            ]
        );
    }
}</code></pre>
<p><span class="caption">Codeblock 13-16: Die <code>filter</code>-Methode mit einen
Funktionsabschluss benutzen der <code>shoe_size</code> erfasst</span></p>
<p>Die <code>shoes_in_size</code>-Funktion übernimmt die Eigentümerschaft über einen Vektor
aus Schuhen mit der Schuhgröße als Parameter und gibt einen Vektor zurück, der
nur Schuhe einer bestimmten Größe enthält.</p>
<p>Im Funktionsrumpf von <code>shoes_in_size</code> rufen wir <code>into_iter</code> auf, um einen
Iterator zu erzeugen, der die Eigentümerschaft vom Vektor übernimmt. Im Anschluss
rufen wir den <code>filter</code>-Adapter auf, um einen neuen Iterator zu erzeugen, der nur
Elemente enthält, für die der Funktionsabschluss <code>true</code> zurückgibt.</p>
<p>Der Funktionsabschluss erfasst den <code>shoe_size</code>-Parameter aus seiner Umgebung und
vergleicht dessen Wert mit der jeweiligen Schuhgröße und behält nur Schuhe der
gewählten Größe. Zuletzt sammelt der Aufruf der <code>collect</code>-Methode die
zurückgegeben Werte des angeschlossenen Adapters in den Vektor, der von der
Funktion zurückgegeben wird.</p>
<p>Der Test zeigt, wenn wir <code>shoes_in_size</code> aufrufen, bekommen wir nur Schuhe
der spezifizierten Größe zurück.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unser-ea-projekt-verbessern"><a class="header" href="#unser-ea-projekt-verbessern">Unser E/A-Projekt verbessern</a></h2>
<p>Mit diesem Wissen über Iteratoren können wir unser E/A-Projekt in Kapitel 12
verbessern. Wir werden Bereiche im Code klarer und prägnanter gestalten. Lass
uns herausfinden wie Iteratoren unsere Implementierung der
Funktion <code>Config::build</code> und der Funktion <code>search</code> optimieren können.</p>
<h3 id="ein-clone-durch-verwendung-eines-iterators-entfernen"><a class="header" href="#ein-clone-durch-verwendung-eines-iterators-entfernen">Ein <code>clone</code> durch Verwendung eines Iterators entfernen</a></h3>
<p>Im Codeblock 12-6 haben wir Programmcode hinzugefügt, der einen Anteilstyp
(slice) von <code>Zeichenketten</code>-Werten (String values) nimmt, und erzeugten eine
<code>Config</code>-Struktur indem wir den Anteilstyp indexierten und die Werte klonten
und der <code>Config</code>-Struktur die Eigentümerschaft dieser Werte gaben. Im Codeblock
13-17 haben wir die Implementierung der Funktion <code>Config::build</code> so reproduziert 
wie sie im Codeblock 12-23 aussah:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;nicht genügend Argumente&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_err();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-17: Reproduktion der <code>Config::build</code>-Funktion
vom Codeblock 12-23</span></p>
<p>Zu diesem Zeitpunkt sagten wir, dass man sich keine Gedanken wegen der
ineffizienten <code>clone</code>-Aufrufe machen soll, da sie zu einem späteren Zeitpunkt
entfernt werden. Jetzt ist es an der Zeit, dass wir uns darum kümmern!</p>
<p>Wir haben <code>clone</code> benutzt, da wir einen Anteilstyp mit <code>String</code>-Elementen im
Parameter <code>args</code> haben, ab die Funktion <code>build</code> besitzt <code>args</code> nicht. Um die
Eigentümerschaft einer <code>Config</code>-Instanz zurückzugeben, mussten wir die Werte
aus den Feldern <code>query</code> und <code>file_path</code> von <code>Config</code> klonen, damit die
<code>Config</code>-Instanz ihre Werte besitzen kann.</p>
<p>Mithilfe unserer neuen Kenntnisse über Iteratoren können wir die Funktion
<code>build</code> so ändern, dass sie die Eigentümerschaft eines Iterators als Argument
nimmt anstatt sich einen Anteilstyp auszuleihen. Wir werden die
<code>Iterator</code>-Funktionalität benutzen und nicht mehr den Programmcode der die
Länge des Anteilstyps überprüft und an bestimmte Stellen indiziert. Dadurch
wird deutlich, was die Funktion <code>Config::build</code> bewirkt, da der Iterator auf
Werte zugreift.</p>
<p>Sobald <code>Config::build</code> die Eigentümerschaft des Iterators hat und keine
ausleihenden Indexierungsoperationen mehr verwendet, können wir die
<code>String</code>-Werte vom <code>Iterator</code> in <code>Config</code> verschieben anstatt <code>clone</code>
aufzurufen und eine neue Zuweisung vorzunehmen.</p>
<h4 id="direktes-verwenden-des-zurückgegebenen-iterators"><a class="header" href="#direktes-verwenden-des-zurückgegebenen-iterators">Direktes Verwenden des zurückgegebenen Iterators</a></h4>
<p>Öffne die Datei <em>src/main.rs</em> deines E/A-Projekts, sie sollte so aussehen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem beim Parsen der Argumente: {err}&quot;);
        process::exit(1);
    });

    // --abschneiden--
<span class="boring">
</span><span class="boring">   if let Err(e) = minigrep::run(config) {
</span><span class="boring">       eprintln!(&quot;Anwendungsfehler: {e}&quot;);
</span><span class="boring">
</span><span class="boring">       process::exit(1);
</span><span class="boring">   }
</span>}</code></pre>
<p>Wir werden zuerst den Anfang der Funktion <code>main</code> von Codeblock 12-24 in den 
Programmcode im Codeblock 13-18 ändern, der dieses Mal einen Iterator
verwendet. Dieser Code wird erst kompilieren, wenn wir auch <code>Config::build</code>
abgeändert haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem beim Parsen der Argumente: {err}&quot;);
        process::exit(1);
    });

    // --abschneiden--
<span class="boring">  
</span><span class="boring">
</span><span class="boring">   if let Err(e) = minigrep::run(config) {
</span><span class="boring">       eprintln!(&quot;Anwendungsfehler: {e}&quot;);
</span><span class="boring">
</span><span class="boring">       process::exit(1);
</span><span class="boring">   }
</span>}</code></pre>
<p><span class="caption">Codeblock 13-18: Übergabe des Rückgabewerts von 
<code>env::args</code> an <code>Config::build</code></span></p>
<p>Die <code>env::arg</code>-Funktion gibt einen Iterator zurück! Anstatt die Werte des Iterators
in einem Vektor zu sammeln und dann einen Anteilstyp an <code>Config::build</code> zu
übergeben, geben wir nun die Eigentümerschaft des Iterators, der von <code>env::args</code>
zurückgegeben wird, direkt an <code>Config::build</code>.</p>
<p>Als Nächstes müssen wir die Definition von <code>Config::build</code> aktualisieren.
Ändere in der Datei <em>src/lib.rs</em> deines E/A-Projekts die Signatur von
<code>Config::build</code> um, damit sie so wie im Codeblock 13-26 aussieht. Dies wird
noch immer nicht kompilieren, da der Funktionsrumpf aktualisiert werden muss.</p>
<p><span class="filename">Dateiname src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">   pub query: String,
</span><span class="boring">   pub file_path: String,
</span><span class="boring">   pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --abschneiden--
<span class="boring">     
</span><span class="boring">       if args.len() &lt; 3 {
</span><span class="boring">           return Err(&quot;nicht genügend Argumente&quot;);
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">       let query = args[1].clone();
</span><span class="boring">       let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">       let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">       Ok(Config {
</span><span class="boring">           query,
</span><span class="boring">           file_path,
</span><span class="boring">           ignore_case,
</span><span class="boring">       })
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">   let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">   let results = if config.ignore_case {
</span><span class="boring">       search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">   } else {
</span><span class="boring">       search(&amp;config.query, &amp;contents)
</span><span class="boring">   };
</span><span class="boring">
</span><span class="boring">   for line in results {
</span><span class="boring">       println!(&quot;{line}&quot;);
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">   let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">   for line in contents.lines() {
</span><span class="boring">       if line.contains(query) {
</span><span class="boring">           results.push(line);
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">   query: &amp;str,
</span><span class="boring">   contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">   let query = query.to_lowercase();
</span><span class="boring">   let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">   for line in contents.lines() {
</span><span class="boring">       if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">           results.push(line);
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn case_sensitive() {
</span><span class="boring">       let query = &quot;duct&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn case_insensitive() {
</span><span class="boring">       let query = &quot;rUsT&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(
</span><span class="boring">           vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">           search_case_insensitive(query, contents)
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-19: Aktualisieren der Funktion
<code>Config::build</code> damit sie einen Iterator annimmt</span></p>
<p>Laut Dokumentation der Standardbibliothek für die Funktion <code>env::args</code> ist der
Typ des zurückgegebenen Iterators <code>std::env::Args</code>, und dieser Typ
implementiert das Merkmal <code>Iterator</code> und gibt <code>String</code>-Werte zurück.</p>
<p>Wir haben die Signatur der Funktion <code>Config::build</code> aktualisiert, sodass der
Parameter <code>args</code> einen generischen Typ mit den Merkmalsabgrenzungen <code>impl Iterator&lt;Item = String&gt;</code> anstelle von <code>&amp;[String]</code> hat. Diese Verwendung der
Syntax <code>impl Trait</code>, die wir im Abschnitt <a href="ch10-02-traits.html#merkmale-als-parameter">„Merkmale als
Parameter“</a> in Kapitel 10 besprochen haben, bedeutet, dass <code>args</code>
jeder Typ sein kann, der den Typ <code>Iterator</code> implementiert und <code>String</code>-Elemente
zurückgibt.</p>
<p>Da wir die Eigentümerschaft von <code>args</code> übernehmen und <code>args</code> beim Iterieren
verändern werden, können wir das Schlüsselwort <code>mut</code> in die Spezifikation des
Parameters <code>args</code> eintragen, um ihn veränderbar (mutable) zu machen.</p>
<h4 id="verwenden-von-iterator-merkmalen-anstelle-von-indizierung"><a class="header" href="#verwenden-von-iterator-merkmalen-anstelle-von-indizierung">Verwenden von <code>Iterator</code>-Merkmalen anstelle von Indizierung</a></h4>
<p>Als Nächstes werden wir den Rumpf von <code>Config::build</code> in Ordnung bringen. Da
<code>args</code> das Merkmal <code>Iterator</code> implementiert, wissen wir, dass wir die Methode
<code>next</code> darauf aufrufen können! Codeblock 13-20 aktualisiert den Code aus
Codeblock 12-23, um die <code>next</code>-Methode zu verwenden:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">   pub query: String,
</span><span class="boring">   pub file_path: String,
</span><span class="boring">   pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Keine Abfragezeichenkette erhalten&quot;),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Keinen Dateinamen erhalten&quot;),
        };

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_err();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">   let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">   let results = if config.ignore_case {
</span><span class="boring">       search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">   } else {
</span><span class="boring">       search(&amp;config.query, &amp;contents)
</span><span class="boring">   };
</span><span class="boring">
</span><span class="boring">   for line in results {
</span><span class="boring">       println!(&quot;{line}&quot;);
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">   let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">   for line in contents.lines() {
</span><span class="boring">       if line.contains(query) {
</span><span class="boring">           results.push(line);
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">   query: &amp;str,
</span><span class="boring">   contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">   let query = query.to_lowercase();
</span><span class="boring">   let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">   for line in contents.lines() {
</span><span class="boring">       if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">           results.push(line);
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn case_sensitive() {
</span><span class="boring">       let query = &quot;duct&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn case_insensitive() {
</span><span class="boring">       let query = &quot;rUsT&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(
</span><span class="boring">           vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">           search_case_insensitive(query, contents)
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-20: Ändern des Rumpfes von <code>Config::build</code> um
Iterator-Methoden zu verwenden</span></p>
<p>Beachte, dass der erste Wert des Rückgabewerts von <code>env::args</code> der Name des
Programms ist, wir wollen das ignorieren und rufen daher gleich <code>next</code> auf um
zum nächsten Wert zu gelangen und den ersten Rückgabewert zu überspringen. Als
Nächstes rufen wir <code>next</code> auf, um den Wert zu erhalten, den wir in das Feld <code>query</code>
von <code>Config</code> einfügen möchten. Falls <code>next</code> ein <code>Some</code> zurückgibt, benutzen wir
<code>match</code>, um den Wert zu extrahieren, wenn es jedoch <code>None</code> zurückgibt,
bedeutet dies, das nicht genügend Argumente eingegeben wurden und wir kehren
vorzeitig mit einem <code>Err</code> zurück. Dasselbe machen wir für den Wert <code>file_path</code>.</p>
<h3 id="programmcode-mit-iteratorenadapter-klarer-gestalten"><a class="header" href="#programmcode-mit-iteratorenadapter-klarer-gestalten">Programmcode mit Iteratorenadapter klarer gestalten</a></h3>
<p>Wir können die Vorteile der Iteratoren auch in der Funktion <code>search</code> unseres
E/A-Projekts nutzen, die hier im Codeblock 13-21 wiedergegeben, ist wie im
Codeblock 12-19:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">   pub query: String,
</span><span class="boring">   pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">   pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">       if args.len() &lt; 3 {
</span><span class="boring">           return Err(&quot;nicht genügend Argumente&quot;);
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">       let query = args[1].clone();
</span><span class="boring">       let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">       Ok(Config { query, file_path })
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">   let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">   Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn one_result() {
</span><span class="boring">       let query = &quot;duct&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-21: Implementierung der Funktion <code>search</code>
aus Codeblock 12-19</span></p>
<p>Wir können diesen Programmcode durch die Verwendung von Iteratoradaptern
prägnanter gestalten und vermeiden, einen veränderbaren Vektor <code>results</code> für
die Zwischenergebnisse zu haben. Bevorzugt wird im funktionalen Programmierstil
die Menge der veränderbaren Werte reduziert, um den Code übersichtlicher zu
machen. Das Entfernen des veränderbar-Status kann uns eventuell zukünftige
Verbesserungen ermöglichen, um die Suche parallel auszuführen, da wir uns nicht
um die Verwaltung des simultanen Zugriffs auf den Vektor <code>results</code> kümmern
müssen. Codeblock 13-22 zeigt diese Änderung:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">   pub query: String,
</span><span class="boring">   pub file_path: String,
</span><span class="boring">   pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">   pub fn build(
</span><span class="boring">       mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">   ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">       args.next();
</span><span class="boring">
</span><span class="boring">       let query = match args.next() {
</span><span class="boring">           Some(arg) =&gt; arg,
</span><span class="boring">           None =&gt; return Err(&quot;Keine Abfragezeichenkette erhalten&quot;),
</span><span class="boring">       };
</span><span class="boring">
</span><span class="boring">       let file_path = match args.next() {
</span><span class="boring">           Some(arg) =&gt; arg,
</span><span class="boring">           None =&gt; return Err(&quot;Keinen Dateinamen erhalten&quot;),
</span><span class="boring">       };
</span><span class="boring">
</span><span class="boring">       let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">       Ok(Config {
</span><span class="boring">           query,
</span><span class="boring">           file_path,
</span><span class="boring">           ignore_case,
</span><span class="boring">       })
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">   let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">   let results = if config.ignore_case {
</span><span class="boring">       search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">   } else {
</span><span class="boring">       search(&amp;config.query, &amp;contents)
</span><span class="boring">   };
</span><span class="boring">
</span><span class="boring">   for line in results {
</span><span class="boring">       println!(&quot;{line}&quot;);
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">   query: &amp;str,
</span><span class="boring">   contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">   let query = query.to_lowercase();
</span><span class="boring">   let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">   for line in contents.lines() {
</span><span class="boring">       if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">           results.push(line);
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn case_sensitive() {
</span><span class="boring">       let query = &quot;duct&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn case_insensitive() {
</span><span class="boring">       let query = &quot;rUsT&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(
</span><span class="boring">           vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">           search_case_insensitive(query, contents)
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 13-22: Verwendung von Iteratoradapter-Methoden
bei der Implementierung der Funktion <code>search</code></span></p>
<p>Denke daran, der Zweck der Funktion <code>search</code> besteht darin, alle Zeilen in
<code>contents</code> zurückzugeben, die die <code>query</code> enthalten. So ähnlich wie im Beispiel
<code>filter</code> im Codeblock 13-16 verwendet dieser Programmcode den <code>filter</code>-Adapter,
um nur die Zeilen beizubehalten, für die <code>line.contains(query)</code> den Wert <code>true</code> zurückgibt.
Wir sammeln dann die passenden Zeilen mit <code>collect</code> in einen anderen Vektor.
Viel einfacher! Nimm die gleiche Änderung vor, um Iteratormethoden auch in der
Funktion <code>search_case_insensitive</code> zu nutzen.</p>
<h3 id="zwischen-schleifen-und-iteratoren-wählen"><a class="header" href="#zwischen-schleifen-und-iteratoren-wählen">Zwischen Schleifen und Iteratoren wählen</a></h3>
<p>Die nächste logische Frage wäre, welchen Stil du in deinem eigenen Programmcode
wählen solltest und warum. Die ursprüngliche Implementierung im Codeblock 13-21
oder die Version die Iteratoren verwendet im Codeblock 13-22. Die meisten
Rust-Programmierer bevorzugen den Iterator-Stil. Zunächst ist es zwar
schwieriger, den Überblick zu behalten, aber sobald du ein Gefühl für die
verschiedenen Iteratoradapter und deren Funktionsweise hast, können Iteratoren 
einfacher zu verstehen sein. Statt mit verschiedensten Schleifen herumzuspielen
und Vektoren zu erstellen, konzentriert sich der Programmcode auf das höhere
Ziel der Schleife. Dadurch wird ein Teil des gewöhnlichen Programmcodes
abstrahiert und die einzigartigen Konzepte, z.B. die Filterbedingung die
jedes Element bestehen muss um durch den Iterator zu kommen, werden leichter
erkennbar.</p>
<p>Aber sind beide Implementierungen wirklich gleichwertig? Die intuitive Annahme
könnte sein, dass die weniger abstrakte Schleife schneller ist. Lass uns über
Performanz sprechen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="performanzvergleich-schleifen-vs-iteratoren"><a class="header" href="#performanzvergleich-schleifen-vs-iteratoren">Performanzvergleich: Schleifen vs. Iteratoren</a></h2>
<p>Um festzustellen, ob man besser Schleifen oder Iteratoren verwendet, solltest
du wissen, welche Implementierung schneller ist: Die Version der Funktion
<code>search</code> mit einer expliziten <code>for</code>-Schleife oder die Version mit Iteratoren.</p>
<p>Wir haben einen Benchmark durchführt, der den gesamten Inhalt von <em>The
Adventures of Sherlock Holmes</em> von Sir Arthur Conan Doyle in eine <code>Zeichenkette</code>
(String) lädt und nach dem Wort <em>the</em> im Inhalt sucht. Hier sind die
Ergebnisse des Benchmarks für die Version von <code>search</code> mit <code>for</code>-Schleife und
der Version die Iteratoren verwendet:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>Die Version mit Iteratoren war ein wenig schneller! Wir werden den Programmcode
des Benchmarks hier nicht erläutern, da es nicht darum geht, nachzuweisen, dass
die beiden Versionen gleichwertig sind, sondern einen allgemeinen Eindruck davon
zu bekommen, wie diese beiden Versionen im Bezug auf Performanz verglichen
werden.</p>
<p>Für einen umfassenderen Benchmark würde man verschiedene Texte
unterschiedlicher Größe als <code>contents</code>, verschiedene Wörter und Wörter
unterschiedlicher Länge als <code>query</code> verwenden und verschiedene Arten anderer
Variationen verwenden. Der Punkt ist folgender: Obwohl Iteratoren eine
hochrangige Abstraktion sind, werden sie ungefähr auf denselben Programmcode
kompiliert, als hättest du diesen selbst auf niedriger Ebene geschrieben.
Iteratoren sind eine von Rusts <em>Zero-Cost Abstraktionen</em>, damit ist gemeint,
dass die Verwendung keinen zusätzlichen Laufzeitaufwand verursacht. Dies
entspricht der Definition von <em>Zero-Overhead</em> in C++ von Bjarne Stroustrup in
&quot;Foundations of C++&quot; (2012):</p>
<blockquote>
<p>Im Allgemeinen folgen C++-Implementierungen dem Zero-Overhead-Prinzip: Was
du nicht verwendest, bezahlst du nicht. Und darüber hinaus: Was du verwendest,
hättest du von Hand nicht besser programmieren können.</p>
</blockquote>
<p>Als anderes Beispiel wird der folgende Programmcode eines Audiodecoders
übernommen. Der Decodierungsalgorithmus verwendet die mathematische Operation
der linearen Vorhersage (linear prediction), um zukünftige Werte aufgrund einer
linearen Funktion der vergangenen Abtastwerte zu schätzen. Der Programmcode
verwendet eine Iteratorkette, die drei Variablen im Gültigkeitsbereich
berechnet, einen Anteilstyp <code>buffer</code>, ein Array mit 12 <code>coefficients</code> und einen 
Wert um den die Daten die nach <code>glp_shift</code> verschoben werden sollen. Wir haben
die Variablen in diesem Beispiel deklariert, diesen jedoch keine Werte
zugewiesen, obwohl dieser Programmcode aus seinem Kontext gerissen keine große
Bedeutung hat, ist er dennoch ein gutes Beispiel dafür, wie Rust abstrakte Ideen
im Programmcode auf Code niedriger Ebene übersetzt.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}</code></pre>
<p>Um den Wert von <code>prediction</code> zu berechnen, durchläuft dieser Code jeden der 12
Werte in <code>coefficients</code> und verwendet die Methode <code>zip</code>, um die Werte der
Koeffizienten mit den vorherigen 12 Werten in <code>buffer</code> zu paaren. Anschließend
multiplizieren wir die Werte jedes Paars miteinander, summieren alle
Ergebnisse und verschieben die Bits in der Summe um den Wert von <code>glp_shift</code> nach
rechts.</p>
<p>Bei Berechnungen in Anwendungen wie Audiodecodern wird die Performanz häufig
priorisiert. Hier erstellen wir einen Iterator mit zwei Adaptern und verbrauchen
dann den Wert. Zu welchen Assemblercode würde dieser Rustprogrammcode
kompiliert werden? Er würde auf denselben Programmcode kompiliert werden, als
hättest du das Programm selbst in Assemblersprache geschrieben. Es gibt keine
Schleife, die der Iteration über die Werte von <code>coefficients</code> entsprechen würde.
Rust weiß, dass es 12 Iterationen gibt und „rollt“ daher die Schleife ab.
<em>Abrollen</em> (unrolling) ist eine Optimierung, die den Mehraufwand (overhead) der
Steuerung der Schleife beseitigt und stattdessen sich wiederholenden
Programmcode für jede Iteration der Schleife generiert.</p>
<p>Alle Koeffizienten werden in Registern gespeichert, das bedeutet, dass der
Zugriff auf die Werte sehr schnell ist. Es gibt keine Begrenzungsprüfungen (bounds
checks) für den Zugriff auf Arrays zur Laufzeit. Durch diese Optimierungen, die
Rust anwenden kann, ist der resultierende Programmcode äußerst effizient. Nun,
da du das weißt, kannst du, ohne Angst zu haben, Funktionsabschlüsse und
Iteratoren verwenden! Sie lassen den Code abstrakter erscheinen, verursachen
aber keine Performanzeinbußen zur Laufzeit.</p>
<h2 id="zusammenfassung-12"><a class="header" href="#zusammenfassung-12">Zusammenfassung</a></h2>
<p>Funktionsabschlüsse und Iteratoren sind Rust-Funktionalitäten, die von Ideen der
funktionalen Programmierung inspiriert sind. Sie tragen zu Rusts Fähigkeit bei,
abstrakte Ideen bei guter Performanz zu ermöglichen. Die Implementierungen von
Iteratoren und Funktionsabschlüssen sind so, dass die Performanz der Laufzeit
nicht beeinträchtigt wird. Dies ist ein Teil von Rusts Ziel,
Zero-Cost-Abstraktionen zu ermöglichen.</p>
<p>Nachdem wir die Ausdruckskraft unseres E/A-Projekts verbessert haben, wollen
wir uns nun einige weitere Funktionalitäten von <code>cargo</code> ansehen, die uns helfen
werden, das Projekt mit der Welt zu teilen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mehr-über-cargo-und-cratesio"><a class="header" href="#mehr-über-cargo-und-cratesio">Mehr über Cargo und Crates.io</a></h1>
<p>Bisher haben wir nur die grundlegendsten Funktionalitäten von Cargo für das
Bauen (build), zum Ausführen und für das Testen unseres Programmcodes
verwendet, aber es kann noch vieles mehr. In diesem Kapitel werden einige der
fortgeschrittenen Funktionalitäten erläutern, um zu zeigen, wie man Folgendes
tun kann:</p>
<ul>
<li>Anpassen deines Bauvorgangs mit Freigabeprofilen (release profiles)</li>
<li>Veröffentlichen von Programmbibliotheken auf <a href="https://crates.io/">crates.io</a></li>
<li>Organisieren von großen Projekten mit Arbeitsbereichen (workspaces)</li>
<li>Installieren von Binärdateien (binaries) von <a href="https://crates.io/">crates.io</a></li>
<li>Cargo erweitern mit benutzerdefinierten Befehlen</li>
</ul>
<p>Cargo kann noch einiges mehr als die Funktionalität, die wir in diesem Kapitel
behandeln, eine vollständige Erklärung aller Funktionen findest du in seiner
<a href="https://doc.rust-lang.org/cargo/">Dokumentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="bauvorgang-anpassen-mit-freigabeprofilen-release-profiles"><a class="header" href="#bauvorgang-anpassen-mit-freigabeprofilen-release-profiles">Bauvorgang anpassen mit Freigabeprofilen (release profiles)</a></h2>
<p>In Rust sind <em>Freigabeprofile</em> vordefinierte, anpassbare Profile mit
unterschiedlichen Konfigurationen, durch die ein Programmierer mehr Kontrolle
über verschiedene Optionen zum Kompilieren von Programmcode hat. Jedes Profil
wird von den anderen unabhängig konfiguriert.</p>
<p>Cargo hat zwei Hauptprofile: Das Profil <code>dev</code>, das von Cargo verwendet wird, wenn
du <code>cargo build</code> ausführst, und das Profil <code>release</code>, das Cargo verwendet, wenn
<code>cargo build --release</code> ausgeführt wird. <code>dev</code> ist mit guten
Standardeinstellungen für die Entwicklung (development) definiert und <code>release</code>
hat gute Standardeinstellungen für Releasebuilds. <sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>Profilnamen die dir möglicherweise aus der Ausgabe beim Bauvorgang bekannt sind:</p>
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<p>Die Angaben <code>dev</code> und <code>release</code> sind diese verschiedenen Profile, die vom
Compiler verwendet werden.</p>
<p>Cargo hat Standardeinstellungen für jedes der Profile, die verwendet werden,
wenn du keine expliziten Abschnitte <code>[profile.*]</code> in der Datei <em>Cargo.toml</em> des
Projekts hast. Durch Hinzufügen eines Abschnitts <code>[profile.*]</code> für Profile, die
du anpassen möchtest, überschreibst du Teile der Standardeinstellungen. Hier
sind zum Beispiel die Standardwerte für die Einstellung <code>opt-level</code> der Profile
<code>dev</code> und <code>release</code>:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>Die Einstellung <code>opt-level</code> steuert die Anzahl der Optimierungen, die Rust auf
den Programmcode anwendet, in einem Bereich 0 bis 3. Das Anwenden zusätzlicher
Optimierungen verlängert die Kompilierzeit. Wenn man in der Entwicklung häufig
den Programmcode kompiliert, wünscht man zumeist weniger Optimierungen, um
schneller zu kompilieren, auch wenn dadurch der resultierende Programmcode
langsamer ausgeführt wird. Das Standard-<code>opt-level</code> für <code>dev</code> ist daher <code>0</code>.
Wenn du bereit bist, deinen Programmcode zu veröffentlichen, ist es besser,
wenn das Kompilieren mehr Zeit benötigt, man wird nur einmal im Releasemodus
kompilieren, aber das Programm oft ausführen, daher tauscht der Releasemodus
eine längere Kompilierzeit gegen Programmcode, der schneller ausgeführt wird.
Aus diesem Grund ist das standardmäßige <code>opt-level</code> für das Profil <code>release</code>
<code>3</code>.</p>
<p>Du kannst eine Standardeinstellung überschreiben, indem du dafür in
<em>Cargo.toml</em> einen anderen Wert hinzufügst. Wenn wir zum Beispiel die
Optimierungsstufe 1 im Entwicklungsprofil verwenden möchten, können wir diese
beiden Zeilen in die Datei <em>Cargo.toml</em> unseres Projekts hinzufügen:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>Dieser Code überschreibt die Standardeinstellung von <code>0</code>. Wenn wir nun <code>cargo build</code> ausführen, verwendet Cargo die Standardeinstellung für das Profil <code>dev</code>
sowie unsere Anpassung <code>1</code> für <code>opt-level</code>. Cargo wird mehr Optimierungen
vornehmen als mit Standardeinstellungen, aber weniger als bei einem
Releasebuild.</p>
<p>Eine vollständige Liste der Konfigurationsoptionen und Standardeinstellungen für
jedes Profil findest du in <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargos Dokumentation</a>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><strong>Release</strong>: Veröffentlichung, <strong>Build</strong>: Kompilierter Quelltext</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kisten-crate-auf-cratesio-veröffentlichen"><a class="header" href="#kisten-crate-auf-cratesio-veröffentlichen">Kisten (crate) auf crates.io veröffentlichen</a></h2>
<p>Wir haben Pakete von <a href="https://crates.io/">crates.io</a> als
Abhängigkeiten (dependencies) unseres Projekts verwendet. Du kannst deinen
Programmcode jedoch auch für andere Personen freigeben, indem du eigene Pakete
veröffentlichst. Die Registrierung von Kisten auf <a href="https://crates.io/">crates.io</a>
verteilt den Quellcode deiner Pakete, daher wird primär Open Source Programmcode
gehostet.</p>
<p>Rust und Cargo verfügen über Funktionalitäten, die es Benutzern erleichtern, ihr
veröffentlichtes Paket zu finden und zu verwenden. Wir werden nun über einige
dieser Funktionalitäten sprechen und dann erklären, wie ein Paket veröffentlicht
wird.</p>
<h3 id="sinnvolle-dokumentationskommentare-erstellen"><a class="header" href="#sinnvolle-dokumentationskommentare-erstellen">Sinnvolle Dokumentationskommentare erstellen</a></h3>
<p>Die genaue Dokumentation deiner Pakete hilft anderen Benutzern zu verstehen,
wie diese zu verwenden sind, daher lohnt es sich, Zeit in das Schreiben von
Dokumentationen zu investieren. In Kapitel 3 haben wir besprochen, wie man
Rust-Code mit zwei Schrägstrichen <code>//</code> kommentiert. Rust hat auch eine eigene
Art von Kommentar für die Dokumentation, die passenderweise als
<em>Dokumentationskommentar</em> bezeichnet wird und HTML-Dokumentation generiert.
Der HTML-Code zeigt den Inhalt von Dokumentationskommentaren für öffentliche
API-Elemente an, die für Programmierer bestimmt sind, die wissen möchten,
wie deine Kiste <em>benutzt</em> wird, und nicht, wie deine Kiste <em>implementiert</em>
ist.</p>
<p>Dokumentationskommentare verwenden drei Schrägstriche <code>///</code> anstelle von zwei
und unterstützen Markdown-Notation zum Formatieren des Textes. Platziere
Dokumentationskommentare nur vor dem zu dokumentierenden Element. Codeblock
14-1 zeigt Dokumentationskommentare für eine Funktion <code>add_one</code> in einer Kiste
mit dem Namen <code>my_crate</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given 
///
/// # Examples 
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p><span class="caption">Codeblock 14-1: Ein Dokumentationskommentar für eine Funktion</span> </p>
<p>Hier geben wir eine Beschreibung der Funktionsweise der Funktion <code>add_one</code> an,
beginnen einen Abschnitt mit der Überschrift <code>Examples</code> gefolgt vom
Programmcode, der die Verwendung der Funktion <code>add_one</code> demonstriert. Wir können
die HTML-Dokumentation aus diesem Dokumentationskommentar generieren, indem wir
<code>cargo doc</code> ausführen. Dieser Befehl führt das mit Rust verbreitete Werkzeug
<code>rustdoc</code> aus und legt die generierte HTML-Dokumentation im Verzeichnis
<em>target/doc</em> ab.</p>
<p>Wenn du <code>cargo doc --open</code> ausführst, wird der HTML-Code für die Dokumentation
deiner aktuellen Kiste (und auch die Dokumentation aller Abhängigkeiten
(dependencies) deiner Kiste) erstellt und das Ergebnis in einem Webbrowser
geöffnet. Wenn du zur Funktion <code>add_one</code> navigierst, wirst du sehen wie der Text
in den Dokumentationskommentaren gerendert wird. Siehe Abbildung 14-1:</p>
<img alt="Gerenderte HTML-Dokumentation für die Funktion `add_one` von `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Abbildung 14-1: HTML-Dokumentation für die Funktion
<code>add_one</code></span></p>
<h4 id="häufig-verwendete-abschnitte"><a class="header" href="#häufig-verwendete-abschnitte">Häufig verwendete Abschnitte</a></h4>
<p>Wir haben die Markdown-Überschrift <code># Examples</code> in Codeblock 14-1 verwendet um
einen Abschnitt im HTML-Code mit dem Titel <code>Examples</code> zu erstellen. Hier sind
einige andere Abschnitte, die Autoren von Kisten häufig in ihrer Dokumentation
verwenden:</p>
<ul>
<li><strong>Panics</strong>: Die Szenarien, in denen die dokumentierte Funktion <code>panic</code>
aufruft. Anwender der Funktion, die nicht möchten, dass ihre Programme
<code>panic</code> aufrufen, sollten sicherstellen, dass sie die Funktion in solchen
Situationen nicht aufrufen.</li>
<li><strong>Errors</strong>: Wenn die Funktion einen Typ <code>Result</code> zurückgibt, der die Arten von
Fehlern die auftreten können beschreibt und unter welchen Bedingungen diese
Fehler auftreten können, dies kann für Aufrufende hilfreich sein, um
Programmcode zu schreiben der die verschiedenen Arten von Fehlern auf
unterschiedliche Art behandelt.</li>
<li><strong>Safety</strong>: Wenn die Funktion aufzurufen unsicher (<code>unsafe</code>) ist (wir
behandeln die Unsicherheit im Kapitel 19), sollte ein Abschnitt existieren,
in dem erläutert wird, warum die Funktion unsicher ist, und die Invarianten
behandelt werden die die Funktion vom Aufrufenden erwartet.</li>
</ul>
<p>Die meisten Dokumentationskommentare benötigen nicht alle Abschnitte, aber dies
ist eine gute Checkliste um dich an die Aspekte deines Programmcodes erinnern,
die für Benutzer interessant sein werden.</p>
<h4 id="dokumentationskommentare-als-tests"><a class="header" href="#dokumentationskommentare-als-tests">Dokumentationskommentare als Tests</a></h4>
<p>Das Hinzufügen von Beispiel-Codeblöcken in deinen Dokumentationskommentaren kann
dabei hilfreich sein, die Verwendung deiner Programmbibliothek darzustellen.
Dies hat einen zusätzlichen Bonus: Das Ausführen von <code>cargo test</code> führt die
Codeblöcke in deiner Dokumentation als Test aus! Nichts ist besser als eine
Dokumentation mit Beispielen, aber nichts ist schlimmer als eine Dokumentation
mit Beispielen die nicht funktionieren, da sich der Code seit dem Schreiben der
Dokumentation geändert hat. Wenn wir <code>cargo test</code> für die Dokumentation der
Funktion <code>add_one</code> aus Codeblock 14-1 aufrufen, sehen wir folgenden Abschnitt in
den Testergebnissen:</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Wenn wir nun entweder die Funktion oder das Beispiel so ändern, dass <code>assert_eq!</code>
im Beispiel <code>panic</code> aufruft und erneut <code>cargo test</code> aufrufen, werden wir
bemerken, das <code>cargo test</code> feststellt, dass das Beispiel und der Code nicht
synchron miteinander sind!</p>
<h4 id="enthaltene-elemente-kommentieren"><a class="header" href="#enthaltene-elemente-kommentieren">Enthaltene Elemente kommentieren</a></h4>
<p>Der Stil des Dokumentationskommentars <code>//!</code> fügt dem Element, das die
Kommentare enthält, Dokumentation hinzu, anstatt den Elementen die auf die
Kommentare folgen Dokumentation hinzuzufügen. Wir verwenden diese
Dokumentationskommentare üblicherweise in der Wurzeldatei (laut Konvention
<em>src/lib.rs</em>) oder in einem Modul, um die Kiste oder das Modul als Ganzes zu
dokumentieren.</p>
<p>Um beispielsweise eine Dokumentation hinzuzufügen, die den Zweck der Kiste
<code>my_crate</code> beschreibt, die die Funktion <code>add_one</code> enthält, können wir am Anfang
der Datei <em>src/lib.rs</em> Dokumentationskommentare hinzufügen die mit <code>//!</code>
beginnen. Siehe Codeblock 14-2: </p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --abschneiden--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">   x + 1
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 14-2: Dokumentation für die gesamte
<code>my_crate</code>-Kiste</span></p>
<p>Beachte, dass nach der letzten Zeile, die mit <code>//!</code> beginnt, kein Programmcode
mehr vorhanden ist. Da wir die Kommentare mit <code>//!</code> anstatt <code>///</code> begonnen
haben, dokumentieren wir das Element, das diesen Kommentar enthält und nicht ein 
Element, das diesem Kommentar folgt. In diesem Fall ist dieses Element die
Datei <em>src/lib.rs</em>, dabei handelt es sich um das Wurzelverzeichnis der Kiste.
Diese Kommentare beschreiben die gesamte Kiste.</p>
<p>Wenn wir <code>cargo doc --open</code> ausführen, werden diese Kommentare auf der
Startseite der Dokumentation für <code>my_crate</code> angezeigt, oberhalb der Liste der
veröffentlichten Elemente in der Kiste. Siehe Abbildung 14-2:</p>
<img alt="Gerenderte HTML-Dokumentation mit einem Kommentar für die gesamte Kiste" src="img/trpl14-02.png" class="center" />
<p><span class="caption">Abbildung 14-2: Gerenderte Dokumentation für <code>my_crate</code>,
einschließlich des Kommentars, der die Kiste als Ganzes beschreibt</span></p>
<p>Dokumentationskommentare innerhalb von Elementen sind besonders nützlich, um
Kisten und Module zu beschreiben. Erkläre anhand dieser Informationen den
allgemeinen Zweck des Containers, damit seine Benutzer die Aufteilung der Kiste
besser verstehen können.</p>
<h3 id="mit-pub-use-eine-benutzerfreundliche-öffentliche-api-exportieren"><a class="header" href="#mit-pub-use-eine-benutzerfreundliche-öffentliche-api-exportieren">Mit <code>pub use</code> eine benutzerfreundliche öffentliche API exportieren</a></h3>
<p>Die Struktur deiner öffentlichen API spielt beim Veröffentlichen einer Kiste eine
wichtige Rolle. Personen, die deine Kiste verwenden, sind mit der Struktur weniger
vertraut als du und haben vielleicht Schwierigkeiten, die Teile zu finden,
die sie verwenden möchten, wenn deine Kiste eine große Modulhierarchie aufweist.</p>
<p>In Kapitel 7 wurde erläutert, wie wir unseren Programmcode mithilfe des
Schlüsselworts <code>mod</code> in Module organisieren, Elemente mit dem Schlüsselwort 
<code>pub</code> veröffentlichen und Elemente mit dem Schlüsselwort <code>use</code> in einen
Gültigkeitsbereich (scope) bringen. Die Struktur, die für dich während der
Entwicklung einer Kiste sinnvoll ist, ist für ihre Benutzer jedoch
möglicherweise nicht sehr benutzerfreundlich. Vielleicht möchtest du Strukturen
in einer Hierarchie mit mehreren Ebenen organisieren, aber Personen, die einen
Typ verwenden möchten, den du tief in der Hierarchie definiert hast, haben
möglicherweise Probleme, herauszufinden, ob dieser Typ vorhanden ist. Sie
könnten sich auch darüber ärgern, dass sie <code>use</code>
<code>my_crate::some_module::another_module::UsefulType;</code>
eingeben müssen anstatt <code>use</code> <code>my_crate::UsefulType;</code>.</p>
<p>Die gute Nachricht ist, dass du die interne Organisation nicht neu anordnen
musst, wenn sie für andere aus einer anderen Bibliothek <em>nicht</em> geeignet ist.
Stattdessen kannst du Elemente erneut exportieren, um mit <code>pub use</code> eine
veränderte öffentliche Struktur von deiner privaten Struktur zu erstellen.
Beim Re-Exportieren wird ein öffentliches Element an einem Speicherort genommen 
und an einem anderen Speicherort öffentlich gemacht, als ob es stattdessen am
anderen Speicherort definiert worden wäre.</p>
<p>Nehmen wir zum Beispiel an, wir haben eine Bibliothek mit dem Namen <code>art</code>
erstellt, um künstlerische Konzepte zu modellieren. In dieser Bibliothek sind
zwei Module enthalten: Ein Modul <code>kinds</code> mit zwei Aufzählungen (enums) namens
<code>PrimaryColor</code> und <code>SecondaryColor</code> und ein Modul <code>utils</code> das eine Funktion
namens <code>mix</code> beinhaltet. Siehe Codeblock 14-3:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --abschneiden--
<span class="boring">       unimplemented!();
</span>    }
}</code></pre>
<p><span class="caption">Codeblock 14-3: Eine Bibliothek <code>art</code> mit Elementen die in
Modulen <code>kinds</code> und <code>utils</code> organisiert sind</span></p>
<p>Abbildung 14-3 zeigt wie die Startseite der Dokumentation für diese Kiste
generiert von <code>cargo doc</code> aussehen würde.</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Abbildung 14-3: Startseite der Dokumentation für <code>art</code>
die Module <code>kinds</code> und <code>utils</code> auflistet</span></p>
<p>Beachte, dass die Typen <code>PrimaryColor</code>, <code>SecondaryColor</code> und die Funktion <code>mix</code>
nicht auf der Startseite angeführt sind. Wir müssen auf <code>kinds</code> und <code>utils</code>
klicken um sie zu sehen.</p>
<p>Eine Kiste, die von dieser Bibliothek abhängt, würde <code>use</code>-Anweisungen
benötigen, die die Elemente aus <code>art</code> in den Gültigkeitsbereich bringen und die
derzeit definierte Modulstruktur angeben. Codeblock 14-4 zeigt ein Beispiel für
eine Kiste, in der die Elemente <code>PrimaryColor</code> und <code>mix</code> aus der <code>art</code>-Kiste
verwendet werden:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
<p><span class="caption">Codeblock 14-4: Eine Kiste, die die Gegenstände der 
<code>art</code>-Kiste mit ihrer internen Struktur exportiert</span></p>
<p>Der Autor des Programmcodes in Codeblock 14-4, der die Kiste <code>art</code> verwendet,
musste herausfinden, dass sich <code>PrimaryColor</code> im Modul <code>kinds</code> und <code>mix</code> im Modul
<code>utils</code> befindet. Die Modulstruktur der <code>art</code>-Kiste ist für Entwickler, die an
der <code>art</code>-Kiste arbeiten, relevanter als für Entwickler die die <code>art</code>-Kiste
verwenden. Die interne Struktur enthält keine nützlichen Informationen für jemanden,
der diese benutzen möchte, sondern sorgt für Verwirrung, da diese herausfinden
müssen wo sie suchen müssen und die Struktur ist unpraktisch, da Entwickler die
Modulnamen in den <code>use</code>-Anweisungen angeben müssen.</p>
<p>Um die interne Organisation aus der öffentlichen API zu entfernen, können wir den
Programmcode der <code>art</code>-Kiste ändern, um <code>pub use</code>-Anweisungen hinzuzufügen, um
die Elemente der obersten Ebene erneut zu exportieren, wie in Codeblock 14-5
gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
   // --abschneiden--
<span class="boring">   /// The primary colors according to the RYB color model.
</span><span class="boring">   pub enum PrimaryColor {
</span><span class="boring">       Red,
</span><span class="boring">       Yellow,
</span><span class="boring">       Blue,
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   /// The secondary colors according to the RYB color model.
</span><span class="boring">   pub enum SecondaryColor {
</span><span class="boring">       Orange,
</span><span class="boring">       Green,
</span><span class="boring">       Purple,
</span><span class="boring">   }
</span>}

pub mod utils {
    // --abschneiden--
<span class="boring">   use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">   /// Combines two primary colors in equal amounts to create
</span><span class="boring">   /// a secondary color.
</span><span class="boring">   pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">       SecondaryColor::Orange
</span><span class="boring">   }
</span>}</code></pre>
<p><span class="caption">Codeblock 14-5: Hinzufügen von <code>pub use</code>-Anmerkungen um
Elemente erneut zu exportieren</span></p>
<p>Die Dokumentation der API, die von <code>cargo doc</code> generiert wurde, wird nun
aufgelistet und die erneut exportierten Links werden auf der Startseite, wie in
Abbildung 14-4 ersichtlich, angezeigt, so sind die Typen <code>PrimaryColor</code> und
<code>SecondaryColor</code> leichter zu finden.</p>
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
<p><span class="caption">Abbildung 14-4: Die Startseite der Dokumentation von
<code>art</code> mit den aufgelisteten erneuten Exporten</span></p>
<p>Die Benutzer der <code>art</code>-Kiste können weiterhin die interne Struktur aus Codeblock
14-3 sehen und verwenden, wie es in Codeblock 14-4 gezeigt wurde, oder sie
können die benutzerfreundliche Struktur in Codeblock 14-5 verwenden, wie es im
Codeblock 14-6 gezeigt wurde:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --abschneiden--
<span class="boring">   let red = PrimaryColor::Red;
</span><span class="boring">   let yellow = PrimaryColor::Yellow;
</span><span class="boring">   mix(red, yellow);
</span>}</code></pre>
<p><span class="caption">Codeblock 14-6: Ein Programm, das die erneut exportierten
Elemente der <code>art</code>-Kiste verwendet</span></p>
<p>In Fällen, in denen es viele verschachtelte Module gibt, kann das erneute 
Exportieren der Typen auf der obersten Ebene mit <code>pub use</code> die Erfahrung der
Benutzer der Kiste signifikant verbessern. Eine andere häufige Verwendung von
<code>pub use</code> ist es, Definitionen einer Abhängigkeit in der aktuellen Kiste zu
re-exportieren, um die Definitionen dieser Kiste zu einem Teil der öffentlichen
API deiner Kiste zu machen.</p>
<p>Das Erstellen einer sinnvollen öffentlichen API-Struktur ist eher eine Kunst als
eine Wissenschaft, und du kannst iterieren, um die API zu finden, die für
Benutzer am besten geeignet ist. Wenn man <code>pub use</code> wählt, erhält man
Flexibilität bei der internen Strukturierung einer Kiste und entkoppelt diese
interne Struktur von dem, was man ihren Benutzern präsentiert. Sieh dir 
einige der Programmcodes von Kisten an die du installiert hast, um festzustellen,
ob sie intern strukturiert sind und ob sich ihre interne Struktur von der
öffentlichen API unterscheidet.</p>
<h3 id="einrichten-eines-kontos-auf-cratesio"><a class="header" href="#einrichten-eines-kontos-auf-cratesio">Einrichten eines Kontos auf Crates.io</a></h3>
<p>Bevor man eine Kiste veröffentlichen kann, muss man ein Konto auf 
<a href="https://crates.io/">crates.io</a> erstellen um ein API-Token zu
erhalten. Besuche dazu die Homepage auf <a href="https://crates.io/">crates.io</a>
und melde dich über ein GitHub-Konto an. (Derzeit ist ein GitHub-Konto eine
Voraussetzung, aber die Seite wird möglicherweise in Zukunft andere Wege einen
Account zu erstellen ermöglichen.) Sobald du angemeldet bist, gehe zu
Kontoeinstellungen (account settings) auf 
<a href="https://crates.io/me/">https://crates.io/me/</a> und erhalte deinen 
API-Schlüssel. Rufe anschließend das Kommando <code>cargo login</code> mit deinem
API-Schlüssel auf:</p>
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<h3 id="metadaten-zu-einer-neuen-kiste-hinzufügen"><a class="header" href="#metadaten-zu-einer-neuen-kiste-hinzufügen">Metadaten zu einer neuen Kiste hinzufügen</a></h3>
<p>Angenommen, du hast eine Kiste, die du veröffentlichen möchtest. Vor dem
Veröffentlichen musst du deiner Kiste einige Metadaten im Abschnitt <code>[package]</code>
der Datei <em>Cargo.toml</em> der Kiste hinzufügen.</p>
<p>Deine Kiste benötigt einen eindeutigen Namen. Während du vor Ort an einer Kiste
arbeitest, kannst du eine Kiste beliebig benennen. Allerdings werden
Kistennamen auf <a href="https://crates.io/">crates.io</a> nach Verfügbarkeit vergeben. Sobald ein
Kistenname vergeben ist, kann niemand mehr eine Kiste mit diesem Namen
veröffentlichen. Suche vor dem Versuch, eine Kiste zu veröffentlichen, nach dem
Namen, den du verwenden möchtest. Wenn der Name von einer anderen Kiste
verwendet wurde, wirst du einen anderen Namen suchen müssen und das Feld <code>name</code>
in der Datei <em>Cargo.toml</em> im Abschnitt <code>[package]</code> bearbeiten, um den neuen
Namen für die Veröffentlichung zu verwenden:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>Selbst wenn du einen eindeutigen Namen gewählt hast, wird beim Ausführen von
<code>cargo publish</code> zum Veröffentlichen der Kiste an dieser Stelle eine Warnung und 
anschließend ein Fehler angezeigt:</p>
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--abschneiden--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<p>Dies schlägt fehlt, weile einige wichtige Informationen fehlen: Eine
Beschreibung und eine Lizenz sind erforderlich, damit die Benutzer wissen, was
deine Kiste tut und unter welchen Bedingungen man sie verwenden kann. Ergänze
in der Datei <em>Cargo.toml</em> eine Beschreibung hinzu, die nur ein oder zwei Sätze
umfasst, da sie zusammen mit deiner Kiste in den Suchergebnissen angezeigt
wird. Für das Feld <code>license</code> musst du einen <em>Lizenzkennungswert</em> (licence
identifier value) angeben. In <a href="http://spdx.org/licenses/">Linux Foundation's Software Package Data
Exchange (SPDX)</a> sind die Bezeichner aufgeführt, die Sie für diesen Wert
verwenden können. Um beispielsweise anzugeben, dass du deine Kiste mit der
MIT-Lizenz lizenziert hast, füge die <code>MIT</code>-Identifikation hinzu:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>Wenn man eine Lizenz verwenden möchte, die nicht in SPDX angezeigt wird, muss
man den Text dieser Lizenz in eine Datei einfügen, die Datei in das Projekt
aufnehmen und dann <code>license-file</code> verwenden um den Namen dieser Lizenz zu
spezifizieren anstelle der Verwendung des <code>license</code>-Schlüssels.</p>
<p>Die Anleitung, welche Lizenz für dein Projekt geeignet ist, geht über den
Rahmen dieses Buches hinaus. Viele Leute in der Rust-Gemeinschaft lizenzieren
ihre Projekte genauso wie Rust mit einer Doppellizenz von <code>MIT OR Apache-2.0</code>.
Diese Übung zeigt, dass man durch <code>OR</code> auch mehrere Lizenzkennungen getrennt
angeben kann, um mehrere Lizenzen für ein Projekt zu haben.</p>
<p>Mit einem eindeutigen Namen, der Version, deiner Beschreibung und einer
hinzugefügten Lizenz könnte die Datei <em>Cargo.toml</em> für ein Projekt, das zur
Veröffentlichung bereit ist, folgendermaßen aussehen:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargos documentation</a> beschreibt andere 
Metadaten, die du angeben kannst, um sicherzustellen, dass andere deine Kiste
leichter entdecken und verwenden können.</p>
<h3 id="veröffentlichen-auf-cratesio"><a class="header" href="#veröffentlichen-auf-cratesio">Veröffentlichen auf Crates.io</a></h3>
<p>Nachdem man ein Konto erstellt, den API-Token gespeichert, einen Namen für seine
Kiste ausgewählt und die erforderlichen Metadaten angegeben hat, kann man
sie veröffentlichen! Durch das Veröffentlichen einer Kiste wird eine bestimmte
Version auf <a href="https://crates.io/">crates.io</a> hochgeladen, damit andere sie verwenden können.</p>
<p>Sei vorsichtig, da eine Veröffentlichung <em>dauerhaft</em> ist. Die Version kann
niemals überschrieben und der Programmcode nicht gelöscht werden. Ein Hauptziel
von <a href="https://crates.io/">crates.io</a> ist es, als permanentes Archiv von Code zu fungieren,
sodass alle Projekte die erstellt werden und von Kisten aus <a href="https://crates.io/">crates.io</a>
abhängen weiter funktionieren werden. Das Zulassen von Versionslöschungen würde
das Erreichen dieses Ziels unmöglich machen. Die Anzahl der Kistenversionen,
die man veröffentlichen kann, ist jedoch unbegrenzt.</p>
<p>Rufe <code>cargo publish</code> erneut auf. Diesmal sollte es funktionieren:</p>
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Herzlichen Glückwunsch! Du hast deinen Programmcode nun für die
Rust-Gemeinschaft freigegeben. Jeder kann deine Kiste einfach als Abhängigkeit
für sein Projekt hinzufügen.</p>
<h3 id="veröffentlichen-einer-neuen-version-einer-vorhandenen-kiste"><a class="header" href="#veröffentlichen-einer-neuen-version-einer-vorhandenen-kiste">Veröffentlichen einer neuen Version einer vorhandenen Kiste</a></h3>
<p>Wenn du Änderungen an deiner Kiste vorgenommen hast und bereit bist, eine neue
Version zu veröffentlichen, ändere den in der <em>Cargo.toml</em>-Datei
angegebenen Versionswert und veröffentliche ihn erneut. Verwende die
<a href="https://semver.org/lang/de/">Regeln für die semantische Versionierung</a>, um auf den von dir 
vorgenommenen Änderungen basierend welche neue Versionsnummer geeignet ist.
Führe dann <code>cargo publish</code> aus, um die neue Version hochzuladen.</p>
<h3 id="mit-cargo-yank-versionen-auf-cratesio-als-veraltet-kennzeichnen"><a class="header" href="#mit-cargo-yank-versionen-auf-cratesio-als-veraltet-kennzeichnen">Mit <code>cargo yank</code> Versionen auf Crates.io als veraltet kennzeichnen</a></h3>
<p>Obwohl man frühere Versionen einer Kiste nicht entfernen kann, kann man
verhindern, dass zukünftige Projekte sie als neue Abhängigkeit hinzufügen. Dies
ist nützlich, wenn eine Kistenversion aus dem einen oder anderen Grund defekt
ist. In solchen Situationen unterstützt Cargo das <em>herausziehen</em> (yanking)
einer Kistenversion.</p>
<p>Durch das Herausziehen einer Version wird verhindert, dass neue Projekte von
dieser Version abhängen, während alle vorhandenen Projekte, die davon abhängen,
weiterhin heruntergeladen werden können. Im Wesentlichen bedeutet Herausziehen
(yank), dass alle Projekte mit einem <em>Cargo.lock</em> nicht kaputt gehen und
zukünftige generierte <em>Cargo.lock</em>-Dateien nicht die herausgezogene Version
verwenden.</p>
<p>Um eine Version einer Kiste herauszuziehen, rufe <code>cargo yank</code> auf und
spezifiziere welche Version du herausziehen möchtest. Wenn wir zum Beispiel
eine Kiste mit dem Namen <code>guessing_game</code> in Version 1.0.1 veröffentlicht haben
und sie löschen wollen, würden wir im Projektverzeichnis für <code>guessing_game</code>
folgendes ausführen:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>Durch Hinzufügen von <code>--undo</code>, kann man das Herausziehen rückgängig machen und
Projekten wieder erlauben von der Version abzuhängen:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>Das Herausziehen löscht <em>keinen</em> Programmcode. Es kann zum Beispiel keine
versehentlich hochgeladenen Geheimnisse löschen. Falls das passieren sollte
musst du diese Geheimnisse sofort zurücksetzen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-arbeitsbereiche"><a class="header" href="#cargo-arbeitsbereiche">Cargo-Arbeitsbereiche</a></h2>
<p>In Kapitel 12 haben wir ein Paket erstellt, das eine binäre Kiste und eine
Bibliothekskiste enthält. Während dein Projekt entwickelt wird, wirst du
möglicherweise feststellen, dass die Bibliothekskiste immer größer wird und du
dein Paket weiter in mehrere Bibliothekskisten aufteilen möchtest. Cargo bietet
eine Funktion namens <em>Arbeitsbereiche</em> (workspaces), mit denen mehrere
verwandte Pakete verwaltet werden können, die gemeinsam entwickelt werden.</p>
<h3 id="einen-arbeitsbereich-erstellen"><a class="header" href="#einen-arbeitsbereich-erstellen">Einen Arbeitsbereich erstellen</a></h3>
<p>Ein <em>Arbeitsbereich</em> ist eine Reihe von Paketen, die dieselbe Datei
<em>Cargo.lock</em> sowie dasselbe Ausgabeverzeichnis (output directory) verwenden.
Lass uns mithilfe eines Arbeitsbereiches ein Projekt erstellen. Wir verwenden
einfachen Programmcode, damit wir uns auf die Struktur des Arbeitsbereiches
konzentrieren können. Es gibt verschiedene Möglichkeiten, einen Arbeitsbereich
zu strukturieren. Wir werden nur einen einen üblichen Weg zeigen. Wir haben
einen Arbeitsbereich mit einer Binärdatei und zwei Bibliotheken. Die Binärdatei
stellt die Hauptfunktion bereit und hängt von den beiden Bibliotheken ab. Eine
Bibliothek stellt die Funktion <code>add_one</code> und die andere <code>add_two</code> zur
Verfügung. Diese drei Kisten werden Teil desselben Arbeitsbereichs sein.
Zunächst erstellen wir ein neues Verzeichnis für den Arbeitsbereich:</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>Als Nächstes erstellen wir im Verzeichnis <em>add</em> die Datei <em>Cargo.toml</em>, mit der
der gesamte Arbeitsbereich konfiguriert wird. Diese Datei enthält keine
Abschnitt <code>[package]</code>. Stattdessen beginnt sie mit einem Abschnitt
<code>[workspace]</code>, in dem wir Mitglieder zum Arbeitsbereich hinzufügen können,
indem wir den Pfad zum Paket mit unserer Binärkiste angeben. In diesem Fall
lautet dieser Pfad <em>adder</em>:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>Als nächstes erstellen wir die Binärkiste <code>adder</code>, indem wir <code>cargo new</code> im
Verzeichnis <em>add</em> ausführen:</p>
<pre><code class="language-console">$ cargo new adder
     Created binary (application) `adder` package
</code></pre>
<p>An dieser Stelle können wir den Arbeitsbereich erstellen, indem wir <code>cargo build</code>
ausführen. Die Dateien in deinem <em>add</em>-Verzeichnis sollten folgendermaßen
aussehen: </p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>Der Arbeitsbereich verfügt auf der obersten Ebene über ein <em>Zielverzeichnis</em> 
(target), in das die kompilierten Artefakte abgelegt werden; das Paket
<code>adder</code> hat kein eigenes <em>Zielverzeichnis</em>. Selbst wenn wir <code>cargo build</code> aus
dem Verzeichnis <em>adder</em> heraus ausführen würden, landen die kompilierten
Artefakte noch immer in <em>add/target</em> und nicht in <em>add/adder/target</em>. Cargo
strukturiert das <em>Zielverzeichnis</em> in einem derartigen Arbeitsverzeichnis, da
die Kisten voneinander abhängig sein sollen. Wenn jede Kiste ihr eigenes
<em>Zielverzeichnis</em> hätte, müssten für jede Kiste die anderen Kisten im
Arbeitsbereich neu kompiliert werden, damit die Artefakte ein eigenes
<em>Zielverzeichnis</em> haben könnten. Durch die gemeinsame Nutzung eines
Verzeichnisses können die Kisten unnötig wiederholte Erstellung vermeiden.</p>
<h3 id="erstellen-des-zweiten-pakets-im-arbeitsbereich"><a class="header" href="#erstellen-des-zweiten-pakets-im-arbeitsbereich">Erstellen des zweiten Pakets im Arbeitsbereich</a></h3>
<p>Als Nächstes erstellen wir ein weiteres, dem Arbeitsbereich zugehöriges Paket
und nennen es <code>add_one</code>. Ändere die auf der obersten Ebene befindliche Datei
<em>Cargo.toml</em> um den <em>add_one</em>-Pfad in der Mitgliederliste anzugeben:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add_one&quot;,
]
</code></pre>
<p>Dann erzeuge eine neue Bibliothekskiste namens <code>add_one</code>:</p>
<pre><code class="language-console">$ cargo new add_one --lib
     Created library `add_one` package
</code></pre>
<p>Dein <em>add</em>-Verzeichnis sollte nun so aussehen:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>Lass uns in der Datei <em>add_one/src/lib.rs</em>, eine Funktion <code>add_one</code> hinzufügen.</p>
<p><span class="filename">Dateiname: add_one/src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<p>Nun können wir das <code>adder</code>-Paket von unserem <code>add_one</code>-Paket, das unsere
Bibliothek enthält, abhängig machen. Zuerst müssen wir <em>adder/Cargo.toml</em>
einen Pfad zur Abhängigkeit von <code>add_one</code> hinzufügen.</p>
<p><span class="filename">Dateiname: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

add_one = { path = &quot;../add_one&quot; }
</code></pre>
<p>Cargo geht nicht davon aus, dass Kisten in einem Arbeitsbereich voneinander
abhängen, daher müssen wir die Abhängigkeit explizit angeben.</p>
<p>Als nächstes verwenden wir die Funktion <code>add_one</code> (aus der <code>add_one</code>-Kiste) in
der <code>adder</code>-Kiste. Öffne die Datei <em>adder/src/main.rs</em> und füge oben eine Zeile
<code>use</code> hinzu, um die neue Bibliothekskiste <code>add_one</code> in den Gültigkeitsbereich
(scope) zu bringen. Ändere dann die Funktion <code>main</code>, um die Funktion <code>add_one</code>
aufzurufen, siehe Codeblock 14-7.</p>
<p><span class="filename">Dateiname: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">use add_one;

fn main() {
    let num = 10;
    println!(
        &quot;Hello, world! {} plus one is {}!&quot;,
        num,
        add_one::add_one(num)
    );
}</code></pre>
<p><span class="caption">Codeblock 14-7: Die <code>add_one</code>-Bibliothekskiste aus der 
<code>adder</code>-Kiste verwenden</span></p>
<p>Erstellen wir den Arbeitsbereich, indem wir <code>cargo build</code> im obersten
Verzeichnis <em>add</em> ausführen!</p>
<pre><code class="language-console">$ cargo build
  Compiling add_one v0.1.0 (file:///projects/add/add_one)
  Compiling adder v0.1.0 (file:///projects/add/adder)
   Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<p>Um die Binärkiste aus dem Verzeichnis <em>add</em> auszuführen, können wir mithilfe des
Arguments <code>-p</code> und des Paketnamens mit <code>cargo run</code> angeben, welches Paket im
Arbeitsbereich ausgeführt werden soll:</p>
<pre><code class="language-console">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>Dadurch wird der Programmcode in <em>adder/src/main.rs</em> ausgeführt, der von der
Kiste <code>add_one</code> abhängt.</p>
<h4 id="abhängigkeiten-zu-externen-paketen-in-einem-arbeitsbereich"><a class="header" href="#abhängigkeiten-zu-externen-paketen-in-einem-arbeitsbereich">Abhängigkeiten zu externen Paketen in einem Arbeitsbereich</a></h4>
<p>Beachte, dass der Arbeitsbereich nur eine <em>Cargo.lock</em>-Datei auf der obersten
Ebene enthält, anstatt einer in jeder Kiste. Dies stellt sicher, dass alle
Kisten dieselbe Version aller Abhängigkeiten verwenden. Wenn wir das Paket
<code>rand</code> zu den Dateien <em>adder/Cargo.toml</em> und <em>add_one/Cargo.toml</em> hinzufügen,
löst Cargo beide dieser Versionen zu einer auf und fügt diese in der
<em>Cargo.lock</em>-Datei hinzu. Wenn alle Kisten im Arbeitsbereich dieselben
Abhängigkeiten verwenden, sind die Kisten immer miteinander kompatibel. Lass
uns die <code>rand</code>-Kiste in der Datei <em>add_one/Cargo.toml</em> zum Abschnitt
<code>[dependencies]</code> hinzufügen, damit wir die Kiste <code>rand</code> in der <code>add_one</code>-Kiste
verwenden können:</p>
<p><span class="filename">Dateiname: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.3&quot;
</code></pre>
<p>Wir können nun <code>use rand;</code> zur Datei <em>add_one/src/lib.rs</em> hinzufügen, und wenn
du den gesamten Arbeitsbereich durch Ausführen von <code>cargo build</code> im Verzeichnis
<em>add</em> erstellst, wird die Kiste <code>rand</code> eingefügt und kompiliert. Wir erhalten
eine Warnung, weil wir nicht auf <code>rand</code> referenzieren, das wir in den
Gültigkeitsbereich gebracht haben:</p>
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --abschneiden--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `add_one` (lib) generated 1 warning
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<p>Die <em>Cargo.lock</em>-Datei der obersten Ebene enthält nun Informationen über die
Abhängigkeit von <code>add_one</code> von <code>rand</code>. Obwohl <code>rand</code> irgendwo im Arbeitsbereich
verwendet wird, können wir es nicht in anderen Kisten im Arbeitsbereich
verwenden, es sei denn, wir fügen <code>rand</code> zu ihren <em>Cargo.toml</em>-Dateien hinzu.
Wenn wir beispielsweise <code>use rand;</code> zur Datei <em>adder/src/main.rs</em> für das Paket
<code>adder</code> hinzufügen, wird folgende Fehlermeldung angezeigt:</p>
<pre><code class="language-console">$ cargo build
  --abschneiden--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>Um dies zu beheben, bearbeiten wir die Datei <em>Cargo.toml</em> für das Paket <code>adder</code>
und geben an, dass <code>rand</code> auch eine Abhängigkeit davon ist. Durch das Erstellen
des Pakets <code>adder</code> wird <code>rand</code> zur Liste der Abhängigkeiten für <code>adder</code> in
<em>Cargo.lock</em> hinzugefügt, es werden jedoch keine zusätzlichen Kopien von <code>rand</code>
heruntergeladen. Cargo hat dafür gesorgt, dass jede Kiste in jedem Paket im
Arbeitsbereich, das das <code>rand</code>-Paket verwendet, die gleiche Version verwendet,
was uns Platz spart und sicherstellt, dass die Kisten im Arbeitsbereich
miteinander kompatibel sind.</p>
<h4 id="hinzufügen-eines-tests-zu-einem-arbeitsbereich"><a class="header" href="#hinzufügen-eines-tests-zu-einem-arbeitsbereich">Hinzufügen eines Tests zu einem Arbeitsbereich</a></h4>
<p>Füge für eine weitere Verbesserung innerhalb der <code>add_one</code>-Kiste einen Test der
Funktion <code>add_one::add_one</code> hinzu:</p>
<p><span class="filename">Dateiname: add_one/src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Führen wir nun <code>cargo test</code> in der obersten Ebene im Verzeichnis <em>add</em> aus. Die
Ausführung von <code>cargo test</code> in einem Arbeitsbereich, der wie dieser
strukturiert ist, führt die Tests für alle Kisten im Arbeitsbereich aus:</p>
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Der erste Abschnitt der Ausgabe zeigt, dass der Test <code>it_works</code> in der
<code>add_one</code>-Kiste bestanden wurde. Der nächste Abschnitt zeigt, dass in der Kiste
<code>adder</code> keine Tests gefunden wurden, und der letzte Abschnitt zeigt, dass in der
Kiste <code>add_one</code> keine Dokumentationstests gefunden wurden.</p>
<p>Wir können auch Tests für eine bestimmte Kiste in einem Arbeitsbereich aus dem
Verzeichnis der obersten Ebene ausführen, indem wir die Option <code>-p</code> verwenden und
den Namen der Kiste angeben, die wir testen möchten:</p>
<pre><code class="language-console">$ cargo test -p add_one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Die Ausgabe zeigt, dass <code>cargo test</code> nur die Tests für die Kiste <code>add_one</code> aber
nicht die <code>adder</code>-Tests ausgeführt hat.</p>
<p>Wenn du die Kisten im Arbeitsbereich unter <a href="https://crates.io/">crates.io</a>
veröffentlichst, muss jede Kiste im Arbeitsbereich separat veröffentlicht
werden. Der Befehl <code>cargo publish</code> hat kein Flag <code>--all</code> oder <code>-p</code>, daher musst
du in das Verzeichnis jeder Kiste wechseln und <code>cargo publish</code> auf jeder Kiste
im Arbeitsbereich ausführen, um die Kisten zu veröffentlichen.</p>
<p>Als zusätzliche Übung, füge ähnlich der Kiste <code>add_one</code> diesem Arbeitsbereich
eine <code>add-two</code>-Kiste hinzu!</p>
<p>Wenn dein Projekt wächst, solltest du einen Arbeitsbereich verwenden, es ist
einfacher kleinere, einzelne Komponenten zu verstehen, als ein großes
Programmcode-Objekt. Darüber hinaus kann die Verwaltung von Kisten in einem
Arbeitsbereich die Koordination zwischen Kisten erleichtern, wenn sie häufig
zur gleichen Zeit verändert werden.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installieren-von-binärdateien-mit--cargo-install"><a class="header" href="#installieren-von-binärdateien-mit--cargo-install">Installieren von Binärdateien mit  <code>cargo install</code></a></h2>
<p>Mit dem Befehl <code>cargo install</code> kannst du Binärkisten installieren und verwenden.
Dies soll keine Systempakete ersetzen, sondern soll Rust-Entwicklern eine
bequeme Möglichkeit bieten, Tools zu installieren, die andere auf
<a href="https://crates.io/">crates.io</a> veröffentlicht haben. Beachte,
dass du nur binäre Pakete installieren kannst, das heißt in der Kiste muss eine
Datei <em>src/main.rs</em> oder eine andere als binär spezifizierte Datei vorhanden
sein, und nicht nur eine Bibliothek, die alleine nicht ausführbar ist sondern zur 
Aufnahme in andere Programme geeignet ist. Für gewöhnlich enthalten Kisten eine
<em>README</em>-Datei mit Informationen darüber ob die Datei ausführbar ist, eine
Bibliothek enthält oder beides.</p>
<p>Alle mit <code>cargo install</code> installierten Binärdateien werden im Verzeichnis <em>bin</em> 
des Wurzelverzeichnisses der Installation gespeichert. Wenn du die Installation
mit <em>rustup.rs</em> durchgeführt und keine benutzerdefinierte Konfiguration
hast, lautet dieses Verzeichnis <code>$HOME/.cargo/bin</code>. Stelle sicher, dass sich
dieses Verzeichnis in deinem <code>$PATH</code> befindet, damit du Programme ausführen
kannst, die du mit <code>cargo install</code> installiert hast.</p>
<p>In Kapitel 12 haben wir beispielsweise erwähnt, dass es eine
Rust-Implementierung namens <code>ripgrep</code> des Werkzeugs <code>grep</code> zum Durchsuchen von
Dateien gibt. Um <code>ripgrep</code> zu installieren, führen wir Folgendes aus:</p>
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v13.0.0
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v13.0.0
--abschneiden--
   Compiling ripgrep v13.0.0
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
</code></pre>
<p>Die vorletzte Zeile der Ausgabe zeigt den Speicherort und den Namen der
installierten Binärdatei, der im Fall von <code>ripgrep</code> <code>rg</code> ist. Solange sich das
Installationsverzeichnis in deinem <code>$PATH</code> befindet, kannst du <code>rg --help</code>
ausführen und damit beginnen ein schnelleres, in Rust programmiertes
Werkzeug zum Durchsuchen von Dateien verwenden!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-um-benutzerdefinierte-befehle-erweitern"><a class="header" href="#cargo-um-benutzerdefinierte-befehle-erweitern">Cargo um benutzerdefinierte Befehle erweitern</a></h2>
<p>Cargo ist so konzipiert, dass man es mit neuen Unterbefehlen erweitern kann,
ohne Cargo ändern zu müssen. Wenn  in deinem <code>$PATH</code> eine Binärdatei
<code>cargo-something</code> benannt wird, kannst du sie wie einen Unterbefehl von Cargo
ausführen, indem du <code>cargo something</code> ausführst. Benutzerdefinierte Befehle wie
dieser werden auch aufgelistet, wenn du <code>cargo --list</code> ausführst. Die
Möglichkeit, mithilfe von <code>cargo install</code> Erweiterungen zu installieren und
diese dann wie die integrierten Werkzeuge von Cargo auszuführen, ist ein
äußerst praktischer Vorteil des Cargo-Designs!</p>
<h2 id="zusammenfassung-13"><a class="header" href="#zusammenfassung-13">Zusammenfassung</a></h2>
<p>Das veröffentlichen von Programmcode mit Cargo und <a href="https://crates.io/">crates.io</a> ist Teil
dessen, was das Rust-Ökosystem für viele verschiedene Aufgaben nützlich macht.
Die Standardbibliothek von Rust ist klein und stabil, aber Kisten können
einfach geteilt, verwendet und auf einer von der Sprache unterschiedlichen
Zeitlinie verbessert werden. Scheue dich nicht, Programmcode von 
<a href="https://crates.io/">crates.io</a>, der für dich nützlich ist, zu veröffentlichen. Es ist
wahrscheinlich, dass er auch für andere nützlich sein wird!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intelligente-zeiger"><a class="header" href="#intelligente-zeiger">Intelligente Zeiger</a></h1>
<p>Im Allgemeinen ist ein <em>Zeiger</em> ein Konzept für eine Variable die eine
Speicheradresse enthält. Diese Adresse bezieht sich, oder „zeigt“, auf andere
Daten. Die häufigste Art von Zeigern in Rust ist eine Referenz, die wir bereits
in Kapitel 4 kennengelernt haben. Referenzen werden durch das Symbol <code>&amp;</code>
gekennzeichnet und leihen (borrow) den Wert auf den sie zeigen aus. Sie haben,
außer dem Verweisen auf Daten, keine besonderen Funktionalitäten. Im Übrigen
erzeugen sie keinen Mehraufwand (overhead) und sind die am häufigsten
verwendete Art von Zeigern.</p>
<p><em>Intelligente Zeiger</em> (smart pointers) sind hingegen Datenstrukturen, die wie
ein Zeiger wirken, sondern auch über zusätzliche Metadaten und Funktionalitäten
verfügen. Das Konzept der intelligenten Zeiger gilt nicht nur für Rust, sie
stammen aus C++ und sind auch in anderen Sprachen vorhanden. Rust hat diverse
intelligente Zeiger, die in der Standardbibliothek definiert sind und
Funktionalitäten die über die durch Referenzen bereitgestellten Möglichkeiten
hinausgehen. Um das allgemeine Konzept zu erkunden, werden wir uns einige
verschiedene Beispiele für intelligente Zeiger ansehen, darunter einen
<em>referenzzählenden</em> (reference counting) intelligenten Zeigertyp. Dieser Zeiger
ermöglicht es, dass Daten mehrere Eigentümer (owner) haben können, indem er die
Anzahl der Eigentümer verfolgt und die Daten aufräumt, wenn keine Eigentümer
mehr vorhanden sind.</p>
<p>Da Rust das Konzept der Eigentümerschaft (ownership) und Ausleihen
(borrowing) verwendet, besteht ein zusätzlicher Unterschied zwischen Referenzen
und intelligenten Zeigern: Während Referenzen Zeiger sind, die Daten nur
ausleihen, <em>besitzen</em> intelligente Zeiger in vielen Fällen die Eigentümerschaft
der Daten, auf die sie zeigen.</p>
<p>Obwohl wir sie nicht so genannt haben, sind wir in diesem Buch bereits auf
einige intelligente Zeiger gestoßen, z.B. <code>String</code> und <code>Vec&lt;T&gt;</code> in Kapitel 8.
Diese beiden Typen zählen zu den intelligenten Zeigern, da sie einen gewissen
Speicher besitzen und es dir ermöglichen, diesen zu manipulieren. Sie verfügen
auch über Metadaten und zusätzliche Fähigkeiten oder Garantien. <code>String</code>
speichert beispielsweise seine Kapazität als Metadaten und hat die zusätzliche
Fähigkeit, sicherzustellen, dass seine Daten immer gültiges UTF-8 enthalten.</p>
<p>Intelligente Zeiger werden normalerweise mithilfe von Strukturen implementiert.
Im Unterschied zu einer gewöhnlichen Struktur (struct) implementieren
intelligente Zeiger die Merkmale <code>Deref</code> und <code>Drop</code>. Das Merkmal <code>Deref</code>
ermöglicht es einer Instanz der Struktur für intelligente Zeiger, sich wie eine
Referenz zu verhalten, sodass du Programmcode schreiben kannst, der entweder mit
Referenzen oder intelligenten Zeigern funktioniert. Mit dem Merkmal <code>Drop</code>
kannst du den Programmcode anpassen, der ausgeführt wird, wenn eine Instanz des
intelligenten Zeigers den Gültigkeitsbereich (scope) verlässt. In diesem
Kapitel werden wir beide Merkmale besprechen und zeigen, warum sie für
intelligente Zeiger wichtig sind.</p>
<p>Da das Muster des intelligenten Zeigers ein allgemeines Entwurfsmuster ist, das
in Rust häufig verwendet wird, werden in diesem Kapitel nicht alle vorhandenen
intelligenten Zeiger behandelt. Viele Bibliotheken haben ihre eigenen
intelligenten Zeiger, und du kannst sogar deine eigenen schreiben. Wir werden
die am häufigsten verwendeten intelligenten Zeiger der Standardbibliothek
behandeln:</p>
<ul>
<li><code>Box&lt;T&gt;</code> zum Zuweisen von Werten auf dem Heap</li>
<li><code>Rc&lt;T&gt;</code>, ein Typ der Referenzen zählt und dadurch mehrfache Eigentümerschaft
ermöglicht</li>
<li><code>Ref&lt;T&gt;</code> und <code>RefMut&lt;T&gt;</code>, Zugriff über <code>RefCell&lt;T&gt;</code>, ein Typ, der das
Einhalten der Ausleihregel zur Laufzeit (runtime) statt zur Kompilierzeit
erzwingt.</li>
</ul>
<p>Darüber hinaus wird das <em>innere Veränderbarkeitsmuster</em> (interior mutability pattern)
behandelt, bei dem ein unveränderbarer Typ eine API zum Verändern eines inneren
Werts verfügbar macht. Wir werden auch <em>Referenzzyklen</em> besprechen, wie diese
Speicherverlust verursachen können und wie das verhindert werden kann.</p>
<p>Lass uns in die Materie eintauchen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mit-boxt-auf-daten-im-haldenspeicher-heap-zeigen"><a class="header" href="#mit-boxt-auf-daten-im-haldenspeicher-heap-zeigen">Mit <code>Box&lt;T&gt;</code> auf Daten im Haldenspeicher (heap) zeigen</a></h2>
<p>Der einfachste intelligente Zeiger ist <em>Box</em>, deren Typ <code>Box&lt;T&gt;</code> lautet. In
Boxen kann man Daten statt auf dem Stapelspeicher im Haldenspeicher
speichern. Was auf dem Stapelspeicher verbleibt, ist der Zeiger auf die Daten im
Haldenspeicher. In Kapitel 4 findest du Informationen zum Unterschied
zwischen dem Stapelspeicher und dem Haldenspeicher.</p>
<p>Boxen haben keinen Performanz-Overhead, außer dass die Daten auf
den Haldenspeicher anstatt auf dem Stapelspeicher gespeichert werden, aber
sie haben auch nicht viele zusätzliche Funktionalitäten. Sie werden am
häufigsten in folgenden Situationen verwendet:</p>
<ul>
<li>Wenn man einen Typ hat, dessen Größe zum Zeitpunkt der Kompilierung nicht
bekannt ist, und man einen Wert dieses Typs in einem Kontext verwenden
möchte, für den eine genaue Größe erforderlich ist.</li>
<li>Wenn man über eine große Datenmenge verfügt und die Eigentümerschaft
(ownership) übertragen möchte und sicherstellen will, dass die Daten dabei
nicht kopiert werden.</li>
<li>Wenn man einen Wert besitzen möchte und sich nur darum kümmert, dass es sich
um einen Typ handelt, der ein bestimmtes Merkmal implementiert, anstatt den
Typ zu spezifizieren.</li>
</ul>
<p>Wir werden die erste Situation im Abschnitt <a href="ch15-01-box.html#erm%C3%B6glichen-rekursiver-typen-mit-boxen">„Ermöglichen rekursiver Typen mit
Boxen“</a> zeigen. Im zweiten Fall kann
die Übertragung der Eigentümerschaft einer großen Datenmenge lange dauern, da
die Daten auf dem Stapelspeicher kopiert werden. Um die Performanz in dieser
Situation zu verbessern, können wir die große Datenmenge auf dem Haldenspeicher
in einer Box speichern. Dann wird nur die kleine Menge von Zeigerdaten auf dem
Stapelspeicher kopiert, während die Daten, auf die verwiesen wird, im
Haldenspeicher an einer Stelle verbleiben. Der dritte Fall ist als
<em>Merkmalsobjekt</em> (trait object) bekannt, und Kapitel 17 widmet einen ganzen
Abschnitt <a href="ch17-02-trait-objects.html">„Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen
erlauben“</a> diesem Thema. Was du hier lernst, wirst du im Kapitel
17 erneut anwenden!</p>
<h3 id="boxt-verwenden-um-daten-im-haldenspeicher-zu-speichern"><a class="header" href="#boxt-verwenden-um-daten-im-haldenspeicher-zu-speichern"><code>Box&lt;T&gt;</code> verwenden um Daten im Haldenspeicher zu speichern</a></h3>
<p>Bevor wir den Haldenspeicher-Anwendungsfall für <code>Box&lt;T&gt;</code> besprechen, werden wir
die Syntax und die Interaktion mit Werten behandeln, die in einer <code>Box&lt;T&gt;</code>
gespeichert sind.</p>
<p>Codeblock 15.1 zeigt, wie man mit einer Box einen <code>i32</code>-Wert auf dem
Haldenspeicher speichert:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-1: Speichern eines <code>i32</code>-Wertes in einer Box
im Haldenspeicher</span></p>
<p>Wir definieren die Variable <code>b</code> so, dass sie den den Wert einer <code>Box</code> hat die
auf den Wert <code>5</code> zeigt, der auf dem Haldenspeicher alloziert ist.
Dieses Programm gibt <code>b = 5</code> aus, in diesem Fall können wir auf die Daten in der
Box zugreifen, ähnlich als würden sich die Daten im Stapelspeicher befinden.
Genau wie bei Werten mit Eigentümerschaft wird auch eine Box freigegeben
wenn sie den Gültigkeitsbereich verlässt, wie dies bei <code>b</code> am Ende von <code>main</code>
der Fall ist. Die Freigabe erfolgt sowohl für die Box (gespeichert im
Stapelspeicher) als auch für die Daten, auf die sie zeigt (gespeichert im
Haldenspeicher).</p>
<p>Es ist nicht sehr nützlich, einen einzelnen Wert im Haldenspeicher zu
speichern, daher verwendet man Boxen selten alleine. Meistens ist es besser,
Werte wie eine <code>i32</code> auf dem Stapelspeicher zu haben, wo sie standardmäßig
gespeichert werden. Sehen wir uns einen Fall an, in dem Boxen es uns
ermöglichen, Typen zu definieren, die wir nicht hätten, wenn es keine Boxen
gäbe.</p>
<h3 id="ermöglichen-rekursiver-typen-mit-boxen"><a class="header" href="#ermöglichen-rekursiver-typen-mit-boxen">Ermöglichen rekursiver Typen mit Boxen</a></h3>
<p>Ein Wert eines <em>rekursiven Typs</em> kann einen anderen Wert desselben Typs als
Teil von sich selbst haben. Rekursive Typen stellen ein Problem dar, weil Rust
zur Kompilierzeit wissen muss, wie viel Platz ein Typ einnimmt. Allerdings
könnte die Verschachtelung von Werten rekursiver Typen theoretisch unendlich
weitergehen, sodass Rust nicht wissen kann, wie viel Platz der Wert benötigt.
Da Boxen eine bekannte Größe haben, können wir rekursive Typen ermöglichen,
indem wir eine Box in die Definition des rekursiven Typs einfügen.</p>
<p>Als Beispiel für einen rekursiven Typ wollen wir uns die <em>Cons-Liste</em> ansehen.
Dies ist ein Datentyp, den man häufig in funktionalen Programmiersprachen
findet. Der Cons-Listen-Typ, den wir definieren werden, ist bis auf die
Rekursion einfach; daher werden die Konzepte in dem Beispiel, mit dem wir
arbeiten werden, immer dann nützlich sein, wenn du in komplexeren Situationen
mit rekursiven Typen arbeitest.</p>
<h4 id="weitere-informationen-zur-cons-liste"><a class="header" href="#weitere-informationen-zur-cons-liste">Weitere Informationen zur Cons-Liste</a></h4>
<p>Eine <em>Cons-Liste</em> ist eine Datenstruktur, die aus der Programmiersprache Lisp
und ihren Dialekten stammt und aus verschachtelten Paaren besteht. Sie ist die
Lisp-Version einer verketteten Liste. Ihr Name stammt von der Funktion <code>cons</code>
(Kurzform von „construct function“) in Lisp, die aus ihren beiden Argumenten
ein neues Paar konstruiert. Durch den Aufruf von <code>cons</code> für ein Paar, das aus
einem Wert und einem anderen Paar besteht, können wir Cons-Listen konstruieren,
die aus rekursiven Paaren bestehen.</p>
<p>Hier ist zum Beispiel eine Pseudocode-Darstellung einer Cons-Liste, die die
Liste 1, 2, 3 enthält, wobei jedes Paar in Klammern steht:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Jedes Element in einer Cons-Liste enthält zwei Elemente: Den Wert des aktuellen
Elements und das nächste Element. Das letzte Element in der Liste enthält nur
ein Element namens <code>Nil</code> ohne ein nächstes Element. Eine Cons-Liste wird durch
rekursives Aufrufen der Funktion <code>cons</code> erstellt. Der kanonische Name für den
Basisfall der Rekursion lautet <code>Nil</code>. Beachte, dass dies nicht mit dem Konzept
„null“ oder „nil“ in Kapitel 6 identisch ist, das einen fehlenden oder
ungültigen Wert darstellt.</p>
<p>Die Cons-Liste verwenden ist keine häufig verwendete Datenstruktur in Rust. Wenn
man in Rust eine Liste von Elementen hat, ist <code>Vec&lt;T&gt;</code> die bessere Wahl.
Andere, komplexere rekursive Datentypen sind in verschiedenen Situationen
nützlich. Wenn wir jedoch mit der Cons-Liste beginnen, können wir untersuchen,
wie Boxen es uns ermöglichen, ohne grosse Ablenkung einen rekursiven Datentyp
zu definieren.</p>
<p>Codeblock 15-2 enthält eine Aufzählungsdefinition (enum) für eine Cons-Liste. Beachte,
dass dieser Code nicht kompiliert werden kann, da der Typ <code>List</code> keine bekannte
Grösse hat, was wir zeigen werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-2: Der erste Versuch eine Aufzählung zu
definieren, um eine Datenstruktur der Cons-Liste von <code>i32</code>-Werten darzustellen</span></p>
<blockquote>
<p>Hinweis: Für dieses Beispiel implementieren wir eine Cons-Liste, die nur
<code>i32</code>-Werte enthält. Wir hätten sie mit generischen Typen implementieren
können wie wir es in Kapitel 10 besprochen haben, um eine Cons-Liste zu
erstellen, in der Werte eines beliebigen Typs gespeichert werden können.</p>
</blockquote>
<p>Verwendung des Typs <code>List</code> um die Liste <code>1, 2, 3</code> zu speichern.
Siehe Codeblock 15-3:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">enum List {
</span><span class="boring">   Cons(i32, List),
</span><span class="boring">   Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre></pre>
<p><span class="caption">Codeblock 15-3: Verwendung der <code>List</code>-Aufzählung um die 
Liste <code>1, 2, 3</code> zu speichern</span></p>
<p>Der erste <code>Cons</code>-Wert enthält <code>1</code> und einen anderen <code>List</code>-Wert. Dieser
<code>List</code>-Wert ist ein weiterer <code>Cons</code>-Wert, der <code>2</code> und einen anderen <code>List</code>-Wert
enthält. Dieser <code>List</code>-Wert ist ein weiterer <code>Cons</code>, der <code>3</code> enthält und ein
<code>List</code>, der schließlich <code>Nil</code> ist, die nicht rekursive Variante, die das Ende
der Liste signalisiert.</p>
<p>Wenn wir versuchen den Programmcode in Codeblock 15-3 zu kompilieren,
erhalten wir den Fehler der in Codeblock 15-4 gezeigt wird:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing drop-check constraints for `List`
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which again requires computing drop-check constraints for `List`, completing the cycle
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing }, value: List } }`

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` due to 2 previous errors
</code></pre>
<p><span class="caption">Codeblock 15-4: Der Fehler den wir erhalten wenn wir
versuchen eine rekursive Aufzählung zu definieren</span></p>
<p>Der Fehler zeigt, dass dieser Typ „unendlich groß“ ist. Der Grund dafür ist,
dass wir <code>List</code> mit einer rekursiven Variante definiert haben, sie enthält
direkt einen anderen Wert von sich selbst, daher kann Rust nicht herausfinden,
wie viel Speicherplatz zum Speichern eines Listenwerts erforderlich ist. Lass
uns zusammenfassen, warum wir diesen Fehler bekommen. Schauen wir uns zunächst
an, wie Rust entscheidet, wie viel Speicherplatz zum Speichern des Werts eines
nicht rekursiven Typs benötigt wird.</p>
<h4 id="die-größe-eines-nicht-rekursiven-typs-berechnen"><a class="header" href="#die-größe-eines-nicht-rekursiven-typs-berechnen">Die Größe eines nicht-rekursiven Typs berechnen</a></h4>
<p>Erinnere dich an die in Codeblock 6-2 definierte <code>Message</code>-Aufzählung, als wir
die Definition von Aufzählungen in Kapitel 6 besprochen haben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">}</span></code></pre></pre>
<p>Um zu bestimmen, wie viel Speicherplatz für einen <code>Message</code>-Wert zugewiesen
werden soll, durchläuft Rust jede der Varianten, um festzustellen, welche
Variante den meisten Speicherplatz benötigt. Rust sieht, dass <code>Message::Quit</code>
keinen Speicherplatz benötigt, und <code>Message::Move</code> genügend Speicherplatz braucht
um zwei <code>i32</code>-Werte zu speichern, und so weiter. Da nur eine Variante verwendet
wird, ist der größte Speicherplatz, den ein <code>Message</code>-Wert benötigt, gleich
den, der zum Speichern der größten Variante benötigt wird.</p>
<p>Vergleiche das mit dem, was passiert wenn Rust zu bestimmen versucht, wie viel
Speicherplatz ein rekursiver Typ wie die Aufzählung <code>List</code> in Codeblock 15-2
benötigt. Der Compiler betrachtet zunächst die Variante <code>Cons</code>, die einen Typ
<code>i32</code> und einen Wert vom Typ <code>List</code> enthält. Daher benötigt <code>Cons</code> einen
Speicherplatz, der der Größe eines <code>i32</code> plus der Größe einer <code>List</code>
entspricht. Um herauszufinden, wie viel Speicher der Typ <code>List</code> benötigt,
betrachtet der Compiler die Varianten, beginnend mit der Variante <code>Cons</code>. Die
Variante <code>Cons</code> enthält einen Typ <code>i32</code> und einen Wert vom Typ <code>List</code>. Dieser
Vorgang wird wie in Abbildung 15-1 dargestellt, unendlich fortgesetzt.</p>
<img alt="Eine unendliche Cons-Liste" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 15-1: Ein unendlicher <code>List</code>-Typ der aus unendlichen 
<code>Cons</code>-Varianten besteht</span></p>
<h4 id="verwenden-von-boxt-um-einen-rekursiven-typ-mit-einer-bekannten-größe-zu-erhalten"><a class="header" href="#verwenden-von-boxt-um-einen-rekursiven-typ-mit-einer-bekannten-größe-zu-erhalten">Verwenden von <code>Box&lt;T&gt;</code>, um einen rekursiven Typ mit einer bekannten Größe zu erhalten</a></h4>
<p>Da Rust nicht herausfinden kann, wie viel Speicherplatz für rekursiv definierte
Typen reserviert werden muss, gibt der Compiler eine Fehlermeldung mit diesem
hilfreichen Vorschlag aus:</p>
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>In diesem Hinweis bedeutet „indirection“ (Dereferenzierung), dass anstelle
eines direkten Speicherns des Wertes die Datenstruktur geändert werden soll, um
den Wert indirekt zu speichern, indem stattdessen ein Zeiger auf den Wert
gespeichert wird.</p>
<p>Da eine <code>Box&lt;T&gt;</code> ein Zeiger ist, weiß Rust immer, wie viel Platz eine <code>Box&lt;T&gt;</code>
benötigt: Die Größe eines Zeigers ändert sich nicht basierend auf der
Datenmenge, auf die er zeigt. Dies bedeutet, dass wir anstelle eines anderen
<code>List</code>-Wertes direkt eine <code>Box&lt;T&gt;</code> in die <code>Cons</code>-Variante einfügen können. Die
<code>Box&lt;T&gt;</code> zeigt auf den nächsten <code>List</code>-Wert, der sich auf dem Haldenspeicher
befindet und nicht in der <code>Cons</code>-Variante. Konzeptionell haben wir immer noch
eine Liste, die mit Listen erstellt wurde, die andere Listen enthalten. Diese
Implementierung ähnelt nun eher dem Platzieren der Elemente nebeneinander als
ineinander.</p>
<p>Wir können die Definition der Liste <code>List</code> in Codeblock 15-2 und die Verwendung
von <code>List</code> in Codeblock 15-3 in den Programmcode von Codeblock 15-5 ändern, der
kompilieren wird:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<p><span class="caption">Codeblock 15-5: Definition von <code>List</code> die <code>Box&lt;T&gt;</code> benutzt
um eine bekannte Größe zu haben</span></p>
<p>Die <code>Cons</code>-Variante benötigt die Größe eines <code>i32</code> plus Platz zum Speichern der
Zeigerdaten der Box. Die <code>Nil</code>-Variante speichert keine Werte und benötigt daher
weniger Speicher als die <code>Cons</code>-Variante. Wir wissen nun, dass jeder <code>List</code>-Wert 
die Größe eines <code>i32</code> plus die Größe der Zeigerdaten einer Box annimmt. Durch
Verwenden einer Box haben wir die unendliche, rekursive Kette unterbrochen,
sodass der Compiler die Größe ermitteln kann, die zum Speichern eines
Listenwerts erforderlich ist. Abbildung 15-2 zeigt, wie die Variante <code>Cons</code>
jetzt aussieht.</p>
<img alt="Eine endliche Cons-Liste" src="img/trpl15-02.svg" class="center" style="width: 20%;" />
<p><span class="caption">Abbildung 15-2: Ein <code>List</code>-Typ der keine unendliche Größe 
hat da <code>Cons</code> eine <code>Box</code> enthält</span></p>
<p>Boxen bieten nur die Dereferenzierung und Zuordnung am Haldenspeicher, haben
aber sonst keine speziellen Funktionalitäten, wie wir sie bei anderen
intelligenten Zeigertypen sehen werden. Sie haben aber auch keinen
Performanz-Overhead, der mit diesen zusätzlichen Funktionalitäten verbunden
ist. Daher können sie in Fällen wie der Cons-Liste nützlich sein, in denen die
Dereferenzierung die einzige Funktionalität ist, die wir benötigen. Weitere
Anwendungsfälle für Boxen werden wir uns in Kapitel 17 ansehen.</p>
<p>Der Typ <code>Box&lt;T&gt;</code> ist ein intelligenter Zeiger, da er das Merkmal <code>Deref</code>
implementiert, mit dem <code>Box&lt;T&gt;</code> Werte wie Referenzen behandelt werden können.
Wenn ein <code>Box&lt;T&gt;</code>-Wert den Gültigkeitsbereich verlässt, werden die Daten am
Haldenspeicher, auf die die Box zeigt, aufgrund der Implementierung des
Merkmals <code>Drop</code> ebenfalls bereinigt. Diese beiden Merkmale sind für die
Funktionalität der anderen intelligenten Zeigertypen, die wir im restlichen
Kapitel erläutern, noch wichtiger. Lass uns diese beiden Merkmale genauer
untersuchen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="intelligente-zeiger-wie-normale-referenzen-behandeln-mit-dem-merkmal-trait-deref"><a class="header" href="#intelligente-zeiger-wie-normale-referenzen-behandeln-mit-dem-merkmal-trait-deref">Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) <code>Deref</code></a></h2>
<p>Durch die Implementierung des Merkmals <code>Deref</code> kann man das Verhalten des
<em>Dereferenzierungsoperators</em> (dereference operator) <code>*</code> (nicht zu verwechseln
mit dem Multiplikations- oder Stern-Operator (glob operator)) anpassen. Indem
du <code>Deref</code> so implementierst, dass ein intelligenter Zeiger wie eine reguläre
Referenz behandelt werden kann, kannst du Programmcode schreiben, der mit
Referenzen arbeitet, und diesen Programmcode auch mit intelligenten Zeigern
verwenden.</p>
<p>Schauen wir uns zunächst an, wie der Dereferenzierungsoperator mit regulären
Referenzen arbeitet. Dann werden wir versuchen, einen benutzerdefinierten Typ
zu definieren, der sich wie <code>Box&lt;T&gt;</code> verhält, und herausfinden, warum der
Dereferenzierungsoperator nicht wie eine Referenz für unseren neu definierten
Typ funktioniert. Wir werden untersuchen, wie die Implementierung des Merkmals
<code>Deref</code> es intelligenten Zeigern ermöglicht, auf ähnliche Weise wie Referenzen
zu funktionieren, dann sehen wir uns an wie wir mit Rusts <em>automatischer
Umwandlung</em> (deref coercion) mit Referenzen oder intelligenten Zeigern arbeiten
können.</p>
<blockquote>
<p>Hinweis: Es gibt einen großen Unterschied zwischen dem Typ <code>MyBox&lt;T&gt;</code>, den wir
gerade erstellen, und dem echten Typ <code>Box&lt;T&gt;</code>: Unsere Version speichert ihre
Daten nicht auf dem Haldenspeicher (heap). In diesem Beispiel konzentrieren wir uns auf
<code>Deref</code>, daher ist es weniger wichtig, wo die Daten tatsächlich gespeichert sind
als das zeigerähnliche Verhalten.</p>
</blockquote>
<h3 id="dem-zeiger-zum-wert-folgen"><a class="header" href="#dem-zeiger-zum-wert-folgen">Dem Zeiger zum Wert folgen</a></h3>
<p>Eine reguläre Referenz ist eine Art Zeiger, und eine Möglichkeit, sich einen
Zeiger vorzustellen, ein Pfeil der auf einen Wert zeigt der an einer anderen
Stelle gespeichert ist. In Codeblock 15-6 erstellen wir eine Referenz auf einen
<code>i32</code>-Wert und verwenden dann den Dereferenzierungsoperator, um der Referenz
zum Wert zu folgen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-6: Einen Dereferenzierungsoperator verwenden
um einer Referenz auf einen <code>i32</code>-Wert zu folgen </span></p>
<p>Die Variable <code>x</code> enthält den <code>i32</code>-Wert <code>5</code>. Wir setzen <code>y</code> gleich einer
Referenz auf <code>x</code>. Wir können sicherstellen, das <code>x</code> gleich <code>5</code> ist. Wenn wir
jedoch eine Aussage über den Wert <code>y</code> machen möchten, auf den er zeigt, müssen
wir <code>*y</code> verwenden, um der Referenz auf den Wert zu folgen, auf den sie zeigt
(daher <em>Dereferenzierung</em>), damit der Compiler den aktuellen Wert vergleichen
kann. Sobald wir <code>y</code> dereferenzieren, haben wir Zugriff auf den Zahlenwert auf
den <code>y</code> zeigt und können ihn mit <code>5</code> vergleichen.</p>
<p>Wenn wir stattdessen versuchen würden, <code>assert_eq!(5, y);</code> zu schreiben, würden
wir diesen Fehler beim Kompilieren erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z external-macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` due to previous error
</code></pre>
<p>Das Vergleichen einer Zahl mit einer Referenz auf eine Zahl ist nicht zulässig,
da es sich um verschiedene Typen handelt. Wir müssen den Dereferenzierungsoperator
verwenden um der Referenz auf den Wert zu folgen, auf den sie zeigt.</p>
<h3 id="boxt-wie-eine-referenz-verwenden"><a class="header" href="#boxt-wie-eine-referenz-verwenden"><code>Box&lt;T&gt;</code> wie eine Referenz verwenden</a></h3>
<p>Wir können den Programmcode in Codeblock 15-6 neu schreiben, um anstelle einer
Referenz <code>Box&lt;T&gt;</code> zu verwenden. Wie Codeblock 15-7 zeigt, funktioniert der
Dereferenzierungsoperator:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-7: Using the dereference operator on a
<code>Box&lt;i32&gt;</code></span></p>
<p>Der Hauptunterschied zwischen Codeblock 15-7 und 15-6 besteht darin, dass wir
hier <code>y</code> als Instanz einer <code>Box&lt;T&gt;</code> festlegen, das auf einen kopierten Wert von
<code>x</code> zeigt, und nicht als Referenz, die auf den Wert <code>x</code> zeigt. In der letzten
Zusicherung (assertion) können wir den Dereferenzierungsoperator verwenden um
dem Zeiger der <code>Box&lt;T&gt;</code> auf die gleiche Weise zu folgen, wie wir es getan
haben, als <code>y</code> eine Referenz war. Als Nächstes werden wir ergründen, was das
Besondere an <code>Box&lt;T&gt;</code> ist, das es uns ermöglicht, den Dereferenzierungsoperator
zu verwenden, indem wir unseren eigenen Box-Typ definieren.</p>
<h3 id="einen-eigenen-intelligenten-zeiger-definieren"><a class="header" href="#einen-eigenen-intelligenten-zeiger-definieren">Einen eigenen intelligenten Zeiger definieren</a></h3>
<p>Erstellen wir einen intelligenten Zeiger, der dem von der Standardbibliothek
bereitgestellten Typ <code>Box&lt;T&gt;</code> ähnelt, um zu erfahren, wie sich intelligente
Zeiger standardmäßig anders als Referenzen verhalten. Anschließend sehen wir
uns an, wie man die Möglichkeit zur Verwendung des Dereferenzierungsoperators
hinzufügen kann.</p>
<p>Der Typ <code>Box&lt;T&gt;</code> wird letztendlich als Tupel-Struktur (tuple struct) mit einem
Element definiert, sodass Codeblock 15-8 einen Typ <code>MyBox&lt;T&gt;</code> auf die gleiche
Weise definiert. Wir werden auch eine <code>new</code>-Funktion definieren, die mit der in
der <code>Box&lt;T&gt;</code> definierten übereinstimmt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-8: Einen <code>MyBox&lt;T&gt;</code>-Typ definieren</span></p>
<p>Wir definieren eine Struktur mit dem Namen <code>MyBox</code> und deklarieren einen
generischen Parameter <code>T</code>, da unser Typ Werte eines beliebigen Typs enthalten
soll. Der Typ <code>MyBox</code> ist eine Tupelstruktur mit einem Element vom Typ <code>T</code>. Die
Funktion <code>MyBox::new</code> verwendet einen Parameter vom Typ <code>T</code> und gibt eine 
<code>MyBox</code>-Instanz zurück, die den übergebenen Wert enthält.</p>
<p>Versuchen wir, die <code>main</code>-Funktion in Codeblock 15-7 zu Codeblock 15-8
hinzuzufügen und sie so zu ändern, dass der von uns definierte Typ <code>MyBox&lt;T&gt;</code>
anstelle von <code>Box&lt;T&gt;</code> verwendet wird. Der Programmcode in Codeblock 15-9 wird
nicht kompilieren, da Rust nicht weiß, wie er <code>MyBox</code> dereferenzieren kann.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring"> }
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-9: Versuch, <code>MyBox&lt;T&gt;</code> auf die gleiche Weise
wie <code>Box&lt;T&gt;</code> und Referenzen zu benutzen</span></p>
<p>Hier ist der Kompilierfehler den wir erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` due to previous error
</code></pre>
<p>Unser Typ <code>MyBox&lt;T&gt;</code> kann nicht dereferenziert werden, da wir diese
Fähigkeit für unseren Typ nicht implementiert haben. Um eine
Dereferenzierung mit dem Operator <code>*</code> zu ermöglichen, implementieren wir das
Merkmal <code>Deref</code>.</p>
<h3 id="einen-typ-wie-eine-referenz-behandeln-durch-implementieren-des-deref-merkmals"><a class="header" href="#einen-typ-wie-eine-referenz-behandeln-durch-implementieren-des-deref-merkmals">Einen Typ wie eine Referenz behandeln durch Implementieren des <code>Deref</code>-Merkmals</a></h3>
<p>Wie im Abschnitt <a href="ch10-02-traits.html#ein-merkmal-f%C3%BCr-einen-typ-implementieren">„Ein Merkmal für einen Typ implementieren“</a> in
Kapitel 10 beschrieben, müssen wir zur Implementierung eines Merkmals
Implementierungen für die erforderlichen Methoden des Merkmals bereitstellen.
Das von der Standardbibliothek bereitgestellte Merkmal <code>Deref</code> erfordert die
Implementierung einer Methode namens <code>deref</code>, die <code>self</code> ausleiht (borrow) und
eine Referenz auf die beinhalteten Daten zurückgibt. Codeblock 15-10 enthält
eine Implementierung von <code>Deref</code>, um die Definition von <code>MyBox</code> zu ergänzen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-10: <code>Deref</code> auf <code>MyBox&lt;T&gt;</code> implementieren</span></p>
<p>Die Syntax <code>type Target = T;</code> definiert einen assoziierten Typ, den das Merkmal
<code>Deref</code> verwenden soll. Assoziierte Typen sind eine andere Art, einen
generischen Parameter zu deklarieren, aber darüber musst du dir vorerst noch
keine Gedanken machen, in Kapitel 19 werden wir sie ausführlicher behandeln.</p>
<p>Wir füllen den Rumpf der Methode <code>deref</code> mit <code>&amp;self.0</code>, damit <code>deref</code> eine
Referenz auf den Wert zurückgibt, auf den wir mit dem Operator <code>*</code> zugreifen
wollen. Erinnere dich an den Abschnitt <a href="ch05-01-defining-structs.html#verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen">„Verwenden von Tupel-Strukturen ohne
benannte Felder um verschiedene Typen zu erzeugen“</a> in Kapitel
5, wo <code>.0</code> auf den ersten Wert in einer Tupel-Struktur zugreift. Die
<code>main</code>-Funktion in Codeblock 15-9, die <code>*</code> für den Wert <code>MyBox&lt;T&gt;</code> aufruft,
kompiliert nun und die Zusicherungen werden erfüllt!</p>
<p>Ohne das Merkmal <code>Deref</code> kann der Compiler nur <code>&amp;</code>-Referenzen dereferenzieren.
Die <code>deref</code>-Methode gibt dem Compiler die Möglichkeit, einen Wert eines
beliebigen Typs zu verwenden, der <code>Deref</code> implementiert, und die <code>deref</code>-Methode
aufzurufen, um eine <code>&amp;</code>-Referenz zu erhalten, die er dereferenzieren kann.</p>
<p>Als wir in Codeblock 15-9 <code>*y</code> eingegeben haben, hat Rust hinter den Kulissen
tatsächlich diesen Programmcode ausgeführt:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust ersetzt den Operator <code>*</code> durch einen Aufruf der <code>deref</code>-Methode und dann
durch eine einfache Dereferenzierung, sodass wir nicht darüber nachdenken
müssen, ob wir die <code>deref</code>-Methode aufrufen müssen oder nicht. Mit dieser
Rust-Funktionalität können wir Code schreiben, der unabhängig davon, ob wir eine reguläre
Referenz oder einen Typ haben der <code>Deref</code> implementiert, identisch funktioniert.</p>
<p>Der Grund, warum die <code>deref</code>-Methode eine Referenz auf einen Wert zurückgibt
und die einfache Dereferenzierung außerhalb der Klammern in <code>*(y.deref())</code>
weiterhin erforderlich ist, hat mit der Eigentümerschaft (ownership) zu tun.
Wenn die <code>deref</code>-Methode den Wert direkt anstelle einer Referenz auf den Wert
zurückgibt, wird der Wert aus <code>self</code> herausverschoben. Meistens wenn wir den
Dereferenzierungsoperator verwenden, wollen wir, so wie auch in diesem Fall,
nicht die Eigentümerschaft des inneren Wertes von <code>MyBox&lt;T&gt;</code> übernehmen.</p>
<p>Beachte, dass der <code>*</code>-Operator durch einen Aufruf der <code>deref</code>-Methode und dann
nur einmal durch einen Aufruf des <code>*</code>-Operators ersetzt wird, jedes Mal, wenn
wir ein <code>*</code> in unserem Programmcode verwenden. Da die Ersetzung des 
<code>*</code>-Operator nicht unendlich rekursiv ist, erhalten wir Daten vom Typ
<code>i32</code>, die mit der <code>5</code> in <code>assert_eq!</code> in Codeblock 15-9 übereinstimmen.</p>
<h3 id="implizite-automatische-umwandlung-mit-funktionen-und-methoden"><a class="header" href="#implizite-automatische-umwandlung-mit-funktionen-und-methoden">Implizite automatische Umwandlung mit Funktionen und Methoden</a></h3>
<p><em>Automatische Umwandlung</em> (deref coercion) wandelt eine Referenz auf einen Typ,
der das Merkmal <code>Deref</code> implementiert, in eine Referenz auf einen anderen Typ
um. Zum Beispiel kann die automatische Umwandlung <code>&amp;String</code> in <code>&amp;str</code>
konvertieren, da <code>String</code> das Merkmal <code>Deref</code> implementiert, sodass <code>&amp;str</code>
zurückgegeben wird. Die automatische Umwandlung ist eine Bequemlichkeit, die
Rust auf Argumente für Funktionen und Methoden ausübt, und funktioniert nur bei
Typen, die das Merkmal <code>Deref</code> implementieren. Die automatische Umwandlung
erfolgt automatisch, wenn wir eine Referenz auf den Wert eines bestimmten Typs
als Argument an eine Funktion oder Methode übergeben, die nicht dem
Parametertyp in der Funktion oder Methodendefinition übereinstimmt. Eine Folge
von Aufrufen der <code>deref</code>-Methode konvertiert den von uns angegebenen Typ in den
Typ, den der Parameter benötigt.</p>
<p>Rust wurde um die automatische Umwandlung erweitert, damit Programmierer, die Funktions- und
Methodenaufrufe schreiben, nicht so viele explizite Referenzierungen und Dereferenzierungen
mit <code>&amp;</code> und <code>*</code> angeben müssen. Mit der Funktionalität der automatischen Umwandlung
können wir auch mehr Programmcode schreiben, der sowohl für Referenzen als auch
für intelligente Zeiger geeignet ist.</p>
<p>Um die automatische Umwandlung in Aktion zu sehen, verwenden wir den in Codeblock 15-8
definierten Typ <code>MyBox&lt;T&gt;</code> sowie die Implementierung von <code>Deref</code>, die wir in
Codeblock 15-10 hinzugefügt haben. Codeblock 15-11 zeigt die Definition einer
Funktion mit einen Zeichenketten-Anteilstyp (string slice) Parameter:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello(name: &amp;str) {
    println!(&quot;Hallo {name}!&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-11: Eine <code>hello</code>-Funktion mit dem Parameter
<code>name</code> vom Typ <code>&amp;str</code></span></p>
<p>Wir können die Funktion <code>hello</code> mit einem Zeichenketten-Anteilstyp als Argument
aufrufen, wie zum Beispiel <code>hello(&quot;Rust&quot;);</code>. Die automatischer Umwandlung ermöglicht es,
<code>hello</code> mit einer Referenz auf einen Wert vom Typ <code>MyBox&lt;String&gt;</code> aufzurufen,
wie es in Codeblock 15-12 gezeigt wird:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hallo {name}!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-12: <code>hello</code> mit einer Referenz auf einen
<code>MyBox&lt;String&gt;</code>-Wert, der aufgrund automatischer Umwandlung funktioniert</span></p>
<p>Hier rufen wir die Funktion <code>hello</code> mit dem Argument <code>&amp;m</code> auf, das auf einen
<code>MyBox&lt;String&gt;</code>-Wert verweist. Da wir in Codeblock 15-10 das Merkmal <code>Deref</code> für
<code>MyBox&lt;T&gt;</code> implementiert haben, kann Rust <code>&amp;MyBox&lt;String&gt;</code> durch Aufrufen von
<code>deref</code> in <code>&amp;String</code> verwandeln. Die Standardbibliothek bietet eine
Implementierung von <code>Deref</code> auf <code>String</code>, die einen Zeichenketten-Anteilstyp
zurückgibt. Dies kann man in der API-Dokumentation für <code>Deref</code> nachlesen. Rust
ruft erneut <code>deref</code> auf, um <code>&amp;String</code> in <code>&amp;str</code> umzuwandeln, was der Definition
der Funktion <code>hello</code> entspricht.</p>
<p>Wenn Rust keine automatische Umwandlung implementiert hätte, müssten wir den
Programmcode in Codeblock 15-13 anstelle des Programmcodes in 15-12 schreiben,
um <code>hello</code> mit einem Wert vom Typ <code>&amp;MyBox&lt;String&gt;</code> aufzurufen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hallo {name}!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-13: Programmcode den wir schreiben
müssten wenn Rust keine automatische Umwandlung hätte</span></p>
<p>Das <code>(*m)</code> dereferenziert <code>Mybox&lt;String&gt;</code> in einen <code>String</code>. Dann nehmen die
<code>&amp;</code> und <code>[..]</code> einen Anteilstyp des <code>String</code>, der gleich der gesamten
Zeichenkette ist, um der Signatur von <code>hello</code> zu entsprechen. Dieser
Programmcode ohne automatische Umwandlung ist mit allen Symbolen schwerer zu
lesen, zu schreiben und zu verstehen. Durch die automatische Umwandlung kann
Rust diese Konvertierung automatisch für uns abwickeln.</p>
<p>Wenn das Merkmal <code>Deref</code> für die beteiligten Typen definiert ist, analysiert
Rust die Typen und verwendet <code>Deref::deref</code> so oft wie nötig, um eine Referenz
zu erhalten, die dem Typ des Parameters entspricht. Die Häufigkeit, mit der
<code>Deref::deref</code> eingefügt werden muss, wird zur Kompilierzeit aufgelöst,
sodass kein Nachteil zur Laufzeit bei der Nutzung der automatischen Umwandlung
entsteht!</p>
<h3 id="wie-die-automatische-umwandlung-mit-veränderbarkeit-umgeht"><a class="header" href="#wie-die-automatische-umwandlung-mit-veränderbarkeit-umgeht">Wie die automatische Umwandlung mit Veränderbarkeit umgeht</a></h3>
<p>Ähnlich wie du das Merkmal <code>Deref</code> verwendest, um den <code>*</code>-Operator bei
unveränderbaren Referenzen zu überschreiben, kannst du das Merkmal <code>DerefMut</code>
verwenden, um den <code>*</code>-Operator bei veränderbaren Referenzen zu überschreiben.</p>
<p>Rust wendet die automatische Umwandlung an, wenn Typen und
Merkmalsimplementierungen in folgenden drei Fällen gefunden werden:</p>
<ul>
<li>Von <code>&amp;T</code> zu <code>&amp;U</code>, wenn <code>T:Deref&lt;Target=U&gt;</code></li>
<li>Von <code>&amp;mutT</code> zu <code>&amp;mutU</code>, wenn <code>T:DerefMut&lt;Target=U&gt;</code></li>
<li>Von <code>&amp;mutT</code> zu <code>&amp;U</code>, wenn <code>T:Deref&lt;Target=U&gt;</code></li>
</ul>
<p>Die ersten beiden Fälle sind identisch, mit der Ausnahme, dass der zweite die
Veränderbarkeit implementiert. Der erste Fall besagt, dass wenn man einen <code>&amp;T</code>
hat und <code>T</code> <code>Deref</code> für einen Typ <code>U</code> implementiert hat, man transparent einen
<code>&amp;U</code> erhalten kann. Der zweite Fall besagt, dass die gleiche automatische
Umwandlung bei veränderbaren Referenzen erfolgt.</p>
<p>Der dritte Fall ist schwieriger: Rust wird auch eine veränderbare Referenz in
eine unveränderbare umwandeln. Das Gegenteil ist jedoch <em>nicht</em> möglich:
Unveränderbare Referenzen werden niemals zu veränderbaren gemacht. Wenn man
eine veränderbare Referenz hat, muss diese veränderbare Referenz aufgrund der
Ausleihregeln (borrowing rules) die einzige Referenz auf diese Daten sein
(anderenfalls würde das Programm nicht kompilieren). Das Konvertieren einer
veränderbaren Referenz in eine unveränderbare verstößt niemals gegen die
Ausleihregeln. Das Konvertieren einer unveränderbaren Referenz in eine
veränderbare Referenz, würde erfordern, dass die ursprüngliche unveränderbare
Referenz die einzige unveränderbare Referenz auf diese Daten ist, aber die
Ausleihregeln garantieren dies nicht.
Daher kann Rust nicht davon ausgehen, dass die Konvertierung einer
unveränderbaren Referenz in eine veränderbare Referenz möglich ist.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="programmcode-beim-aufräumen-ausführen-mit-dem-merkmal-trait-drop"><a class="header" href="#programmcode-beim-aufräumen-ausführen-mit-dem-merkmal-trait-drop">Programmcode beim Aufräumen ausführen mit dem Merkmal (trait) <code>Drop</code></a></h2>
<p>Das zweite wichtige Merkmal für intelligente Zeiger ist <code>Drop</code>, mit dem man
anpassen kann, was passiert, wenn ein Wert den Gültigkeitsbereich verlässt. Man
kann eine Implementierung für das Merkmal (trait) <code>Drop</code> für jeden Typ
bereitstellen, und der angegebene Programmcode kann zum Freigeben von
Ressourcen wie Dateien oder Netzwerkverbindungen verwendet werden.</p>
<p>Wir führen <code>Drop</code> im Kontext von intelligenten Zeigern ein, da die
Funktionalität des Merkmals <code>Drop</code> fast immer bei der Implementierung eines
intelligenten Zeigers verwendet wird. Wenn beispielsweise eine <code>Box&lt;T&gt;</code>
aufgeräumt wird, wird der Speicherplatz auf dem Haldenspeicher freigegeben, auf
den die Box zeigt.</p>
<p>In einigen Programmiersprachen muss der Programmierer bei jeder Verwendung einer
Instanz eines intelligenten Zeigers Programmcode aufrufen, um Speicher oder
Ressourcen freizugeben. Beispiele hierfür sind Dateiressurcen, Sockets oder
Sperren. Wenn sie es vergessen, kann das System überlastet werden und
abstürzen. In Rust kann man festlegen, dass ein bestimmter Programmcode
ausgeführt wird, wenn ein Wert seinen Gültigkeitsbereich verlässt, und der
Compiler fügt diesen Programmcode automatisch ein. Infolgedessen muss man nicht
vorsichtig sein, wenn man Bereinigungscode überall in einem Programm platziert,
mit dem eine Instanz eines bestimmten Typs fertig ist, man wird dennoch keine
Ressourcen verlieren!</p>
<p>Du schreibst den Programmcode der ausgeführt wird, wenn ein Wert den
Gültigkeitsbereich verlässt, durch Implementieren des Merkmals <code>Drop</code>. Für das
Merkmal <code>Drop</code> muss man eine Methode <code>drop</code> implementieren, die eine 
veränderbare Referenz auf <code>self</code> enthält. Um zu sehen, wann Rust <code>drop</code>
aufruft, implementieren wir <code>drop</code> zunächst mit <code>println!</code>-Anweisungen.</p>
<p>Codeblock 15-14 zeigt eine Struktur (struct) <code>CustomSmartPointer</code>, deren einzige 
benutzerdefinierte Funktionalität darin besteht, dass <code>Lösche CustomSmartPointer!</code> ausgegeben wird, wenn die Instanz den Gültigkeitsbereich
verlässt, um zu zeigen, wann Rust die <code>drop</code>-Funktion ausführt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;CustomSmartPointer und Daten aufräumen: `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;meine Sache&quot;),
    };
    let d = CustomSmartPointer {
        data: String::from(&quot;andere Sachen&quot;),
    };
    println!(&quot;CustomSmartPointers erzeugt.&quot;);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-14: Eine Struktur <code>CustomSmartPointer</code> die
das <code>Drop</code>-Merkmal implementiert wo wir unseren Programmcode für das
Aufräumen platzieren würden</span></p>
<p>Das Merkmal <code>Drop</code> ist im Präludium (prelude) enthalten, daher müssen wir es
nicht in den Gültigkeitsbereich bringen. Wir implementieren das Merkmal <code>Drop</code>
in <code>CustomSmartPointer</code> und stellen eine Implementierung für die Methode <code>drop</code>
bereit, die <code>println!</code> aufruft. Im Hauptteil der <code>drop</code>-Funktion kannst du jede
Logik platzieren, die du ausführen möchtest, wenn eine Instanz deines Typs
ihren Gültigkeitsbereich verlässt. Wir geben hier einen Text aus, um visuell zu
zeigen, wann Rust <code>drop</code> aufruft.</p>
<p>In <code>main</code> erstellen wir zwei Instanzen von <code>CustomSmartPointer</code> und geben dann 
<code>CustomSmartPointers erzeugt</code> aus. Am Ende von <code>main</code> werden unsere Instanzen
von <code>CustomSmartPointer</code> nicht mehr gültig sein, und Rust ruft den Programmcode
auf, den wir in der <code>drop</code>-Methode angegeben haben, und gibt unsere endgültige
Nachricht aus. Beachte, dass wir die <code>drop</code>-Methode nicht explizit aufrufen
mussten.</p>
<p>Wenn wir das Programm ausführen, erhalten wir folgende Ausgabe:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers erzeugt.
CustomSmartPointer und Daten aufräumen: `andere Sachen`!
CustomSmartPointer und Daten aufräumen: `meine Sache`!
</code></pre>
<p>Rust hat für uns automatisch <code>drop</code> und den von uns angegebenen Programmcode 
aufgerufen, sobald unsere Instanzen den Gültigkeitsbereich verlassen haben. 
Variablen werden in umgekehrter Reihenfolge ihrer Erstellung aufgeräumt, daher
wurde <code>d</code> vor <code>c</code> aufgeräumt. Der Zweck dieses Beispiels ist, dir eine visuelle
Anleitung zur Funktionsweise der <code>drop</code>-Methode zu geben. Normalerweise gibst
du den Bereinigungscode an, den dein Typ ausführen muss, anstatt einen Text
auszugeben.</p>
<h3 id="einen-wert-mit-stdmemdrop-frühzeitig-aufräumen"><a class="header" href="#einen-wert-mit-stdmemdrop-frühzeitig-aufräumen">Einen Wert mit <code>std::mem::drop</code> frühzeitig aufräumen</a></h3>
<p>Unglücklicherweise ist es nicht einfach, die automatische <code>drop</code>-Funktionalität
zu deaktivieren. Für gewöhnlich ist es auch nicht erforderlich; der wesentliche
Punkt des <code>Drop</code>-Merkmals ist, dass es automatisch erledigt wird. Gelegentlich
möchte man jedoch möglicherweise einen Wert frühzeitig bereinigen. Ein Beispiel
ist die Verwendung intelligenter Zeiger, die Sperren verwalten: Möglicherweise
möchtest du die <code>drop</code>-Methode dazu zwingen, die Sperre freizugegeben,
damit anderer Programmcode im selben Gültigkeitsbereich die Sperre erhalten
kann. Mit Rust kann man die <code>drop</code>-Methode des <code>Drop</code>-Merkmals nicht manuell
aufrufen. Stattdessen muss man die von der Standardbibliothek bereitgestellte
Funktion <code>std::mem::drop</code> aufrufen, wenn man das Aufräumen eines Werts vor dem
Ende seines ültigkeitsbereich erzwingen möchte.</p>
<p>Wenn wir versuchen die <code>drop</code>-Methode des <code>Drop</code>-Merkmals manuell aufzurufen,
indem wir die <code>main</code>-Funktion aus Codeblock 15-14 ändern, wie im Codeblock
15-15, gezeigt, erhalten wir folgenden Fehler beim Kompilieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;CustomSmartPointer und Daten aufräumen: `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;Daten&quot;),
    };
    println!(&quot;CustomSmartPointer erzeugt.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer vor dem Ende von main aufgeräumt.&quot;);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-15: Der Versuch, die <code>drop</code>-Methode 
des <code>Drop</code>-Merkmals manuell aufzurufen, um frühzeitig zu bereinigen</span></p>
<p>Wenn wir versuchen, diesen Programmcode zu kompilieren, wird folgende
Fehlermeldung ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(c)`

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` due to previous error
</code></pre>
<p>Diese Fehlermeldung besagt, dass wir <code>drop</code> nicht explizit aufrufen dürfen. Die
Fehlermeldung verwendet den Begriff <em>Destruktor</em> (destructor), der der
allgemeine Programmierbegriff für eine Funktion ist, die eine Instanz
bereinigt. Ein <em>Destruktor</em> ist analog zu einem <em>Konstruktor</em> (constructor),
der eine Instanz erstellt. Die <code>drop</code>-Funktion in Rust ist ein bestimmter
<em>Destruktor</em>.</p>
<p>Rust lässt uns <code>drop</code> nicht explizit aufrufen, da Rust immer noch automatisch
für den Wert am Ende von <code>main</code> <code>drop</code> aufruft. Dies würde einen
<em>Doppel-Freigabe-Fehler</em> (double free error) verursachen, da Rust versuchen
würde, den gleichen Wert zweimal aufzuräumen.</p>
<p>Wir können das automatische Einfügen von <code>drop</code> nicht deaktivieren, wenn ein
Wert den Gültigkeitsbereich verlässt, und wir können die Methode <code>drop</code> nicht
explizit aufrufen. Wenn wir also erzwingen müssen, dass ein Wert frühzeitig
aufgeräumt wird, verwenden wir die Funktion <code>std::mem::drop</code>.</p>
<p>Die Funktion <code>std::mem::drop</code> unterscheidet sich von der Methode <code>drop</code> im
Merkmal <code>Drop</code>. Wir rufen sie auf, indem wir den Wert, dessen vorzeitiges
Aufräumen wir erzwingen möchten, der Funktion als Argument mitgeben. Die
Funktion befindet sich im Präludium, daher können wir <code>main</code> in Codeblock 15-15
ändern, um die <code>drop</code>-Funktion wie in Codeblock 15-16 gezeigt aufzurufen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;CustomSmartPointer und Daten aufräumen: `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;Daten&quot;),
    };
    println!(&quot;CustomSmartPointer erzeugt.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer vor dem Ende von main aufgeräumt.&quot;);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-16: <code>std::mem::drop</code> aufrufen um einen Wert
explizit aufzuräumen bevor er den Gültigkeitsbereich verlässt</span></p>
<p>Wenn wir den Programmcode aufrufen, wird folgendes ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer erzeugt.
CustomSmartPointer und Daten aufräumen: `Daten`!
CustomSmartPointer vor dem Ende von main aufgeräumt.
</code></pre>
<p>Der Text <code>CustomSmartPointer und Daten aufräumen: `Daten`!</code> wird zwischen
<code>CustomSmartPointer erzeugt</code> und <code>CustomSmartPointer vor dem Ende von main aufgeräumt.</code> ausgegeben und zeigt, dass der <code>drop</code>-Methodencode aufgerufen wird
um <code>c</code> an diesem Punkt aufzuräumen.</p>
<p>Du kannst den Programmcode, der in einer Implementierung des <code>Drop</code>-Merkmals
angegeben ist, auf viele Arten verwenden, um die Bereinigung bequem und sicher
zu gestalten, du kannst ihn beispielsweise dazu verwnden, um deinen eigenen
Speicher-Allokator (memory allocator) zu erstellen! Mit dem Merkmal <code>Drop</code> und
dem Eigentümerschaftssystem von Rust musst du nicht daran denken den
Programmcode zu bereinigen, da Rust dies automatisch tut.</p>
<p>Man muss sich auch keine Sorgen über Probleme machen, die sich aus der
versehentlichen Bereinigung noch verwendeter Werte ergeben: Das
Eigentümerschaftssystem, das sicherstellt, das Referenzen immer gültig sind,
stellt auch sicher, dass <code>drop</code> nur einmal aufgerufen wird, wenn der Wert nicht
mehr verwendet wird.</p>
<p>Nachdem wir nun <code>Box&lt;T&gt;</code> und einige der Merkmale von intelligenten Zeigern
untersucht haben, schauen wir uns einige andere intelligente Zeiger an, die in
der Standardbibliothek definiert sind.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="der-referenzzählende-intelligente-zeiger-rct"><a class="header" href="#der-referenzzählende-intelligente-zeiger-rct">Der referenzzählende intelligente Zeiger <code>Rc&lt;T&gt;</code></a></h2>
<p>In den meisten Fällen ist die Eigentümerschaft klar, man weiß genau, welche
Variable einen bestimmten Wert besitzt. Es gibt jedoch Fälle, in denen ein
einzelner Wert mehrere Eigentümer haben kann. In Diagrammdatenstrukturen (graph
data structures) können beispielsweise mehrere Kanten auf denselben Knoten
verweisen, und dieser Knoten gehört konzeptionell allen Kanten, die darauf
verweisen. Ein Knoten sollte nur aufgeräumt werden, wenn keine Kanten darauf
zeigen und daher keine Eigentümer hat.</p>
<p>Du musst die mehrfache Eigentümerschaft explizit aktivieren, indem du den
Rust-Typ <code>Rc&lt;T&gt;</code> verwendest, was eine Kurzform für <em>Referenzzählung</em> (reference
counting) ist. Der Typ <code>Rc&lt;T&gt;</code> zählt die Anzahl der Referenzen auf einen
Wert, um festzustellen, ob der Wert noch verwendet wird oder nicht. Wenn auf
einen Wert keine Referenz vorhanden ist, kann der Wert aufgeräumt werden, ohne
dass Referenzen ungültig werden.</p>
<p>Stell dir <code>Rc&lt;T&gt;</code> als einen Fernseher im Wohnzimmer vor. Wenn eine Person zum
Fernsehen hereinkommt, schaltet sie ein. Andere können in das Zimmer kommen und
fernsehen. Wenn die letzte Person den Raum verlässt, schaltet sie den Fernseher
aus, da er nicht mehr verwendet wird. Wenn jemand den Fernseher ausschaltet,
während andere noch fernsehen möchten, wird es Aufruhr bei den übrigen
Zuschauern geben!</p>
<p>Wir verwenden den Typ <code>Rc&lt;T&gt;</code>, wenn wir Daten auf dem Haldenspeicher allokieren
möchten, damit mehrere Teile unseres Programms diese lesen können,
und wir können zum Zeitpunkt der Kompilierung nicht bestimmen, welcher Teil
zuletzt fertig sein würde. Wenn wir wüssten, welcher Teil zuletzt fertig sein
würde, könnten wir diesen Teil einfach zum Eigentümer der Daten machen, und die
Eigentumsregeln, die zur Kompilierzeit durchgesetzt werden, würden wirksam.</p>
<p>Beachte, dass <code>Rc&lt;T&gt;</code> nur in einsträngigen (single-threaded) Szenarien verwendet
werden kann. Wenn wir in Kapitel 16 auf Nebenläufigkeit (concurrency) eingehen,
werden wir uns mit der Referenzzählung in mehrsträngigen (multi-threaded)
Programmen befassen.</p>
<h3 id="rct-zur-gemeinsamen-nutzung-von-daten-verwenden"><a class="header" href="#rct-zur-gemeinsamen-nutzung-von-daten-verwenden"><code>Rc&lt;T&gt;</code> zur gemeinsamen Nutzung von Daten verwenden</a></h3>
<p>Kehren wir zu unserem Beispiel für die Cons-Liste in Codeblock 15-5 zurück.
Denke daran, dass wir es mit <code>Box&lt;T&gt;</code> definiert haben. Dieses Mal erstellen
wir zwei Listen, die beide gemeinsam eine dritte Liste besitzen. Konzeptionell
sieht dies ähnlich aus wie in Abbildung 15-3:</p>
<p><img alt="Zwei Listen die sich die Eigentümerschaft einer dritten Liste teilen" 
src="img/trpl15-03.svg" class="center" /></p>
<p><span class="caption">Abbildung 15-3: Zwei Listen <code>b</code> und <code>c</code> teilen sich 
die Eigentümerschaft über eine dritte Liste <code>a</code></span></p>
<p>Wir erstellen eine Liste <code>a</code>, die 5 und dann 10 enthält. Dann erstellen wir zwei
weitere Listen: <code>b</code>, die mit 3 beginnt, und <code>c</code>, die mit 4 beginnt. Sowohl
<code>b</code> als auch <code>c</code> werden dann mit mit der ersten Liste <code>a</code> fortfahren, die 5 und
10 enthält. Mit anderen Worten, beide Listen teilen sich die erste Liste mit 5
und 10.</p>
<p>Der Versuch, dieses Szenario mithilfe unserer Definition von <code>List</code> mit <code>Box&lt;T&gt;</code>
zu implementieren, funktioniert nicht, wie in Codeblock 15-17 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre></pre>
<p><span class="caption">Codeblock 15-17: Dies zeigt, dass wir mit <code>Box&lt;T&gt;</code> keine
zwei Listen haben dürfen, die versuchen, die Eigentümerschaft einer dritten Liste zu
teilen</span></p>
<p>Beim Versuch den Programmcode zu kompilieren, erhalten wir folgende Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` due to 2 previous errors
</code></pre>
<p>Die <code>Cons</code>-Varianten besitzen die Daten, die sie enthalten. Wenn wir also die
<code>b</code>-Liste erstellen, wird <code>a</code> in <code>b</code> verschoben und <code>b</code> besitzt <code>a</code>. Wenn wir
dann beim Erstellen von <code>c</code> versuchen erneut <code>a</code> zu verwenden, ist dies nicht
zulässig, da <code>a</code> verschoben wurde.</p>
<p>Wir könnten die Definition von <code>Cons</code> ändern, um stattdessen Referenzen zu
erhalten, aber dann müssten wir Lebensdauerparameter (lifetime parameters)
angeben. Durch die Angabe von Lebensdauerparametern würden wir angeben, dass
jedes Element in der Liste mindestens so lange wie die gesamte Liste lebt. Dies
ist bei den Elementen und Listen in Codeblock 15-17 der Fall, aber nicht in
jedem Szenario.</p>
<p>Stattdessen ändern wir unsere Definition von <code>List</code> so, dass <code>Rc&lt;T&gt;</code> anstelle
von <code>Box&lt;T&gt;</code> verwendet wird, wie in Codeblock 15-18 gezeigt. Jede
<code>Cons</code>-Variante enthält nun einen Wert und ein <code>Rc&lt;T&gt;</code>, das auf eine <code>List</code>
zeigt. Wenn wir <code>b</code> erstellen, klonen wir, anstatt <code>a</code> zu übernehmen, die
<code>Rc&lt;List&gt;</code>, die <code>a</code> enthält, und erhöhen die Anzahl der Referenzen von eins auf
zwei und lassen <code>a</code> und <code>b</code> die Eigentümerschaft (ownership) an den Daten
dieser <code>Rc&lt;List&gt;</code> teilen. Wir werden auch <code>a</code> klonen, wenn wir <code>c</code> erstellen,
wodurch die Anzahl der Referenzen von zwei auf drei erhöht wird. Jedes Mal,
wenn wir <code>Rc::clone</code> aufrufen, erhöht sich die Anzahl der Referenzen auf die
Daten in der <code>Rc&lt;List&gt;</code>, und die Daten werden erst dann aufgeräumt, wenn keine
Referenzen darauf vorhanden sind.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
<p><span class="caption">Codeblock 15-18: Eine Definition von <code>List</code> die <code>Rc&lt;T&gt;</code>
verwendet</span></p>
<p>Wir müssen eine <code>use</code>-Anweisung hinzufügen, um <code>Rc&lt;T&gt;</code> in den
Gültigkeitsbereich (scope) zu bringen, da sie nicht im Präludium (prelude) ist.
In <code>main</code> erstellen wir die Liste mit 5 und 10 und speichern sie in einem neuen
<code>Rc&lt;List&gt;</code> in <code>a</code>. Wenn wir dann <code>b</code> und <code>c</code> erstellen, rufen wir die Funktion
<code>Rc::clone</code> auf und übergeben eine Referenz auf <code>Rc&lt;List&gt;</code> in <code>a</code> als Argument.</p>
<p>Wir hätten <code>a.clone()</code> anstelle von <code>Rc::clone(&amp;a)</code> aufrufen können, aber Rusts
Konvention lautet in diesem Fall <code>Rc::clone</code>. Die Implementierung von <code>Rc::clone</code>
erstellt keine tiefe Kopie aller Daten, wie es bei den meisten Implementierungen
von <code>clone</code> der Fall ist. Der Aufruf von <code>Rc::clone</code> erhöht nur den
Referenzzähler, was nicht viel Zeit in benötigt. Tiefe Kopien von Daten
können viel Zeit in Anspruch nehmen. Durch die Verwendung von <code>Rc::clone</code> für
die Referenzzählung können wir visuell zwischen den Arten von Klonen mit tiefer
Kopie und Klonen, die den Referenzzähler erhöhen, unterscheiden. Bei
der Suche nach Performanzproblemen im Code müssen wir nur die Klone mit tiefer
Kopie berücksichtigen und können die Aufrufe von <code>Rc::clone</code> ignorieren.</p>
<h3 id="rct-zu-klonen-erhöht-den-referenzzähler"><a class="header" href="#rct-zu-klonen-erhöht-den-referenzzähler"><code>Rc&lt;T&gt;</code> zu klonen erhöht den Referenzzähler</a></h3>
<p>Lass uns unser Arbeitsbeispiel in Codeblock 15-18 ändern, damit sich die
Referenzanzahl ändert, wenn wir Referenzen auf <code>Rc&lt;List&gt;</code> in <code>a</code> erstellen
und aufräumen.</p>
<p>In Codeblock 15-19 ändern wir <code>main</code>, damit es einen inneren Gültigkeitsbereich um die
Liste <code>c</code> hat, so können wir sehen, wie sich der Referenzzähler ändert, wenn <code>c</code>
den Gültigkeitsbereich verlässt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;Zähler nach der Erstellung von a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;Zähler nach der Erstellung von b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;Zähler nach der Erstellung von c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;Zahler nachdem c den Gültigkeitsbereich verlässt = {}&quot;, Rc::strong_count(&amp;a));
}</code></pre></pre>
<p><span class="caption">Codeblock 15-19: Den Referenzzähler ausgeben</span></p>
<p>An jeden Punkt im Programm, an dem sich der Referenzzähler ändert, geben wir
den Referenzzähler aus, den wir durch Aufrufen der Funktion <code>Rc::strong_count</code>
erhalten. Diese Funktion heißt <code>strong_count</code> und nicht <code>count</code>, da der Typ
<code>Rc&lt;T&gt;</code> auch eine Funktion <code>weak_count</code> hat. Wir werden im Abschnitt
<a href="ch15-06-reference-cycles.html#verhindern-von-referenzzyklen-umwandeln-von-rct-in-weakt">„Verhindern von Referenzzyklen: <code>Rc&lt;T&gt;</code> in <code>Weak&lt;T&gt;</code>
verwandeln“</a> sehen wofür <code>weak_count</code> verwendet wird.</p>
<p>Dieser Programmcode gibt folgendes aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
Zähler nach der Erstellung von a = 1
Zähler nach der Erstellung von b = 2
Zähler nach der Erstellung von c = 3
Zahler nachdem c den Gültigkeitsbereich verlässt = 2
</code></pre>
<p>Wir sehen, dass <code>Rc&lt;List&gt;</code> in <code>a</code> einen anfänglichen Referenzzähler
von 1 hat. Jedes Mal wenn wir <code>clone</code> aufrufen, steigt die Anzahl um 1. Wenn <code>c</code>
den Gültigkeitsbereich verlässt, sinkt die Anzahl um 1. Wir müssen keine
Funktion aufrufen, um den Referenzzähler wie erforderlich zu verringern,
während wir <code>Rc::clone</code> aufrufen müssen, um den Referenzzähler zu erhöhen: Die
Implementierung des Merkmals (trait) <code>Drop</code> verringert den Referenzzähler
automatisch, wenn ein <code>Rc&lt;T&gt;</code>-Wert den Gültigkeitsbereich verlässt.</p>
<p>Was wir in diesem Beispiel nicht sehen können, ist, dass wenn <code>b</code> und dann <code>a</code>
am Ende von <code>main</code> den Gültigkeitsbereich verlassen, der Zähler 0 ist und
<code>Rc&lt;List&gt;</code> vollständig aufgeräumt wird. Durch die Verwendung von <code>Rc&lt;T&gt;</code> kann
ein einzelner Wert mehrere Eigentümer haben und der Zähler stellt sicher, dass
der Wert gültig bleibt, solange ein Eigentümer vorhanden ist.</p>
<p>Über unveränderbare (immutable) Referenzen kann man mit <code>Rc&lt;T&gt;</code> Daten zwischen
mehreren Teilen eines Programms zum Lesen austauschen. Wenn man mit <code>Rc&lt;T&gt;</code>
auch mehrere veränderbare (mutable) Referenzen haben könnte, verstößt man
möglicherweise gegen eine der in Kapitel 4 beschriebenen Ausleihregeln: Mehrere
veränderbar ausgeliehene Referenzen an derselben Stelle können zu
Daten-Wettlaufsituationen (data races) und Inkonsistenzen führen. Es ist jedoch
sehr nützlich, Daten verändern zu können! Im nächsten Abschnitt werden wir das
innere Veränderbarkeitsmuster und den Typ <code>RefCell&lt;T&gt;</code> erläutern, den man in
Verbindung mit <code>Rc&lt;T&gt;</code> verwenden kann, um mit dieser
Unveränderbarkeitsbeschränkung zu arbeiten.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-und-das-innere-veränderbarkeitsmuster"><a class="header" href="#refcellt-und-das-innere-veränderbarkeitsmuster"><code>RefCell&lt;T&gt;</code> und das innere Veränderbarkeitsmuster</a></h2>
<p><em>Innere Veränderbarkeit</em> (interior mutability) ist ein Entwurfsmuster in Rust,
mit dem man Daten auch dann verändern kann, wenn unveränderbare Referenzen auf
diese Daten vorhanden sind. Normalerweise ist diese Aktion nach den
Ausleihregeln nicht zulässig. Um Daten zu verändern, verwendet das Muster
„unsicherer Programmcode“ (<code>unsafe</code> code) innerhalb einer Datenstruktur, um
Rusts übliche Regeln, die Veränderbarkeit und Ausleihen betreffen, zu
verändern. Unsicherer Code zeigt dem Compiler an, dass wir die Regeln manuell
überprüfen, anstatt uns darauf zu verlassen, dass der Compiler sie für uns
überprüft; wir werden unsicheren Code in Kapitel 19 genauer besprechen.</p>
<p>Wir können Typen verwenden, die das innere Veränderbarkeitsmuster verwenden,
wenn wir sicherstellen können, dass die Ausleihregeln zur Laufzeit eingehalten
werden, obwohl der Compiler dies nicht garantieren kann. Der betroffene
unsichere Programmcode wird dann in eine sichere API eingeschlossen und der
äußere Typ ist immer noch unveränderbar.</p>
<p>Lass uns dieses Konzept untersuchen, indem wir uns den Typ <code>RefCell&lt;T&gt;</code> ansehen,
der dem inneren Veränderbarkeitsmuster folgt.</p>
<h3 id="mit-refcellt-ausleihregeln-zur-laufzeit-durchsetzen"><a class="header" href="#mit-refcellt-ausleihregeln-zur-laufzeit-durchsetzen">Mit <code>RefCell&lt;T&gt;</code> Ausleihregeln zur Laufzeit durchsetzen</a></h3>
<p>Im Gegensatz zu <code>Rc&lt;T&gt;</code> repräsentiert der Typ <code>RefCell&lt;T&gt;</code> die
einzige Eigentümerschaft (ownership) für die darin enthaltenen Daten. Was unterscheidet
<code>RefCell&lt;T&gt;</code> von einem Typ wie <code>Box&lt;T&gt;</code>? Erinnere dich an die Ausleihregeln die
wir im Kapitel 4 gelernt haben:</p>
<ul>
<li>Zu jeder Zeit kann man <em>entweder</em> eine veränderbare Referenz oder eine
beliebige Anzahl unveränderbarer Referenzen haben (nicht aber beides).</li>
<li>Referenzen müssen immer gültig sein.</li>
</ul>
<p>Mit Referenzen und <code>Box&lt;T&gt;</code> werden die Invarianten der Ausleihregeln beim
Kompilieren erzwungen. Mit <code>RefCell&lt;T&gt;</code> werden diese Invarianten <em>zur Laufzeit</em>
erzwungen. Wenn man mit Referenzen gegen diese Regeln verstößt wird beim
Kompilieren ein Fehler angezeigt. Wenn man mit <code>RefCell&lt;T&gt;</code> gegen diese Regeln
verstößt, wird das Programm mit <code>panic</code> beendet.</p>
<p>Die Überprüfung der Ausleihregeln zur Kompilierzeit hat den Vorteil, dass
Fehler früher im Entwicklungsprozess erkannt werden und die Laufzeitperformanz
nicht beeinträchtigt wird, da die gesamte Analyse im Voraus abgeschlossen
wurde. Aus diesen Gründen ist es in den meisten Fällen die beste Wahl, die
Ausleihregeln zur Kompilierzeit zu überprüfen. Aus diesem Grund ist dies die
Standardeinstellung von Rust.</p>
<p>Der Vorteil der Überprüfung der Ausleihregeln zur Laufzeit besteht darin, dass
bestimmte speichersichere Szenarien zulässig sind, während sie durch die
Überprüfung zur Kompilierzeit nicht zulässig gewesen wären. Die statische
Analyse ist wie der Rust-Compiler von Natur aus konservativ. Einige
Eigenschaften des Programmcodes lassen sich durch Analyse des Programmcodes
nicht erkennen: Das bekannteste Beispiel ist das Halteproblem, das den Rahmen
dieses Buches sprengt, aber ein interessantes Thema zum Nachforschen darstellt.</p>
<p>Da eine Analyse nicht möglich ist, lehnt der Rust-Compiler möglicherweise ein
ein korrektes Programm ab, wenn er nicht sicher sein kann, dass der Programmcode
den Eigentümerschaftsregeln entspricht. Auf diese Art ist Rust konservativ. Wenn
es ein falsches Programm akzeptiert, können Benutzer den Garantien von Rust
nicht vertrauen. Wenn Rust jedoch ein korrektes Programm ablehnt, wird der
Programmierer belästigt, obwohl nichts negatives passieren kann. Der Typ
<code>RefCell&lt;T&gt;</code> ist nützlich, wenn man sicher ist, dass der Programmcode den
Ausleihregeln entspricht, der Compiler dies jedoch nicht verstehen und
garantieren kann.</p>
<p>Ähnlich wie <code>Rc&lt;T&gt;</code> ist <code>RefCell&lt;T&gt;</code> nur für die Verwendung in einsträngigen
(single-threaded) Szenarien vorgesehen und gibt einen Fehler beim Kompilieren
aus, wenn man versucht, es in einem mehrsträngigen (multi-threaded) Kontext zu
verwenden. Wir werden in Kapitel 16 darüber sprechen, wie man die Funktionalität 
von <code>RefCell&lt;T&gt;</code> in einem mehrsträngigen Programm erhält.</p>
<p>Eine Zusammenfassung der Gründe für die Wahl von <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> oder
<code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> erlaubt mehrere Eigentümer derselben Daten. Mit <code>Box&lt;T&gt;</code> und
<code>RefCell&lt;T&gt;</code> haben Daten nur einen Eigentümer.</li>
<li><code>Box&lt;T&gt;</code> ermöglicht unveränderbares oder veränderbares Ausleihen, das zur
Kompilierzeit überprüft wird. <code>Rc&lt;T&gt;</code> erlaubt nur unveränderbares
Ausleihen, das zur Kompilierzeit geprüft wird und <code>RefCell&lt;T&gt;</code>
erlaubt unveränderbares oder veränderbares Ausleihen, das zur Laufzeit
überprüft wird.</li>
<li>Da <code>RefCell&lt;T&gt;</code> zur Laufzeit überprüfbares veränderbares Ausleihen zulässt,
kann man den Wert innerhalb von <code>RefCell&lt;T&gt;</code> auch dann ändern, wenn
<code>RefCell&lt;T&gt;</code> unveränderbar ist.</li>
</ul>
<p>Das Ändern des Werts innerhalb eines unveränderbaren Werts ist das <em>innere
Veränderbarkeitsmuster</em>. Schauen wir uns eine Situation an, in der innere
Veränderbarkeit nützlich ist, und untersuchen, wie dies möglich ist.</p>
<h3 id="innere-veränderbarkeit-das-veränderbare-ausleihen-eines-unveränderbaren-wertes"><a class="header" href="#innere-veränderbarkeit-das-veränderbare-ausleihen-eines-unveränderbaren-wertes">Innere Veränderbarkeit: Das veränderbare Ausleihen eines unveränderbaren Wertes</a></h3>
<p>Eine Konsequenz der Ausleihregeln ist, dass man einen unveränderbaren Wert
nicht veränderbar ausleihen kann. Dieser Programmcode wird beispielsweise nicht
kompilieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
let x = 5;
let y = &amp;mut x;
}</code></pre></pre>
<p>Wenn man versucht, diesen Programmcode zu kompilieren, wird die folgende
Fehlermeldung angezeigt:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` due to previous error
</code></pre>
<p>Es gibt jedoch Situationen, in denen es nützlich wäre, wenn ein Wert in
seinen Methoden selbst veränderbar ist, aber für einen anderen Programmcode
unveränderbar erscheint. Programmcode außerhalb der Methoden des Werts kann
diesen nicht verändern. Die Verwendung von <code>RefCell&lt;T&gt;</code> ist eine Möglichkeit,
die Fähigkeit zur inneren Veränderbarkeit zu erhalten, allerdings umgeht
<code>RefCell&lt;T&gt;</code> die Ausleihregeln nicht vollständig: Der Ausleihenprüfer (borrow
checker) im Compiler ermöglicht diese innere Veränderbarkeit, und die
Ausleihregeln werden stattdessen zur Laufzeit überprüft. Wenn man gegen die
Regeln verstößt wird <code>panic</code> anstelle eines Fehlers beim Kompilieren ausgelöst.</p>
<p>Lass uns ein praktisches Beispiel durcharbeiten, in dem wir <code>RefCell&lt;T&gt;</code>
verwenden können, um einen unveränderbaren Wert zu ändern und herauszufinden,
warum dies nützlich ist.</p>
<h4 id="ein-anwendungsfall-für-die-innere-veränderbarkeit-mock-objekte-mock-objects"><a class="header" href="#ein-anwendungsfall-für-die-innere-veränderbarkeit-mock-objekte-mock-objects">Ein Anwendungsfall für die innere Veränderbarkeit: Mock-Objekte (Mock Objects)</a></h4>
<p>Manchmal verwendet ein Programmierer beim Testen einen Typ anstelle eines
anderen Typs, um ein bestimmtes Verhalten zu beobachten und festzustellen, ob
es korrekt implementiert ist. Dieser Platzhaltertyp wird <em>Testdoppel</em> (test
double) genannt. Stell dir das so vor wie ein „Stunt-Double“ beim Film, bei dem
eine Person einspringt und einen Schauspieler in einer besonders schwierigen
Szene ersetzt. Testdoppel stehen für andere Typen ein, wenn wir Tests
durchführen. <em>Mock-Objekte</em> sind bestimmte Arten von Testdoppeln, die
aufzeichnen, was während eines Tests passiert, damit man bestätigen kann, dass
die richtigen Aktionen ausgeführt wurden.</p>
<p>Rust verfügt nicht im gleichen Sinne wie andere Programmiersprachen über
Objekte und in die Standardbibliothek integrierte Mock-Objekt-Funktionen. Man
kann jedoch definitiv eine Struktur erstellen, die denselben Zwecken dient wie
ein Mock-Objekt.</p>
<p>Hier ist das Szenario, das wir testen werden: Wir erstellen eine Bibliothek, die
einen Wert anhand eines Maximalwerts verfolgt und Nachrichten basierend darauf
sendet, wie nahe der Maximalwert am aktuellen Wert liegt. Diese Bibliothek kann
verwendet werden, um das Kontingent eines Benutzers für die Anzahl der
API-Aufrufe zu verfolgen, die er beispielsweise ausführen darf.</p>
<p>Unsere Bibliothek bietet nur die Funktionalität, zu verfolgen, wie nahe ein Wert
am Maximum liegt und wie die Nachrichten zu welchen Zeiten sein sollten.
Von Anwendungen, die unsere Bibliothek verwenden wird erwartet, dass sie den
Mechanismus zum Senden der Nachrichten bereitstellen: Die Anwendung könnte eine
Nachricht in der Anwendung anlegen, eine E-Mail senden, eine Textnachricht
senden oder etwas anderes. Die Bibliothek muss dieses Detail nicht kennen.
Alles, was es braucht, ist etwas, das ein von uns bereitgestelltes Merkmal
(trait) namens <code>Messenger</code> implementiert. Codeblock 15-20 zeigt den
Bibliothekscode:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Fehler: Du hast dein Kontingent überschritten!&quot;);
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send(&quot;Dringliche Warnung: Du hast über 90% deines Kontingents verbraucht!&quot;);
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send(&quot;Warnung: Du hast über 75% deines Kontingents verbraucht!&quot;);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-20: Eine Bibliothek um zu verfolgen, wie nahe
ein Wert an einem Maximalwert liegt, und um zu warnen, wenn der Wert über
bestimmten Schwellwerten liegt</span></p>
<p>Ein wichtiger Teil dieses Programmcodes ist, dass das Merkmal <code>Messenger</code> eine
Methode namens <code>send</code> hat, die eine unveränderbare Referenz auf <code>self</code> und den
Text der Nachricht enthält. Dieses Merkmal ist die Schnittstelle, die unser
Mock-Objekt implementieren muss, damit das Mock-Objekt auf die gleiche Weise
wie ein reales Objekt verwendet werden kann. Der andere wichtige Teil ist, dass
wir das Verhalten der Methode <code>set_value</code> von <code>LimitTracker</code> testen wollen. Wir
können ändern, was wir für den Parameter <code>value</code> übergeben, aber <code>set_value</code>
gibt nichts zurück, auf das wir Zusicherungen machen können. Wir wollen in der
Lage sein zu sagen, dass, wenn wir einen <code>LimitTracker</code> mit etwas erstellen,
das das Merkmal <code>Messenger</code> und einen bestimmten Wert für <code>max</code> implementiert,
wenn wir verschiedene Zahlen für <code>value</code> übergeben, der Messenger angewiesen
wird, die entsprechenden Nachrichten zu senden.</p>
<p>Wir benötigen ein Mock-Objekt, das anstelle einer E-Mail oder einer
Textnachricht beim Aufrufen von <code>send</code> nur die Nachrichten verfolgt, die
gesendet werden sollen. Wir können eine neue Instanz des Mock-Objekts estellen,
einen <code>LimitTracker</code> erstellen, der das Mock-Objekt verwendet, die
<code>set_value</code>-Methode für <code>LimitTracker</code> aufrufen und dann überprüfen, ob das
Mock-Objekt die erwarteten Nachrichten enthält. Codeblock 15-21 zeigt den
Versuch, ein Mock-Objekt zu implementieren, um genau das zu tun, aber der
Ausleihenprüfer erlaubt dies nicht:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Fehler: Du hast dein Kontingent überschritten!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Dringliche Warnung: Du hast über 90% deines Kontingents verbraucht!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warnung: Du hast über 50% deines Kontingents verbraucht!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-21: Der Versuch einen <code>MockMessenger</code> zu
implementieren, der vom Ausleihenprüfer nicht erlaubt wird</span></p>
<p>Dieser Testcode definiert eine Struktur <code>MockMessenger</code> mit einem
<code>sent_messages</code>-Feld mit einem <code>Vec</code> von <code>String</code>-Werten, um Nachrichten zu
verfolgen, die gesendet werden sollen. Wir definieren auch eine zugehörige
Funktion <code>new</code>, um das Erstellen neuer <code>MockMessenger</code>-Werte zu vereinfachen,
die mit einer leeren Liste von Nachrichten beginnen. Wir implementieren dann das
Merkmal <code>Messenger</code> für <code>MockMessenger</code> damit wir einem <code>LimitTracker</code> einen
<code>MockMessenger</code> übergeben können. Bei der Definition der Methode <code>send</code> nehmen wir
die übergebene Nachricht als Parameter und speichern sie in der Liste
<code>sent_messages</code> von <code>MockMessenger</code>.</p>
<p>Im Test testen wir, was passiert, wenn dem <code>LimitTracker</code> gesagt wird, er solle
<code>value</code> auf etwas setzen, das mehr als 75 Prozent des <code>max</code>-Wertes beträgt.
Zuerst erstellen wir einen neuen <code>MockMessenger</code>, der mit einer leeren
Nachrichtenliste beginnt. Dann erstellen wir einen neuen <code>LimitTracker</code> und
geben ihm eine Referenz auf den neuen <code>MockMessenger</code> und einen <code>max</code>-Wert von
100. Wir rufen die Methode <code>set_value</code> auf <code>LimitTracker</code> mit dem Wert 80 auf,
was mehr als 75 Prozent von 100 ist. Dann stellen wir sicher, dass die
Nachrichtenliste, die der <code>MockMessenger</code> verwaltet, nun eine einzige Nachricht
enthalten sollte.</p>
<p>Es gibt jedoch ein Problem mit diesem Test, wie hier gezeigt:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
2  |     fn send(&amp;self, msg: &amp;str);
   |             ----- help: consider changing that to be a mutable reference: `&amp;mut self`
...
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` due to previous error

warning: build failed, waiting for other jobs to finish...
error: build failed
</code></pre>
<p>Wir können den <code>MockMessenger</code> nicht ändern, um die Nachrichten zu verfolgen, da
die <code>send</code>-Methode eine unveränderbare Referenz auf <code>self</code> verwendet. Wir
können auch nicht den Vorschlag aus dem Fehlertext übernehmen, stattdessen 
<code>&amp;mut self</code> zu verwenden, da die Signatur von <code>send</code>nicht mit der Signatur in 
der Merkmalsdefinition von <code>Messenger</code> übereinstimmt (probiere es gerne aus und
schau dir die Fehlermeldung an, die dabei ausgegeben wird).</p>
<p>Dies ist eine Situation, in der innere Veränderbarkeit helfen kann! Wir
speichern die <code>send_messages</code> in einer <code>RefCell&lt;T&gt;</code> und dann kann die
<code>send</code>-Methode <code>sent_messages</code> ändern, um Nachrichten zu speichern, die wir
gesehen haben. Codeblock 15-22 zeigt, wie das aussieht:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Fehler: Du hast dein Kontingent überschritten!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Dringliche Warnung: Du hast über 90% deines Kontingents verbraucht!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warnung: Du hast über 50% deines Kontingents verbraucht!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --abschneiden--

<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span>        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
<p><span class="caption">Codeblock 15-22: <code>RefCell&lt;T&gt;</code> verwenden, um einen inneren
Wert zu verändern, während der äußere Wert als unveränderbar betrachtet wird</span></p>
<p>Das Feld <code>sent_messages</code> ist jetzt vom Typ <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> anstelle von
<code>Vec&lt;String&gt;</code>. In der Funktion <code>new</code> erstellen wir eine neue 
<code>RefCell&lt;Vec&lt;Sting&gt;&gt;</code>-Instanz um den leeren Vektor.</p>
<p>Für die Implementierung der <code>send</code>-Methode ist der erste Parameter immer noch
eine unveränderbare Ausleihe von <code>self</code>, die der Merkmalsdefinition entspricht.
Wir rufen <code>borrow_mut</code> auf der <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code>self.sent_messages</code> auf,
um eine veränderbare Referenz auf den Wert in der <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> zu
erhalten, der der Vektor ist. Dann können wir <code>push</code> auf der veränderbaren
Referenz zum Vektor aufrufen, um die während des Tests gesendeten Nachrichten zu
verfolgen.</p>
<p>Die letzte Änderung, die wir vornehmen müssen, betrifft die Behauptung: Um zu
sehen, wie viele Elemente sich im inneren Vektor befinden, rufen wir in der
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> <code>borrow</code> auf, um eine unveränderbare Referenz auf den
Vektor zu erhalten.</p>
<p>Nachdem du nun gesehen hast, wie du <code>RefCell&lt;T&gt;</code> verwendest, wollen wir uns mit
der Funktionsweise befassen.</p>
<h4 id="mit-refcellt-den-Überblick-über-die-ausleihen-zur-laufzeit-behalten"><a class="header" href="#mit-refcellt-den-Überblick-über-die-ausleihen-zur-laufzeit-behalten">Mit <code>RefCell&lt;T&gt;</code> den Überblick über die Ausleihen zur Laufzeit behalten</a></h4>
<p>Beim Erstellen unveränderbarer und veränderbarer Referenzen verwenden wir die
Syntax <code>&amp;</code> bzw. <code>&amp;mut</code>. Bei <code>RefCell&lt;T&gt;</code> verwenden wir die Methoden <code>borrow</code> und
<code>borrow_mut</code>, die Teil der sicheren API sind, die zu <code>RefCell&lt;T&gt;</code> gehört. Die
Methode <code>borrow</code> gibt den intelligenten Zeigertyp <code>Ref&lt;T&gt;</code> zurück und
<code>borrow_mut</code> den intelligenten Zeigertyp <code>RefMut&lt;T&gt;</code>. Beide Typen
implementieren <code>Deref</code>, sodass wir sie wie reguläre Referenzen behandeln
können.</p>
<p>Der <code>RefCell&lt;T&gt;</code> verfolgt, wie viele intelligente Zeiger <code>Ref&lt;T&gt;</code> und <code>RefMut&lt;T&gt;</code>
derzeit aktiv sind. Jedes Mal, wenn wir <code>borrow</code> aufrufen, erhöht <code>RefCell&lt;T&gt;</code>
die Anzahl der aktiven unveränderbaren Ausleihen. Wenn ein <code>Ref&lt;T&gt;</code>-Wert
außerhalb des Gültigkeitsbereichs (scope) liegt, sinkt die Anzahl der unveränderbaren
Ausleihen um eins. Genau wie bei den Ausleihregeln zur Kompilierzeit können
wir mit <code>RefCell&lt;T&gt;</code> zu jedem Zeitpunkt viele unveränderbare Ausleihen oder eine
veränderbare Ausleihe haben.</p>
<p>Wenn wir versuchen, diese Regeln zu verletzen, erhalten wir keinen
Kompilierfehler wie bei Referenzen, sondern die Implementierung von
<code>RefCell&lt;T&gt;</code> wird zur Laufzeit abstürzen. Codeblock 15-23 zeigt eine
Modifikation der Implementierung von <code>send</code> in Codeblock 15-22. Wir versuchen
absichtlich, zwei veränderbare Ausleihen zu erstellen, die für denselben
Bereich aktiv sind, um zu veranschaulichen, dass <code>RefCell&lt;T&gt;</code> uns daran
hindert, dies zur Laufzeit zu tun.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust panics"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Fehler: Du hast dein Kontingent überschritten!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Dringliche Warnung: Du hast über 90% deines Kontingents verbraucht!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warnung: Du hast über 50% deines Kontingents verbraucht!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 15-23: Wir erstellen zwei veränderbare Referenzen im
selben Gültigkeitsbereich, um zu sehen, dass <code>RefCell&lt;T&gt;</code> abstürzt</span></p>
<p>Wir erstellen eine Variable <code>one_borrow</code> für den intelligenten Zeiger 
<code>RefMut&lt;T&gt;</code>, der von <code>borrow_mut</code> zurückgegeben wird. Dann erstellen wir auf die
gleiche Weise eine weitere veränderbare Ausleihe in der Variable <code>two_borrow</code>.
Dadurch werden zwei veränderbare Referenzen im selben Bereich erstellt, was
nicht zulässig ist. Wenn wir die Tests für unsere Bibliothek ausführen, wird der
Programmcode in Codeblock 15-23 fehlerfrei kompiliert, aber der Test schlägt
fehl: </p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/lib.rs:60:53
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Beachte, dass der Programmcode mit der Meldung <code>already borrowed: BorrowMutError</code> abstürzt. Auf diese Weise behandelt <code>RefCell&lt;T&gt;</code> zur
Laufzeit Verstöße gegen die Ausleihregel.</p>
<p>Wenn du dich dafür entscheidest, Ausleihfehler zur Laufzeit und nicht zur
Kompilierzeit abzufangen, wie wir es hier getan haben, bedeutet das, dass du
Fehler in deinem Code möglicherweise erst später im Entwicklungsprozess
findest: Möglicherweise erst, wenn dein Code in der Produktion eingesetzt
wurde. Außerdem würde dieser Programmcode eine kleine Beeinträchtigung der
Laufzeitperformanz verursachen, da die Ausleihen zur Laufzeit und nicht zur
Kompilierzeit nachverfolgt werden. Die Verwendung von <code>RefCell&lt;T&gt;</code> ermöglicht
es jedoch, ein Mock-Objekt zu schreiben, das sich selbst ändern kann, um die
Nachrichten zu verfolgen, die es gesehen hat, während man es in einem Kontext
verwendet, in dem nur unveränderbare Werte zulässig sind. Man kann
<code>RefCell&lt;T&gt;</code> trotz seiner Kompromisse verwenden, um mehr Funktionen zu
erhalten, als reguläre Referenzen bieten.</p>
<h3 id="mehrere-eigentümer-veränderbarer-daten-durch-kombinieren-von-rct-und-refcellt"><a class="header" href="#mehrere-eigentümer-veränderbarer-daten-durch-kombinieren-von-rct-und-refcellt">Mehrere Eigentümer veränderbarer Daten durch Kombinieren von <code>Rc&lt;T&gt;</code> und <code>RefCell&lt;T&gt;</code></a></h3>
<p>Eine übliche Methode zur Verwendung von <code>RefCell&lt;T&gt;</code> ist die Kombination mit
<code>Rc&lt;T&gt;</code>. Erinnere dich, dass man mit <code>Rc&lt;T&gt;</code> mehrere Eigentümer einiger Daten
haben kann, aber nur unveränderbaren Zugriff auf diese Daten erhält. Wenn
man eine <code>Rc&lt;T&gt;</code> hat, das eine <code>RefCell&lt;T&gt;</code> enthält, kann man einen Wert
erhalten, der mehrere Eigentümer hat <em>und</em> veränderbar ist!</p>
<p>Erinnern wir uns beispielsweise an das Beispiel für die Cons-Liste in Codeblock
15-18, in dem wir <code>Rc&lt;T&gt;</code> verwendet haben, um mehrere Listen die gemeinsame
Nutzung einer anderen Liste zu ermöglichen. Da <code>Rc&lt;T&gt;</code> nur unveränderbare Werte
enthält, können wir keinen der Werte in der Liste ändern, sobald wir sie
erstellt haben. Fügen wir <code>RefCell&lt;T&gt;</code> hinzu, um die Werte in den Listen ändern
zu können. Codeblock 15-24 zeigt, dass wir durch Verwendung einer <code>RefCell&lt;T&gt;</code>
in der Cons-Definition den in allen Listen gespeicherten Wert ändern können:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}</code></pre></pre>
<p><span class="caption">Codeblock 15-24: Verwendung von <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> um <code>List</code>
zu erstellen, die wir verändern können</span></p>
<p>Wir erstellen einen Wert, der eine Instanz von <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> ist, und
speichern ihn dann in einer Variable mit dem Namen <code>value</code>, damit wir später
direkt darauf zugreifen können. Dann erstellen wir eine Liste in <code>a</code> mit einer
<code>Cons</code>-Variante, die <code>value</code> enthält. Wir müssen <code>value</code> klonen, damit sowohl 
<code>a</code> als auch <code>value</code> Eigentümerschaft am inneren Wert <code>5</code> haben, anstatt das
Eigentum von <code>value</code> auf <code>a</code> zu übertragen oder <code>a</code> von <code>value</code> auszuleihen.</p>
<p>Wir wickeln die Liste <code>a</code> in ein <code>Rc&lt;T&gt;</code> ein. Wenn wir also die Listen <code>b</code> und
<code>c</code> erstellen, können beide auf <code>a</code> verweisen, was wir in Codeblock 15-18 getan
haben.</p>
<p>Nachdem wir die Listen <code>a</code>, <code>b</code> und <code>c</code> erstellt haben, wollen wir 10 zum Wert
in <code>value</code> addieren. Dazu rufen wir <code>borrow_mut</code> für <code>value</code> auf, wobei die in
Kapitel 5 beschriebene automatische Dereferenzierung verwendet wird (siehe
Abschnitt <a href="ch05-03-method-syntax.html#wo-ist-der-operator--">„Wo ist der Operator <code>-&gt;</code>?“</a>), um den <code>Rc&lt;T&gt;</code>
auf den inneren <code>RefCell&lt;T&gt;</code>-Wert zu dereferenzieren. Die Methode <code>borrow_mut</code>
gibt einen intelligenten Zeiger <code>RefMut&lt;T&gt;</code> zurück, und wir verwenden den
Dereferenzierungsoperator darauf und ändern den inneren Wert.</p>
<p>Wenn wir <code>a</code>, <code>b</code> und <code>c</code> ausgeben, können wir sehen, dass sie alle den
veränderten Wert 15 anstelle von 5 haben:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>Diese Technik ist ziemlich sauber! Durch die Verwendung von <code>RefCell&lt;T&gt;</code> haben
wir einen nach außen unveränderbaren <code>List</code>-Wert. Wir können jedoch die
Methoden für <code>RefCell&lt;T&gt;</code> verwenden, die den Zugriff auf die innere
Veränderbarkeit ermöglichen, damit wir unsere Daten bei Bedarf ändern können.
Die Laufzeitprüfungen der Ausleihregeln schützen uns vor
Daten-Wettlaufsituationen (data races), und manchmal lohnt es sich, ein wenig
Geschwindigkeit für diese Flexibilität in unseren Datenstrukturen
einzutauschen. Beachte, dass <code>RefCell&lt;T&gt;</code> nicht bei nebenläufigen Code
funktioniert! <code>Mutex&lt;T&gt;</code> ist die Strang-sichere (thread-safe) Version von
<code>RefCell&lt;T&gt;</code> und wir werden <code>Mutex&lt;T&gt;</code> in Kapitel 16 besprechen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referenzzyklen-können-zu-einem-speicherleck-führen"><a class="header" href="#referenzzyklen-können-zu-einem-speicherleck-führen">Referenzzyklen können zu einem Speicherleck führen</a></h2>
<p>Die Speichersicherheitsgarantien von Rust machen es schwierig, aber nicht
unmöglich, versehentlich Speicher zu erstellen, der niemals aufgeräumt wird
(bekannt als <em>Speicherleck</em> (memory leak)). Das vollständige Verhindern von
Speicherlecks gehört nicht zu den Garantien von Rust, d.h. Speicherlecks sind
in Rust speichersicher. Wir können sehen, dass Rust Speicherlecks mithilfe von
<code>Rc&lt;T&gt;</code> und <code>RefCell&lt;T&gt;</code> zulässt: Es ist möglich, Referenzen zu erstellen, bei
denen Elemente in einem Zyklus aufeinander referenzieren. Dies führt zu
Speicherlecks, da der Referenzzähler jedes Elements im Zyklus niemals 0
erreicht und die Werte niemals aufgeräumt werden.</p>
<h3 id="einen-referenzzyklus-erstellen"><a class="header" href="#einen-referenzzyklus-erstellen">Einen Referenzzyklus erstellen</a></h3>
<p>Schauen wir uns an, wie ein Referenzzyklus stattfinden kann und wie er verhindert
werden kann, beginnend mit der Definition der Aufzählung <code>List</code> und einer
Methode <code>tail</code> in Codeblock 15-25:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
<p><span class="caption">Codeblock 15-25: Definition einer Cons-Liste die ein
<code>RefCell&lt;T&gt;</code> hält, damit man ändern kann, worauf eine <code>Cons</code>-Variante
referenziert</span></p>
<p>Wir verwenden eine andere Variante der <code>List</code>-Definition aus Codeblock 15-5.
Das zweite Element in der <code>Cons</code>-Variante ist jetzt <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>. Dies
bedeutet, dass wir anstelle der Möglichkeit, den <code>i32</code>-Wert wie in Codeblock
15-24 zu ändern, den <code>List</code>-Wert einer <code>Cons</code>-Variante ändern auf den sie
zeigt. Wir fügen eine <code>tail</code>-Methode hinzu, damit wir bequem auf das zweite
Element zugreifen können, wenn wir eine <code>Cons</code>-Variante haben.</p>
<p>In Codeblock 15-26 fügen wir eine Funktion <code>main</code> hinzu, die die Definitionen
in Codeblock 15-25 verwendet. Dieser Code erstellt eine Liste in <code>a</code> und eine
Liste in <code>b</code>, die auf die Liste in <code>a</code> verweist. Anschließend wird die Liste in
<code>a</code> so geändert, dass sie auf <code>b</code> zeigt, wodurch ein Referenzzyklus erstellt
wird. Es gibt <code>println!</code>-Anweisungen auf dem Weg, um zu zeigen, wie hoch der
Referenzzähler an verschiedenen Punkten in diesem Prozess sind.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a anfängliche Rc-Zählung = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a nächstes Element = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a Rc-Zählung nach Erstellen von b = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b anfängliche Rc-Zählung = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b nächstes Element = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b Rc-Zählung nach Änderung von a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a Rc-Zählung nach Änderung von a = {}&quot;, Rc::strong_count(&amp;a));

    // Kommentiere die nächste Zeile aus, um zu sehen, dass wir einen Zyklus haben;
    // es wird den Stapelspeicher überlaufen lassen
    // println!(&quot;a nächstes Element = {:?}&quot;, a.tail());
}</code></pre></pre>
<p><span class="caption">Codeblock 15-26: Erstellen eines Referenzzyklus aus zwei
aufeinanderzeigenden Listenwerten</span></p>
<p>Wir erstellen eine <code>Rc&lt;List&gt;</code>-Instanz, die einen <code>List</code>-Wert in der Variablen
<code>a</code> mit einer initialen Liste <code>5, Nil</code> enthält. Wir erstellen dann eine
<code>Rc&lt;List&gt;</code>-Instanz, die einen anderen <code>List</code>-Wert in der Variablen <code>b</code> enthält,
die den Wert 10 enthält und auf die Liste in <code>a</code> zeigt.</p>
<p>Wir modifizieren <code>a</code> so, dass es auf <code>b</code> anstatt auf <code>Nil</code> zeigt, wodurch ein
Zyklus erstellt wird. Wir tun dies, indem wir die <code>tail</code>-Methode verwenden, um
eine Referenz auf <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> in <code>a</code> zu erhalten, die wir in die
Variable <code>link</code> einfügen. Dann verwenden wir die <code>borrow_mut</code>-Methode für
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, um den Wert von <code>Rc&lt;List&gt;</code>, der einen <code>Nil</code>-Wert enthält,
in <code>Rc&lt;List&gt;</code> in <code>b</code> zu ändern.</p>
<p>Wenn wir diesen Programmcode ausführen und das letzte <code>println!</code>
auskommentieren, erhalten wir folgende Ausgabe:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a anfängliche Rc-Zählung = 1
a nächstes Element = Some(RefCell { value: Nil })
a Rc-Zählung nach erstellen von b = 2
b anfängliche Rc-Zählung = 1
b nächstes Element = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b Rc-Zählung nach Änderung von a = 2
a Rc-Zählung nach Änderung von a = 2     
</code></pre>
<p>Der Referenzzähler der <code>Rc&lt;List&gt;</code>-Instanzen in <code>a</code> und <code>b</code> beträgt 2, nachdem
wir die Liste in <code>a</code> so geändert haben, dass sie auf <code>b</code> zeigt. Am Ende von
<code>main</code> versucht Rust, zuerst <code>b</code> aufzuräumen, wodurch der Zähler der
<code>Rc&lt;List&gt;</code>-Instanz in <code>b</code> um 1 verringert wird. Der Speicher, den <code>Rc&lt;List&gt;</code>
auf dem Haldenspeicher (heap) hat, wird zu diesem Zeitpunkt nicht aufgeräumt,
da seine Referenzanzahl 1 und nicht 0 ist. Dann räumt Rust <code>a</code> auf, was die
Referenzanzahl der <code>Rc&lt;List&gt;</code>-Instanz in <code>a</code> ebenfalls von 2 auf 1 reduziert.
Der Speicher dieser Instanz kann ebenfalls nicht aufgeräumt werden, weil die
andere <code>Rc&lt;List&gt;</code>-Instanz immer noch auf sie referenziert. Der der Liste
zugewiesene Speicher bleibt für immer unaufgeräumt. Um diesen Referenzzyklus zu
veranschaulichen, haben wir in Abbildung 15-4 ein Diagramm erstellt.</p>
<img alt="Referenzzyklus von Listen" src="img/trpl15-04.svg" class="center" style="width: 40%;" />
<p><span class="caption">Abbildung 15-4: Ein Referenzzyklus der Listen <code>a</code> und <code>b</code>,
die aufeinander zeigen</span></p>
<p>Wenn man das letzte <code>println!</code> auskommentiert und das Programm ausführt,
versucht Rust, diesen Zyklus mit <code>a</code> auszugeben, wobei <code>b</code> auf <code>a</code> zeigt, und so
weiter, bis der Stapelspeicher (stack) überläuft.</p>
<p>Im Vergleich zu einem realen Programm sind die Konsequenzen, die das Anlegen
eines Referenzzyklus in diesem Beispiel hat, nicht sehr schlimm: Gleich nachdem
wir den Referenzzyklus angelegt haben, endet das Programm. Wenn jedoch ein
komplexeres Programm viel Speicher in einem Zyklus allokierte und diesen lange
Zeit behielte, würde das Programm mehr Speicher als erforderlich verbrauchen
und das System möglicherweise überlasten, sodass ihm der verfügbare Speicher
ausgeht.</p>
<p>Das Erstellen von Referenzzyklen ist nicht einfach, aber auch nicht unmöglich.
Wenn man <code>RefCell&lt;T&gt;</code>-Werte hat, die <code>Rc&lt;T&gt;</code>-Werte oder ähnliche verschachtelte
Typkombinationen mit innerer Veränderbarkeit und Referenzzählung enthalten,
muss man sicherstellen, dass man keine Zyklen erstellt. Man kann sich nicht
darauf verlassen, dass Rust sie feststellen kann. Das Erstellen eines
Referenzzyklus wäre ein logischer Fehler in deinem Programm, den du mithilfe
automatisierter Tests, Codeüberprüfungen und anderer Methoden zur
Softwareentwicklung minimieren solltest.</p>
<p>Eine andere Lösung zur Vermeidung von Referenzzyklen besteht darin, deine
Datenstrukturen so zu reorganisieren, dass einige Referenzen die
Eigentümerschaft (ownership) erhalten und andere nicht. Infolgedessen können
Zyklen bestehen, die aus Beziehungen mit und ohne Eigentümerschaft bestehen,
und nur die Beziehungen mit Eigentümerschaft beeinflussen, ob ein
Wert aufgeräumt wird oder nicht. In Codeblock 15-25 möchten wir immer, dass
<code>Cons</code>-Varianten ihre Liste besitzen, sodass eine Neuorganisation der
Datenstruktur nicht möglich ist. Schauen wir uns ein Beispiel an, in dem
Diagramme aus übergeordneten und untergeordneten Knoten verwendet werden, um
festzustellen, wann Beziehungen ohne Eigentümerschaft ein geeigneter Weg sind,
um Referenzzyklen zu verhindern.</p>
<h3 id="verhindern-von-referenzzyklen-umwandeln-von-rct-in-weakt"><a class="header" href="#verhindern-von-referenzzyklen-umwandeln-von-rct-in-weakt">Verhindern von Referenzzyklen: Umwandeln von <code>Rc&lt;T&gt;</code> in <code>Weak&lt;T&gt;</code></a></h3>
<p>Bisher haben wir gezeigt, dass das Aufrufen von <code>Rc::clone</code> den <code>strong_count</code>
einer <code>Rc&lt;T&gt;</code>-Instanz erhöht und eine <code>Rc&lt;T&gt;</code>-Instanz nur dann aufgeräumt wird,
wenn ihr <code>strong_count</code> 0 ist. Man kann auch eine <em>schwache Referenz</em> (weak
reference) auf den Wert innerhalb einer <code>Rc&lt;T&gt;</code>-Instanz erstellen, indem man
<code>Rc::downgrade</code> aufruft und eine Referenz auf den <code>Rc&lt;T&gt;</code> übergibt. Starke
Referenzen sind die Art und Weise, wie man die Eigentümerschaft an einer
<code>Rc&lt;T&gt;</code>-Instanz teilen kann. Schwache Referenzen drücken keine
Eigentumsbeziehung aus, und ihre Anzahl hat keinen Einfluss darauf, wann eine
<code>Rc&lt;T&gt;</code> Instanz aufgeräumt wird. Sie werden keinen Referenzzyklus verursachen,
weil jeder Zyklus, der schwache Referenzen beinhaltet, unterbrochen wird,
sobald die Anzahl der starken Referenzen der beteiligten Werte 0 ist.</p>
<p>Wenn man <code>Rc::downgrade</code> aufruft, erhält man einen intelligenten Zeiger vom Typ
<code>Weak&lt;T&gt;</code>. Anstatt den <code>strong_count</code> in der <code>Rc&lt;T&gt;</code>-Instanz um 1 zu erhöhen,
erhöht der Aufruf von <code>Rc::downgrade</code> den <code>weak_count</code> um 1. Der Typ <code>Rc&lt;T&gt;</code>
verwendet <code>weak_count</code>, um den Überblick zu behalten wie viele
<code>Weak&lt;T&gt;</code>-Referenzen existieren, ähnlich wie bei <code>strong_count</code>. Der
Unterschied besteht darin, dass <code>weak_count</code> nicht 0 sein muss, damit die
<code>Rc&lt;T&gt;</code>-Instanz aufgeräumt wird.</p>
<p>Mit starken Referenzen kann man die Eigentümerschaft einer <code>Rc&lt;T&gt;</code>-Instanz
teilen, schwache Referenzen drücken hingegen keine Eigentümerschafts-Beziehung
aus. Sie verursachen keinen Referenzzyklus, da jeder Zyklus mit schwachen
Referenzen unterbrochen wird, sobald die starke Referenzanzahl der beteiligten
Werte 0 beträgt.</p>
<p>Da der Wert, auf den <code>Weak&lt;T&gt;</code> referenziert, möglicherweise aufgeräumt wurde, musst
du sicherstellen, dass der Wert noch vorhanden ist, um etwas mit dem Wert zu
tun, auf den ein <code>Weak&lt;T&gt;</code> zeigt. Ruft man dazu die Methode <code>upgrade</code> für eine
<code>Weak&lt;T&gt;</code>-Instanz auf, die eine <code>Option&lt;Rc&lt;T&gt;&gt;</code>zurückgibt, erhält man ein <code>Some</code>
als Ergebnis, wenn der Wert <code>Rc&lt;T&gt;</code> noch nicht aufgeräumt wurde, und das Ergebnis
<code>None</code>, wenn der <code>Rc&lt;T&gt;</code>-Wert aufgeräumt wurde. Da <code>upgrade</code> eine
<code>Option&lt;Rc&lt;T&gt;&gt;</code> zurückgibt, stellt Rust sicher, dass der Fall <code>Some</code> und der
Fall <code>None</code> behandelt werden und es keine ungültigen Zeiger gibt.</p>
<p>Anstatt eine Liste zu verwenden, deren Elemente nur das nächste Element kennen,
erstellen wir eine Baumstruktur, deren Elemente die Kind-Elemente <em>und</em> die
Eltern-Elemente kennen.</p>
<h4 id="erstellen-einer-baumdatenstruktur-ein-knoten-mit-kind-knoten"><a class="header" href="#erstellen-einer-baumdatenstruktur-ein-knoten-mit-kind-knoten">Erstellen einer Baumdatenstruktur: Ein Knoten mit Kind-Knoten</a></h4>
<p>Zunächst erstellen wir eine Baumstruktur mit Knoten (nodes), die ihre
Kind-Knoten kennen. Wir erstellen eine Struktur mit dem
Namen <code>Node</code>, die ihren eigenen <code>i32</code>-Wert sowie Referenzen auf die
Kind-<code>Node</code>-Werte enthält:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>Wir möchten, dass ein <code>Node</code> seine Kind-Elemente besitzt, und wir möchten diese
Eigentümerschaft mit Variablen teilen, damit wir direkt auf jeden <code>Node</code> in
der Baumstruktur zugreifen können. Zu diesem Zweck definieren wir die
<code>Vec&lt;T&gt;</code>-Elemente als Werte vom Typ <code>Rc&lt;Node&gt;</code>. Wir möchten auch ändern, welche
Knoten Kind-Knoten eines anderen Knotens sind, sodass wir einen <code>RefCell&lt;T&gt;</code> in
<code>children</code> um den <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> haben.</p>
<p>Als Nächstes verwenden wir unsere Strukturdefinition und erstellen eine
<code>Node</code>-Instanz mit dem Namen <code>leaf</code> und dem Wert 3 und ohne Kind-Elemente,
sowie eine weitere Instanz mit dem Namen <code>branch</code> und dem Wert 5 und <code>leaf</code> als
Kind-Element, wie in Codeblock 15-27 gezeigt wird:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
<p><span class="caption">Codeblock 15-27: Erstellen eines <code>leaf</code>-Knotens ohne
Kind-Element und eines <code>branch</code>-Knotens mit <code>leaf</code> als Kind-Element</span></p>
<p>Wir klonen den <code>Rc&lt;Node&gt;</code> in <code>leaf</code> und speichern ihn in <code>branch</code>, was bedeutet,
dass der <code>Node</code> in <code>leaf</code> jetzt zwei Eigentümer hat: <code>leaf</code> und <code>branch</code>. Wir
können über <code>branch.children</code> von <code>branch</code> zu <code>leaf</code> gelangen, aber es gibt
keine Möglichkeit, von <code>leaf</code> zu <code>branch</code> zu gelangen. Der Grund dafür ist, dass
<code>leaf</code> keine Referenz zu <code>branch</code> hat und daher nicht weiß, dass diese in
Beziehung stehen. Wir möchten, dass <code>leaf</code> weiß, dass <code>branch</code> ein
übergeordnetes Element ist. Das machen wir als Nächstes.</p>
<h4 id="hinzufügen-einer-referenz-vom-kind--zum-eltern-element"><a class="header" href="#hinzufügen-einer-referenz-vom-kind--zum-eltern-element">Hinzufügen einer Referenz vom Kind- zum Eltern-Element</a></h4>
<p>Um dem Kind-Knoten seinen Eltern-Knoten bewusst zu
machen, müssen wir unserer Strukturdefinition <code>Node</code> ein <code>parent</code>-Feld
hinzufügen. Das Problem besteht darin, zu entscheiden, welcher Typ <code>parent</code> sein
soll. Wir wissen, dass es keinen <code>Rc&lt;T&gt;</code> enthalten kann, da dies einen
Referenzzyklus erzeugen würde, bei dem <code>leaf.parent</code> auf <code>branch</code> und
<code>branch.children</code> auf <code>leaf</code> zeigt, was dazu führen würde das die 
<code>strong_count</code>-Werte niemals 0 sein würden.</p>
<p>Wenn man die Beziehungen auf andere Weise betrachtet, sollte ein Eltern-Knoten
die Eigentümerschaft seiner Kind-Knoten besitzen: Wenn ein Eltern-Knoten
aufgeräumt wird, sollten auch seine Kind-Knoten aufgeräumt werden. Ein
Kind-Knoten sollte jedoch keine Eigentümerschaft seines Eltern-Elementes haben:
Wenn wir einen Kind-Knoten aufräumen, sollte das Eltern-Element weiterhin
existieren. Dies ist ein Fall für schwache Referenzen!</p>
<p>Anstelle von <code>Rc&lt;T&gt;</code> wird <code>parent</code> den Typ <code>Weak&lt;T&gt;</code> verwenden, im Speziellen
einen <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Nun sieht unsere <code>Node</code>-Strukturdefinition
folgendermaßen aus:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>Ein Knoten kann auf seinen Eltern-Knoten referenzieren, besitzt ihn jedoch
nicht. In Codeblock 15-28 aktualisieren wir <code>main</code>, um diese neue Definition
zu verwenden, damit der <code>leaf</code>-Knoten auf seinen Eltern-Knoten <code>branch</code>
referenzieren kann:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}</code></pre></pre>
<p><span class="caption">Codeblock 15-28: Ein <code>leaf</code>-Knoten mit einer schwachen
Referenz auf seinen Eltern-Knoten <code>branch</code></span></p>
<p>Das Erstellen des <code>leaf</code>-Knotens ähnelt Codeblock 15-27 mit Ausnahme des Feldes
<code>parent</code>: <code>leaf</code> beginnt ohne Eltern-Knoten, daher erstellen wir eine neue
leere <code>Weak&lt;Node&gt;</code>-Referenz-Instanz.</p>
<p>Wenn wir zu diesem Zeitpunkt versuchen, mit der Methode <code>upgrade</code> eine
Referenz auf das Eltern-Element von <code>leaf</code> zu bekommen, erhalten wir den
Wert <code>None</code>. Wir sehen dies in der Ausgabe der ersten <code>println!</code>-Anweisung:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>Wenn wir den <code>branch</code>-Knoten erstellen, hat er auch eine neue <code>Weak&lt;Node&gt;</code>-Referenz
im Feld <code>parent</code>, da <code>branch</code> keinen Eltern-Knoten hat. Wir haben
noch immer <code>leaf</code> als Kind-Element von <code>branch</code>. Sobald
wir die <code>Node</code>-Instanz in <code>branch</code> haben, können wir <code>leaf</code> ändern, um ihm eine
<code>Weak&lt;Node&gt;</code>-Referenz auf sein Eltern-Element zu geben. Wir verwenden
die <code>borrow_mut</code>-Methode für <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> im <code>parent</code>-Feld von <code>leaf</code> und
verwenden dann die Funktion <code>Rc::downgrade</code>, um eine <code>Weak&lt;Node&gt;</code>-Referenz auf
<code>branch</code> aus dem <code>Rc&lt;Node&gt;</code> in <code>branch</code> zu erzeugen.</p>
<p>Wenn wir das Eltern-Element von <code>leaf</code> erneut ausgeben, erhalten wir
diesmal eine <code>Some</code>-Variante mit <code>branch</code>: Jetzt kann <code>leaf</code> auf das
Eltern-Element zugreifen! Wenn wir <code>leaf</code> ausgeben, vermeiden wir auch
den Zyklus, der schließlich zu einem Stapelspeicherüberlauf führte, wie wir ihn
in Codeblock 15-26 hatten. Die <code>Weak&lt;Node&gt;</code>-Referenzen werden als <code>(Weak)</code>
ausgegeben:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>Das Fehlen einer unendlichen Ausgabe bedeutet, dass dieser Programmcode keinen
Referenzzyklus erzeugt hat. Wir können dies auch anhand der Werte erkennen, die
wir durch den Aufruf von <code>Rc::strong_count</code> und <code>Rc::weak_count</code> erhalten.</p>
<h4 id="visualisieren-von-Änderungen-an-strong_count-und-weak_count"><a class="header" href="#visualisieren-von-Änderungen-an-strong_count-und-weak_count">Visualisieren von Änderungen an <code>strong_count</code> und <code>weak_count</code></a></h4>
<p>Schauen wir uns an, wie sich die Werte für <code>strong_count</code> und <code>weak_count</code> der
<code>Rc&lt;Node&gt;</code>-Instanzen ändern, indem ein neuer innerer Gültigkeitsbereich (scope)
erstellt und die Erstellung von <code>branch</code> in diesen Bereich verschoben wird. Auf
diese Weise können wir sehen, was passiert, wenn <code>branch</code> erstellt und dann
aufgeräumt wird, wenn es den Gültigkeitsbereich verlässt. Die Änderungen
sind in Codeblock 15-29 aufgeführt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
<p><span class="caption">Codeblock 15-29: Erstellen von <code>branch</code> in einem inneren
Gültigkeitsbereich und Prüfen der starken und schwachen Referenzzähler</span></p>
<p>Nachdem <code>leaf</code> erstellt wurde, hat <code>Rc&lt;Node&gt;</code> einen <code>strong_count</code> von 1 und
einen <code>weak_count</code> von 0. Im inneren Gültigkeitsbereich erstellen wir <code>branch</code> und ordnen
ihm <code>leaf</code> zu. Zum Zeitpunkt des Ausgebens der Zähler, hat der <code>Rc&lt;Node&gt;</code> in
<code>branch</code> einen <code>strong_count</code> von 1 und einen <code>weak_count</code> von 1 (da <code>leaf.parent</code>
mit einen <code>Weak&lt;Node&gt;</code> auf <code>branch</code> zeigt). Wenn wir den Zähler in <code>leaf</code>
ausgeben, werden wir sehen, dass er einen <code>strong_count</code> von 2 hat, da <code>branch</code>
jetzt einen Klon des <code>Rc&lt;Node&gt;</code> von <code>leaf</code> in <code>branch.children</code> gespeichert hat,
aber immer noch einen <code>weak_count</code>von 0 hat.</p>
<p>Wenn der innere Gültigkeitsbereich endet, verlässt <code>branch</code> den
Gültigkeitsbereich und der <code>strong_count</code> von <code>Rc&lt;Node&gt;</code> sinkt auf 0, sodass
sein <code>Node</code> aufgeräumt wird. Der <code>weak_count</code> von 1 aus <code>leaf_parent</code> hat keinen
Einfluss darauf, ob <code>Node</code> aufgeräumt wird oder nicht, sodass wir kein
Speicherleck bekommen!</p>
<p>Wenn wir nach dem Ende des Gültigkeitsbereichs versuchen, auf das Eltern-Element von
<code>leaf</code> zuzugreifen, erhalten wir erneut <code>None</code>. Am Ende des Programms hat der
<code>Rc&lt;Node&gt;</code> in <code>branch</code> einen <code>strong_count</code> von 1 und einen <code>weak_count</code> von 0, da
die Variable <code>branch</code> jetzt wieder die einzige Referenz auf <code>Rc&lt;Node&gt;</code> ist.</p>
<p>Die gesamte Logik, die die Zähler und das Aufräumen des Wertes verwaltet, ist
in <code>Rc&lt;T&gt;</code> und <code>Weak&lt;T&gt;</code> und deren Implementierung des Merkmals (trait) <code>Drop</code>
integriert. Wenn man angibt, dass die Beziehung von einem Kind- zu seinem
Eltern-Element eine <code>Weak&lt;T&gt;</code>-Referenz in der Definition von <code>Node</code> sein soll,
können Eltern-Knoten auf Kind-Knoten referenzieren und umgekehrt, ohne einen
Referenzzyklus oder Speicherlecks zu erzeugen.</p>
<h2 id="zusammenfassung-14"><a class="header" href="#zusammenfassung-14">Zusammenfassung</a></h2>
<p>In diesem Kapitel wurde beschrieben, wie man mithilfe intelligenter Zeiger
andere Garantien und Kompromisse eingehen kann als es standardmäßig mit gewöhnlichen
Referenzen in Rust möglich ist. Der Typ <code>Box&lt;T&gt;</code> hat eine bekannte Größe und
zeigt auf Daten die auf dem Haldenspeicher allokiert sind. Der Typ <code>Rc&lt;T&gt;</code>
verfolgt die Anzahl der Referenzen von Daten auf dem Haldenspeicher, sodass
Daten mehrere Eigentümer haben können. Der Typ <code>RefCell&lt;T&gt;</code> mit
seiner inneren Veränderbarkeit stellt uns einen Typ zur Verfügung, den wir
verwenden können, wenn wir einen unveränderbaren Typ benötigen, aber einen
inneren Wert dieses Typs ändern müssen. Außerdem werden die Ausleihregeln zur
Laufzeit anstatt zur Kompilierzeit durchgesetzt.</p>
<p>Ebenfalls diskutiert wurden die Merkmale <code>Deref</code> und <code>Drop</code>, die einen Großteil
der Funktionalität von intelligenten Zeigern ermöglichen. Wir haben
Referenzzyklen untersucht, die zu Speicherlecks führen können, und wie diese
mithilfe von <code>Weak&lt;T&gt;</code> verhindert werden können.</p>
<p>Wenn dieses Kapitel dein Interesse geweckt hat und du deinen eigenen
intelligenten Zeiger implementieren möchtest, lies <a href="https://doc.rust-lang.org/nomicon/index.html">„The
Rustonomicon“</a>, um weitere nützliche Informationen zu erhalten.</p>
<p>Als Nächstes werden wir über Nebenläufigkeit (concurrency) in Rust sprechen.
Wir werden sogar einige neue intelligente Zeiger kennenlernen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="furchtlose-nebenläufigkeit"><a class="header" href="#furchtlose-nebenläufigkeit">Furchtlose Nebenläufigkeit</a></h1>
<p>Der sichere und effiziente Umgang mit nebenläufiger Programmierung ist ein
weiteres wichtiges Ziel von Rust. Die <em>nebenläufige Programmierung</em> (concurrent
programming), bei der verschiedene Teile eines Programms unabhängig voneinander
ausgeführt werden, und die <em>parallele Programmierung</em> (parallel programming),
bei der verschiedene Teile eines Programms gleichzeitig ausgeführt werden,
werden immer wichtiger, da immer mehr Computer die Vorteile mehrerer
Prozessoren nutzen. In der Vergangenheit war die Programmierung in diesen
Bereichen schwierig und fehleranfällig: Rust hofft, das ändern zu können.</p>
<p>Ursprünglich dachte das Rust-Team, dass das Gewährleisten von
Speichersicherheit (memory safety) und das Verhindern von
Nebenläufigkeitsproblemen (concurrency problems) zwei separate
Herausforderungen seien, die mit unterschiedlichen Methoden gelöst werden
müssten. Im Laufe der Zeit entdeckte das Team, dass Eigentümerschaft
(ownership) und Typsysteme ein leistungsstarkes Instrumentarium zur Bewältigung
von Speichersicherheits- <em>und</em> Nebenläufigkeitsproblemen sind! Durch das Nutzen
der Eigentümerschaft und Typprüfung werden viele Nebenläufigkeitsfehler zu
Kompilierzeitfehlern in Rust anstatt Laufzeitfehlern. Anstatt dass du viel Zeit
damit verbringen musst, die genauen Umstände zu reproduzieren, unter denen ein
Laufzeit-Nebenläufigkeitsfehler auftritt, wird der fehlerhafte Code nicht
kompilieren und einen Fehler anzeigen, der das Problem erklärt. Dadurch kannst
du deinen Code reparieren, während du daran arbeitest, und nicht möglicherweise
erst, nachdem er in Produktion ausgeliefert wurde. Wir haben diesem Aspekt von
Rust den Spitznamen <em>furchtlose Nebenläufigkeit</em> (fearless concurrency)
gegeben. Die furchtlose Nebenläufigkeit ermöglicht es dir, Code zu schreiben,
der frei von subtilen Fehlern und leicht zu refaktorieren ist, ohne neue
Fehler zu erzeugen.</p>
<blockquote>
<p>Anmerkung: Der Einfachheit halber werden wir viele der Probleme als
<em>nebenläufig</em> bezeichnen, anstatt präziser zu sein, indem wir <em>nebenläufig
und/oder gleichzeitig</em> sagen. Wenn es in diesem Buch um Nebenläufigkeit
und/oder Gleichzeitigkeit ginge, wären wir präziser. Bitte ersetze dieses
Kapitel gedanklich durch <em>nebenläufig und/oder gleichzeitig</em>, wenn wir
<em>nebenläufig</em> verwenden.</p>
</blockquote>
<p>Viele Sprachen sind dogmatisch, was die Lösungen betrifft, die sie zur
Behandlung von Nebenläufigkeitsproblemen anbieten. Beispielsweise verfügt
Erlang über elegante Funktionen für die nachrichtenübermittelnde
Nebenläufigkeit (message-passing concurrency), hat aber nur obskure
Möglichkeiten, einen gemeinsamen Status mit mehreren Strängen (threads) zu
teilen. Die Unterstützung nur einer Teilmenge möglicher Lösungen ist eine
vernünftige Strategie für Hochsprachen, da eine Hochsprache Vorteile
verspricht, wenn sie eine gewisse Kontrolle aufgibt, um Abstraktionen zu
erhalten. Es wird jedoch erwartet, dass Sprachen auf niedrigeren Ebenen in
jeder Situation die Lösung mit der besten Performanz bieten und weniger
Abstraktionen der Hardware haben. Daher bietet Rust eine Vielzahl von
Werkzeugen zur Modellierung von Problemen in der Art und Weise, die für deine
Situation und deine Anforderungen geeignet ist.</p>
<p>Hier sind die Themen, die wir in diesem Kapitel behandeln werden:</p>
<ul>
<li>Wie man Stränge erstellt, um mehrere Code-Stücke gleichzeitig auszuführen.</li>
<li><em>Nachrichtenübermittelnde</em> Nebenläufigkeit, bei der Kanäle Nachrichten
zwischen Strängen senden.</li>
<li>Nebenläufigkeit mit <em>gemeinsamem Zustand</em> (shared-state), bei der mehrere
Stränge Zugriff auf bestimmte Daten haben.</li>
<li>Die Merkmale (traits) <code>Sync</code> und <code>Send</code>, die Rusts Nebenläufigkeitsgarantien
sowohl auf benutzerdefinierte Typen als auch auf von der Standardbibliothek
bereitgestellte Typen erweitern.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mit-strängen-threads-programmcode-gleichzeitig-ausführen"><a class="header" href="#mit-strängen-threads-programmcode-gleichzeitig-ausführen">Mit Strängen (threads) Programmcode gleichzeitig ausführen</a></h2>
<p>In den meisten aktuellen Betriebssystemen wird der Code eines ausgeführten
Programms in einem <em>Prozess</em> ausgeführt und das Betriebssystem verwaltet
mehrere Prozesse gleichzeitig. Innerhalb eines Programms kannst du auch
unabhängige Teile haben, die gleichzeitig laufen. Die Funktionalitäten, die
diese unabhängigen Teile ausführen, werden <em>Stränge</em> (threads) genannt. Ein
Webserver könnte beispielsweise mehrere Stränge haben, damit er auf mehrere
Anfragen gleichzeitig reagieren kann.</p>
<p>Das Aufteilen der Berechnung in deinem Programm in mehrere Stränge, um mehrere
Aufgaben gleichzeitig auszuführen, kann die Performanz erhöhen, aber es erhöht
auch die Komplexität. Da Stränge gleichzeitig laufen können, gibt es keine
inhärente Garantie für die Reihenfolge, in der Teile deines Codes in
verschiedenen Strängen ausgeführt werden. Dies kann zu Problemen führen wie:</p>
<ul>
<li>Wettlaufsituationen (race conditions), bei denen Stränge auf Daten oder
Ressourcen in einer inkonsistenten Reihenfolge zugreifen.</li>
<li>Deadlocks, bei denen zwei Stränge auf den jeweils anderen warten, sodass
beide Stränge nicht fortgesetzt werden können.</li>
<li>Fehler, die nur in bestimmten Situationen auftreten und schwer zu
reproduzieren und zu beheben sind.</li>
</ul>
<p>Rust versucht, die negativen Auswirkungen bei der Verwendung von Strängen zu
mildern, aber die Programmierung in einem mehrsträngigen Kontext erfordert
immer noch sorgfältige Überlegungen und benötigt eine andere Code-Struktur als
bei Programmen, die in einem einzigen Strang laufen.</p>
<p>Programmiersprachen implementieren Stränge auf verschiedene Weise, und viele
Betriebssysteme bieten eine API, die die Sprache aufrufen kann, um neue Stränge
zu erstellen. Die Rust-Standardbibliothek verwendet ein <em>1:1</em>-Modell der
Strang-Implementierung, bei dem ein Programm einen Betriebssystem-Strang für
einen Sprach-Strang verwendet. Es gibt Kisten, die andere Strang-Modelle
implementieren, die andere Kompromisse als das 1:1-Modell eingehen.</p>
<h3 id="erstellen-eines-neuen-strangs-mit-spawn"><a class="header" href="#erstellen-eines-neuen-strangs-mit-spawn">Erstellen eines neuen Strangs mit <code>spawn</code></a></h3>
<p>Um einen neuen Strang zu erstellen, rufen wir die Funktion <code>thread::spawn</code> auf
und übergeben ihr einen Funktionsabschluss (closure) (wir haben in Kapitel 13
über Funktionsabschlüsse gesprochen), der den Code enthält, den wir im neuen
Strang ausführen wollen. Das Beispiel in Codeblock 16-1 gibt etwas Text im
Hauptstrang und anderen Text im neuen Strang aus:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Hallo Zahl {} aus dem erzeugten Strang!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Hallo Zahl {} aus dem Hauptstrang!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 16-1: Erstellen eines neuen Strangs, um eine
Sache auszugeben, während der Hauptstrang etwas anderes ausgibt</span></p>
<p>Beachte, dass bei der Beendigung des Haupt-Strangs eines Rust-Programms alle
erzeugten Stränge beendet werden, unabhängig davon, ob sie zu Ende gelaufen
sind oder nicht. Die Ausgabe dieses Programms kann jedes Mal ein wenig anders
sein, aber sie wird ähnlich wie die folgende aussehen:</p>
<pre><code class="language-text">Hallo Zahl 1 aus dem Hauptstrang!
Hallo Zahl 1 aus dem erzeugten Strang!
Hallo Zahl 2 aus dem Hauptstrang!
Hallo Zahl 2 aus dem erzeugten Strang!
Hallo Zahl 3 aus dem Hauptstrang!
Hallo Zahl 3 aus dem erzeugten Strang!
Hallo Zahl 4 aus dem Hauptstrang!
Hallo Zahl 4 aus dem erzeugten Strang!
Hallo Zahl 5 aus dem erzeugten Strang!
</code></pre>
<p>Aufrufe von <code>thread::sleep</code> zwingen einen Strang, seine Ausführung für eine
kurze Zeit anzuhalten, sodass ein anderer Strang laufen kann. Die Stränge
werden sich wahrscheinlich abwechseln, aber das ist nicht garantiert: Es hängt
davon ab, wie dein Betriebssystem die Stränge organisiert (schedules). In
diesem Lauf wurde der Hauptstrang zuerst ausgegeben, obwohl die
Ausgabeanweisung aus dem erzeugten Strang zuerst im Code erscheint. Und obwohl
wir dem erzeugten Strang gesagt haben, er solle ausgeben, bis <code>i</code> 9 ist, kam er
nur bis 5, bis sich der Hauptstrang beendet hat.</p>
<p>Wenn du diesen Code ausführst und nur Ausgaben aus dem Hauptstrang siehst oder
keine Überschneidungen feststellst, versuche, die Zahlen in den Bereichen zu
erhöhen, um dem Betriebssystem mehr Gelegenheit zu geben, zwischen den Strängen
zu wechseln.</p>
<h3 id="warten-auf-das-ende-aller-stränge-mit-join"><a class="header" href="#warten-auf-das-ende-aller-stränge-mit-join">Warten auf das Ende aller Stränge mit <code>join</code></a></h3>
<p>Der Code in Codeblock 16-1 beendet nicht nur den erzeugten Strang meist
vorzeitig, weil der Hauptstrangs endet, sondern weil es keine Garantie für die
Reihenfolge gibt, in der Stränge laufen. Wir können auch nicht garantieren,
dass der erzeugten Strang überhaupt zum Laufen kommt!</p>
<p>Wir können das Problem, dass der erzeugte Strang nicht läuft oder vorzeitig
beendet wird, beheben, indem wir den Rückgabewert von <code>thread::spawn</code> in einer
Variablen speichern. Der Rückgabetyp von <code>thread::spawn</code> ist <code>JoinHandle</code>. Ein
<code>JoinHandle</code> ist ein aneigenbarer (owned) Wert, der, wenn wir die Methode
<code>join</code> darauf aufrufen, darauf wartet, bis sich sein Strang beendet. Codeblock
16-2 zeigt, wie der <code>JoinHandle</code> des Strangs, den wir in Codeblock 16-1
erstellt haben, verwendet und <code>join</code> aufgerufen wird, um sicherzustellen, dass
der erzeugte Strang beendet wird, bevor <code>main</code> endet:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Hallo Zahl {} aus dem erzeugten Strang!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Hallo Zahl {} aus dem Hauptstrang!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 16-2: Speichern eines <code>JoinHandle</code> von
<code>thread::spawn</code>, um zu garantieren, dass der Strang bis zum Ende ausgeführt
wird</span></p>
<p>Aufrufen von <code>join</code> auf <code>JoinHandle</code> blockiert den gerade laufenden Strang, bis
der durch <code>JoinHandle</code> repräsentierte Strang beendet ist. <em>Blockieren</em> eines
Strangs bedeutet, dass der Strang daran gehindert wird, Arbeit auszuführen oder
sich zu beenden. Da wir den Aufruf von <code>join</code> nach der <code>for</code>-Schleife im
Hauptstrang gesetzt haben, sollte das Ausführen von Codeblock 16-2 eine
ähnliche Ausgabe erzeugen:</p>
<pre><code class="language-text">Hallo Zahl 1 aus dem Hauptstrang!
Hallo Zahl 2 aus dem Hauptstrang!
Hallo Zahl 1 aus dem erzeugten Strang!
Hallo Zahl 3 aus dem Hauptstrang!
Hallo Zahl 2 aus dem erzeugten Strang!
Hallo Zahl 4 aus dem Hauptstrang!
Hallo Zahl 3 aus dem erzeugten Strang!
Hallo Zahl 4 aus dem erzeugten Strang!
Hallo Zahl 5 aus dem erzeugten Strang!
Hallo Zahl 6 aus dem erzeugten Strang!
Hallo Zahl 7 aus dem erzeugten Strang!
Hallo Zahl 8 aus dem erzeugten Strang!
Hallo Zahl 9 aus dem erzeugten Strang!
</code></pre>
<p>Die beiden Stränge setzen abwechselnd fort, aber der Hauptstrang wartet wegen
des Aufrufs von <code>handle.join()</code> und endet nicht, bis der erzeugte Strang
beendet ist.</p>
<p>Aber lass uns sehen, was passiert, wenn wir stattdessen <code>handle.join()</code> vor die
<code>for</code>-Schleife in <code>main</code> schieben, etwa so:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Hallo Zahl {} aus dem erzeugten Strang!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;Hallo Zahl {} aus dem Hauptstrang!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<p>Der Hauptstrang wartet auf das Ende des erzeugten Strangs und führt dann seine
<code>for</code>-Schleife aus, sodass die Ausgabe nicht mehr überlappend ist, wie hier
gezeigt:</p>
<pre><code class="language-text">Hallo Zahl 1 aus dem erzeugten Strang!
Hallo Zahl 2 aus dem erzeugten Strang!
Hallo Zahl 3 aus dem erzeugten Strang!
Hallo Zahl 4 aus dem erzeugten Strang!
Hallo Zahl 5 aus dem erzeugten Strang!
Hallo Zahl 6 aus dem erzeugten Strang!
Hallo Zahl 7 aus dem erzeugten Strang!
Hallo Zahl 8 aus dem erzeugten Strang!
Hallo Zahl 9 aus dem erzeugten Strang!
Hallo Zahl 1 aus dem Hauptstrang!
Hallo Zahl 2 aus dem Hauptstrang!
Hallo Zahl 3 aus dem Hauptstrang!
Hallo Zahl 4 aus dem Hauptstrang!
</code></pre>
<p>Kleine Details, z.B. wo <code>join</code> aufgerufen wird, können beeinflussen, ob deine
Stränge zur gleichen Zeit laufen oder nicht.</p>
<h3 id="verwenden-von-move-funktionsabschlüssen-mit-strängen"><a class="header" href="#verwenden-von-move-funktionsabschlüssen-mit-strängen">Verwenden von <code>move</code>-Funktionsabschlüssen mit Strängen</a></h3>
<p>Wir werden oft das Schlüsselwort <code>move</code> mit Funktionsabschlüssen verwenden, die
an <code>thread::spawn</code> übergeben werden, weil der Funktionsabschluss dann die
Eigentümerschaft an den Werten, die sie benutzt, von der Umgebung übernimmt und
damit die Eigentümerschaft an diesen Werten von einem Strang auf einen anderen
überträgt. Im Abschnitt <a href="ch13-01-closures.html#erfassen-von-referenzen-oder-verschieben-der-eigent%C3%BCmerschaft">„Erfassen von Referenzen oder Verschieben der
Eigentümerschaft“</a> in Kapitel 13 haben wir <code>move</code> im Zusammenhang mit
Funktionsabschlüssen besprochen. Jetzt werden wir uns mehr auf die Interaktion
zwischen <code>move</code> und <code>thread::spawn</code> konzentrieren.</p>
<p>Beachte in Codeblock 16-1, dass der Funktionsabschluss, den wir an
<code>thread::spawn</code> übergeben, keine Argumente erfordert: Wir verwenden keine Daten
aus dem Hauptstrang im Code des erzeugten Strangs. Um Daten aus dem Hauptstrang
im erzeugten Strang zu verwenden, muss der Funktionsabschluss des erzeugten
Strangs die benötigten Werte erfassen. Codeblock 16-3 zeigt einen Versuch,
einen Vektor im Hauptstrang zu erstellen und ihn im erzeugten Strang zu
verwenden. Dies wird jedoch noch nicht funktionieren, wie du gleich sehen
wirst.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Hier ist ein Vektor: {:?}&quot;, v);
    });

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 16-3: Versuch, einen durch den Hauptstrang
erzeugten Vektor in einem anderen Strang zu verwenden</span></p>
<p>Der Funktionsabschluss verwendet <code>v</code>, sodass er <code>v</code> erfasst und zum Teil der
Umgebung des Funktionsabschlusses macht. Da <code>thread::spawn</code> diesen
Funktionsabschluss in einem neuen Strang ausführt, sollten wir in der Lage
sein, auf <code>v</code> innerhalb dieses neuen Strangs zuzugreifen. Aber wenn wir dieses
Beispiel kompilieren, erhalten wir den folgenden Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Hier ist ein Vektor: {:?}&quot;, v);
  |                                               - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!(&quot;Hier ist ein Vektor: {:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` due to previous error
</code></pre>
<p>Rust <em>folgert</em>, wie man <code>v</code> erfasst, und weil <code>println!</code> nur eine Referenz auf
<code>v</code> benötigt, versucht der Funktionsabschluss, <code>v</code> auszuleihen. Es gibt jedoch
ein Problem: Rust kann nicht sagen, wie lange der erzeugte Strang laufen wird,
sodass es nicht weiß, ob die Referenz auf <code>v</code> immer gültig sein wird.</p>
<p>Codeblock 16-4 zeigt ein Szenario, das eine Referenz auf <code>v</code> hat, die eher
nicht gültig ist:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Hier ist ein Vektor: {:?}&quot;, v);
    });

    drop(v); // Oh nein!

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 16-4: Ein Strang mit einem Funktionsabschluss,
der versucht, eine Referenz auf <code>v</code> vom Hauptstrang zu erfassen, der <code>v</code>
aufräumt</span></p>
<p>Wenn Rust uns erlauben würde, diesen Code auszuführen, bestünde die
Möglichkeit, dass der erzeugte Strang sofort in den Hintergrund gestellt wird,
ohne überhaupt zu laufen. Der erzeugte Strang hat eine Referenz auf <code>v</code> im
Inneren, aber der Hauptstrang räumt <code>v</code> sofort auf, indem er die Funktion
<code>drop</code> benutzt, die wir in Kapitel 15 besprochen haben. Wenn der erzeugte
Strang dann mit der Ausführung beginnt, ist <code>v</code> nicht mehr gültig, sodass eine
Referenz darauf ebenfalls ungültig ist. Oh nein!</p>
<p>Um den Kompilierfehler in Codeblock 16-3 zu beheben, können wir die Hinweise
der Fehlermeldung verwenden:</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>Indem wir vor dem Funktionsabschluss das Schlüsselwort <code>move</code> hinzufügen,
zwingen wir den Funktionsabschluss dazu, die Eigentümerschaft der Werte zu
übernehmen, die er benutzt, anstatt zuzulassen, dass Rust daraus ableitet, dass
er sich die Werte ausleihen sollte. Die in Codeblock 16-5 gezeigte Änderung an
Codeblock 16-3 wird wie von uns beabsichtigt kompilieren und ausgeführt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Hier ist ein Vektor: {:?}&quot;, v);
    });

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 16-5: Durch Verwenden des Schlüsselwortes
<code>move</code> zwigen wir den Funktionsabschluss, die Eigentümerschaft der von ihm
verwendeten Werte zu übernehmen</span></p>
<p>Wir könnten versucht sein, dasselbe zu versuchen, um den Code in Codeblock 16-4
zu reparieren, wo der Hauptstrang <code>drop</code> aufruft, indem wir einen
<code>move</code>-Funktionsabschluss verwenden. Diese Lösung wird jedoch nicht
funktionieren, weil das, was Codeblock 16-4 versucht, aus einem anderen Grund
nicht erlaubt ist. Wenn wir dem Funktionsabschluss <code>move</code> hinzufügen würden,
würden wir <code>v</code> in die Umgebung des Funktionsabschlusses verschieben, und wir
könnten im Hauptstrang nicht mehr <code>drop</code> darauf aufrufen. Wir würden
stattdessen diesen Kompilierfehler erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  | 
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Hier ist ein Vektor: {:?}&quot;, v);
   |                                               - variable moved due to use in closure
...
10 |     drop(v); // Oh nein!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` due to previous error
</code></pre>
<p>Die Eigentumsregeln von Rust haben uns wieder einmal gerettet! Wir haben einen
Fehler im Code in Codeblock 16-3 erhalten, weil Rust konservativ war und nur
<code>v</code> für den Strang auslieh, was bedeutete, dass der Hauptstrang theoretisch die
Referenz des erzeugte Strangs ungültig machen konnte. Indem wir Rust anweisen,
die Eigentümerschaft von <code>v</code> in den erzeugte Strang zu verlagern, garantieren
wir Rust, dass der Hauptstrang <code>v</code> nicht mehr benutzen wird. Wenn wir Codeblock
16-4 auf die gleiche Weise ändern, verletzen wir die Eigentumsregeln, wenn wir
versuchen, <code>v</code> im Hauptstrang zu benutzen. Das Schlüsselwort <code>move</code> setzt Rusts
konservative Standardausleihe außer Kraft; es lässt uns nicht gegen die
Eigentumsregeln verstoßen.</p>
<p>Mit einem grundlegenden Verständnis von Strängen und der Strang-API wollen wir
uns ansehen, was wir mit Strängen noch machen können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nachrichtenaustausch-zwischen-strängen-threads"><a class="header" href="#nachrichtenaustausch-zwischen-strängen-threads">Nachrichtenaustausch zwischen Strängen (threads)</a></h2>
<p>Ein immer beliebter werdender Ansatz zur Gewährleistung einer sicheren
Nebenläufigkeit (safe concurrency) ist der <em>Nachrichtenaustausch</em> (message
passing), bei dem Stränge oder Akteure kommunizieren, indem sie sich
gegenseitig Nachrichten mit Daten senden. Hier ist die Idee in einem Slogan aus
<a href="https://golang.org/doc/effective_go.html#concurrency">der Go-Sprachdokumentation</a>: „Kommuniziere nicht, indem du
Arbeitsspeicher teilst; teile stattdessen Arbeitsspeicher durch Kommunikation.“</p>
<p>Um die Gleichzeitigkeit beim Senden von Nachrichten zu erreichen, bietet die
Standardbibliothek von Rust eine Implementierung von <em>Kanälen</em> (channels). Ein
Kanal ist ein allgemeines Programmierkonzept, mit dem Daten von einem Strang zu
einem anderen gesendet werden.</p>
<p>Du kannst dir einen Kanal in der Programmierung wie einen gerichteten
Wasserkanal vorstellen, z.B. einen Bach oder einen Fluss. Wenn du etwas wie
eine Gummiente in einen Fluss setzt, wird sie stromabwärts bis zum Ende des
Wasserwegs reisen.</p>
<p>Ein Kanal hat zwei Hälften: Einen Sender und einen Empfänger. Die Senderhälfte
ist die stromaufwärts gelegene Stelle, an der du Gummienten in den Fluss setzt,
und die Empfängerhälfte ist die Stelle, an der die Gummiente stromabwärts
ankommt. Ein Teil deines Codes ruft Methoden auf dem Sender mit den Daten auf,
die du senden möchtest, und ein anderer Teil überprüft die Empfangsseite auf
ankommende Nachrichten. Ein Kanal gilt als <em>geschlossen</em> (closed), wenn
entweder die Sender- oder die Empfängerhälfte aufgeräumt (dropped) wird.</p>
<p>Hier arbeiten wir uns zu einem Programm hoch, das einen Strang hat, um Werte zu
generieren und sie über einen Kanal zu senden, und einen anderen Strang, der
die Werte empfängt und ausgibt. Wir werden einfache Werte zwischen den Strängen
über einen Kanal senden, um die Funktionalität zu veranschaulichen. Sobald du
mit der Technik vertraut bist, kannst du Kanäle für alle Stränge verwenden, die
miteinander kommunizieren müssen, z.B. für ein Chatsystem oder ein System, in
dem viele Stränge Teile einer Berechnung durchführen und die Teile an einen
Strang senden, der die Ergebnisse zusammenfasst.</p>
<p>Erstens werden wir in Codeblock 16-6 einen Kanal erstellen, aber nichts damit
machen. Beachte, dass sich dieser noch nicht kompilieren lässt, weil Rust nicht
sagen kann, welchen Typ von Werten wir über den Kanal senden wollen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre></pre>
<p><span class="caption">Codeblock 16-6: Erstellen eines Kanals und Zuweisen der
beiden Hälften zu <code>tx</code> und <code>rx</code></span></p>
<p>Wir erstellen einen neuen Kanal mit der Funktion <code>mpsc::channel</code>; <code>mpsc</code> steht
für <em>mehrfacher Produzent, einzelner Konsument</em> (multiple producer, single
consumer). Kurz gesagt, die Art und Weise, wie die Standardbibliothek von Rust
Kanäle implementiert, bedeutet, dass ein Kanal mehrere <em>sendende</em> Enden haben
kann, die Werte produzieren, aber nur ein <em>empfangendes</em> Ende, das diese Werte
konsumiert. Stell dir vor, mehrere Bäche würden zu einem großen Fluss
zusammenfließen: Alles, was in einem der Bäche hinuntergeschickt wird, landet
am Ende in einem Fluss. Wir fangen zunächst mit einem einzigen Produzenten an,
aber wir fügen mehrere Produzenten hinzu, wenn dieses Beispiel funktioniert.</p>
<p>Die Funktion <code>mpsc::channel</code> gibt ein Tupel zurück, dessen erstes Element die
sendende Seite und dessen zweites Element die empfangende Seite ist. Die
Abkürzungen <code>tx</code> und <code>rx</code> werden traditionell in vielen Feldern für <em>Sender</em>
(transmitter) bzw. <em>Empfänger</em> (receiver) verwendet, daher benennen wir unsere
Variablen als solche, um jedes Ende anzugeben. Wir verwenden eine
<code>let</code>-Anweisung mit einem Muster, das die Tupel destrukturiert; wir werden die
Verwendung von Mustern in <code>let</code>-Anweisungen und die Destrukturierung in Kapitel
18 besprechen. Für den Moment solltest du wissen, dass die Verwendung einer
<code>let</code>-Anweisung auf diese Weise ein bequemer Ansatz ist, um die Teile des
Tupels zu extrahieren, die von <code>mpsc::channel</code> zurückgegeben werden.</p>
<p>Verschieben wir das sendende Ende in einen erzeugten Strang und lassen es eine
Zeichenkette senden, sodass der erzeugte Strang mit dem Hauptstrang
kommuniziert, wie in Codeblock 16-7 gezeigt. Das ist so, als würde man eine
Gummiente flussaufwärts in den Fluss setzen oder eine Chat-Nachricht von einem
Strang zum anderen senden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hallo&quot;);
        tx.send(val).unwrap();
    });
}</code></pre></pre>
<p><span class="caption">Codeblock 16-7: Verschieben von <code>tx</code> in einen erzeugten
Strang und Senden von „hallo“</span></p>
<p>Wieder verwenden wir <code>thread::spawn</code>, um einen neuen Strang zu erstellen, und
dann <code>move</code>, um <code>tx</code> in den Funktionsabschluss zu verschieben, sodass der
erzeugte Strang <code>tx</code> besitzt. Der erzeugte Strang muss den Sender besitzen, um
in der Lage zu sein, Nachrichten durch den Kanal zu senden. Der Sender hat eine
Methode <code>send</code>, die den Wert nimmt, den wir senden wollen. Die Methode <code>send</code>
gibt ein <code>Result&lt;T, E&gt;</code> zurück; wenn also die empfangende Seite bereits
aufgeräumt wurde und es keinen Ort gibt, an den ein Wert gesendet werden kann,
wird die Sendeoperation einen Fehler zurückgeben. In diesem Beispiel rufen wir
<code>unwrap</code> auf, um im Falle eines Fehlers abzustürzen. Aber in einer echten
Anwendung würden wir es richtig handhaben: Kehre zu Kapitel 9 zurück, um
Strategien für eine korrekte Fehlerbehandlung anzusehen.</p>
<p>In Codeblock 16-8 erhalten wir den Wert vom Empfänger im Hauptstrang. Das ist
so, als würde man die Gummiente am Ende des Flusses aus dem Wasser holen oder
eine Chat-Nachricht erhalten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hallo&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Erhalten: {}&quot;, received);
}</code></pre></pre>
<p><span class="caption">Codeblock 16-8: Empfangen des Wertes „hallo“ im
Hauptstrang und Ausgeben des Wertes</span></p>
<p>Das Empfänger hat zwei nützliche Methoden: <code>recv</code> und <code>try_recv</code>. Wir benutzen
<code>recv</code>, kurz für <em>empfangen</em> (receive), was die Ausführung des Hauptstrangs
blockiert und wartet, bis ein Wert in den Kanal geschickt wird. Sobald ein Wert
gesendet wurde, wird er von <code>recv</code> in einem <code>Result&lt;T, E&gt;</code> zurückgegeben. Wenn
der Sender geschlossen wird, gibt <code>recv</code> einen Fehler zurück, um zu
signalisieren, dass keine weiteren Werte mehr kommen werden.</p>
<p>Die Methode <code>try_recv</code> blockiert nicht, sondern gibt stattdessen sofort ein
<code>Result&lt;T, E&gt;</code> zurück: Einen <code>Ok</code>-Wert, der eine Nachricht enthält, wenn eine
verfügbar ist, und einen <code>Err</code>-Wert, wenn diesmal keine Nachricht vorhanden
ist. Die Verwendung von <code>try_recv</code> ist nützlich, wenn dieser Strang während des
Wartens auf Nachrichten andere Arbeiten zu erledigen hat: Wir könnten eine
Schleife schreiben, die <code>try_recv</code> ab und zu aufruft, eine Nachricht
verarbeitet, wenn eine verfügbar ist, und ansonsten für eine Weile andere
Arbeiten erledigt, bis sie erneut überprüft wird.</p>
<p>Wir haben in diesem Beispiel der Einfachheit halber <code>recv</code> verwendet; wir haben
keine andere Arbeit für den Hauptstrang zu erledigen, außer auf Nachrichten zu
warten, daher ist es angebracht, den Hauptstrang zu blockieren.</p>
<p>Wenn wir den Code in Codeblock 16-8 ausführen, sehen wir den durch den
Hauptstrang ausgegebenen Wert:</p>
<pre><code class="language-text">Erhalten: hallo
</code></pre>
<p>Perfekt!</p>
<h3 id="kanäle-und-eigentümerschaftsübertragung"><a class="header" href="#kanäle-und-eigentümerschaftsübertragung">Kanäle und Eigentümerschaftsübertragung</a></h3>
<p>Die Eigentumsregeln spielen beim Nachrichtenversand eine entscheidende Rolle,
da sie dir helfen, sicheren, nebenläufigen Code zu schreiben. Die Vermeidung
von Fehlern bei der nebenläufigen Programmierung ist der Vorteil, wenn du bei
deinen Rust-Programmen an die Eigentümerschaft denkst. Lass uns ein Experiment
machen, um zu zeigen, wie Kanäle und Eigentümerschaft zusammenwirken, um
Probleme zu vermeiden: Wir versuchen, einen <code>val</code>-Wert im erzeugten Strang zu
verwenden, <em>nachdem</em> wir ihn in den Kanal geschickt haben. Versuche, den Code
in Codeblock 16-9 zu kompilieren, um zu sehen, warum dieser Code nicht erlaubt
ist:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hallo&quot;);
        tx.send(val).unwrap();
        println!(&quot;val ist {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Erhalten: {}&quot;, received);
}</code></pre></pre>
<p><span class="caption">Codeblock 16-9: Versuch, <code>val</code> zu benutzen, nachdem wir
es in den Kanal geschickt haben</span></p>
<p>Hier versuchen wir, <code>val</code> auszugeben, nachdem wir es per <code>tx.send</code> in den Kanal
geschickt haben. Dies zuzulassen wäre eine schlechte Idee: Sobald der Wert an
einen anderen Strang gesendet wurde, könnte dieser Strang ihn ändern oder
aufräumen, bevor wir versuchen, den Wert erneut zu verwenden. Möglicherweise
können die Änderungen des anderen Strangs aufgrund inkonsistenter oder nicht
vorhandener Daten zu Fehlern oder unerwarteten Ergebnissen führen. Rust gibt
uns jedoch einen Fehler, wenn wir versuchen, den Code in Codeblock 16-9 zu kompilieren:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:31
   |
8  |         let val = String::from(&quot;hallo&quot;);
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val ist {}&quot;, val);
   |                                ^^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` due to previous error
</code></pre>
<p>Unser Nebenläufigkeitsfehler hat einen Kompilierzeitfehler verursacht. Die
Funktion <code>send</code> übernimmt die Eigentümerschaft an ihrem Parameter und wenn der
Wert verschoben wird, übernimmt der Empfänger die Eigentümerschaft an ihm.
Dadurch wird verhindert, dass wir den Wert nach dem Senden versehentlich wieder
verwenden; das Eigentumssystem prüft, ob alles in Ordnung ist.</p>
<h3 id="mehrere-werte-senden-und-den-empfänger-warten-sehen"><a class="header" href="#mehrere-werte-senden-und-den-empfänger-warten-sehen">Mehrere Werte senden und den Empfänger warten sehen</a></h3>
<p>Der Code in Codeblock 16-8 wurde kompiliert und ausgeführt, aber er zeigte uns
nicht eindeutig, dass zwei getrennte Stränge über den Kanal miteinander
sprachen. In Codeblock 16-10 haben wir einige Änderungen vorgenommen, die
beweisen, dass der Code in Codeblock 16-8 nebenläufig ausgeführt wird: Der
erzeugte Strang sendet nun mehrere Nachrichten und macht dazwischen eine Pause
von einer Sekunde.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hallo&quot;),
            String::from(&quot;aus&quot;),
            String::from(&quot;dem&quot;),
            String::from(&quot;Strang&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Erhalten: {}&quot;, received);
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 16-10: Senden mehrerer Nachrichten und
Pausieren dazwischen</span></p>
<p>Diesmal hat der erzeugte Strang einen Vektor von Zeichenketten, die wir an den
Hauptstrang senden wollen. Wir iterieren über diese Zeichenketten, senden jede
einzeln und pausieren dazwischen, indem wir die Funktion <code>thread::sleep</code> mit
einem <code>Duration</code>-Wert von 1 Sekunde aufrufen.</p>
<p>Im Hauptstrang rufen wir die Funktion <code>recv</code> nicht mehr explizit auf:
Stattdessen behandeln wir <code>rx</code> als Iterator. Jeden empfangenen Wert geben wir
aus. Wenn der Kanal geschlossen wird, wird die Iteration beendet.</p>
<p>Wenn du den Code in Codeblock 16-10 ausführst, solltest du die folgende Ausgabe
mit einer 1-Sekunden-Pause zwischen jeder Zeile sehen:</p>
<pre><code class="language-text">Erhalten: hallo
Erhalten: aus
Erhalten: dem
Erhalten: Strang
</code></pre>
<p>Da wir keinen Code haben, der die <code>for</code>-Schleife im Hauptstrang pausiert oder
verzögert, können wir sagen, dass der Hauptstrang darauf wartet, Werte vom
erzeugten Strang zu erhalten.</p>
<h3 id="erstellen-mehrerer-produzenten-durch-klonen-des-senders"><a class="header" href="#erstellen-mehrerer-produzenten-durch-klonen-des-senders">Erstellen mehrerer Produzenten durch Klonen des Senders</a></h3>
<p>Vorhin haben wir erwähnt, dass <code>mpsc</code> ein Akronym für <em>mehrfacher Produzent,
einzelner Konsument</em> ist. Lass uns <code>mpsc</code> verwenden und den Code in Codeblock
16-10 erweitern, um mehrere Stränge zu erzeugen, die alle Werte an den gleichen
Empfänger senden. Wir können dies tun, indem wir den Sender klonen, wie in
Codeblock 16-11 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --abschneiden--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hallo&quot;),
            String::from(&quot;aus&quot;),
            String::from(&quot;dem&quot;),
            String::from(&quot;Strang&quot;),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;mehr&quot;),
            String::from(&quot;Nachrichten&quot;),
            String::from(&quot;für&quot;),
            String::from(&quot;dich&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Erhalten: {}&quot;, received);
    }

    // --abschneiden--
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 16-11: Senden mehrerer Nachrichten von mehreren
Produzenten</span></p>
<p>Bevor wir den ersten Strang erzeugen, rufen wir dieses Mal <code>clone</code> auf dem
Sender auf. Dadurch erhalten wir einen weiteren Sender, das wir an den ersten
erzeugten Strang weitergeben können. Wir übergeben den ursprüngliche Sender an
einen zweiten erzeugten Strang. Dadurch erhalten wir zwei Stränge, die jeweils
unterschiedliche Nachrichten an den Empfänger senden.</p>
<p>Wenn du den Code ausführst, sollte deine Ausgabe in etwa so aussehen:</p>
<pre><code class="language-text">Erhalten: hallo
Erhalten: mehr
Erhalten: aus
Erhalten: Nachrichten
Erhalten: für
Erhalten: dem
Erhalten: Strang
Erhalten: dich
</code></pre>
<p>Möglicherweise siehst du die Werte in einer anderen Reihenfolge, dies hängt von
deinem System ab. Das macht die Nebenläufigkeit sowohl interessant als auch
schwierig. Wenn du mit <code>thread::sleep</code> experimentierst und ihm verschiedene
Werte in den verschiedenen Strängen gibst, wird jeder Durchlauf
nicht-deterministischer sein und jedes Mal eine andere Ausgabe erzeugen.</p>
<p>Nachdem wir uns nun angesehen haben, wie Kanäle funktionieren, wollen wir uns
eine andere Methode der Nebenläufigkeit ansehen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nebenläufigkeit-mit-gemeinsamem-zustand"><a class="header" href="#nebenläufigkeit-mit-gemeinsamem-zustand">Nebenläufigkeit mit gemeinsamem Zustand</a></h2>
<p>Die Nachrichtenübermittlung ist eine gute Methode zur Behandlung von
Nebenläufigkeit, aber sie ist nicht die einzige. Eine andere Methode wäre, dass
mehrere Stränge auf dieselben gemeinsamen Daten zugreifen. Betrachte folgenden
Teil des Slogans aus der Go-Sprachdokumentation noch einmal: „Kommuniziere
nicht, indem du Arbeitsspeicher teilst.“</p>
<p>Wie würde Kommunikation durch gemeinsame Nutzung von Arbeitsspeicher aussehen?
Und warum sollten Liebhaber der Nachrichtenübermittlung davor warnen,
gemeinsamen Arbeitsspeicher zu verwenden?</p>
<p>In gewisser Weise ähneln Kanäle in jeder Programmiersprache dem Alleineigentum,
denn sobald du einen Wert in einen Kanal übertragen hast, solltest du diesen
Wert nicht mehr verwenden. Nebenläufigkeit mit gemeinsam genutztem
Arbeitsspeicher ist wie Mehrfacheigentum: Mehrere Stränge können gleichzeitig
auf denselben Speicherplatz zugreifen. Wie du in Kapitel 15 gesehen hast, wo
intelligente Zeiger Mehrfacheigentum ermöglichten, kann Mehrfacheigentum zu
zusätzlicher Komplexität führen, da die verschiedenen Eigentümer verwaltet
werden müssen. Das Typsystem und die Eigentumsregeln von Rust sind eine große
Hilfe, um diese Verwaltung korrekt zu gestalten. Betrachten wir als Beispiel
den Mutex, eines der gebräuchlicheren Nebenläufigkeitsprimitive für gemeinsam
genutzten Speicher.</p>
<h3 id="verwenden-von-mutex-um-datenzugriff-von-jeweils-einem-strang-zu-ermöglichen"><a class="header" href="#verwenden-von-mutex-um-datenzugriff-von-jeweils-einem-strang-zu-ermöglichen">Verwenden von Mutex, um Datenzugriff von jeweils einem Strang zu ermöglichen</a></h3>
<p><em>Mutex</em> ist eine Abkürzung für <em>mutual exclusion</em> (engl. wechselseitiger
Ausschluss), da ein Mutex zu einem bestimmten Zeitpunkt nur einem Strang
(thread) den Zugriff auf einige Daten erlaubt. Um auf die Daten in einem Mutex
zuzugreifen, muss ein Strang zunächst signalisieren, dass er Zugriff wünscht,
indem er darum bittet, die <em>Sperre</em> (lock) des Mutex zu erwerben. Die Sperre
ist eine Datenstruktur, die Teil des Mutex ist, der verfolgt, wer derzeit
exklusiven Zugriff auf die Daten hat. Daher wird der Mutex als <em>Schutz</em> der
Daten beschrieben, die er über das Schließsystem hält.</p>
<p>Mutexe haben den Ruf, dass sie schwierig anzuwenden sind, weil man sich zwei
Regeln merken muss:</p>
<ul>
<li>Du musst versuchen, die Sperre zu erwerben, bevor du die Daten verwendest.</li>
<li>Wenn du mit den Daten, die der Mutex schützt, fertig bist, musst du die Daten
entsperren, damit andere Stränge die Sperre übernehmen können.</li>
</ul>
<p>Als reale Metapher für einen Mutex stelle dir eine Podiumsdiskussion auf einer
Konferenz mit nur einem Mikrofon vor. Bevor ein Podiumsteilnehmer das Wort
ergreifen kann, muss er fragen oder signalisieren, dass er das Mikrofon
benutzen möchte. Wenn er das Mikrofon erhält, kann er so lange sprechen, wie er
möchte, und das Mikrofon dann dem nächsten Diskussionsteilnehmer übergeben, der
um das Wort bittet. Wenn ein Diskussionsteilnehmer vergisst, das Mikrofon
abzugeben, wenn er damit fertig ist, kann kein anderer mehr sprechen. Wenn die
Verwaltung des gemeinsam genutzten Mikrofons schief geht, funktioniert das
Podium nicht wie geplant!</p>
<p>Das Management von Mutexen kann unglaublich schwierig sein, weshalb so viele
Menschen von Kanälen begeistert sind. Dank des Typsystems und der
Eigentumsregeln von Rust kann man jedoch beim Sperren und Entsperren nichts
falsch machen.</p>
<h4 id="die-api-von-mutext"><a class="header" href="#die-api-von-mutext">Die API von <code>Mutex&lt;T&gt;</code></a></h4>
<p>Als Beispiel für die Verwendung eines Mutex beginnen wir mit der Verwendung
eines Mutex in einem einsträngigen (single-threaded) Kontext, wie in Codeblock
16-12 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}</code></pre></pre>
<p><span class="caption">Codeblock 16-12: Untersuchen der API von <code>Mutex&lt;T&gt;</code> in
einem einsträngigen Kontext zur Vereinfachung</span></p>
<p>Wie bei vielen Typen erzeugen wir einen <code>Mutex&lt;T&gt;</code> mit der zugehörigen Funktion
<code>new</code>. Um auf die Daten innerhalb des Mutex zuzugreifen, verwenden wir die
Methode <code>lock</code>, um die Sperre zu erhalten. Dieser Aufruf blockiert den
aktuellen Strang, sodass er keine Arbeit verrichten kann, bis wir an der Reihe
sind, die Sperre zu haben.</p>
<p>Der Aufruf von <code>lock</code> würde fehlschlagen, wenn ein anderer Strang, der die
Sperre hält, abstürzte. In diesem Fall wäre niemand jemals in der Lage, die
Sperre zu erhalten, also haben wir uns entschieden, <code>unwrap</code> zu benutzen und
diesen Strang abstürzen zu lassen, wenn wir uns in dieser Situation befinden.</p>
<p>Nachdem wir die Sperre erworben haben, können wir den Rückgabewert, in diesem
Fall <code>num</code> genannt, als veränderbare Referenz auf die darin enthaltenen Daten
verwenden. Das Typsystem stellt sicher, dass wir eine Sperre erwerben, bevor
wir den Wert in <code>m</code> verwenden. Der Typ von <code>m</code> ist <code>Mutex&lt;i32&gt;</code>, nicht <code>i32</code>,
also <em>müssen</em> wir <code>lock</code> aufrufen, um den <code>i32</code>-Wert verwenden zu können. Wir
können das nicht vergessen, das Typsystem würde uns sonst keinen Zugriff auf
das innere <code>i32</code> erlauben.</p>
<p>Wie du vielleicht vermutest, ist <code>Mutex&lt;T&gt;</code> ein intelligenter Zeiger. Genauer
gesagt gibt der Aufruf von <code>lock</code> einen intelligenten Zeiger namens
<code>MutexGuard</code> zurück, der in ein <code>LockResult</code> verpackt ist, das wir mit dem
Aufruf von <code>unwrap</code> behandelt haben. Der intelligente Zeiger <code>MutexGuard</code>
implementiert <code>Deref</code>, um auf unsere inneren Daten zu zeigen; der intelligente
Zeiger hat auch eine <code>Drop</code>-Implementierung, die die Sperre automatisch
aufhebt, wenn ein <code>MutexGuard</code> den Gültigkeitsbereich verlässt, was am Ende des
inneren Gültigkeitsbereichs geschieht. Dadurch laufen wir nicht Gefahr, zu
vergessen, die Sperre freizugeben und die Verwendung des Mutex durch andere
Stränge zu blockieren, da die Freigabe der Sperre automatisch erfolgt.</p>
<p>Nachdem wir die Sperre aufgehoben haben, können wir den Mutex-Wert ausgeben und
sehen, dass wir den inneren <code>i32</code> in 6 ändern konnten.</p>
<h4 id="gemeinsames-nutzen-eines-mutext-von-mehreren-strängen"><a class="header" href="#gemeinsames-nutzen-eines-mutext-von-mehreren-strängen">Gemeinsames Nutzen eines <code>Mutex&lt;T&gt;</code> von mehreren Strängen</a></h4>
<p>Versuchen wir nun, einen Wert zwischen mehreren Strängen mit <code>Mutex&lt;T&gt;</code> zu
teilen. Wir starten 10 Stränge und lassen sie jeweils einen Zählerwert um 1
erhöhen, sodass der Zähler von 0 auf 10 geht. Das nächste Beispiel in Codeblock
16-13 wird einen Kompilierfehler haben und wir werden diesen Fehler verwenden,
um mehr über die Verwendung von <code>Mutex&lt;T&gt;</code> zu erfahren und darüber, wie Rust
uns hilft, ihn korrekt zu verwenden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Ergebnis: {}&quot;, *counter.lock().unwrap());
}</code></pre></pre>
<p><span class="caption">Codeblock 16-13: Zehn Stränge inkrementieren jeweils
einen Zähler, der durch einen <code>Mutex&lt;T&gt;</code> geschützt ist</span></p>
<p>Wir erstellen eine Variable <code>counter</code>, um ein <code>i32</code> innerhalb eines <code>Mutex&lt;T&gt;</code>
zu halten, wie wir es in Codeblock 16-12 getan haben. Als Nächstes erstellen
wir 10 Stränge, indem wir über einen Zahlenbereich iterieren. Wir verwenden
<code>thread::spawn</code> und geben allen Strängen den gleichen Funktionsabschluss
(closure), der den Zähler in den Strang verschiebt, eine Sperre auf dem
<code>Mutex&lt;T&gt;</code> durch Aufrufen der <code>lock</code>-Methode erwirbt und dann 1 zum Wert im
Mutex addiert. Wenn ein Strang die Ausführung seines Funktionsabschlusses
beendet hat, verlässt <code>num</code> den Gültigkeitsbereich und gibt die Sperre frei,
sodass ein anderer Strang sie erwerben kann.</p>
<p>Im Hauptstrang sammeln wir alle <code>JoinHandle</code>. Dann rufen wir, wie wir es in
Codeblock 16-2 getan haben, <code>join</code> auf jedem Strang auf, um sicherzustellen,
dass alle Stränge beendet sind. An diesem Punkt erhält der Hauptstrang die
Sperre und gibt das Ergebnis dieses Programms aus.</p>
<p>Wir haben angedeutet, dass sich dieses Beispiel nicht kompilieren lässt. Jetzt
wollen wir herausfinden, warum!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:9:36
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` due to previous error
</code></pre>
<p>Die Fehlermeldung besagt, dass der Wert <code>counter</code> in der vorherigen Iteration
der Schleife verschoben wurde. Rust sagt uns, dass wir die Eigentümerschaft der
Sperre <code>counter</code> nicht in mehrere Stränge verschieben können. Lass uns den
Kompilierfehler mit einer Mehrfacheigentums-Methode beheben, die wir in Kapitel
15 besprochen haben.</p>
<h4 id="mehrfacheigentum-mit-mehreren-strängen"><a class="header" href="#mehrfacheigentum-mit-mehreren-strängen">Mehrfacheigentum mit mehreren Strängen</a></h4>
<p>In Kapitel 15 gaben wir einen Wert mit mehreren Eigentümern an, indem wir den
intelligenten Zeiger <code>Rc&lt;T&gt;</code> verwendeten, um einen Referenzzählwert zu
erstellen. Lass uns hier das Gleiche tun und sehen, was passiert. Wir packen
den <code>Mutex&lt;T&gt;</code> in <code>Rc&lt;T&gt;</code> in Codeblock 16-14 ein und klonen den <code>Rc&lt;T&gt;</code>, bevor
wir die Eigentümerschaft an den Strang übertragen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Ergebnis: {}&quot;, *counter.lock().unwrap());
}</code></pre></pre>
<p><span class="caption">Codeblock 16-14: Versuch, <code>Rc&lt;T&gt;</code> zu verwenden, um
mehreren Strängen zu erlauben, den <code>Mutex&lt;T&gt;</code> zu besitzen</span></p>
<p>Wir kompilieren nochmal und bekommen ... verschiedene Fehler! Der Compiler
lehrt uns eine Menge.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:22
    |
11  |           let handle = thread::spawn(move || {
    |  ______________________^^^^^^^^^^^^^_-
    | |                      |
    | |                      `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`
    |
    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` due to previous error
</code></pre>
<p>Toll, diese Fehlermeldung ist sehr wortreich! Hier ist der wichtige Teil, auf
den wir uns konzentrieren müssen: <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> kann nicht sicher zwischen
Strängen gesendet werden. Der Compiler teilt uns auch den Grund dafür mit: Das
Merkmal (trait) <code>Send</code> ist für <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> nicht implementiert. Wir werden
im nächsten Abschnitt über <code>Send</code> sprechen: Es ist eines der Merkmale, das
sicherstellt, dass die Typen, die wir mit Strängen verwenden, für die
Verwendung in nebenläufigen Situationen gedacht sind.</p>
<p>Leider ist es nicht sicher, <code>Rc&lt;T&gt;</code> über verschiedene Stränge hinweg gemeinsam
zu nutzen. Wenn <code>Rc&lt;T&gt;</code> den Referenzzähler verwaltet, inkrementiert es den
Zähler bei jedem Aufruf von <code>clone</code> und dekrementiert den Zähler bei jedem
Klon, der aufgeräumt wird. Es werden jedoch keine Nebenläufigkeitsprimitive
verwendet, um sicherzustellen, dass Änderungen am Zähler nicht durch einen
anderen Strang unterbrochen werden können. Dies könnte zu falschen Zählungen
führen – subtile Fehler, die wiederum zu Speicherlecks (memory leaks)
oder zum Aufräumen eines Wertes führen könnten, obwohl wir ihn noch nutzen
wollen. Was wir brauchen, ist ein Typ genau wie <code>Rc&lt;T&gt;</code>, aber einer, der
Änderungen am Referenzzähler auf Strang-sichere Weise vornimmt.</p>
<h4 id="atomare-referenzzählung-mit-arct"><a class="header" href="#atomare-referenzzählung-mit-arct">Atomare Referenzzählung mit <code>Arc&lt;T&gt;</code></a></h4>
<p>Glücklicherweise ist <code>Arc&lt;T&gt;</code> ein Typ wie <code>Rc&lt;T&gt;</code>, der in nebenläufigen
Situationen sicher zu verwenden ist. Das <em>a</em> steht für <em>atomar</em>, d.h. es
handelt sich um einen <em>atomar referenzgezählten</em> (atomically reference
counted) Typ. Atomare Typen (atomics) sind eine zusätzliche Art von
Nebenläufigkeitsprimitiven, die wir hier nicht im Detail behandeln werden:
Weitere Einzelheiten findest du in der Standardbibliotheksdokumentation für
<a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a>. An dieser Stelle musst du nur wissen, dass
atomare Typen wie primitive Typen funktionieren, aber sicher über Stränge
hinweg gemeinsam genutzt werden können.</p>
<p>Du wirst dich dann vielleicht fragen, warum nicht alle primitiven Typen atomar
sind und warum Standardbibliothekstypen nicht so implementiert sind, dass sie
standardmäßig <code>Arc&lt;T&gt;</code> verwenden. Der Grund dafür ist, dass Strang-Sicherheit
mit Performanzeinbußen verbunden ist, die du nur dann zahlen willst, wenn du
sie wirklich brauchst. Wenn du nur Operationen an Werten innerhalb eines
einzelnen Strangs durchführst, kann dein Code schneller laufen, wenn er nicht
die Garantien erzwingen muss, die atomare Typen bieten.</p>
<p>Kehren wir zu unserem Beispiel zurück: <code>Arc&lt;T&gt;</code> und <code>Rc&lt;T&gt;</code> haben die gleiche
API, also reparieren wir unser Programm, indem wir die <code>use</code>-Zeile, den Aufruf
von <code>new</code> und den Aufruf von <code>clone</code> ändern. Der Code in Codeblock 16-15 wird
schließlich kompilieren und laufen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Ergebnis: {}&quot;, *counter.lock().unwrap());
}</code></pre></pre>
<p><span class="caption">Codeblock 16-15: Verwenden von <code>Arc&lt;T&gt;</code>, um den <code>Mutex&lt;T&gt;</code>
einzupacken, um die Eigentümerschaft mit mehreren Strängen teilen zu
können</span></p>
<p>Dieser Code gibt folgendes aus:</p>
<pre><code class="language-text">Ergebnis: 10
</code></pre>
<p>Wir haben es geschafft! Wir zählten von 0 bis 10, was nicht sehr beeindruckend
erscheinen mag, aber wir haben viel über <code>Mutex&lt;T&gt;</code> und Strangsicherheit
gelernt. Du kannst die Struktur dieses Programms auch dazu benutzen,
kompliziertere Operationen durchzuführen als nur einen Zähler zu
inkrementieren. Mit dieser Strategie kannst du eine Berechnung in unabhängige
Teile aufteilen, diese Teile auf Stränge aufteilen und dann <code>Mutex&lt;T&gt;</code>
verwenden, damit jeder Strang das Endergebnis mit seinem Teil aktualisiert.</p>
<p>Beachte, dass es für einfache numerische Operationen einfachere Typen als
<code>Mutex&lt;T&gt;</code> gibt, die durch das <a href="https://doc.rust-lang.org/std/sync/atomic/index.html">Modul <code>std::sync::atomic</code> der
Standardbibliothek</a> bereitgestellt werden. Diese Typen bieten sicheren,
gleichzeitigen, atomaren Zugriff auf primitive Typen. Wir haben uns
entschieden, <code>Mutex&lt;T&gt;</code> mit einem primitiven Typ für dieses Beispiel zu
verwenden, damit wir uns darauf konzentrieren können, wie <code>Mutex&lt;T&gt;</code>
funktioniert.</p>
<h3 id="Ähnlichkeiten-zwischen-refcelltrct-und-mutextarct"><a class="header" href="#Ähnlichkeiten-zwischen-refcelltrct-und-mutextarct">Ähnlichkeiten zwischen <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> und <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>Du hast vielleicht bemerkt, dass <code>counter</code> unveränderbar (immutable) ist, aber
wir könnten eine veränderbare (mutable) Referenz auf den Wert in seinem
Inneren erhalten; das bedeutet, dass <code>Mutex&lt;T&gt;</code> innere Veränderbarkeit
(interior mutability) bietet, wie es die <code>Cell</code>-Familie tut. Auf die gleiche
Weise, wie wir <code>RefCell&lt;T&gt;</code> in Kapitel 15 benutzt haben, um uns zu erlauben,
Inhalte innerhalb eines <code>Rc&lt;T&gt;</code> zu mutieren, benutzen wir <code>Mutex&lt;T&gt;</code>, um
Inhalte innerhalb eines <code>Arc&lt;T&gt;</code> zu mutieren.</p>
<p>Ein weiteres zu beachtendes Detail ist, dass Rust dich nicht vor allen Arten
von Logikfehlern schützen kann, wenn du <code>Mutex&lt;T&gt;</code> verwendest. Erinnere dich in
Kapitel 15 daran, dass die Verwendung von <code>Rc&lt;T&gt;</code> mit dem Risiko verbunden war,
Referenzzyklen zu erzeugen, bei denen zwei <code>Rc&lt;T&gt;</code> Werte aufeinander
referenzieren und dadurch Speicherlecks verursachen. In ähnlicher Weise ist
<code>Mutex&lt;T&gt;</code> mit dem Risiko verbunden, <em>Deadlocks</em> zu schaffen. Diese treten auf,
wenn eine Operation zwei Ressourcen sperren muss und zwei Stränge jeweils eine
der Sperren erworben haben, was dazu führt, dass sie ewig aufeinander warten.
Wenn du an Deadlocks interessiert bist, versuche, ein Programm in Rust zu
erstellen, das einen Deadlock hat; dann recherchiere Strategien zur Minderung
von Deadlocks für Mutexe in einer Sprache und versuche, sie in Rust zu
implementieren. Die Standardbibliotheks-API-Dokumentation für <code>Mutex&lt;T&gt;</code> und
<code>MutexGuard</code> bietet nützliche Informationen.</p>
<p>Wir runden dieses Kapitel ab, indem wir über die Merkmale <code>Send</code> und <code>Sync</code>
sprechen und wie wir sie mit benutzerdefinierten Typen verwenden können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="erweiterbare-nebenläufigkeit-mit-den-merkmalen-traits-sync-und-send"><a class="header" href="#erweiterbare-nebenläufigkeit-mit-den-merkmalen-traits-sync-und-send">Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) <code>Sync</code> und <code>Send</code></a></h2>
<p>Interessanterweise hat die Sprache Rust <em>sehr wenige</em>
Nebenläufigkeitsfunktionalitäten. Fast jede Nebenläufigkeitsfunktionalität,
über die wir bisher in diesem Kapitel gesprochen haben, war Teil der
Standardbibliothek, nicht der Sprache. Deine Möglichkeiten für den Umgang mit
Nebenläufigkeit sind nicht auf die Sprache oder die Standardbibliothek
beschränkt; du kannst deine eigenen Nebenläufigkeitsfunktionalitäten schreiben
oder die von anderen geschriebenen verwenden.</p>
<p>In der Sprache sind jedoch zwei Nebenläufigkeitskonzepte eingebettet: Die
<code>std::marker</code>-Merkmale (traits) <code>Sync</code> und <code>Send</code>.</p>
<h3 id="erlauben-der-eigentümerschaftübertragung-zwischen-strängen-mit-send"><a class="header" href="#erlauben-der-eigentümerschaftübertragung-zwischen-strängen-mit-send">Erlauben der Eigentümerschaftübertragung zwischen Strängen mit <code>Send</code></a></h3>
<p>Das Markierungsmerkmal (marker trait) <code>Send</code> zeigt an, dass die
Eigentümerschaft an Werten des Typs, der <code>Send</code> implementiert, zwischen
Strängen (threads) übertragen werden kann. Fast jeder Rust-Typ ist <code>Send</code>, aber
es gibt einige Ausnahmen, einschließlich <code>Rc&lt;T&gt;</code>: Dieser kann nicht <code>Send</code>
sein, denn wenn du einen <code>Rc&lt;T&gt;</code> Wert geklont hast und versucht hast, die
Eigentümerschaft am Klon auf einen anderen Strang zu übertragen, könnten beide
Stränge gleichzeitig die Referenzzahl aktualisieren. Aus diesem Grund ist
<code>Rc&lt;T&gt;</code> für die Verwendung in einsträngigen Situationen implementiert, in denen
du nicht die Strang-sichere Performanzeinbuße zahlen willst.</p>
<p>Daher stellen das Typsystem und die Merkmalsabgrenzungen (trait bounds) von
Rust sicher, dass du niemals versehentlich einen <code>Rc&lt;T&gt;</code>-Wert über Stränge
unsicher senden kannst. Als wir dies in Codeblock 16-14 versuchten, erhielten
wir folgenden Fehler: Das Merkmal <code>Send</code> ist für <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> nicht
implementiert. Als wir zu <code>Arc&lt;T&gt;</code>, das <code>Send</code> ist, wechselten, wurde der Code
kompiliert.</p>
<p>Jeder Typ, der vollständig aus <code>Send</code>-Typen besteht, wird automatisch auch als
<code>Send</code> markiert. Fast alle primitiven Typen sind <code>Send</code>, abgesehen von
Roh-Zeigern, die wir in Kapitel 19 besprechen werden.</p>
<h3 id="erlauben-des-zugriffs-von-mehreren-strängen-mit-sync"><a class="header" href="#erlauben-des-zugriffs-von-mehreren-strängen-mit-sync">Erlauben des Zugriffs von mehreren Strängen mit <code>Sync</code></a></h3>
<p>Das Markierungsmerkmal <code>Sync</code> zeigt an, dass es sicher ist, den Typ, der <code>Sync</code>
implementiert, von mehreren Strängen zu referenzieren. Mit anderen Worten,
jeder Typ <code>T</code> ist <code>Sync</code>, wenn <code>&amp;T</code> (eine unveränderbare Referenz auf <code>T</code>)
<code>Send</code> ist, was bedeutet, dass die Referenz sicher an einen anderen Strang
gesendet werden kann. Ähnlich wie bei <code>Send</code> sind primitive Typen <code>Sync</code> und
Typen, die vollständig aus Typen bestehen, die <code>Sync</code> sind, sind ebenfalls
<code>Sync</code>.</p>
<p>Der intelligente Zeiger <code>Rc&lt;T&gt;</code> ist nicht <code>Sync</code>, aus den gleichen Gründen, aus
denen er nicht <code>Send</code> ist. Der Typ <code>RefCell&lt;T&gt;</code> (über den wir in Kapitel 15
gesprochen haben) und die Familie der verwandten <code>Cell&lt;T&gt;</code>-Typen sind nicht
<code>Sync</code>. Die Implementierung der Ausleihenprüfung (borrow checking), die
<code>RefCell&lt;T&gt;</code> zur Laufzeit durchführt, ist nicht Strang-sicher. Der intelligente
Zeiger <code>Mutex&lt;T&gt;</code> ist <code>Sync</code> und kann verwendet werden, um den Zugriff mit
mehreren Strängen zu teilen, wie du im Abschnitt <a href="ch16-03-shared-state.html#gemeinsames-nutzen-eines-mutext-von-mehreren-str%C3%A4ngen">„Gemeinsames Nutzen eines
<code>Mutex&lt;T&gt;</code> von mehreren Strängen“</a> gesehen hast.</p>
<h3 id="manuelles-implementieren-von-send-und-sync-ist-unsicher"><a class="header" href="#manuelles-implementieren-von-send-und-sync-ist-unsicher">Manuelles Implementieren von <code>Send</code> und <code>Sync</code> ist unsicher</a></h3>
<p>Da Typen, die sich aus den Merkmalen <code>Send</code> und <code>Sync</code> zusammensetzen,
automatisch auch <code>Send</code> und <code>Sync</code> sind, müssen wir diese Merkmale nicht
manuell implementieren. Als Markierungsmerkmale haben sie noch nicht einmal
irgendwelche Methoden, um sie zu implementieren. Sie sind nur nützlich, um
Invarianten in Bezug auf die Nebenläufigkeit zu erzwingen.</p>
<p>Das manuelle Implementieren dieser Merkmale beinhaltet das Schreiben von
unsicherem Rust-Code. Wir werden über das Verwenden von unsicherem Rust-Code in
Kapitel 19 sprechen; für den Moment ist die wichtige Information, dass das
Erstellen neuer nebenläufiger Typen, die nicht aus <code>Send</code>- und <code>Sync</code>-Teilen
bestehen, sorgfältige Überlegungen erfordert, um die Sicherheitsgarantien
aufrechtzuerhalten. <a href="https://doc.rust-lang.org/nomicon/index.html">„Das Rustonomicon“</a> enthält weitere Informationen
über diese Garantien und wie man sie aufrechterhalten kann.</p>
<h2 id="zusammenfassung-15"><a class="header" href="#zusammenfassung-15">Zusammenfassung</a></h2>
<p>Dies ist nicht das letzte Mal, dass du in diesem Buch der Nebenläufigkeit
begegnest: Das Projekt in Kapitel 20 wird die Konzepte in diesem Kapitel in
einer realistischeren Situation verwenden als die hier besprochenen kleinen
Beispiele.</p>
<p>Wie bereits erwähnt, ist nur sehr wenig davon, wie Rust mit Nebenläufigkeit
umgeht, Teil der Sprache; viele Nebenläufigkeitslösungen sind als Kisten
(crates) implementiert. Diese entwickeln sich schneller als die
Standardbibliothek. Stelle also sicher, dass du online nach den aktuellen,
hochmodernen Kisten suchst, die in mehrsträngigen Situationen verwendet werden
können.</p>
<p>Die Rust-Standardbibliothek bietet Kanäle (channels) für die
Nachrichtenübermittlung und intelligente Zeigertypen, wie <code>Mutex&lt;T&gt;</code> und
<code>Arc&lt;T&gt;</code>, die sicher in nebenläufigen Kontexten verwendet werden können. Das
Typsystem und der Ausleihenprüfer stellen sicher, dass der Code, der diese
Lösungen verwendet, nicht mit Daten-Wettlaufsituationen (data races) oder
ungültigen Referenzen endet. Sobald du deinen Code zum Kompilieren gebracht
hast, kannst du sicher sein, dass er problemlos mit mehreren Strängen läuft,
ohne die schwer aufzuspürenden Fehler, die in anderen Sprachen üblich sind.
Nebenläufige Programmierung ist kein Konzept mehr, vor dem man sich fürchten
muss: Gehe hinaus und mache deine Programme nebenläufig – furchtlos!</p>
<p>Als Nächstes werden wir über idiomatische Wege sprechen, Probleme zu
modellieren und Lösungen zu strukturieren, während deine Rust-Programme größer
werden. Darüber hinaus werden wir besprechen, wie Rusts Idiome mit denen
zusammenhängen, die dir vielleicht aus der objektorientierten Programmierung
bekannt sind.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objektorientierte-sprachelemente-von-rust"><a class="header" href="#objektorientierte-sprachelemente-von-rust">Objektorientierte Sprachelemente von Rust</a></h1>
<p>Die objektorientierte Programmierung (OOP) ist eine Methode zur Modellierung
von Programmen. Objekte als programmatisches Konzept wurden in den 1960er
Jahren in der Programmiersprache Simula eingeführt. Diese Objekte beeinflussten
die Programmierarchitektur von Alan Kay, in der Objekte sich gegenseitig
Nachrichten übermitteln. Er prägte 1967 den Begriff <em>objektorientierte
Programmierung</em>, um diese Architektur zu beschreiben. Viele konkurrierende
Definitionen beschreiben, was OOP ist; einige Definitionen würden Rust als
objektorientiert klassifizieren, andere hingegen nicht. In diesem Kapitel
untersuchen wir bestimmte Charakteristiken, die gemeinhin als objektorientiert
gelten, und wie sich diese Charakteristiken in idiomatisches Rust übersetzen
lassen. Anschließend zeigen wir dir, wie du ein objektorientiertes
Entwurfsmuster in Rust implementieren kannst, und erörtern die Kompromisse, die
sich daraus gegenüber der Implementierung einer Lösung ergeben, die stattdessen
einige der Stärken von Rust nutzt.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="charakteristiken-objektorientierter-sprachen"><a class="header" href="#charakteristiken-objektorientierter-sprachen">Charakteristiken objektorientierter Sprachen</a></h2>
<p>Es gibt in der Programmierergemeinschaft keinen Konsens darüber, welche
Funktionalitäten eine Sprache haben muss, um als objektorientiert zu gelten.
Rust wird von vielen Programmierparadigmen beeinflusst, einschließlich OOP; zum
Beispiel haben wir in Kapitel 13 die Funktionalitäten untersucht, die aus der
funktionalen Programmierung stammen. Die OOP-Sprachen haben wohl bestimmte
gemeinsame Charakteristiken, nämlich Objekte, Kapselung (encapsulation) und
Vererbung (inheritance). Schauen wir uns an, was jedes dieser Charakteristiken
bedeutet und ob Rust es unterstützt.</p>
<h3 id="objekte-enthalten-daten-und-verhalten"><a class="header" href="#objekte-enthalten-daten-und-verhalten">Objekte enthalten Daten und Verhalten</a></h3>
<p>Das Buch <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> von
Erich Gamma, Richard Helm, Ralph Johnson und John Vlissides (Addison-Wesley
Professional, 1994), umgangssprachlich als <em>The Gang of Four</em>-Buch bezeichnet,
ist ein Katalog von objektorientierten Entwurfsmustern. Es definiert OOP auf
diese Weise:</p>
<blockquote>
<p>Objektorientierte Programme setzen sich aus Objekten zusammen. Ein <em>Objekt</em>
verpackt sowohl Daten als auch Prozeduren, die auf diesen Daten operieren.
Die Prozeduren werden normalerweise <em>Methoden</em> oder <em>Operationen</em> genannt.</p>
</blockquote>
<p>Mit dieser Definition ist Rust objektorientiert: Strukturen (structs) und
Aufzählungen (enums) haben Daten, und <code>impl</code>-Blöcke stellen Methoden auf
Strukturen und Aufzählungen zur Verfügung. Auch wenn Strukturen und
Aufzählungen mit Methoden keine <em>aufgerufenen</em> Objekte sind, bieten sie
dieselbe Funktionalität gemäß der Definition von Objekten der Gang of Four.</p>
<h3 id="kapselung-die-implementierungsdetails-verbirgt"><a class="header" href="#kapselung-die-implementierungsdetails-verbirgt">Kapselung, die Implementierungsdetails verbirgt</a></h3>
<p>Ein weiterer Aspekt, der gemeinhin mit OOP in Verbindung gebracht wird, ist die
Idee der <em>Kapselung</em> (encapsulation), was bedeutet, dass die
Implementierungsdetails eines Objekts nicht zugänglich sind für Code, der
dieses Objekt verwendet. Daher ist die einzige Möglichkeit, mit einem Objekt zu
interagieren, seine öffentliche API; Code, der das Objekt verwendet, sollte
nicht in der Lage sein, in die Interna des Objekts einzudringen und Daten oder
Verhalten direkt zu ändern. Dies ermöglicht es dem Programmierer, die Interna
eines Objekts zu ändern und umzugestalten, ohne Code ändern zu müssen, der das
Objekt verwendet.</p>
<p>Wie man die Kapselung steuert, haben wir in Kapitel 7 besprochen: Wir können
das Schlüsselwort <code>pub</code> benutzen, um zu entscheiden, welche Module, Typen,
Funktionen und Methoden in unserem Code öffentlich sein sollen, alles andere
ist standardmäßig privat. Zum Beispiel können wir eine Struktur
<code>AveragedCollection</code> definieren, die ein Feld hat, das einen Vektor mit
<code>i32</code>-Werten enthält. Die Struktur kann auch ein Feld haben, das den Mittelwert
der Werte im Vektor enthält, was bedeutet, dass der Mittelwert nicht auf
Anfrage berechnet werden muss, wenn jemand ihn braucht. Mit anderen Worten:
<code>AveragedCollection</code> wird den errechneten Durchschnitt für uns
zwischenspeichern. Codeblock 17-1 zeigt die Definition der Struktur
<code>AveragedCollection</code>:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-1: Eine Struktur <code>AveragedCollection</code>, die
eine Liste von ganzen Zahlen und den Durchschnitt der Elemente in der
Kollektion verwaltet</span></p>
<p>Die Struktur wird als <code>pub</code> markiert, damit anderer Code sie verwenden kann,
aber die Felder innerhalb der Struktur bleiben privat. Dies ist in diesem Fall
wichtig, weil wir sicherstellen wollen, dass immer dann, wenn ein Wert
hinzugefügt oder aus der Liste entfernt wird, auch der Durchschnitt
aktualisiert wird. Wir tun dies, indem wir die Methoden <code>add</code>, <code>remove</code> und
<code>average</code> auf der Struktur implementieren, wie in Codeblock 17-2 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-2: Implementierungen der öffentlichen
Methoden <code>add</code>, <code>remove</code> und <code>average</code> auf  <code>AveragedCollection</code></span></p>
<p>Die öffentlichen Methoden <code>add</code>, <code>remove</code> und <code>average</code> sind die einzigen
Möglichkeiten, auf Daten in einer <code>AveragedCollection</code>-Instanz zuzugreifen oder
sie zu ändern. Wenn ein Eintrag mit der Methode <code>add</code> zu <code>list</code> hinzugefügt
oder mit der Methode <code>remove</code> entfernt wird, rufen die Implementierungen der
einzelnen Methoden die private Methode <code>update_average</code> auf, die auch das
Aktualisieren des Feldes <code>average</code> übernimmt.</p>
<p>Wir lassen die Felder <code>list</code> und <code>average</code> privat, sodass es keine Möglichkeit
für externen Code gibt, Elemente direkt zum Feld <code>list</code> hinzuzufügen oder zu
entfernen; andernfalls könnte das Feld <code>average</code> inkonsistent werden, wenn sich
<code>list</code> ändert. Die Methode <code>average</code> gibt den Wert im Feld <code>average</code> zurück,
sodass externer Code den Wert <code>average</code> lesen, aber nicht verändern kann.</p>
<p>Da wir die Implementierungsdetails der Struktur <code>AveragedCollection</code> gekapselt
haben, können wir Aspekte, z.B. die Datenstruktur, in Zukunft leicht ändern.
Zum Beispiel könnten wir ein <code>HashSet&lt;i32&gt;</code> anstelle eines <code>Vec&lt;i32&gt;</code> für das
<code>list</code>-Feld verwenden. Solange die Signaturen der öffentlichen Methoden <code>add</code>,
<code>remove</code> und <code>average</code> gleich bleiben, würde Code, der <code>AveragedCollection</code>
verwendet, nicht geändert werden müssen. Wenn wir stattdessen <code>list</code> öffentlich
machen würden, wäre dies nicht unbedingt der Fall: <code>HashSet&lt;i32&gt;</code> und
<code>Vec&lt;i32&gt;</code> haben unterschiedliche Methoden zum Hinzufügen und Entfernen von
Elementen, sodass externer Code wahrscheinlich geändert werden müsste, wenn er
<code>list</code> direkt modifizieren würde.</p>
<p>Wenn die Kapselung ein erforderlicher Aspekt ist, damit eine Sprache als
objektorientiert betrachtet werden kann, dann erfüllt Rust diese Anforderung.
Die Möglichkeit, <code>pub</code> für verschiedene Teile des Codes zu verwenden oder auch
nicht, ermöglicht die Kapselung von Implementierungsdetails.</p>
<h3 id="vererbung-als-typsystem-und-für-gemeinsamen-code"><a class="header" href="#vererbung-als-typsystem-und-für-gemeinsamen-code">Vererbung als Typsystem und für gemeinsamen Code</a></h3>
<p><em>Vererbung</em> ist ein Mechanismus, mit dem ein Objekt Elemente von der Definition
eines anderen Objekts erben kann und so die Daten und das Verhalten des
übergeordneten Objekts erhält, ohne dass du diese erneut definieren musst.</p>
<p>Wenn eine Sprache Vererbung haben muss, um eine objektorientierte Sprache zu
sein, dann ist Rust keine solche. Es gibt keine Möglichkeit, eine Struktur zu
definieren, die die Felder und Methodenimplementierungen der Elternstruktur
erbt, ohne ein Makro zu benutzen.</p>
<p>Wenn du jedoch daran gewöhnt bist, Vererbung in deinem
Programmierwerkzeugkasten zu haben, kannst du in Rust andere Lösungen
verwenden, je nachdem, warum du überhaupt zu Vererbung gegriffen hast.</p>
<p>Du würdest dich aus zwei Hauptgründen für die Vererbung entscheiden. Einer ist
die Wiederverwendung von Code: Du kannst ein bestimmtes Verhalten für einen Typ
implementieren und die Vererbung ermöglicht es dir, diese Implementierung für
einen anderen Typ wiederzuverwenden. Du kannst das auf begrenzte Weise in
Rust-Code unter Verwendung von Standard-Merkmalsmethoden-Implementierungen tun,
was du in Codeblock 10-14 gesehen hast, als wir eine Standard-Implementierung
der Methode <code>summarize</code> für das Merkmal (trait) <code>Summary</code> hinzugefügt haben.
Jeder Typ, der das Merkmal <code>Summary</code> implementiert, hätte die Methode
<code>summarize</code> ohne weiteren Code darauf zur Verfügung. Dies ist vergleichbar mit
einer Elternklasse, die eine Implementierung einer Methode hat, und einer
erbenden Kindklasse, die ebenfalls die Implementierung der Methode hat. Wir
können auch die Standard-Implementierung der Methode <code>summarize</code> außer Kraft
setzen, wenn wir das Markmal <code>Summary</code> implementieren, die einer Kindklasse
ähnelt, die die Implementierung einer von einer Elternklasse geerbten Methode
außer Kraft setzt.</p>
<p>Der andere Grund, Vererbung zu verwenden, bezieht sich auf das Typsystem: Ein
untergeordneter Typ soll an den gleichen Stellen wie der übergeordnete Typ
verwendet werden können. Dies wird auch <em>Polymorphismus</em> (polymorphism)
genannt, d.h. du kannst mehrere Objekte zur Laufzeit gegeneinander austauschen,
wenn sie bestimmte Eigenschaften gemeinsam haben.</p>
<blockquote>
<h3 id="polymorphismus"><a class="header" href="#polymorphismus">Polymorphismus</a></h3>
<p>Für viele Menschen ist Polymorphismus gleichbedeutend mit Vererbung. Aber es
ist eigentlich ein allgemeinerer Begriff, der sich auf Code bezieht, der mit
Daten unterschiedlichen Typs arbeiten kann. Für die Vererbung sind diese
Typen im Allgemeinen Unterklassen.</p>
<p>Rust verwendet stattdessen generische Datentypen (generics), um über
verschiedene mögliche Typen und Merkmalsabgrenzungen (trait bounds) zu
abstrahieren, um Beschränkungen für das aufzuerlegen, was diese Typen bieten
müssen. Dies wird manchmal als <em>begrenzter parametrischer Polymorphismus</em>
(bounded parametric polymorphism) bezeichnet.</p>
</blockquote>
<p>Die Vererbung ist in letzter Zeit als Lösung für das Programmierdesign in
vielen Programmiersprachen in Ungnade gefallen, da sie oft das Risiko birgt,
mehr Code als nötig zu teilen. Unterklassen sollten nicht immer alle
Charakteristiken ihrer Elternklasse teilen, bei Vererbung tun sie es aber. Dies
kann den Programmentwurf weniger flexibel machen. Es wird auch die Möglichkeit
eingeführt, Methoden auf Unterklassen aufzurufen, die keinen Sinn machen oder
die Fehler verursachen, weil die Methoden nicht auf die Unterklasse zutreffen.
Darüber hinaus lassen einige Sprachen nur Einfachvererbung zu (d.h. eine
Unterklasse kann nur von einer Klasse erben), was die Flexibilität des
Programmdesigns weiter einschränkt.</p>
<p>Aus diesen Gründen verfolgt Rust den anderen Ansatz durch Verwendung von
Merkmalsobjekten (trait objects) anstelle der Vererbung. Schauen wir uns an,
wie Merkmalsobjekte Polymorphismus in Rust ermöglichen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="merkmalsobjekte-trait-objects-die-werte-unterschiedlicher-typen-erlauben"><a class="header" href="#merkmalsobjekte-trait-objects-die-werte-unterschiedlicher-typen-erlauben">Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen erlauben</a></h2>
<p>In Kapitel 8 haben wir erwähnt, dass eine Einschränkung von Vektoren darin
besteht, dass sie nur Elemente eines einzigen Typs speichern können. Wir haben
in Codeblock 8-9 eine Abhilfe geschaffen, indem wir eine Aufzählung (enum)
<code>SpreadsheetCell</code> definiert haben, die Varianten zur Aufnahme von Ganzzahlen,
Fließkommazahlen und Text enthielt. Das bedeutete, dass wir in jeder Zelle
verschiedene Typen von Daten speichern konnten und trotzdem einen Vektor
hatten, der eine Reihe von Zellen darstellte. Dies ist eine perfekte Lösung,
wenn unsere austauschbaren Elemente ein fester Satz von Typen sind, die wir
kennen, wenn unser Code kompiliert wird.</p>
<p>Manchmal möchten wir jedoch, dass unsere Bibliotheksbenutzer in der Lage sind,
die Menge der Typen, die in einer bestimmten Situation erlaubt sind, zu
erweitern. Um zu zeigen, wie wir dies erreichen können, werden wir ein Beispiel
für ein GUI-Werkzeug (Graphical User Interface) erstellen, das über eine Liste
von Elementen iteriert, wobei auf jedem Element eine Methode <code>draw</code> aufgerufen
wird, um es auf den Bildschirm zu zeichnen – eine übliche Technik für
GUI-Werkzeuge. Wir werden eine Bibliothekskiste (library crate) namens <code>gui</code>
erstellen, die die Struktur einer GUI-Bibliothek enthält. Diese Kiste (crate)
könnte einige Typen enthalten, die Leute benutzen können, z.B. <code>Button</code> und
<code>TextField</code>. Darüber hinaus werden <code>gui</code>-Benutzer ihre eigenen Typen erstellen
wollen, die gezeichnet werden können: Zum Beispiel könnte ein Programmierer ein
<code>Image</code> und ein anderer eine <code>SelectBox</code> hinzufügen.</p>
<p>Wir werden für dieses Beispiel keine vollwertige GUI-Bibliothek implementieren,
aber wir werden zeigen, wie die Teile zusammenpassen würden. Zum Zeitpunkt des
Schreibens der Bibliothek können wir nicht alle Typen kennen und definieren,
die andere Programmierer vielleicht erstellen möchten. Aber wir wissen, dass
<code>gui</code> den Überblick über viele Werte unterschiedlicher Typen behalten muss, und
es muss für jeden dieser unterschiedlich typisierten Werte eine Methode <code>draw</code>
aufrufen. Es muss nicht genau wissen, was passieren wird, wenn wir die Methode
<code>draw</code> aufrufen, sondern nur, dass der Wert diese Methode für uns zum Aufruf
bereithält.</p>
<p>Um dies in einer Sprache mit Vererbung zu tun, könnten wir eine Klasse namens
<code>Component</code> definieren, die eine Methode namens <code>draw</code> enthält. Die anderen
Klassen, z.B. <code>Button</code>, <code>Image</code> und <code>SelectBox</code>, würden von <code>Component</code> erben
und somit die Methode <code>draw</code> erben. Sie könnten jeweils die <code>draw</code>-Methode
überschreiben, um ihr eigenes Verhalten zu definieren, aber das
Programmiergerüst (framework) könnte alle Typen so behandeln, als wären sie
<code>Component</code>-Instanzen, und <code>draw</code> aufrufen. Aber da Rust keine Vererbung hat,
brauchen wir einen anderen Weg, die <code>gui</code>-Bibliothek zu strukturieren, damit
die Benutzer sie um neue Typen erweitern können.</p>
<h3 id="definieren-eines-merkmals-trait-für-allgemeines-verhalten"><a class="header" href="#definieren-eines-merkmals-trait-für-allgemeines-verhalten">Definieren eines Merkmals (trait) für allgemeines Verhalten</a></h3>
<p>Um das Verhalten zu implementieren, das wir in <code>gui</code> haben wollen, werden wir ein
Merkmal namens <code>Draw</code> definieren, das eine Methode namens <code>draw</code> haben wird.
Dann können wir einen Vektor definieren, der ein <em>Merkmalsobjekt</em> (trait
object) annimmt. Ein Merkmalsobjekt verweist sowohl auf eine Instanz eines
Typs, der das von uns spezifizierte Merkmal implementiert, und eine Tabelle, in
der Merkmalsmethoden dieses Typs zur Laufzeit nachgeschlagen werden können. Wir
erstellen ein Merkmalsobjekt, indem wir eine Art Zeiger angeben, z.B. eine
Referenz <code>&amp;</code> oder einen intelligenten Zeiger <code>Box&lt;T&gt;</code>, dann das Schlüsselwort
<code>dyn</code> und dann das relevante Merkmal. (Wir werden über den Grund, warum
Merkmalsobjekte einen Zeiger verwenden müssen, in Kapitel 19 im Abschnitt
<a href="ch19-04-advanced-types.html#dynamisch-gro%C3%9Fe-typen-und-das-merkmal-sized">„Dynamisch große Typen und das Merkmal <code>Sized</code>“</a>) sprechen.
Wir können Merkmalsobjekte an Stelle eines generischen oder konkreten Typs
verwenden. Wo immer wir ein Merkmalsobjekt verwenden, stellt Rusts Typsystem
zur Kompilierzeit sicher, dass jeder in diesem Kontext verwendete Wert das
Merkmal des Merkmalsobjekts implementiert. Folglich müssen wir zur
Kompilierzeit nicht alle möglichen Typen kennen.</p>
<p>Wir haben erwähnt, dass wir in Rust davon absehen, Strukturen (structs) und
Aufzählungen „Objekte“ zu nennen, um sie von den Objekten anderer Sprachen zu
unterscheiden. In einer Struktur oder Aufzählung sind die Daten in den
Struktur-Feldern vom Verhalten in <code>impl</code>-Blöcken getrennt, während in anderen
Sprachen die Daten und das Verhalten, die in einem Konzept zusammengefasst
sind, oft als ein Objekt bezeichnet werden. Merkmalsobjekte <em>sind</em> jedoch eher
wie Objekte in anderen Sprachen in dem Sinne, dass sie Daten und Verhalten
kombinieren. Aber Merkmalsobjekte unterscheiden sich von traditionellen
Objekten dadurch, dass wir einem Merkmalsobjekt keine Daten hinzufügen können.
Merkmalsobjekte sind nicht so allgemein einsetzbar wie Objekte in anderen
Sprachen: Ihr spezifischer Zweck besteht darin, Abstraktion über allgemeines
Verhalten zu ermöglichen.</p>
<p>In Codeblock 17-3 wird gezeigt, wie ein Merkmal namens <code>Draw</code> mit einer Methode
namens <code>draw</code> definiert werden kann:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
    fn draw(&amp;self);
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-3: Definition des Merkmals <code>Draw</code></span></p>
<p>Diese Syntax sollte uns aus unseren Diskussionen über die Definition von
Merkmalen in Kapitel 10 bekannt vorkommen. Als nächstes kommt eine neue Syntax:
Codeblock 17-4 definiert eine Struktur namens <code>Screen</code>, die einen Vektor namens
<code>components</code> enthält. Dieser Vektor ist vom Typ <code>Box&lt;dyn Draw&gt;</code>, der ein
Merkmalsobjekt ist; er ist ein Stellvertreter für jeden Typ innerhalb einer
<code>Box</code>, der das Merkmal <code>Draw</code> implementiert.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-4: Definition der Struktur <code>Screen</code> mit
einem Feld <code>components</code>, das einen Vektor von Merkmalsobjekten enthält, die das
<code>Draw</code>-Merkmal implementieren</span></p>
<p>Auf der Struktur <code>Screen</code> definieren wir eine Methode namens <code>run</code>, die die
<code>draw</code>-Methode auf jeder ihrer <code>components</code> aufruft, wie in Codeblock 17-5 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-5: Eine Methode <code>run</code> auf <code>Screen</code>, die die
<code>draw</code>-Methode jeder Komponente aufruft</span></p>
<p>Dies funktioniert anders als die Definition einer Struktur, die einen
generischen Typparameter mit Merkmalsabgrenzungen (trait bounds) verwendet. Ein
generischer Typparameter kann jeweils nur durch einen konkreten Typ ersetzt
werden, während Merkmalsobjekte die Möglichkeit bieten, zur Laufzeit mehrere
konkrete Typen für das Merkmalsobjekt einzusetzen. Beispielsweise hätten wir
die Struktur <code>Screen</code> mit einem generischen Typ und einer Merkmalsabgrenzung
wie in Codeblock 17-6 definieren können:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-6: Eine alternative Implementierung der
Struktur <code>Screen</code> und ihrer <code>run</code>-Methode unter Verwendung generischer Typen
und Merkmalsabgrenzungen</span></p>
<p>Dies schränkt uns auf eine <code>Screen</code>-Instanz ein, die eine Liste von Komponenten
hat, die alle vom Typ <code>Button</code> oder alle vom Typ <code>TextField</code> sind. Wenn du
immer nur homogene Kollektionen haben wirst, ist das Verwenden von generischen
Typen und Merkmalsabgrenzungen vorzuziehen, da die Definitionen zur
Kompilierszeit monomorphisiert werden, um die konkreten Typen zu verwenden.</p>
<p>Andererseits kann bei der Methode mit Merkmalsobjekten eine <code>Screen</code>-Instanz
einen <code>Vec&lt;T&gt;</code> enthalten, der sowohl eine <code>Box&lt;Button&gt;</code> als auch eine
<code>Box&lt;TextField&gt;</code> enthält. Schauen wir uns an, wie dies funktioniert, und dann
werden wir über die Auswirkungen auf die Laufzeitperformanz sprechen.</p>
<h3 id="implementieren-des-merkmals"><a class="header" href="#implementieren-des-merkmals">Implementieren des Merkmals</a></h3>
<p>Nun fügen wir einige Typen hinzu, die das Merkmal <code>Draw</code> implementieren. Wir
werden den Typ <code>Button</code> zur Verfügung stellen. Auch hier liegt die eigentliche
Implementierung einer GUI-Bibliothek jenseits des Rahmens dieses Buches, sodass
die <code>draw</code>-Methode keine nützliche Implementierung in ihrem Rumpf haben wird.
Um sich vorzustellen, wie die Implementierung aussehen könnte, könnte eine
Struktur <code>Button</code> Felder für <code>width</code>, <code>height</code> und <code>label</code> haben, wie in
Codeblock 17-7 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // Code zum tatsächlichen Zeichnen einer Schaltfläche
    }
}</code></pre>
<p><span class="caption">Codeblock 17-7: Eine Struktur <code>Button</code>, die das Merkmal
<code>Draw</code> implementiert</span></p>
<p>Die Felder <code>width</code>, <code>height</code> und <code>label</code> in <code>Button</code> unterscheiden sich von den
Feldern anderer Komponenten; beispielsweise könnte ein Typ <code>TextField</code> diese
Felder und zusätzlich ein <code>placeholder</code> haben. Jeder der Typen, die wir auf dem
Bildschirm zeichnen wollen, wird das Merkmal <code>Draw</code> implementieren, aber
unterschiedlichen Code in der <code>draw</code>-Methode verwenden, um zu definieren, wie
dieser bestimmte Typ gezeichnet werden soll, wie es hier bei <code>Button</code> der Fall
ist (ohne wie erwähnt den eigentlichen GUI-Code). Der Typ <code>Button</code> könnte zum
Beispiel einen zusätzlichen <code>impl</code>-Block haben, der Methoden enthält, die sich
darauf beziehen, was passiert, wenn ein Benutzer auf die Schaltfläche klickt.
Diese Art von Methoden trifft nicht auf Typen wie <code>TextField</code> zu.</p>
<p>Wenn sich jemand, der unsere Bibliothek benutzt, dazu entschließt, eine
Struktur <code>SelectBox</code> zu implementieren, die die Felder <code>width</code>, <code>height</code> und
<code>options</code> enthält, implementiert er ebenfalls das Merkmal <code>Draw</code> für den Typ
<code>SelectBox</code>, wie in Codeblock 17-8 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // Code zum tatsächlichen Zeichnen eines Auswahlfeldes
    }
}</code></pre>
<p><span class="caption">Codeblock 17-8: Eine weitere Kiste, die <code>gui</code> verwendet
und das Merkmal <code>Draw</code> auf einer <code>SelectBox</code>-Struktur implementiert</span></p>
<p>Der Benutzer unserer Bibliothek kann nun seine Funktion <code>main</code> schreiben, um
eine <code>Screen</code>-Instanz zu erzeugen. Der <code>Screen</code>-Instanz kann er eine
<code>SelectBox</code> und einen <code>Button</code> hinzufügen, indem er jede in eine <code>Box&lt;T&gt;</code>
setzt, um ein Merkmalsobjekt zu werden. Er kann dann die <code>run</code>-Methode auf der
<code>Screen</code>-Instanz aufrufen, die dann <code>draw</code> auf jeder der Komponenten aufruft.
Der Codeblock 17-9 zeigt diese Umsetzung:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // Code zum tatsächlichen Zeichnen eines Auswahlfeldes
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Ja&quot;),
                    String::from(&quot;Vielleicht&quot;),
                    String::from(&quot;Nein&quot;),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Codeblock 17-9: Verwenden von Merkmalsobjekten zum
Speichern von Werten verschiedener Typen, die das gleiche Merkmal
implementieren</span></p>
<p>Als wir die Bibliothek schrieben, wussten wir nicht, dass jemand den Typ
<code>SelectBox</code> hinzufügen könnte, aber unsere <code>Screen</code>-Implementierung war in der
Lage, mit dem neuen Typ umzugehen und ihn zu zeichnen, weil <code>SelectBox</code> das
Merkmal <code>Draw</code> implementiert, was bedeutet, dass sie die <code>draw</code>-Methode
implementiert.</p>
<p>Dieses Konzept – sich nur mit den Nachrichten zu befassen, auf die ein
Wert reagiert, und nicht mit dem konkreten Typ des Wertes – ähnelt dem
Konzept des <em>Duck-Typing</em> in dynamisch typisierten Sprachen: Wenn es wie eine
Ente läuft und wie eine Ente quakt, dann muss es eine Ente sein! Bei der
Implementierung von <code>run</code> auf <code>Screen</code> in Codeblock 17-5 braucht <code>run</code> nicht zu
wissen, was der konkrete Typ jeder Komponente ist. Es prüft nicht, ob eine
Komponente eine Instanz eines <code>Buttons</code> oder einer <code>SelectBox</code> ist, es ruft nur
die <code>draw</code>-Methode auf der Komponente auf. Durch die Spezifikation von
<code>Box&lt;dyn Draw&gt;</code> als Typ der Werte im <code>components</code>-Vektor haben wir <code>Screen</code> so
definiert, dass wir Werte benötigen, auf denen wir die <code>draw</code>-Methode aufrufen
können.</p>
<p>Der Vorteil der Verwendung von Merkmalsobjekten und des Rust-Typsystems zum
Schreiben von Code, der dem Code mit Duck-Typing ähnelt, besteht darin, dass
wir nie prüfen müssen, ob ein Wert eine bestimmte Methode zur Laufzeit
implementiert, oder uns Sorgen machen müssen, Fehler zu bekommen, wenn ein Wert
eine Methode nicht implementiert, wir sie aber trotzdem aufrufen. Rust wird
unseren Code nicht kompilieren, wenn die Werte nicht die Merkmale
implementieren, die die Merkmalsobjekte benötigen.</p>
<p>Beispielsweise zeigt Codeblock 17-10, was passiert, wenn wir versuchen, einen
<code>Screen</code> mit einem <code>String</code> als Komponente zu erstellen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from(&quot;Hallo&quot;))],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Codeblock 17-10: Versuch, einen Typ zu verwenden, der das
Merkmal des Merkmalsobjekts nicht implementiert</span></p>
<p>Wir werden diesen Fehler erhalten, weil <code>String</code> das Merkmal <code>Draw</code> nicht
implementiert:</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from(&quot;Hallo&quot;))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = note: required for the cast to the object type `dyn Draw`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` due to previous error
</code></pre>
<p>Dieser Fehler lässt uns wissen, dass wir entweder etwas an <code>Screen</code> übergeben,
das wir nicht übergeben wollten und einen anderen Typ übergeben sollten, oder
wir sollten <code>Draw</code> auf <code>String</code> implementieren, sodass <code>Screen</code> in der Lage
ist, <code>Draw</code> darauf aufzurufen.</p>
<h3 id="merkmalsobjekte-führen-dynamischen-aufruf-durch"><a class="header" href="#merkmalsobjekte-führen-dynamischen-aufruf-durch">Merkmalsobjekte führen dynamischen Aufruf durch</a></h3>
<p>Erinnere dich im Abschnitt <a href="ch10-01-syntax.html#code-performanz-beim-verwenden-generischer-datentypen">„Code-Performanz beim Verwenden generischer
Datentypen“</a> in Kapitel 10 an unsere
Diskussion über den Monomorphisierungsprozess, den der Compiler durchführt,
wenn wir bei generischen Typen Merkmalsabgrenzungen verwenden: Der Compiler
generiert nicht-generische Implementierungen von Funktionen und Methoden für
jeden konkreten Typ, den wir anstelle eines generischen Typparameters
verwenden. Der Code, der sich aus der Monomorphisierung ergibt, macht
<em>statische Aufrufe</em> (static dispatch), d.h. wenn der Compiler weiß, welche
Methode du zur Kompilierzeit aufrufst. Dies steht im Gegensatz zum <em>dynamischen
Aufruf</em> (dynamic dispatch), bei dem der Compiler zur Kompilierzeit nicht weiß,
welche Methode du aufrufst. In Fällen von dynamischem Aufruf erzeugt der
Compiler Code, der zur Laufzeit herausfindet, welche Methode aufzurufen ist.</p>
<p>Wenn wir Merkmalsobjekte verwenden, muss Rust dynamische Aufrufe verwenden. Der
Compiler kennt nicht alle Typen, die mit dem Code verwendet werden könnten, der
Merkmalsobjekte verwendet, sodass er nicht weiß, welche Methode auf welchem Typ
implementiert ist, um sie aufzurufen. Stattdessen verwendet Rust zur Laufzeit
die Zeiger innerhalb des Merkmalsobjekts, um zu wissen, welche Methode
aufgerufen werden soll. Dieses Nachschlagen verursacht Laufzeitkosten, die
beim statischen Aufruf nicht anfallen. Der dynamische Aufruf verhindert auch,
dass der Compiler sich dafür entscheiden kann, den Code einer Methode inline zu
verwenden, was wiederum einige Optimierungen verhindert. Wir haben jedoch
zusätzliche Flexibilität im Code erhalten, den wir in Codeblock 17-5
geschrieben haben und in Codeblock 17-9 unterstützen konnten, sodass es sich um
einen Kompromiss handelt, den es zu berücksichtigen gilt.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ein-objektorientiertes-entwurfsmuster-implementieren"><a class="header" href="#ein-objektorientiertes-entwurfsmuster-implementieren">Ein objektorientiertes Entwurfsmuster implementieren</a></h2>
<p>Das <em>Zustandsmuster</em> (state pattern) ist ein objektorientiertes Entwurfsmuster.
Der Kernpunkt des Musters besteht darin, dass wir eine Reihe von Zuständen
definieren, die ein Wert intern annehmen kann. Die Zustände werden durch eine
Reihe von <em>Zustandsobjekten</em> (state objects) dargestellt, und das Verhalten des
Wertes ändert sich je nach Zustand. Wir werden ein Beispiel für eine
Blog-Post-Struktur durcharbeiten, die ein Feld für ihren Status hat, das ein
Statusobjekt mit den Möglichkeiten „Entwurf“, „Überprüfung“ und
„Veröffentlicht“ sein wird.</p>
<p>Die Zustandsobjekte haben eine gemeinsame Funktionalität: In Rust verwenden wir
Strukturen (structs) und Merkmale (traits) und nicht Objekte und Vererbung.
Jedes Zustandsobjekt ist für sein eigenes Verhalten verantwortlich und
bestimmt, wann es in einen anderen Zustand übergehen soll. Der Wert, den ein
Zustandsobjekt enthält, weiß nichts über das unterschiedliche Verhalten der
Zustände oder den Zeitpunkt des Übergangs zwischen den Zuständen.</p>
<p>Der Vorteil der Verwendung des Zustandsmusters besteht darin, dass wir, wenn
sich die geschäftlichen Anforderungen des Programms ändern, weder den Code des
Werts, der den Zustand hält, noch den Code, der den Wert verwendet, ändern
müssen. Wir müssen nur den Code in einem der Zustandsobjekte aktualisieren, um
seine Regeln zu ändern oder vielleicht weitere Zustandsobjekte hinzuzufügen.</p>
<p>Zunächst werden wir das Zustandsmuster auf eine traditionellere
objektorientierte Weise implementieren, dann werden wir einen Ansatz verwenden,
der in Rust etwas natürlicher ist. Beginnen wir mit der inkrementellen
Implementierung eines Blogpost-Workflows unter Verwendung des Zustandsmusters.</p>
<p>Die finale Funktionalität des Blogs wird wie folgt aussehen:</p>
<ol>
<li>Ein Blog-Beitrag (post) beginnt als leerer Entwurf.</li>
<li>Wenn der Entwurf fertig ist, wird um eine Überprüfung des Beitrags gebeten.</li>
<li>Wenn der Beitrag genehmigt ist, wird er veröffentlicht.</li>
<li>Nur veröffentlichte Blog-Beiträge geben anzuzeigenden Inhalt zurück, sodass
nicht genehmigte Beiträge nicht versehentlich veröffentlicht werden können.</li>
</ol>
<p>Alle anderen Änderungen, die an einem Beitrag versucht werden, sollten keine
Auswirkungen haben. Wenn wir zum Beispiel versuchen, den Entwurf eines
Blog-Beitrags zu genehmigen, bevor wir eine Überprüfung beantragt haben, sollte
der Beitrag ein unveröffentlichter Entwurf bleiben.</p>
<p>Codeblock 17-11 zeigt diesen Workflow in Codeform: Dies ist eine
Beispielverwendung der API, die wir in einer Bibliothekskiste (library crate)
<code>blog</code> implementieren werden. Dieser Code wird sich noch nicht kompilieren
lassen, da wir die Kiste (crate) <code>blog</code> noch nicht implementiert haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;Ich habe heute Mittag einen Salat gegessen&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;Ich habe heute Mittag einen Salat gegessen&quot;, post.content());
}</code></pre>
<p><span class="caption">Codeblock 17-11: Code, der das gewünschte Verhalten
demonstriert, das wir für unsere Kiste <code>blog</code> haben wollen</span></p>
<p>Wir möchten dem Benutzer erlauben, einen neuen Entwurf eines Blog-Beitrags mit
<code>Post::new</code> zu erstellen. Wir möchten dem Blog-Beitrag erlauben, Text
hinzuzufügen. Wenn wir versuchen, den Inhalt des Beitrags sofort, also vor der
Genehmigung, abzurufen, sollten wir keinen Text erhalten, da der Beitrag noch
ein Entwurf ist. Wir haben zu Demonstrationszwecken <code>assert_eq!</code> in den Code
eingefügt. Ein ausgezeichneter Modultest dafür wäre die Zusicherung, dass ein
Entwurf eines Blog-Beitrags eine leere Zeichenkette aus der Methode <code>content</code>
zurückgibt, aber wir werden für dieses Beispiel keine Tests schreiben.</p>
<p>Als nächstes wollen wir einen Antrag auf Überprüfung des Beitrags ermöglichen
und wir wollen, dass <code>content</code> eine leere Zeichenkette zurückgibt, solange wir
auf die Überprüfung warten. Wenn der Beitrag die Genehmigung erhält, soll er
veröffentlicht werden, d.h. der Text des Beitrags wird zurückgegeben, wenn
<code>content</code> aufgerufen wird.</p>
<p>Beachte, dass der einzige Typ, mit dem wir von der Kiste aus interagieren, der
<code>Post</code>-Typ ist. Dieser Typ verwendet das Zustandsmuster und enthält einen Wert,
der eines von drei Zustandsobjekten ist, die die verschiedenen Zustände
repräsentieren, in denen sich ein Beitrag im Entwurf befinden, auf eine
Überprüfung warten oder veröffentlicht werden kann. Der Wechsel von einem
Zustand in einen anderen wird intern innerhalb des <code>Post</code>-Typs verwaltet. Die
Zustände ändern sich als Reaktion auf die Methoden, die von den Benutzern
unserer Bibliothek auf der <code>Post</code>-Instanz aufgerufen werden, aber sie müssen
die Zustandsänderungen nicht direkt verwalten. Auch können die Benutzer keinen
Fehler mit den Zuständen machen, z.B. einen Beitrag veröffentlichen, bevor er
überprüft wurde.</p>
<h3 id="definieren-von-post-und-erstellen-einer-neuen-instanz-im-entwurfszustand"><a class="header" href="#definieren-von-post-und-erstellen-einer-neuen-instanz-im-entwurfszustand">Definieren von <code>Post</code> und Erstellen einer neuen Instanz im Entwurfszustand</a></h3>
<p>Fangen wir mit der Implementierung der Bibliothek an! Wir wissen, dass wir eine
öffentliche Struktur <code>Post</code> benötigen, die einige Inhalte enthält, also
beginnen wir mit der Definition der Struktur und einer zugehörigen öffentlichen
Funktion <code>new</code>, um eine Instanz von <code>Post</code> zu erzeugen, wie in Codeblock 17-12
gezeigt. Wir werden auch ein privates Merkmal <code>State</code> erstellen, das das
Verhalten definiert, das alle Zustandsobjekte für einen <code>Post</code> haben müssen.</p>
<p>Dann wird <code>Post</code> ein Merkmalsobjekt (trait object) von <code>Box&lt;dyn State&gt;</code>
innerhalb einer <code>Option&lt;T&gt;</code> in einem privaten Feld namens <code>state</code> halten, um
das Zustandsobjekt zu halten. Du wirst gleich sehen, warum die <code>Option&lt;T&gt;</code>
notwendig ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-12: Definition einer Struktur <code>Post</code> und
einer Funktion <code>new</code>, die eine neue <code>Post</code>-Instanz erzeugt, einem Merkmal
<code>State</code> und einer Struktur <code>Draft</code></span></p>
<p>Das Merkmal <code>State</code> definiert das Verhalten, das die verschiedenen
Beitragszustände gemeinsam haben. Die Zustandsobjekte sind <code>Draft</code>,
<code>PendingReview</code> und <code>Published</code> und sie werden alle das Merkmal <code>State</code>
implementieren. Im Moment hat das Merkmal noch keine Methoden und wir werden
damit beginnen, nur den Zustand <code>Draft</code> zu definieren, weil das der Zustand
ist, in dem ein Beitrag beginnen soll.</p>
<p>Wenn wir einen neuen <code>Post</code> erstellen, setzen wir sein <code>state</code>-Feld auf einen
<code>Some</code>-Wert, der eine <code>Box</code> enthält. Diese <code>Box</code> verweist auf eine neue Instanz
der Struktur <code>Draft</code>. Dies stellt sicher, dass jedes Mal, wenn wir eine neue
Instanz von <code>Post</code> erzeugen, diese als Entwurf beginnt. Da das Feld <code>state</code> von
<code>Post</code> privat ist, gibt es keine Möglichkeit, einen <code>Post</code> in einem anderen
Zustand zu erzeugen! In der Funktion <code>Post::new</code> setzen wir das Feld <code>content</code>
auf einen neuen, leeren <code>String</code>.</p>
<h3 id="speichern-des-textes-des-beitragsinhalts"><a class="header" href="#speichern-des-textes-des-beitragsinhalts">Speichern des Textes des Beitragsinhalts</a></h3>
<p>Wir haben in Codeblock 17-11 gesehen, dass wir in der Lage sein wollen, eine
Methode namens <code>add_text</code> aufzurufen und ihr einen <code>&amp;str</code> zu übergeben, die
dann als Textinhalt des Blog-Beitrags hinzugefügt wird. Wir implementieren dies
als Methode, anstatt das Feld <code>content</code> mit <code>pub</code> offenzulegen, damit wir
später eine Methode implementieren können, die steuert, wie die Daten des
Feldes <code>content</code> gelesen werden. Die Methode <code>add_text</code> ist ziemlich einfach,
also lass uns die Implementierung in Codeblock 17-13 zum Block <code>impl Post</code>
hinzufügen:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<p><span class="caption">Codeblock 17-13: Implementierung der Methode <code>add_text</code>
zum Hinzufügen von Text zum <code>content</code> eines Beitrags</span></p>
<p>Die Methode <code>add_text</code> nimmt eine veränderbare Referenz auf <code>self</code>, weil wir
die <code>Post</code>-Instanz, auf der wir <code>add_text</code> aufrufen, ändern. Dann rufen wir
<code>push_str</code> auf den <code>String</code> in <code>content</code> auf und übergeben das Argument <code>text</code>,
um es zum gespeicherten <code>content</code> hinzuzufügen. Dieses Verhalten hängt nicht
vom Zustand ab, in dem sich der Beitrag befindet, es ist also nicht Teil des
Zustandsmusters. Die Methode <code>add_text</code> interagiert überhaupt nicht mit dem
Feld <code>state</code>, aber sie ist Teil des Verhaltens, das wir unterstützen wollen.</p>
<h3 id="sicherstellen-dass-der-inhalt-eines-beitragsentwurfs-leer-ist"><a class="header" href="#sicherstellen-dass-der-inhalt-eines-beitragsentwurfs-leer-ist">Sicherstellen, dass der Inhalt eines Beitragsentwurfs leer ist</a></h3>
<p>Selbst nachdem wir <code>add_text</code> aufgerufen und unserem Beitrag etwas Inhalt
hinzugefügt haben, wollen wir immer noch, dass die Methode <code>content</code> einen
leeren Zeichenkettenanteilstyp (string slice) zurückgibt, weil sich der Beitrag
noch im Entwurfszustand befindet, wie in Zeile 7 von Codeblock 17-11 gezeigt
wird. Lass uns fürs Erste die <code>content</code>-Methode mit der einfachsten Sache
implementieren, die diese Anforderung erfüllt: Immer einen leeren
Zeichenkettenanteilstyp zurückgeben. Wir werden dies später ändern, sobald wir
die Möglichkeit implementiert haben, den Zustand eines Beitrags zu ändern,
damit er veröffentlicht werden kann. Bislang können Beiträge nur im
Entwurfszustand sein, daher sollte der Beitragsinhalt immer leer sein.
Codeblock 17-14 zeigt diese Platzhalter-Implementierung:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<p><span class="caption">Codeblock 17-14: Hinzufügen einer
Platzhalter-Implementierung für die <code>content</code>-Methode auf <code>Post</code>, die immer
einen leeren Zeichenkettenanteilstyp zurückgibt</span></p>
<p>Mit dieser zusätzlichen Methode <code>content</code> funktioniert alles in Codeblock 17-11
bis hin zu Zeile 7 wie beabsichtigt.</p>
<h3 id="antrag-auf-Überprüfung-des-beitrags-ändert-seinen-zustand"><a class="header" href="#antrag-auf-Überprüfung-des-beitrags-ändert-seinen-zustand">Antrag auf Überprüfung des Beitrags ändert seinen Zustand</a></h3>
<p>Als nächstes müssen wir eine Funktionalität hinzufügen, um eine Überprüfung
eines Beitrags zu beantragen, die seinen Zustand von <code>Draft</code> in <code>PendingReview</code>
ändern sollte. Codeblock 17-15 zeigt diesen Code:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<p><span class="caption">Codeblock 17-15: Implementierung der Methoden
<code>request_review</code> für <code>Post</code> und des Merkmals <code>State</code></span></p>
<p>Wir geben <code>Post</code> eine öffentliche Methode namens <code>request_review</code>, die eine
veränderbare Referenz auf <code>self</code> nimmt. Dann rufen wir eine interne
<code>request_review</code>-Methode über den aktuellen Zustand von <code>Post</code> auf und diese
zweite <code>request_review</code>-Methode konsumiert den aktuellen Zustand und gibt einen
neuen Zustand zurück.</p>
<p>Wir fügen die Methode <code>request_review</code> zum Merkmal <code>State</code> hinzu; alle Typen,
die das Merkmal implementieren, müssen nun die Methode <code>request_review</code>
implementieren. Beachte, dass wir statt <code>self</code>, <code>&amp;self</code> oder <code>&amp;mut self</code> als
ersten Parameter der Methode <code>self: Box&lt;Self&gt;</code> haben. Diese Syntax bedeutet,
dass die Methode nur gültig ist, wenn sie auf einer <code>Box</code> mit dem Typ
aufgerufen wird. Diese Syntax übernimmt die Eigentümerschaft von <code>Box&lt;Self&gt;</code>,
wodurch der alte Zustand ungültig wird, sodass der Zustandswert von <code>Post</code> in
einen neuen Zustand transformiert werden kann.</p>
<p>Um den alten Zustand zu konsumieren, muss die <code>request_review</code>-Methode die
Eigentümerschaft des Zustandswerts übernehmen. Hier kommt die <code>Option</code> im Feld
<code>state</code> von <code>Post</code> ins Spiel: Wir rufen die Methode <code>take</code> auf, um den
<code>Some</code>-Wert aus dem <code>state</code>-Feld zu nehmen und an seiner Stelle ein <code>None</code> zu
hinterlassen, weil Rust es nicht zulässt, dass wir unbestückte Felder in
Strukturen haben. Dadurch können wir den Wert <code>state</code> aus <code>Post</code> herausnehmen,
anstatt ihn auszuleihen. Dann setzen wir den Wert <code>state</code> des Beitrags auf das
Ergebnis dieser Operation.</p>
<p>Wir müssen <code>state</code> vorübergehend auf <code>None</code> setzen, anstatt es direkt mit Code
wie <code>self.state = self.state.request_review();</code> zu setzen, um die
Eigentümerschaft des <code>state</code>-Wertes zu erhalten. Das stellt sicher, dass <code>Post</code>
nicht den alten <code>state</code>-Wert verwenden kann, nachdem wir ihn in einen neuen
Zustand transformiert haben.</p>
<p>Die Methode <code>request_review</code> auf <code>Draft</code> gibt eine neue, in einer Box
gespeicherte Instanz einer neuen <code>PendingReview</code>-Struktur zurück, die den
Zustand darstellt, in dem ein Beitrag auf eine Überprüfung wartet. Die Struktur
<code>PendingReview</code> implementiert auch die Methode <code>request_review</code>, führt aber
keine Transformationen durch. Vielmehr gibt sie sich selbst zurück, denn wenn
wir eine Überprüfung für einen Beitrag anfordern, der sich bereits im
<code>PendingReview</code>-Zustand befindet, sollte er im <code>PendingReview</code>-Zustand bleiben.</p>
<p>Jetzt können wir anfangen, die Vorteile des Zustandsmusters zu erkennen: Die
Methode <code>request_review</code> auf <code>Post</code> ist die gleiche, unabhängig von ihrem
<code>state</code>-Wert. Jeder Zustand ist für seine eigenen Regeln verantwortlich.</p>
<p>Wir lassen die Methode <code>content</code> auf <code>Post</code> so wie sie ist und geben einen
leeren Zeichenkettenanteilstyp zurück. Wir können jetzt einen <code>Post</code> sowohl im
Zustand <code>PendingReview</code> als auch im Zustand <code>Draft</code> haben, aber wir wollen das
gleiche Verhalten im Zustand <code>PendingReview</code>. Codeblock 17-11 funktioniert
jetzt bis Zeile 10!</p>
<h3 id="hinzufügen-von-approve-um-das-verhalten-von-content-zu-ändern"><a class="header" href="#hinzufügen-von-approve-um-das-verhalten-von-content-zu-ändern">Hinzufügen von <code>approve</code>, um das Verhalten von <code>content</code> zu ändern</a></h3>
<p>Die Methode <code>approve</code> ähnelt der Methode <code>request_review</code>: Sie setzt den
<code>state</code> auf den Wert, den der aktuelle Zustand nach der Genehmigung haben
sollte, wie in Codeblock 17-16 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --abschneiden--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --abschneiden--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-16: Implementierung der Methode <code>approve</code>
bei <code>Post</code> und des Merkmals <code>State</code></span></p>
<p>Wir fügen die Methode <code>approve</code> zum Merkmal <code>State</code> hinzu und fügen eine neue
Struktur <code>State</code> hinzu, die den Zustand <code>Published</code> implementiert.</p>
<p>Ähnlich wie <code>request_review</code> bei <code>PendingReview</code> funktioniert, hat der Aufruf
der Methode <code>approve</code> bei einem <code>Draft</code> keine Wirkung, weil <code>approve</code> den Wert
<code>self</code> zurückgibt. Wenn wir die Methode <code>approve</code> bei <code>PendingReview</code> aufrufen,
gibt sie eine neue, geschlossene Instanz der Struktur <code>Published</code> zurück. Die
Struktur <code>Published</code> implementiert das Merkmal <code>State</code> und sowohl bei der
Methode <code>request_review</code> als auch bei der Methode <code>approve</code> gibt sie sich
selbst zurück, weil der Beitrag in diesen Fällen im Zustand <code>Published</code> bleiben
sollte.</p>
<p>Jetzt müssen wir die Methode <code>content</code> auf <code>Post</code> aktualisieren: Wir wollen,
dass der von <code>content</code> zurückgegebene Wert vom aktuellen Zustand von <code>Post</code>
abhängt, also delegieren wir <code>Post</code> an eine <code>content</code>-Methode, die auf seinen
<code>state</code> definiert ist, wie in Codeblock 17-17 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-17: Aktualisieren der Methode <code>content</code> auf
<code>Post</code> zum Delegieren an eine Methode <code>content</code> auf <code>State</code></span></p>
<p>Da das Ziel darin besteht, all diese Regeln innerhalb der Strukturen zu halten,
die <code>State</code> implementieren, rufen wir eine Methode <code>content</code> auf dem Wert in
<code>state</code> auf und übergeben die Post-Instanz (d.h. <code>self</code>) als Argument. Dann
geben wir den Wert zurück, der von der Verwendung der Methode <code>content</code> für den
<code>state</code>-Wert zurückgegeben wird.</p>
<p>Wir rufen die Methode <code>as_ref</code> auf <code>Option</code> auf, weil wir eine Referenz auf den
Wert innerhalb <code>Option</code> wollen und nicht die Eigentümerschaft am Wert. Weil
<code>State</code> eine <code>Option&lt;Box&lt;dyn State&gt;&gt;</code> ist, wird beim Aufruf von <code>as_ref</code> eine
<code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> zurückgegeben. Würden wir nicht <code>as_ref</code> aufrufen,
bekämen wir einen Fehler, weil wir <code>state</code> nicht aus dem ausgeliehenen <code>&amp;self</code>
im Funktionsparameter herausverschieben können.</p>
<p>Wir rufen dann die <code>unwrap</code>-Methode auf, von der wir wissen, dass sie das
Programm niemals abstürzen lassen wird, weil wir wissen, dass die Methoden auf
<code>Post</code> sicherstellen, dass <code>state</code> stets einen <code>Some</code>-Wert enthält, wenn diese
Methoden zu Ende sind. Dies ist einer der Fälle, über die wir im Abschnitt
<a href="ch09-03-to-panic-or-not-to-panic.html#f%C3%A4lle-in-denen-du-mehr-informationen-als-der-compiler-hast">„Fälle, in denen du mehr Informationen als der Compiler
hast“</a> in Kapitel 9 gesprochen haben, wenn wir wissen,
dass ein <code>None</code>-Wert niemals möglich ist, obwohl der Compiler nicht in der Lage
ist, das zu verstehen.</p>
<p>Wenn wir nun <code>content</code> auf der <code>&amp;Box&lt;dyn State&gt;</code> aufrufen, wird eine
automatische Umwandlung (deref coercion) auf <code>&amp;</code> und <code>Box</code> stattfinden, sodass
die <code>content</code>-Methode letztlich auf dem Typ aufgerufen wird, der das Merkmal
<code>State</code> implementiert. Das bedeutet, dass wir die Definition des Merkmals
<code>State</code> um <code>content</code> erweitern müssen, und hier werden wir die Logik dafür
unterbringen, welcher Inhalt je nach Zustand zurückgegeben wird, wie in
Codeblock 17-18 gezeigt wird:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --abschneiden--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --abschneiden--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --abschneiden--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-18: Hinzufügen der Methode <code>content</code> zum
Merkmal <code>State</code></span></p>
<p>Wir fügen eine Standard-Implementierung für die Methode <code>content</code> hinzu, die
einen leeren Zeichenkettenanteilstyp zurückgibt. Das bedeutet, dass wir
<code>content</code> in den Strukturen <code>Draft</code> und <code>PendingReview</code> nicht implementieren
müssen. Die Struktur <code>Published</code> überschreibt die Methode <code>content</code> und gibt
den Wert in <code>post.content</code> zurück.</p>
<p>Beachte, dass wir Lebensdauer-Annotationen bei dieser Methode benötigen, wie
wir in Kapitel 10 besprochen haben. Wir nehmen eine Referenz auf ein <code>post</code> als
Argument und geben eine Referenz auf einen Teil dieses <code>post</code> zurück, sodass
die Lebensdauer der zurückgegebenen Referenz mit der Lebensdauer des
<code>post</code>-Arguments zusammenhängt.</p>
<p>Und wir sind fertig – der Codeblock 17-11 funktioniert jetzt! Wir haben
das Zustandsmuster mit den Regeln des Blog-Beitrags-Workflows implementiert.
Die Logik, die sich auf die Regeln bezieht, lebt in den Zustandsobjekten und
ist nicht über den gesamten <code>Post</code> verstreut.</p>
<blockquote>
<h4 id="warum-nicht-eine-aufzählung"><a class="header" href="#warum-nicht-eine-aufzählung">Warum nicht eine Aufzählung?</a></h4>
<p>Vielleicht hast du dich gefragt, warum wir nicht ein <code>enum</code> mit den
verschiedenen möglichen Poststatus als Varianten verwendet haben. Das ist
sicherlich eine mögliche Lösung. Probiere es aus und vergleiche die
Endergebnisse, um zu sehen, was du bevorzugst! Ein Nachteil der Verwendung
einer Aufzählung ist, dass jede Stelle, die den Wert der Aufzählung prüft,
einen <code>match</code>-Ausdruck oder ähnliches benötigt, um jede mögliche Variante zu
behandeln. Dies könnte zu mehr Wiederholungen führen als die Lösung mit dem
Merkmals-Objekt.</p>
</blockquote>
<h3 id="kompromisse-des-zustandsmusters"><a class="header" href="#kompromisse-des-zustandsmusters">Kompromisse des Zustandsmusters</a></h3>
<p>Wir haben gezeigt, dass Rust in der Lage ist, das objektorientierte
Zustandsmuster zu implementieren, um die verschiedenen Verhaltensweisen, die
ein Beitrag im jeweiligen Zustand haben sollte, zu kapseln. Die Methoden auf
<code>Post</code> wissen nichts über die verschiedenen Verhaltensweisen. So, wie wir den
Code organisiert haben, müssen wir nur an einem einzigen Ort suchen, um zu
wissen, wie sich ein veröffentlichter Beitrag verhalten kann: Die
Implementierung des Merkmals <code>State</code> auf der Struktur <code>Published</code>.</p>
<p>Wenn wir eine alternative Implementierung erstellen würden, die nicht das
Zustandsmuster verwendet, könnten wir stattdessen <code>match</code>-Ausdrücke in den
Methoden auf <code>Post</code> oder sogar im <code>main</code>-Code verwenden, die den Zustand des
Beitrags überprüfen und das Verhalten an diesen Stellen ändern. Das würde
bedeuten, dass wir an mehreren Stellen nachschauen müssten, um alle
Auswirkungen eines Beitrags im veröffentlichten Zustand zu verstehen! Dies
würde sich nur noch erhöhen, je mehr Zustände wir hinzufügen: Jeder dieser
<code>match</code>-Ausdrücke würde einen weiteren Zweig benötigen.</p>
<p>Mit dem Zustandsmuster, den <code>Post</code>-Methoden und den Stellen, an denen wir
<code>Post</code> verwenden, brauchen wir keine <code>match</code>-Ausdrücke, und um einen neuen
Zustand hinzuzufügen, müssten wir nur eine neue Struktur hinzufügen und die
Merkmalsmethoden auf dieser einen Struktur implementieren.</p>
<p>Die Implementierung unter Verwendung des Zustandsmusters ist leicht zu
erweitern, um weitere Funktionalität hinzuzufügen. Um zu sehen, wie einfach es
ist, Code zu pflegen, der das Zustandsmuster verwendet, probiere einige dieser
Vorschläge aus:</p>
<ul>
<li>Füge eine <code>reject</code>-Methode hinzu, die den Zustand des Beitrags von
<code>PendingReview</code> zurück zu <code>Draft</code> ändert.</li>
<li>Verlange zwei <code>approve</code>-Aufrufe, bevor der Zustand in <code>Published</code> geändert
werden kann.</li>
<li>Erlaube Benutzern das Hinzufügen von Textinhalten nur dann, wenn sich ein
Beitrag im Zustand <code>Draft</code> befindet. Hinweis: Lasse das Zustandsobjekt dafür
verantwortlich sein, was sich am Inhalt ändern könnte, aber nicht für die
Änderung des Beitrags.</li>
</ul>
<p>Ein Nachteil des Zustandsmusters besteht darin, dass einige der Zustände
miteinander gekoppelt sind, weil die Zustände die Übergänge zwischen den
Zuständen implementieren. Wenn wir einen weiteren Zustand zwischen
<code>PendingReview</code> und <code>Published</code> hinzufügen, z.B. <code>Scheduled</code>, müssten wir den
Code in <code>PendingReview</code> ändern und stattdessen zu <code>Scheduled</code> übergehen. Es
wäre weniger Arbeit, wenn <code>PendingReview</code> nicht mit dem Hinzufügen eines neuen
Zustands geändert werden müsste, aber das würde bedeuten, zu einem anderen
Entwurfsmuster zu wechseln.</p>
<p>Ein weiterer Nachteil ist, dass wir eine gewisse Logik dupliziert haben. Um
einen Teil der Duplikation zu eliminieren, könnten wir versuchen,
Standard-Implementierungen für die Methoden <code>request_review</code> und <code>approval</code> für
das Merkmal <code>State</code> zu erstellen, die <code>self</code> zurückgeben; dies würde jedoch die
Objektsicherheit verletzen, da das Merkmal nicht weiß, was das konkrete <code>self</code>
genau sein wird. Wir wollen in der Lage sein, <code>State</code> als Merkmalsobjekt zu
verwenden, deshalb müssen seine Methoden objektsicher sein.</p>
<p>Eine weitere Duplikation sind die ähnlichen Implementierungen der Methoden
<code>request_review</code> und <code>approve</code> auf <code>Post</code>. Beide Methoden delegieren die
Implementierung der gleichen Methode auf den Wert im Feld <code>state</code> von <code>Option</code>
und setzen den neuen Wert des Feldes <code>state</code> auf das Ergebnis. Wenn wir eine
Menge Methoden auf <code>Post</code> hätten, die diesem Muster folgen, könnten wir in
Erwägung ziehen, ein Makro zu definieren, um die Wiederholung zu eliminieren
(siehe den Abschnitt <a href="ch19-06-macros.html">„Makros“</a> in Kapitel 19).</p>
<p>Indem wir das Zustandsmuster genau so implementieren, wie es für
objektorientierte Sprachen definiert ist, nutzen wir die Stärken Rusts nicht so
aus, wie wir es könnten. Sehen wir uns einige Änderungen an, die wir an der
Kiste <code>blog</code> vornehmen können, die ungültige Zustände und Übergänge in
Kompilierzeitfehler verwandeln können.</p>
<h4 id="kodieren-von-zuständen-und-verhalten-als-typen"><a class="header" href="#kodieren-von-zuständen-und-verhalten-als-typen">Kodieren von Zuständen und Verhalten als Typen</a></h4>
<p>Wir werden dir zeigen, wie du das Zustandsmuster überdenken kannst, um andere
Kompromisse zu erzielen. Anstatt die Zustände und Übergänge vollständig zu
kapseln, sodass Außenstehende keine Kenntnis von ihnen haben, werden wir die
Zustände in verschiedene Typen kodieren. Folglich wird Rusts
Typprüfungssystem Versuche verhindern, Entwurfsbeiträge zu verwenden, bei denen
nur veröffentlichte Beiträge erlaubt sind, indem ein Kompilierfehler ausgegeben
wird.</p>
<p>Betrachten wir den ersten Teil von <code>main</code> in Codeblock 17-11:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text(&quot;Ich habe heute Mittag einen Salat gegessen&quot;);
    assert_eq!(&quot;&quot;, post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!(&quot;&quot;, post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!(&quot;Ich habe heute Mittag einen Salat gegessen&quot;, post.content());
</span>}</code></pre>
<p>Wir ermöglichen nach wie vor das Erstellen neuer Beiträge im Entwurfsstadium
unter Verwendung von <code>Post::new</code> und der Möglichkeit, dem Inhalt des Beitrags
Text hinzuzufügen. Aber anstatt eine <code>content</code>-Methode bei einem
Beitragsentwurf zu haben, die eine leere Zeichenkette zurückgibt, werden wir
es so einrichten, dass Beitragsentwürfe überhaupt keine <code>content</code>-Methode
haben. Wenn wir auf diese Weise versuchen, den Inhalt eines Beitragsentwurfs
zu erhalten, erhalten wir einen Kompilierfehler, der uns sagt, dass die Methode
nicht existiert. Infolgedessen wird es für uns unmöglich, versehentlich den
Inhalt eines Beitragsentwurfs in der Produktion anzuzeigen, weil sich dieser
Code nicht einmal kompilieren lässt. Codeblock 17-19 zeigt die Definition einer
Struktur <code>Post</code> und einer Struktur <code>DraftPost</code> sowie die Methoden dieser
Strukturen:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-19: Ein <code>Post</code> mit einer Methode <code>content</code>
und ein <code>DraftPost</code> ohne Methode <code>content</code></span></p>
<p>Die beiden Strukturen <code>Post</code> und <code>DraftPost</code> haben ein privates Feld <code>content</code>,
in dem der Text des Blog-Beitrags gespeichert wird. Die Strukturen haben nicht
mehr das <code>state</code>-Feld, weil wir die Kodierung des Zustands auf die Typen der
Strukturen verlagert haben. Die Struktur <code>Post</code> wird einen veröffentlichten
Beitrag repräsentieren und sie hat eine Methode <code>content</code>, die den <code>content</code>
zurückgibt.</p>
<p>Wir haben immer noch die Funktion <code>Post::new</code>, aber anstatt eine Instanz von
<code>Post</code> zurückzugeben, gibt sie eine Instanz von <code>DraftPost</code> zurück. Da
<code>content</code> privat ist und es keine Funktion gibt, die <code>Post</code> zurückgibt, ist es
im Moment nicht möglich, eine Instanz von <code>Post</code> zu erzeugen.</p>
<p>Die Struktur <code>DraftPost</code> hat eine Methode <code>add_text</code>, sodass wir wie bisher
Text zum <code>content</code> hinzufügen können, aber beachte, dass <code>DraftPost</code> keine
Methode <code>content</code> definiert hat! Daher stellt das Programm jetzt sicher, dass
alle Beiträge als Beitragsentwürfe beginnen und dass der Inhalt von
Beitragsentwürfen nicht zur Anzeige verfügbar ist. Jeder Versuch, diese
Einschränkungen zu umgehen, führt zu einem Kompilierfehler.</p>
<h4 id="umsetzen-von-Übergängen-als-transformationen-in-verschiedene-typen"><a class="header" href="#umsetzen-von-Übergängen-als-transformationen-in-verschiedene-typen">Umsetzen von Übergängen als Transformationen in verschiedene Typen</a></h4>
<p>Wie bekommen wir also einen veröffentlichten Beitrag? Wir wollen die Regel
durchsetzen, dass ein Beitragsentwurf geprüft und genehmigt werden muss, bevor
er veröffentlicht werden kann. Ein Beitrag, der sich im Stadium der Überprüfung
befindet, sollte noch immer keinen Inhalt haben. Lass uns diese Bedingung
implementieren, indem wir eine weitere Struktur <code>PendingReviewPost</code> hinzufügen,
indem wir die Methode <code>request_review</code> auf <code>DraftPost</code> definieren, um einen
<code>PendingReviewPost</code> zurückzugeben, und eine Methode <code>approve</code> auf
<code>PendingReviewPost</code>, um einen <code>Post</code> zurückzugeben, wie in Codeblock 17-20
gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --abschneiden--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-20: Ein <code>PendingReviewPost</code>, der durch
Aufrufen von <code>request_review</code> auf <code>DraftPost</code> erzeugt wird, und eine
<code>approve</code>-Methode, die einen <code>PendingReviewPost</code> in einen veröffentlichten
<code>Post</code> verwandelt</span></p>
<p>Die Methoden <code>request_review</code> und <code>approve</code> übernehmen die Eigentümerschaft von
<code>self</code>, wodurch die Instanzen <code>DraftPost</code> und <code>PendingReviewPost</code> verbraucht
und in einen <code>PendingReviewPost</code> bzw. einen veröffentlichten <code>Post</code> umgewandelt
werden. Auf diese Weise werden wir keine <code>DraftPost</code>-Instanzen mehr haben,
nachdem wir <code>request_review</code> darauf aufgerufen haben, und so weiter. Die
<code>PendingReviewPost</code>-Struktur hat keine <code>content</code>-Methode definiert, sodass der
Versuch, ihren Inhalt zu lesen, zu einem Kompilierfehler führt, wie bei
<code>DraftPost</code>. Da der einzige Weg, eine veröffentlichte <code>Post</code>-Instanz zu
erhalten, die eine <code>content</code>-Methode definiert hat, der Aufruf der
<code>approve</code>-Methode auf einem <code>PendingReviewPost</code> ist, und der einzige Weg, einen
<code>PendingReviewPost</code> zu erhalten, der Aufruf der <code>request_review</code>-Methode auf
einem <code>DraftPost</code> ist, haben wir jetzt den Blog-Beitrags-Workflow in das
Typsystem kodiert.</p>
<p>Aber wir müssen auch einige kleine Änderungen an <code>main</code> vornehmen. Die Methoden
<code>request_review</code> und <code>approve</code> geben neue Instanzen zurück, anstatt die
Struktur, auf der sie aufgerufen werden, zu modifizieren, sodass wir mehr <code>let post =</code> Verschattungs-Zuweisungen (shadowing assignments) hinzufügen müssen, um
die zurückgegebenen Instanzen zu speichern. Wir können auch nicht zulassen,
dass die Zusicherungen über den Inhalt des Entwurfs und der anstehenden
Überprüfungsbeiträge leere Zeichenketten sind, und wir brauchen sie auch nicht:
Wir können keinen Code mehr kompilieren, der versucht, den Inhalt von Beiträgen
in diesen Zuständen zu verwenden. Der aktualisierte Code in <code>main</code> ist in
Codeblock 17-21 aufgeführt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;Ich habe heute Mittag einen Salat gegessen&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;Ich habe heute Mittag einen Salat gegessen&quot;, post.content());
}</code></pre>
<p><span class="caption">Codeblock 17-21: Änderungen an <code>main</code>, um die neue
Implementierung des Blog-Beitrags-Workflows zu nutzen</span></p>
<p>Die Änderungen, die wir an <code>main</code> vornehmen mussten, um <code>post</code> neu zuzuweisen,
bedeuten, dass diese Implementierung nicht mehr ganz dem objektorientierten
Zustandsmuster folgt: Die Transformationen zwischen den Zuständen sind nicht
mehr vollständig in der <code>Post</code>-Implementierung gekapselt. Unser Vorteil ist
jedoch, dass ungültige Zustände aufgrund des Typsystems und der Typprüfung, die
zur Kompilierzeit stattfindet, jetzt unmöglich sind! Dadurch wird
sichergestellt, dass bestimmte Fehler, z.B. das Anzeigen des Inhalts eines
unveröffentlichten Beitrags, entdeckt werden, bevor sie in die Produktion
gelangen.</p>
<p>Versuche es mit den Aufgaben, die wir zu Beginn dieses Abschnitts über die
Kiste <code>blog</code> nach Codeblock 17-20 erwähnt haben, um zu sehen, was du über das
Design dieser Version des Codes denkst. Beachte, dass einige der Aufgaben
möglicherweise bereits in diesem Entwurf abgeschlossen sind.</p>
<p>Wir haben gesehen, dass, obwohl Rust in der Lage ist, objektorientierte
Entwurfsmuster zu implementieren, auch andere Muster, z.B. das Kodieren des
Zustands in das Typsystem, in Rust verfügbar sind. Diese Muster weisen
unterschiedliche Kompromisse auf. Auch wenn du mit objektorientierten Mustern
sehr vertraut bist, kann ein Überdenken des Problems, um die Funktionen von
Rust zu nutzen, Vorteile bringen, z.B. das Vermeiden einiger Fehler zur
Kompilierzeit. Objektorientierte Muster werden in Rust nicht immer die beste
Lösung sein, da objektorientierte Sprachen bestimmte Funktionalitäten, z.B.
Eigentümerschaft, nicht haben.</p>
<h2 id="zusammenfassung-16"><a class="header" href="#zusammenfassung-16">Zusammenfassung</a></h2>
<p>Unabhängig davon, ob du nach der Lektüre dieses Kapitels der Meinung bist, dass
Rust eine objektorientierte Sprache ist oder nicht, weißt du jetzt, dass du
Merkmalsobjekte verwenden kannst, um einige objektorientierte Funktionalitäten
in Rust zu erhalten. Dynamische Aufrufe können deinem Code eine gewisse
Flexibilität im Austausch gegen ein wenig Laufzeitperformanz verleihen. Du
kannst diese Flexibilität nutzen, um objektorientierte Muster zu
implementieren, die die Wartbarkeit deines Codes verbessern können. Rust hat
auch andere Funktionalitäten, z.B. Eigentümerschaft, die objektorientierte
Sprachen nicht haben. Ein objektorientiertes Muster wird nicht immer der beste
Weg sein, um die Stärken von Rust zu nutzen, ist aber eine verfügbare Option.</p>
<p>Als nächstes werden wir uns mit Mustern befassen, die eine weitere
Funktionalität von Rust sind und viel Flexibilität ermöglichen. Wir haben sie
uns im Laufe des Buches kurz angeschaut, haben aber noch nicht ihre volle
Leistungsfähigkeit gesehen. Los geht's!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="muster-patterns-und-abgleich-matching"><a class="header" href="#muster-patterns-und-abgleich-matching">Muster (patterns) und Abgleich (matching)</a></h1>
<p><em>Muster</em> sind eine spezielle Syntax in Rust für den Abgleich mit der Struktur
von Typen, sowohl komplexen als auch einfachen Typen. Das Verwenden von Mustern
in Verbindung mit <code>match</code>-Ausdrücken und anderen Konstrukten gibt dir mehr
Kontrolle über den Kontrollfluss eines Programms. Ein Muster besteht aus einer
Kombination der folgenden Elemente:</p>
<ul>
<li>Literale</li>
<li>Destrukturierte Arrays, Aufzählungen (enums), Strukturen (structs) oder Tupel</li>
<li>Variablen</li>
<li>Wildcards</li>
<li>Platzhalter</li>
</ul>
<p>Einige Beispielmuster sind <code>x</code>, <code>(a, 3)</code>, und <code>Some(Color::Red)</code>. In den
Kontexten, in denen Muster gültig sind, beschreiben diese Komponenten die
Datenform. Unser Programm gleicht dann Werte mit den Mustern ab, um
festzustellen, ob es die richtige Datenform hat, um ein bestimmtes Stück Code
weiter auszuführen.</p>
<p>Um ein Muster zu verwenden, vergleichen wir es mit einem Wert. Wenn das Muster
zum Wert passt, verwenden wir die Wertteile in unserem Code. Erinnere dich an
die <code>match</code>-Ausdrücke in Kapitel 6, in denen Muster verwendet wurden, z.B. die
Münzsortiermaschine. Wenn der Wert zur Form des Musters passt, können wir die
genannten Teile verwenden. Wenn dies nicht der Fall ist, wird der mit dem
Muster verbundene Code nicht ausgeführt.</p>
<p>Dieses Kapitel ist eine Referenz zu allen Dingen, die mit Mustern zu tun haben.
Wir behandeln die gültigen Stellen, an denen Muster verwendet werden können,
den Unterschied zwischen abweisbaren (refutable) und unabweisbaren
(irrefutable) Mustern und die verschiedenen Arten der Mustersyntax, die du
sehen kannst. Am Ende des Kapitels wirst du wissen, wie du Muster verwenden
kannst, um viele Konzepte auf klare Weise auszudrücken.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="alle-stellen-an-denen-muster-patterns-verwendet-werden-können"><a class="header" href="#alle-stellen-an-denen-muster-patterns-verwendet-werden-können">Alle Stellen an denen Muster (patterns) verwendet werden können</a></h2>
<p>Muster tauchen an vielen Stellen in Rust auf und du hast sie oft benutzt, ohne
es zu merken! In diesem Abschnitt werden alle Stellen besprochen, an denen
Muster gültig sind.</p>
<h3 id="match-zweige"><a class="header" href="#match-zweige"><code>match</code>-Zweige</a></h3>
<p>Wie in Kapitel 6 besprochen, verwenden wir Muster in den Zweigen von
<code>match</code>-Ausdrücken. Formal werden <code>match</code>-Ausdrücke definiert mit dem
Schlüsselwort <code>match</code>, einem Wert, mit dem verglichen wird, und einem oder
mehreren <code>match</code>-Zweigen, die aus einem Muster und einem Ausdruck bestehen, der
ausgeführt wird, wenn der Wert zum Muster dieses Zweigs passt, wie hier:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>Hier ist zum Beispiel der <code>match</code>-Ausdruck aus Codeblock 6-5, der auf einen
<code>Option&lt;i32&gt;</code>-Wert in der Variablen <code>x</code> passt:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>Die Muster in diesem <code>match</code>-Ausdruck sind <code>None</code> und <code>Some(i)</code> links von jedem
Pfeil.</p>
<p>Eine Anforderung für <code>match</code>-Ausdrücke ist, dass sie <em>erschöpfend</em> (exhaustive)
in dem Sinne sein müssen, dass alle Möglichkeiten für den Wert im
<code>match</code>-Ausdruck berücksichtigt sein müssen. Ein Weg, um sicherzustellen, dass
alle Möglichkeiten abgedeckt sind, ist ein Sammel-Muster (catchall pattern) für
den letzten Zweig: Zum Beispiel kann ein Variablenname, der zu einem beliebigen
Wert passt, niemals fehlschlagen und deckt somit jeden verbleibenden Fall ab.</p>
<p>Das spezielle Muster <code>_</code> wird auf alles passen, aber es bindet nie an eine
Variable, daher wird es oft im letzten <code>match</code>-Zweig verwendet. Das Muster <code>_</code>
kann zum Beispiel nützlich sein, wenn du jeden nicht angegebenen Wert
ignorieren willst. Wir werden das Muster <code>_</code> im Abschnitt <a href="ch18-03-pattern-syntax.html#ignorieren-von-werten-in-einem-muster">„Ignorieren von
Werten in einem Muster“</a> später in diesem Kapitel
ausführlicher behandeln.</p>
<h3 id="bedingte-if-let-ausdrücke"><a class="header" href="#bedingte-if-let-ausdrücke">Bedingte <code>if let</code>-Ausdrücke</a></h3>
<p>In Kapitel 6 haben wir erörtert, wie man <code>if let</code>-Ausdrücke hauptsächlich als
kürzeren Weg verwendet, um das Äquivalent eines <code>match</code>-Ausdrucks zu schreiben,
der nur einen Fall prüft. Optional kann <code>if let</code> ein entsprechendes <code>else</code>
haben mit Code, der ausgeführt wird, wenn das Muster in <code>if let</code> nicht passt.</p>
<p>Codeblock 18-1 zeigt, dass es auch möglich ist, die Ausdrücke <code>if let</code>, <code>else if</code> und <code>else if let</code> zu mischen und anzupassen. Dies gibt uns mehr
Flexibilität als ein <code>match</code>-Ausdruck, in dem wir nur einen Wert zum Abgleich
mit den Mustern haben können. Auch erfordert Rust nicht, dass die Bedingungen
in einer Reihe von <code>if let</code>-, <code>else if</code>- und <code>else if let</code>-Zweigen sich
notwendigerweise aufeinander beziehen.</p>
<p>Der Code in Codeblock 18-1 bestimmt die Farbe des Hintergrunds auf der
Grundlage einer Reihe von Prüfungen mehrerer Bedingungen. Für dieses Beispiel
haben wir Variablen mit hartkodierten Werten erstellt, die ein reales Programm
von Benutzereingaben erhalten könnte.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Verwende deine Lieblingsfarbe {color} als Hintergrund&quot;);
    } else if is_tuesday {
        println!(&quot;Dienstag ist grüner Tag!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Verwende violett als Hintergrundfarbe&quot;);
        } else {
            println!(&quot;Verwende orange als Hintergrundfarbe&quot;);
        }
    } else {
        println!(&quot;Verwende blau als Hintergrundfarbe&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 18-1: Mischen von <code>if let</code>, <code>else if</code>, <code>else if let</code> und <code>else</code></span></p>
<p>Wenn der Benutzer eine Lieblingsfarbe angibt, ist diese Farbe die
Hintergrundfarbe. Wenn keine Lieblingsfarbe angegeben wurde und heute Dienstag
ist, ist die Hintergrundfarbe grün. Ansonsten, wenn der Benutzer sein Alter als
Zeichenkette angibt und wir es erfolgreich als Zahl parsen können, ist die
Farbe entweder violett oder orange, je nach dem Wert der Zahl. Wenn keine
dieser Bedingungen zutrifft, ist die Hintergrundfarbe blau.</p>
<p>Mit dieser bedingten Struktur können wir komplexe Anforderungen unterstützen.
Mit den hartkodierten Werten, die wir hier haben, wird dieses Beispiel
<code>Verwende violett als Hintergrundfarbe</code> ausgeben.</p>
<p>Du kannst sehen, dass <code>if let</code> auch verschattete Variablen (shadowed variables)
auf die gleiche Weise einführen kann wie bei <code>match</code>-Zweigen: Die Zeile <code>if let Ok(age) = age</code> führt eine neue verschattete Variable <code>age</code> ein, die den Wert
innerhalb der <code>Ok</code>-Variante enthält. Das bedeutet, dass wir die Bedingung <code>if age &gt; 30</code> innerhalb dieses Blocks platzieren müssen: Wir können diese beiden
Bedingungen nicht in <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code> kombinieren. Das
verschattete <code>age</code>, das wir mit 30 vergleichen wollen, ist erst gültig, wenn der
neue Gültigkeitsbereich mit der geschweiften Klammer beginnt.</p>
<p>Der Nachteil der Verwendung von <code>if let</code>-Ausdrücken ist, dass der Compiler die
Vollständigkeit nicht prüft, während er dies bei <code>match</code>-Ausdrücken tut. Wenn
wir den letzten <code>else</code>-Block weglassen und daher einige Fälle nicht behandelt
haben, würde uns der Compiler nicht auf den möglichen Logikfehler hinweisen.</p>
<h3 id="while-let-bedingte-schleifen"><a class="header" href="#while-let-bedingte-schleifen"><code>while let</code>-bedingte Schleifen</a></h3>
<p>Ähnlich konstruiert wie <code>if let</code> erlaubt die <code>while let</code>-bedingte Schleife,
dass eine <code>while</code>-Schleife so lange läuft, wie ein Muster weiterhin passt. In
Codeblock 18-2 haben wir eine <code>while let</code>-Schleife geschrieben, die einen
Vektor als Stapel (stack) verwendet und die Werte im Vektor in der umgekehrten
Reihenfolge ausgibt, in der sie auf den Stapel gelegt wurden.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!(&quot;{}&quot;, top);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-2: Das Verwenden einer <code>while let</code>-Schleife,
um Werte so lange auszugeben, wie <code>stack.pop()</code> ein <code>Some</code> zurückgibt</span></p>
<p>Dieses Beispiel gibt 3, 2 und 1 aus. Die <code>pop</code>-Methode nimmt das letzte Element
aus dem Vektor und gibt <code>Some(value)</code> zurück. Wenn der Vektor leer ist, gibt
<code>pop</code> den Wert <code>None</code> zurück. Die <code>while</code>-Schleife führt den Code in ihrem
Block so lange aus, wie <code>pop</code> ein <code>Some</code> zurückgibt. Wenn <code>pop</code> den Wert <code>None</code>
zurückgibt, stoppt die Schleife. Wir können <code>while let</code> benutzen, um jedes
Element von unserem Stapel zu holen.</p>
<h3 id="for-schleifen"><a class="header" href="#for-schleifen"><code>for</code>-Schleifen</a></h3>
<p>In einer <code>for</code>-Schleife ist der Wert, der direkt auf das Schlüsselwort <code>for</code>
folgt, ein Muster. Zum Beispiel ist in <code>for x in y</code> das <code>x</code> das Muster.
Codeblock 18-3 zeigt, wie man ein Muster in einer <code>for</code>-Schleife verwendet, um
ein Tupel als Teil der <code>for</code>-Schleife zu destrukturieren oder zu zerlegen.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!(&quot;{} ist beim Index {}&quot;, value, index);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-3: Verwenden eines Musters in einer
<code>for</code>-Schleife zum Destrukturieren eines Tupels</span></p>
<p>Der Code in Codeblock 18-3 wird Folgendes ausgeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a ist beim Index 0
b ist beim Index 1
c ist beim Index 2
</code></pre>
<p>Wir passen einen Iterator mit der Methode <code>enumerate</code> so an, dass er einen
Wert und den Index für diesen Wert erzeugt, die in einem Tupel abgelegt sind.
Der erste Aufruf von <code>enumerate</code> erzeugt das Tupel <code>(0, 'a')</code>. Wenn dieser Wert
zum Muster <code>(index, value)</code> passt, ist <code>index</code> gleich <code>0</code> und <code>value</code> gleich
<code>'a'</code>, wodurch die erste Zeile der Ausgabe ausgegeben wird.</p>
<h3 id="let-anweisungen"><a class="header" href="#let-anweisungen"><code>let</code>-Anweisungen</a></h3>
<p>Vor diesem Kapitel hatten wir das Verwenden von Mustern nur explizit mit
<code>match</code> und <code>if let</code> besprochen, aber tatsächlich haben wir Muster auch an
anderen Stellen verwendet, auch in <code>let</code>-Anweisungen. Betrachte zum Beispiel
diese einfache Variablenzuweisung mit <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Jedes Mal, wenn du eine <code>let</code>-Anweisung wie diese verwendet hast, hast du
Muster verwendet, auch wenn du es vielleicht nicht bemerkt hast! Formal sieht
eine <code>let</code>-Anweisung wie folgt aus:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>In Anweisungen wie <code>let x = 5;</code> mit einem Variablennamen an der Stelle
<code>PATTERN</code> ist der Variablenname nur eine besonders einfache Form eines Musters.
Rust vergleicht den Ausdruck mit dem Muster und weist alle gefundenen Namen zu.
Im Beispiel <code>let x = 5;</code> ist <code>x</code> also ein Muster, das bedeutet: „Binde das, was
hier passt, an die Variable <code>x</code>.“ Da der Name <code>x</code> das gesamte Muster ist,
bedeutet dieses Muster effektiv „Binde alles an die Variable <code>x</code>, was auch
immer der Wert ist.“.</p>
<p>Um den Aspekt des Musterabgleichs (pattern matching) von <code>let</code> deutlicher zu
sehen, betrachte Codeblock 18-4, der ein Muster mit <code>let</code> verwendet, um ein
Tupel zu destrukturieren.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-4: Verwenden eines Musters zum
Destrukturieren eines Tupels und zum gleichzeitigen Erzeugen von drei
Variablen</span></p>
<p>Hier vergleichen wir ein Tupel mit einem Muster. Rust vergleicht den Wert <code>(1, 2, 3)</code> mit dem Muster <code>(x, y, z)</code> und sieht, dass der Wert zum Muster passt,
also bindet Rust <code>1</code> an <code>x</code>, <code>2</code> an <code>y</code> und <code>3</code> an <code>z</code>. Man kann sich dieses
Tupelmuster als Verschachtelung von drei einzelnen Variablen-Mustern darin
vorstellen.</p>
<p>Wenn die Anzahl der Elemente im Muster nicht mit der Anzahl der Elemente im
Tupel übereinstimmt, passt der Gesamttyp nicht, und wir erhalten einen
Kompilierfehler. Beispielsweise zeigt Codeblock 18-5 einen Versuch, ein Tupel
mit drei Elementen in zwei Variablen zu destrukturieren, was nicht
funktioniert.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-5: Fehlerhaft aufgebautes Musters, dessen
Variablen nicht mit der Anzahl der Elemente im Tupel übereinstimmen</span></p>
<p>Der Versuch, diesen Code zu kompilieren, führt zu diesem Typfehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` due to previous error
</code></pre>
<p>Um den Fehler zu beheben, könnten wir einen oder mehrere der Werte im Tupel
mittels <code>_</code> oder <code>..</code> ignorieren, wie du im Abschnitt <a href="ch18-03-pattern-syntax.html#ignorieren-von-werten-in-einem-muster">„Ignorieren von Werten
in einem Muster“</a> sehen wirst. Wenn das Problem
darin besteht, dass wir zu viele Variablen im Muster haben, besteht die Lösung
darin, die Typen aufeinander abzustimmen, indem Variablen entfernt werden,
sodass die Anzahl der Variablen gleich der Anzahl der Elemente im Tupel ist.</p>
<h3 id="funktionsparameter"><a class="header" href="#funktionsparameter">Funktionsparameter</a></h3>
<p>Funktionsparameter können auch Muster sein. Der Code in Codeblock 18-6, der
eine Funktion namens <code>foo</code> deklariert, die einen Parameter namens <code>x</code> vom Typ
<code>i32</code> benötigt, sollte inzwischen bekannt aussehen.</p>
<pre><pre class="playground"><code class="language-rust">fn foo(x: i32) {
    // Code kommt hierher
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-6: Eine Funktionssignatur verwendet Muster
in den Parametern</span></p>
<p>Der Teil <code>x</code> ist ein Muster! Wie wir es mit <code>let</code> taten, konnten wir ein Tupel
in den Argumenten einer Funktion dem Muster zuordnen. Codeblock 18-7 teilt die
Werte in einem Tupel auf, wenn wir es an eine Funktion übergeben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Aktuelle Position: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
<p><span class="caption">Codeblock 18-7: Eine Funktion mit Parametern, die ein
Tupel destrukturieren</span></p>
<p>Dieser Code gibt <code>Aktuelle Position: (3, 5)</code> aus. Die Werte <code>&amp;(3, 5)</code> passen
zum Muster <code>&amp;(x, y)</code>, sodass <code>x</code> den Wert <code>3</code> und <code>y</code> den Wert <code>5</code> hat.</p>
<p>Wir können auch Muster in Funktionsabschlussparameterlisten (closure parameter
lists) auf die gleiche Weise wie in Funktionsparameterlisten verwenden, da
Funktionsabschlüsse ähnlich wie Funktionen sind, wie in Kapitel 13 besprochen.</p>
<p>An diesem Punkt hast du verschiedene Möglichkeiten der Verwendung von Mustern
gesehen, aber Muster funktionieren nicht an allen Stellen, an denen wir sie
verwenden können, gleich. An manchen Stellen müssen die Muster unabweisbar
(irrefutable) sein, unter anderen Umständen können sie abweisbar (refutable)
sein. Wir werden diese beiden Konzepte als Nächstes besprechen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="abweisbarkeit-falls-ein-muster-pattern-mal-nicht-passt"><a class="header" href="#abweisbarkeit-falls-ein-muster-pattern-mal-nicht-passt">Abweisbarkeit: Falls ein Muster (pattern) mal nicht passt</a></h2>
<p>Es gibt zwei Arten von Mustern: Abweisbare (refutable) und unabweisbare
(irrefutable). Muster, die für jeden möglichen übergebenen Wert passen, sind
<em>unabweisbar</em>. Ein Beispiel wäre <code>x</code> in der Anweisung <code>let x = 5;</code> weil <code>x</code> auf
alles passt und daher nicht fehlschlagen kann. Muster, die für irgendeinen
möglichen Wert nicht passen können, sind <em>abweisbar</em>. Ein Beispiel wäre
<code>Some(x)</code> im Ausdruck <code>if let Some(x) = a_value</code>, denn wenn der Wert in der
Variablen <code>a_value</code> eher <code>None</code> als <code>Some</code> ist, wird das Muster <code>Some(x)</code> nicht
passen. </p>
<p>Funktionsparameter, <code>let</code>-Anweisungen und <code>for</code>-Schleifen können nur
unabweisbare Muster akzeptieren, da das Programm nichts Sinnvolles tun kann,
wenn die Werte nicht passen. Die Ausdrücke <code>if let</code> und <code>while let</code> akzeptieren
abweisbare und unabweisbare Muster, aber der Compiler warnt vor unabweisbaren
Mustern, weil sie per Definition dazu gedacht sind, mit einem möglichen
Fehlerfall umzugehen: Die Funktionalität einer Bedingung besteht in ihrer
Fähigkeit, sich abhängig von Erfolg oder Fehlerfall unterschiedlich zu
verhalten.</p>
<p>Im Allgemeinen solltest du dich nicht um die Unterscheidung zwischen
abweisbaren und unabweisbaren Mustern kümmern müssen; du musst jedoch mit dem
Konzept der Abweisbarkeit vertraut sein, damit du reagieren kannst, wenn du es
in einer Fehlermeldung siehst. In diesen Fällen musst du entweder das Muster
oder das Konstrukt, in dem du das Muster verwendest, ändern, je nach dem
beabsichtigten Verhalten des Codes.</p>
<p>Betrachten wir ein Beispiel dafür, was passiert, wenn wir versuchen, ein
abweisbares Muster zu verwenden, wo Rust ein unabweisbares Muster erfordert und
umgekehrt. Codeblock 18-8 zeigt eine <code>let</code>-Anweisung, allerdings haben wir für
das Muster <code>Some(x)</code> angegeben, ein abweisbares Muster. Wie zu erwarten ist,
lässt sich dieser Code nicht kompilieren.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-8: Versuch, ein abweisbares Muster mit <code>let</code>
zu verwenden</span></p>
<p>Wenn <code>some_option_value</code> ein <code>None</code>-Wert wäre, würde er nicht zum Muster
<code>Some(x)</code> passen, was bedeutet, dass das Muster abweisbar ist. Die
<code>let</code>-Anweisung kann jedoch nur ein unabweisbares Muster akzeptieren, weil es
nichts Gültiges gibt, was der Code mit einem <code>None</code>-Wert tun kann. Zur
Kompilierzeit wird sich Rust beschweren, dass wir versucht haben, ein
abweisbares Muster zu verwenden, wo ein unabweisbares Muster erforderlich ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
   --&gt; src/main.rs:3:9
    |
3   |     let Some(x) = some_option_value;
    |         ^^^^^^^ pattern `None` not covered
    |
    = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant
    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
note: `Option&lt;i32&gt;` defined here
    = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `if let` to ignore the variant that isn't matched
    |
3   |     let x = if let Some(x) = some_option_value { x } else { todo!() };
    |     ++++++++++                                 ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` due to previous error
</code></pre>
<p>Da wir nicht jeden gültigen Wert mit dem Muster <code>Some(x)</code> abgedeckt haben (und
auch nicht abdecken konnten!), erzeugt Rust zu Recht einen Kompilierfehler.</p>
<p>Wenn wir ein abweisbares Muster haben, obwohl ein unabweisbares Muster benötigt
wird, können wir den Code, der das Muster verwendet, korrigieren: Anstatt <code>let</code>
zu verwenden, können wir <code>if let</code> verwenden. Wenn das Muster dann nicht passt,
überspringt der Code einfach den Code in den geschweiften Klammern und gibt ihm
die Möglichkeit, gültig fortzufahren. Codeblock 18-9 zeigt, wie der Code in
Codeblock 18-8 zu korrigieren ist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!(&quot;{}&quot;, x);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-9: Verwenden von <code>if let</code> und eines Blocks
mit abweisbaren Mustern anstelle von <code>let</code></span></p>
<p>Wir haben den Code repariert! Dieser Code ist vollkommen gültig, obwohl er
bedeutet, dass wir kein unabweisbares Muster verwenden können, ohne einen
Fehler zu erhalten. Wenn wir <code>if let</code> ein Muster geben, das immer passen wird,
z.B. <code>x</code>, wie in Codeblock 18-10 gezeigt, gibt der Compiler eine Warnung aus.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!(&quot;{}&quot;, x);
    };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-10: Der Versuch, ein unabweisbares Muster
mit <code>if let</code> zu verwenden</span></p>
<p>Rust beklagt, dass es keinen Sinn macht, <code>if let</code> mit einem unabweisbaren
Muster zu verwenden:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 --&gt; src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`

warning: `patterns` (bin &quot;patterns&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>Aus diesem Grund müssen <code>match</code>-Zweige abweisbare Muster verwenden, mit
Ausnahme des letzten Zweigs, bei dem alle verbleibenden Werte mit einem
unabweisbaren Muster übereinstimmen sollten. Rust erlaubt es uns, ein
unabweisbares Muster in einem <code>match</code> mit nur einem Zweig zu verwenden, aber
diese Syntax ist nicht besonders nützlich und könnte durch eine einfachere
<code>let</code>-Anweisung ersetzt werden.</p>
<p>Nun, da du weißt, wo du Muster verwenden kannst und den Unterschied zwischen
abweisbaren und unabweisbaren Mustern kennst, lass uns alle Syntaxen behandeln,
die wir zum Erstellen von Mustern verwenden können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mustersyntax"><a class="header" href="#mustersyntax">Mustersyntax</a></h2>
<p>In diesem Abschnitt stellen wir die gesamte Syntax gültiger Muster zusammen und
erörtern, warum und wann du jedes einzelne Muster verwenden solltest.</p>
<h3 id="passende-literale"><a class="header" href="#passende-literale">Passende Literale</a></h3>
<p>Wie du in Kapitel 6 gesehen hast, kannst du Muster direkt mit Literalen
abgleichen. Der folgende Code enthält einige Beispiele:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;eins&quot;),
        2 =&gt; println!(&quot;zwei&quot;),
        3 =&gt; println!(&quot;drei&quot;),
        _ =&gt; println!(&quot;sonstige&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code gibt <code>eins</code> aus, weil der Wert in <code>x</code> 1 ist. Diese Syntax ist
nützlich, wenn du willst, dass dein Code eine Aktion ausführt, wenn er einen
bestimmten konkreten Wert erhält.</p>
<h3 id="benannte-variablen-abgleichen"><a class="header" href="#benannte-variablen-abgleichen">Benannte Variablen abgleichen</a></h3>
<p>Benannte Variablen (named variables) sind unabweisbare Muster, die zu jedem
Wert passen, und wir haben sie in diesem Buch schon oft verwendet. Es gibt
jedoch eine Komplikation, wenn du benannte Variablen in <code>match</code>-Ausdrücken
verwendest. Da <code>match</code> einen neuen Gültigkeitsbereich beginnt, werden
Variablen, die als Teil eines Musters innerhalb des <code>match</code>-Ausdrucks
deklariert sind, diejenigen mit dem gleichen Namen außerhalb des
<code>match</code>-Konstrukts verschatten (shadow), wie es bei allen Variablen der Fall
ist. In Codeblock 18-11 deklarieren wir eine Variable mit dem Namen <code>x</code> mit dem
Wert <code>Some(5)</code> und eine Variable <code>y</code> mit dem Wert <code>10</code>. Dann erzeugen wir einen
<code>match</code>-Ausdruck für den Wert <code>x</code>. Sieh dir die Muster in den <code>match</code>-Zweigen
und <code>println!</code> am Ende an und versuche herauszufinden, was der Code ausgeben
wird, bevor du diesen Code ausführst oder weiterliest.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Habe 50 erhalten&quot;),
        Some(y) =&gt; println!(&quot;Passt, y = {y}&quot;),
        _ =&gt; println!(&quot;Standardfall, x = {:?}&quot;, x),
    }

    println!(&quot;Am Ende: x = {:?}, y = {y}&quot;, x);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-11: Ein <code>match</code>-Ausdruck mit einem Zweig,
der eine verschattete Variable <code>y</code> einführt</span></p>
<p>Lass uns durchgehen, was passiert, wenn der <code>match</code>-Ausdruck ausgeführt wird.
Das Muster im ersten Zweig passt nicht zum definierten Wert von <code>x</code>, also setzt
der Code fort.</p>
<p>Das Muster im zweiten Zweig führt eine neue Variable namens <code>y</code> ein, die zu
jedem Wert innerhalb eines <code>Some</code>-Wertes passt. Da wir uns in einem neuen
Gültigkeitsbereich innerhalb des <code>match</code>-Ausdrucks befinden, ist dies eine neue
Variable <code>y</code>, nicht das <code>y</code>, das wir am Anfang mit dem Wert 10 deklariert
haben. Diese neue <code>y</code>-Bindung wird mit jedem Wert innerhalb eines <code>Some</code>
übereinstimmen, das ist das, was wir in <code>x</code> haben. Daher bindet dieses neue <code>y</code>
an den inneren Wert des <code>Some</code> in <code>x</code>. Dieser Wert ist <code>5</code>, sodass der Ausdruck
für diesen Zweig ausgeführt und <code>Passt, y = 5</code> ausgegeben wird.</p>
<p>Wäre <code>x</code> ein <code>None</code>-Wert anstelle von <code>Some(5)</code> gewesen, hätten die Muster in
den ersten beiden Zweigen nicht gepasst, sodass der Wert zum Unterstrich
gepasst hätte. Wir haben die Variable <code>x</code> nicht im Muster des
Unterstrich-Zweigs verwendet, sodass <code>x</code> im Ausdruck immer noch das äußere <code>x</code>
ist, das nicht verschattet wurde. In diesem hypothetischen Fall würde <code>match</code>
den Text <code>Standardfall, x = None</code> ausgeben.</p>
<p>Wenn der <code>match</code>-Ausdruck zu Ende ist, endet sein Gültigkeitsbereich und damit
auch der Gültigkeitsbereich des inneren <code>y</code>. Das letzte <code>println!</code> gibt <code>Am Ende: x = Some(5), y = 10</code> aus.</p>
<p>Um einen <code>match</code>-Ausdruck zu erstellen, der die Werte der äußeren <code>x</code> und <code>y</code>
abgleicht anstatt eine verschattete Variable einzuführen, müssten wir
stattdessen eine Abgleichsbedingung (match guard conditional) verwenden. Wir
werden über Abgleichsbedingungen später im Abschnitt <a href="ch18-03-pattern-syntax.html#extra-bedingungen-mit-abgleichsbedingungen">„Extra-Bedingungen mit
Abgleichsbedingungen“</a> sprechen.</p>
<h3 id="mehrfache-muster"><a class="header" href="#mehrfache-muster">Mehrfache Muster</a></h3>
<p>In <code>match</code>-Ausdrücken kannst du mehrere Muster mit der Syntax <code>|</code> abgleichen,
die das <em>oder</em>-Operator-Muster ist. Zum Beispiel gleicht der folgende Code den
Wert von <code>x</code> mit den <code>match</code>-Zweigen ab, wobei der erste davon eine
<em>oder</em>-Option hat, was bedeutet, wenn der Wert von <code>x</code> zu einem der Werte in
diesem Zweig passt, wird der Code dieses Zweigs ausgeführt:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;eins oder zwei&quot;),
        3 =&gt; println!(&quot;drei&quot;),
        _ =&gt; println!(&quot;sonstige&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code gibt <code>eins oder zwei</code> aus.</p>
<h3 id="abgleichen-von-wertebereichen-mit-"><a class="header" href="#abgleichen-von-wertebereichen-mit-">Abgleichen von Wertebereichen mit <code>..=</code></a></h3>
<p>Die Syntax <code>..=</code> erlaubt es uns, einen inklusiven Wertebereich abzugleichen.
Wenn im folgenden Code ein Muster zu einem der Werte innerhalb des
vorgegebenen Bereichs passt, wird dieser Zweig ausgeführt:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;eins bis fünf&quot;),
        _ =&gt; println!(&quot;etwas anderes&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Wenn <code>x</code> 1, 2, 3, 4 oder 5 ist, passt der erste Zweig. Diese Syntax ist
bequemer bei mehreren Abgleichswerten als das Verwenden des <code>|</code>-Operators, um
die gleiche Idee auszudrücken; wenn wir <code>|</code> verwenden wollten, müssten wir <code>1 | 2 | 3 | 4 | 5</code> angeben. Die Angabe eines Bereichs ist viel kürzer, besonders
wenn wir beispielsweise eine beliebige Zahl zwischen 1 und 1.000 angeben
wollen!</p>
<p>Der prüft Compiler zur Kompilierzeit, dass der Bereich nicht leer ist. Die
einzigen Typen, bei denen Rust erkennen kann, ob ein Bereich leer ist oder
nicht, sind <code>char</code> und numerische Werte, Bereiche sind nur mit numerischen oder
<code>char</code>-Werten zulässig.</p>
<p>Hier ist ein Beispiel mit Bereichen von <code>char</code>-Werten:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;früher ASCII-Buchstabe&quot;),
        'k'..='z' =&gt; println!(&quot;später ASCII-Buchstabe&quot;),
        _ =&gt; println!(&quot;etwas anderes&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Rust kann erkennen, dass <code>'c'</code> innerhalb des Bereichs des ersten Musters liegt
und gibt <code>früher ASCII-Buchstabe</code> aus.</p>
<h3 id="destrukturieren-um-werte-aufzuteilen"><a class="header" href="#destrukturieren-um-werte-aufzuteilen">Destrukturieren, um Werte aufzuteilen</a></h3>
<p>Wir können auch Muster verwenden, um Strukturen (structs), Aufzählungen (enums)
und Tupel zu destrukturieren, um verschiedene Teile dieser Werte zu verwenden.
Lass uns jeden Wert durchgehen.</p>
<h4 id="destrukturieren-von-strukturen"><a class="header" href="#destrukturieren-von-strukturen">Destrukturieren von Strukturen</a></h4>
<p>Codeblock 18-12 zeigt eine Struktur <code>Point</code> mit zwei Feldern, <code>x</code> und <code>y</code>, die
wir mit einem Muster in einer <code>let</code>-Anweisung aufteilen können.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<p><span class="caption">Codeblock 18-12: Destrukturieren der Felder einer
Struktur in separate Variablen</span></p>
<p>Dieser Code erzeugt die Variablen <code>a</code> und <code>b</code>, die den Werten der Felder <code>x</code>
und <code>y</code> der Struktur <code>p</code> entsprechen. Dieses Beispiel zeigt, dass die Namen der
Variablen im Muster nicht mit den Feldnamen der Struktur übereinstimmen müssen.
Aber es ist üblich, dass die Variablennamen mit den Feldnamen übereinstimmen,
damit man sich leichter merken kann, welche Variablen aus welchen Feldern
stammen. Wegen dieser häufigen Verwendung und weil das Schreiben von <code>let Point { x: x, y: y } = p;</code> eine Menge Duplikation enthält, hat Rust eine Kurzform
für Muster, die mit Strukturfeldern übereinstimmen: Du musst nur die Namen des
Struktur-Felder auflisten, und die Variablen, die aus dem Muster erzeugt
werden, haben die gleichen Namen. Codeblock 18-13 zeigt Code, der sich gleich
verhält wie der Code in Codeblock 18-12, aber die Variablen, die im Muster
<code>let</code> erzeugt werden, sind <code>x</code> und <code>y</code> anstelle von <code>a</code> und <code>b</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<p><span class="caption">Codeblock 18-13: Destrukturieren von Strukturfeldern mit
Hilfe der Strukturfeldkurznotation (struct field shorthand)</span></p>
<p>Dieser Code erzeugt die Variablen <code>x</code> und <code>y</code>, die mit den Feldern <code>x</code> und <code>y</code>
der Variablen <code>p</code> übereinstimmen. Das Ergebnis ist, dass die Variablen <code>x</code> und
<code>y</code> die Werte aus der Struktur <code>p</code> enthalten.</p>
<p>Wir können auch mit literalen Werten als Teil des Strukturmusters
destrukturieren, anstatt Variablen für alle Felder zu erstellen. Auf diese
Weise können wir einige der Felder auf bestimmte Werte testen, während wir
Variablen zum Destrukturieren der anderen Felder erstellen.</p>
<p>In Codeblock 18-14 haben wir einen <code>match</code>-Ausdruck, der <code>Point</code>-Werte in drei
Fälle unterscheidet: Punkte, die direkt auf der <code>x</code>-Achse liegen (was zutrifft,
wenn <code>y = 0</code>), auf der <code>y</code>-Achse liegen (<code>x = 0</code>) oder keines von beiden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;Auf der x-Achse bei {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;Auf der y-Achse bei {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;Auf keiner Achse: ({}, {})&quot;, x, y),
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 18-14: Destrukturieren und Abgleichen literaler
Werte in einem Muster</span></p>
<p>Der erste Zweig passt zu jedem Punkt, der auf der <code>x</code>-Achse liegt, indem er
angibt, dass der Wert des <code>y</code>-Felds zum Literal <code>0</code> passt. Das Muster erzeugt
immer noch eine Variable <code>x</code>, die wir im Code für diesen Zweig verwenden
können.</p>
<p>In ähnlicher Weise passt der zweite Zweig zu jedem Punkt auf der y-Achse, indem
er angibt, dass der Wert des <code>x</code>-Feldes 0 ist, und eine Variable <code>y</code>  für den
Wert des <code>y</code> -Feldes erzeugt. Der dritte Zweig spezifiziert keine Literale,
sodass er zu jedem anderen <code>Point</code> passt und Variablen für die Felder <code>x</code> und
<code>y</code> erzeugt.</p>
<p>In diesem Beispiel passt der Wert <code>p</code> zum zweiten Zweig, da <code>x</code> eine 0 enthält,
sodass dieser Code <code>Auf der y-Achse bei 7</code> ausgeben wird.</p>
<p>Denke daran, dass ein <code>match</code>-Ausdruck aufhört, weitere Zweige zu prüfen,
sobald er das erste übereinstimmende Muster gefunden hat, d.h. auch wenn der
<code>Point { x: 0, y: 0}</code> auf der <code>x</code>-Achse und der <code>y</code>-Achse liegt, würde dieser
Code nur <code>Auf der x-Achse bei 0</code> ausgeben.</p>
<h4 id="destrukturieren-von-aufzählungen"><a class="header" href="#destrukturieren-von-aufzählungen">Destrukturieren von Aufzählungen</a></h4>
<p>Wir haben in diesem Buch bereits Aufzählungen destrukturiert (z.B. Codeblock
6-5 in Kapitel 6), sind aber noch nicht explizit darauf eingegangen, dass das
Muster zur Destrukturierung einer Aufzählung der Art und Weise entspricht, wie
die in der Aufzählung gespeicherten Daten definiert sind. Als Beispiel
verwenden wir in Codeblock 18-15 die Aufzählung <code>Message</code> aus Codeblock 6-2 und
schreiben ein <code>match</code> mit Mustern, das jeden inneren Wert destrukturiert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;Die Quit-Variante hat keine Daten zu destrukturieren.&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Bewege in x-Richtung {} und in y-Richtung {}&quot;,
                x, y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Textnachricht: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(
            &quot;Ändere die Farbe in rot {}, grün {} und blau {}&quot;,
            r, g, b
        ),
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 18-15: Destrukturieren von
Aufzählungsvarianten, die verschiedene Arten von Werten enthalten</span></p>
<p>Dieser Code gibt <code>Ändere die Farbe in rot 0, grün 160 und blau 255</code> aus.
Versuche, den Wert von <code>msg</code> zu ändern, um den Code der anderen Zweige laufen
zu sehen.</p>
<p>Bei Aufzählungs-Varianten ohne Daten, wie <code>Message::Quit</code>, können wir den Wert
nicht weiter destrukturieren. Wir können nur mit dem Literalwert
<code>Message::Quit</code> abgleichen und es gibt keine Variablen in diesem Muster.</p>
<p>Für strukturähnliche Aufzählungsvarianten, z.B. <code>Message::Move</code>, können wir ein
Muster verwenden, das dem von uns angegebenen Muster ähnlich ist, um Strukturen
abzugleichen. Nach dem Variantennamen setzen wir geschweifte Klammern und
listen dann die Felder mit Variablen auf, sodass wir die Teile aufteilen, die
im Code für diesen Zweig verwendet werden sollen. Hier verwenden wir die
Kurznotation, wie wir es in Codeblock 18-13 getan haben.</p>
<p>Bei tupelähnlichen Aufzählungsvarianten wie <code>Message::Write</code>, die ein Tupel mit
einem Element enthält, und <code>Message::ChangeColor</code>, die ein Tupel mit drei
Elementen enthält, ähnelt das Muster dem Muster, das wir für den Abgleich von
Tupeln angeben. Die Anzahl der Variablen im Muster muss mit der Anzahl der
Elemente in der Variante, die wir abgleichen, übereinstimmen.</p>
<h4 id="destrukturieren-verschachtelter-strukturen-und-aufzählungen"><a class="header" href="#destrukturieren-verschachtelter-strukturen-und-aufzählungen">Destrukturieren verschachtelter Strukturen und Aufzählungen</a></h4>
<p>Bis jetzt haben unsere Beispiele alle Strukturen oder Aufzählungen auf einer
Ebene abgeglichen, aber der Abgleich funktioniert auch bei verschachtelten
Elementen! Zum Beispiel können wir den Code in Codeblock 18-15 umstrukturieren,
um RGB- und HSV-Farben in der <code>ChangeColor</code>-Nachricht zu unterstützen, wie in
Codeblock 18-16 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; println!(
            &quot;Ändere die Farbe in rot {}, grün {} und blau {}&quot;,
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; println!(
            &quot;Ändere die Farbe in Farbwert {}, Sättigung {} und Hellwert {}&quot;,
            h, s, v
        ),
        _ =&gt; (),
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 18-16: Abgleich bei verschachtelten
Aufzählungen</span></p>
<p>Das Muster des ersten Zweigs im <code>match</code>-Ausdruck passt zu einer
<code>Message::ChangeColor</code>-Aufzählungsvariante, die eine <code>Color::Rgb</code>-Variante
enthält; dann bindet das Muster an die drei inneren <code>i32</code>-Werte. Das Muster des
zweiten Zweigs passt ebenfalls mit einer
<code>Message::ChangeColor</code>-Aufzählungsvariante, aber die innere Aufzählung passt
stattdessen zur <code>Color::Hsv</code>-Variante. Wir können diese komplexen Bedingungen
in einem einzigen <code>match</code>-Ausdruck angeben, auch wenn es sich um zwei
Aufzählungen handelt.</p>
<h4 id="destrukturieren-von-strukturen-und-tupeln"><a class="header" href="#destrukturieren-von-strukturen-und-tupeln">Destrukturieren von Strukturen und Tupeln</a></h4>
<p>Wir können das Abgleichen und Destrukturieren verschachtelter Muster auf noch
komplexere Weise mischen. Das folgende Beispiel zeigt eine komplizierte
Destrukturierung, bei der wir Strukturen und Tupel innerhalb eines Tupels
verschachteln und alle primitiven Werte herausdestrukturieren:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code ermöglicht es uns, komplexe Typen in ihre Bestandteile zu zerlegen,
sodass wir die Werte, an denen wir interessiert sind, separat verwenden können.</p>
<p>Das Destrukturieren mit Mustern ist eine bequeme Möglichkeit, Wertteile, z.B.
Werte aus den Feldern in einer Struktur, getrennt voneinander zu verwenden.</p>
<h3 id="ignorieren-von-werten-in-einem-muster"><a class="header" href="#ignorieren-von-werten-in-einem-muster">Ignorieren von Werten in einem Muster</a></h3>
<p>Du hast gesehen, dass es manchmal nützlich ist, Werte in einem Muster zu
ignorieren, z.B. im letzten Zweig eines <code>match</code>, um einen Sammelzweig zu
erhalten, der eigentlich nichts tut, aber alle verbleibenden möglichen Werte
berücksichtigt. Es gibt ein paar Möglichkeiten, ganze Werte oder Teile von
Werten in einem Muster zu ignorieren: Verwenden des Musters <code>_</code> (das du gesehen
hast), Verwenden des Musters <code>_</code> innerhalb eines anderen Musters, Verwenden
eines Namens, der mit einem Unterstrich beginnt, oder Verwenden von <code>..</code>, um
verbleibende Teile eines Wertes zu ignorieren. Lass uns untersuchen, wie und
wann jedes dieser Muster zu verwenden ist.</p>
<h4 id="ignorieren-eines-gesamtwertes-mit-_"><a class="header" href="#ignorieren-eines-gesamtwertes-mit-_">Ignorieren eines Gesamtwertes mit <code>_</code></a></h4>
<p>Wir haben den Unterstrich (<code>_</code>) als Platzhalter verwendet, der zu jedem Wert
passt, aber nicht an den Wert gebunden ist. Dies ist besonders nützlich als
letzter Zweig in einem <code>match</code>-Ausdruck ist, aber wir können es in jedem Muster
verwenden, einschließlich Funktionsparameter, wie in Codeblock 18-17 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;Dieser Code verwendet nur den Parameter y: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<p><span class="caption">Codeblock 18-17: Verwenden von <code>_</code> in einer
Funktionssignatur</span></p>
<p>Dieser Code ignoriert den als erstes Argument übergebenen Wert <code>3</code> vollständig
und gibt <code>Dieser Code verwendet nur den Parameter y: 4</code> aus.</p>
<p>In den meisten Fällen, wenn du einen bestimmten Funktionsparameter nicht mehr
benötigst, würdest du die Signatur so ändern, dass sie den unbenutzten
Parameter nicht mehr enthält. Das Ignorieren eines Funktionsparameters kann in
einigen Fällen besonders nützlich sein, z.B. bei der Implementierung eines
Merkmals (trait), wenn du eine bestimmte Typsignatur benötigst, der
Funktionsrumpf in deiner Implementierung jedoch keinen der Parameter benötigt.
Du kannst dann vermeiden, dass der Compiler vor unbenutzten Funktionsparametern
warnt, wie es der Fall wäre, wenn du stattdessen einen Namen verwenden würdest.</p>
<h4 id="ignorieren-von-teilen-eines-wertes-mit-einem-verschachtelten-_"><a class="header" href="#ignorieren-von-teilen-eines-wertes-mit-einem-verschachtelten-_">Ignorieren von Teilen eines Wertes mit einem verschachtelten <code>_</code></a></h4>
<p>Wir können <code>_</code> auch innerhalb eines anderen Musters verwenden, um nur einen
Teil eines Wertes zu ignorieren, z.B. wenn wir nur auf einen Teil eines Wertes
testen wollen, aber keine Verwendung für die anderen Teile in dem
entsprechenden Code haben, den wir ausführen wollen. Der Codeblock 18-18 zeigt
den Code, der für die Verwaltung des Wertes einer Einrichtung verantwortlich
ist. Die Geschäftsanforderungen bestehen darin, dass es dem Benutzer nicht
erlaubt sein soll, eine bestehende Anpassung einer Einstellung zu
überschreiben, sondern dass er die Einstellung rückgängig machen kann und ihr
einen Wert zuweisen kann, wenn sie derzeit nicht gesetzt ist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Kann einen vorhandenen benutzerdefinierten Wert nicht überschreiben.&quot;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&quot;Einstellung ist {:?}&quot;, setting_value);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-18: Das Verwenden eines Unterstrichs
innerhalb von Mustern, die zu <code>Some</code>-Varianten passen, wenn wir den Wert
innerhalb <code>Some</code> nicht benötigen</span></p>
<p>Dieser Code gibt <code>Kann einen vorhandenen benutzerdefinierten Wert nicht überschreiben.</code> aus und dann <code>Einstellung ist Some(5)</code>. Im ersten
<code>match</code>-Zweig müssen wir nicht die Werte innerhalb der beiden <code>Some</code>-Varianten
abgleichen oder diese verwenden, aber wir müssen den Fall prüfen, dass
<code>setting_value</code> und <code>new_setting_value</code> jeweils <code>Some</code>-Varianten sind. In
diesem Fall geben wir den Grund aus, warum wir <code>setting_value</code> nicht ändern,
und es wird nicht geändert.</p>
<p>In allen anderen Fällen (wenn entweder <code>setting_value</code> oder <code>new_setting_value</code>
den Wert <code>None</code> hat), die durch das Muster <code>_</code> im zweiten Zweig ausgedrückt
werden, wollen wir erlauben, dass <code>setting_value</code> den Wert von
<code>new_setting_value</code> erhält.</p>
<p>Wir können Unterstriche auch an mehreren Stellen innerhalb eines Musters
verwenden, um bestimmte Werte zu ignorieren. Codeblock 18-19 zeigt ein Beispiel
für das Ignorieren des zweiten und vierten Wertes in einem Tupel von fünf
Elementen.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&quot;Einige Zahlen: {first}, {third}, {fifth}&quot;)
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-19: Ignorieren mehrerer Teile eines
Tupels</span></p>
<p>Dieser Code gibt <code>Einige Zahlen: 2, 8, 32</code> aus und die Werte 4 und 16 werden
ignoriert.</p>
<h4 id="ignorieren-einer-unbenutzten-variable-indem-ihr-name-mit-_-beginnt"><a class="header" href="#ignorieren-einer-unbenutzten-variable-indem-ihr-name-mit-_-beginnt">Ignorieren einer unbenutzten Variable, indem ihr Name mit <code>_</code> beginnt</a></h4>
<p>Wenn du eine Variable erstellst, sie aber nirgendwo verwendest, wird Rust
normalerweise eine Warnung ausgeben, weil eine unbenutzte Variable ein Fehler
sein könnte. Aber manchmal ist es nützlich, eine Variable erstellen zu können,
die du noch nicht verwenden wirst, z.B. wenn du einen Prototyp erstellst oder
gerade ein Projekt beginnst. In dieser Situation kannst du Rust anweisen, dich
nicht vor der unbenutzten Variablen zu warnen, indem du den Namen der Variablen
mit einem Unterstrich beginnst. In Codeblock 18-20 erstellen wir zwei
unbenutzte Variablen, aber wenn wir diesen Code kompilieren, sollten wir nur
vor einer von ihnen eine Warnung erhalten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<p><span class="caption">Codeblock 18-20: Beginnen eines Variablennamens mit einem
Unterstrich, um Warnungen zu unbenutzten Variablen zu vermeiden</span></p>
<p>Hier erhalten wir eine Warnung zur unbenutzten Variablen <code>y</code>, aber wir erhalten
keine Warnung zur unbenutzten Variablen <code>_x</code>.</p>
<p>Beachte, dass es einen feinen Unterschied gibt zwischen dem Verwenden von <code>_</code>
und dem Verwenden eines Namens, der mit einem Unterstrich beginnt. Die Syntax
<code>_x</code> bindet immer noch den Wert an die Variable, während <code>_</code> überhaupt nicht
bindet. Um einen Fall zu zeigen, in dem diese Unterscheidung von Bedeutung ist,
wird uns Codeblock 18-21 einen Fehler liefern.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hallo!&quot;));

    if let Some(_s) = s {
        println!(&quot;Zeichenkette gefunden&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-21: Eine unbenutzte Variable, die mit einem
Unterstrich beginnt, bindet immer noch den Wert, der die Eigentümerschaft des
Wertes übernehmen könnte</span></p>
<p>Wir werden einen Fehler erhalten, weil der Wert <code>s</code> immer noch in <code>_s</code>
verschoben wird, was uns daran hindert, <code>s</code> wieder zu verwenden. Das Verwenden
des Unterstrichs an sich bindet jedoch niemals einen Wert. Codeblock 18-22 wird
ohne Fehler kompilieren, weil <code>s</code> nicht in <code>_</code> verschoben wird.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hallo!&quot;));

    if let Some(_) = s {
        println!(&quot;Zeichenkette gefunden&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-22: Das Verwenden eines Unterstrichs bindet
den Wert nicht</span></p>
<p>Dieser Code funktioniert prima, weil wir <code>s</code> nie an etwas binden; es wird nicht
verschoben.</p>
<h4 id="ignorieren-der-verbleibenden-teile-eines-wertes-mit-"><a class="header" href="#ignorieren-der-verbleibenden-teile-eines-wertes-mit-">Ignorieren der verbleibenden Teile eines Wertes mit <code>..</code></a></h4>
<p>Bei Werten, die viele Teile haben, können wir die Syntax <code>..</code> verwenden, um nur
spezifische Teile zu verwenden und den Rest zu ignorieren, sodass es nicht
notwendig ist, für jeden ignorierten Wert Unterstriche aufzulisten. Das Muster
<code>..</code> ignoriert alle Teile eines Wertes, die wir im Rest des Musters nicht
explizit zugeordnet haben. In Codeblock 18-23 haben wir eine Struktur <code>Point</code>,
die eine Koordinate im dreidimensionalen Raum enthält. Im <code>match</code>-Ausdruck
wollen wir nur mit der Koordinate <code>x</code> operieren und die Werte in den Feldern
<code>y</code> und <code>z</code> ignorieren.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&quot;x ist {}&quot;, x),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-23: Ignorieren aller Felder eines <code>Point</code>
mit Ausnahme von <code>x</code> durch Verwenden von <code>..</code></span></p>
<p>Wir listen den Wert <code>x</code> auf und fügen dann einfach das Muster <code>..</code> ein. Das
geht schneller, als <code>y: _</code> und <code>z: _</code> anzugeben, insbesondere wenn wir mit
Strukturen arbeiten, die viele Felder haben, in Situationen, in denen nur ein
oder zwei Felder relevant sind.</p>
<p>Die Syntax <code>..</code> wird auf so viele Werte wie nötig erweitert. Codeblock 18-24
zeigt, wie man <code>..</code> mit einem Tupel verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Einige Zahlen: {first}, {last}&quot;);
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-24: Nur den ersten und letzten Wert in einem
Tupel abgleichen und alle anderen Werte ignorieren</span></p>
<p>In diesem Code werden der erste und der letzte Wert mit <code>first</code> und <code>last</code>
abgeglichen. Das <code>..</code> passt zu allem in der Mitte und ignoriert es.</p>
<p>Das Verwenden von <code>..</code> muss jedoch eindeutig sein. Wenn unklar ist, welche
Werte zum Abgleich vorgesehen sind und welche ignoriert werden sollten, gibt
uns Rust einen Fehler. Codeblock 18-25 zeigt ein Beispiel für die mehrdeutige
Verwendung von <code>..</code>, sodass es sich nicht kompilieren lässt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Einige Zahlen: {}&quot;, second)
        },
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-25: Ein Versuch, <code>..</code> auf mehrdeutige Weise
zu verwenden</span></p>
<p>Wenn wir dieses Beispiel kompilieren, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` due to previous error
</code></pre>
<p>Es ist für Rust unmöglich zu bestimmen, wie viele Werte im Tupel zu ignorieren
sind, bevor ein Wert zu <code>second</code> passt, und wie viele weitere Werte danach zu
ignorieren sind. Dieser Code könnte bedeuten, dass wir <code>2</code> ignorieren wollen,
<code>second</code> an <code>4</code> binden und dann <code>8</code>, <code>16</code> und <code>32</code> ignorieren wollen; oder dass
wir <code>2</code> und <code>4</code> ignorieren wollen, <code>second</code> an <code>8</code> binden und dann <code>16</code> und
<code>32</code> ignorieren wollen; und so weiter. Der Variablenname <code>second</code> bedeutet für
Rust nichts Besonderes, sodass wir einen Kompilierfehler erhalten, weil das
Verwenden von <code>..</code> an zwei Stellen wie dieser mehrdeutig ist.</p>
<h3 id="extra-bedingungen-mit-abgleichsbedingungen"><a class="header" href="#extra-bedingungen-mit-abgleichsbedingungen">Extra-Bedingungen mit Abgleichsbedingungen</a></h3>
<p>Eine <em>Abgleichsbedingung</em> (match guard) ist eine zusätzliche <code>if</code>-Bedingung,
die nach dem Muster in einem <code>match</code>-Zweig angegeben wird und die zusammen mit
dem Musterabgleich ebenfalls übereinstimmen muss, damit dieser Zweig ausgewählt
wird. Abgleichsbedingungen sind nützlich, um komplexere Ideen auszudrücken, als
es ein Muster allein erlaubt.</p>
<p>Die Bedingung kann Variablen verwenden, die im Muster erstellt wurden.
Codeblock 18-26 zeigt ein <code>match</code>, wobei der erste Zweig das Muster <code>Some(x)</code>
und die Abgleichsbedingung <code>if x % 2 == 0</code> (die wahr ist, wenn die Zahl gerade
ist) hat.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!(&quot;Die Zahl {} ist gerade&quot;, x),
        Some(x) =&gt; println!(&quot;Die Zahl {} ist ungerade&quot;, x),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-26: Hinzufügen einer Abgleichsbedingung zu
einem Muster</span></p>
<p>In diesem Beispiel wird <code>Die Zahl 4 ist gerade</code> ausgegeben. Wenn <code>num</code> mit dem
Muster im ersten Zweig abgeglichen wird, passt es, weil <code>Some(4)</code> zu <code>Some(x)</code>
passt. Dann prüft die Abgleichsbedingung, ob der Rest der Division von <code>x</code>
durch 2 gleich 0 ist, und weil dies der Fall ist, wird der erste Zweig ausgewählt.</p>
<p>Wenn <code>num</code> stattdessen <code>Some(5)</code> gewesen wäre, wäre die Abgleichsbedingung im
ersten Zweig falsch gewesen, weil der Rest von 5 geteilt durch 2 den Wert 1
ergibt, was ungleich 0 ist. Rust würde dann zum zweiten Zweig gehen, der passen
würde, weil der zweite Zweig keine Abgleichsbedingung hat und daher zu allen
<code>Some</code>-Varianten passt.</p>
<p>Es gibt keine Möglichkeit, die Bedingung <code>if x % 2 == 0</code> innerhalb eines Musters
auszudrücken, also gibt uns die Abgleichsbedingung die Möglichkeit, diese Logik
anzugeben. Der Nachteil dieser zusätzlichen Ausdruckskraft ist, dass der
Compiler nicht versucht, die Vollständigkeit zu prüfen, wenn
Abgleichsbedingungs-Ausdrücke beteiligt sind.</p>
<p>In Codeblock 18-11 haben wir erwähnt, dass wir zur Lösung unseres
Musterverschattungsproblems (pattern-shadowing problem) Abgleichsbedingungen
verwenden könnten. Erinnere dich daran, dass eine neue Variable innerhalb des
Musters im <code>match</code>-Ausdruck erstellt wurde, anstatt die Variable außerhalb von
<code>match</code> zu verwenden. Diese neue Variable bedeutete, dass wir nicht gegen den
Wert der äußeren Variable testen konnten. Codeblock 18-27 zeigt, wie wir eine
Abgleichsbedingung verwenden können, um dieses Problem zu beheben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Habe 50 erhalten&quot;),
        Some(n) if n == y =&gt; println!(&quot;Passt, n = {n}&quot;),
        _ =&gt; println!(&quot;Standardfall, x = {:?}&quot;, x),
    }

    println!(&quot;Am Ende: x = {:?}, y = {y}&quot;, x);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-27: Verwenden einer Abgleichsbedingung zum
Testen der Gleichheit mit einer äußeren Variablen</span></p>
<p>Dieser Code gibt nun <code>Standardfall, x = Some(5)</code> aus. Das Muster im zweiten
<code>match</code>-Zweig führt keine neue Variable <code>y</code> ein, die das äußere <code>y</code> verschatten
würde, was bedeutet, dass wir das äußere <code>y</code> in der Abgleichsbedingung
verwenden können. Anstatt das Muster mit <code>Some(y)</code> zu spezifizieren, was das
äußere <code>y</code> verschattet hätte, spezifizieren wir <code>Some(n)</code>. Dies erzeugt eine
neue Variable <code>n</code>, die nichts verschattet, weil es keine Variable <code>n</code> außerhalb
von <code>match</code> gibt.</p>
<p>Die Abgleichsbedingung <code>if n == y</code> ist kein Muster und führt daher keine neuen
Variablen ein. Dieses <code>y</code> <em>ist</em> das äußere <code>y</code> und nicht ein neues verschattetes
<code>y</code>, und wir können nach einem Wert suchen, der den gleichen Wert wie das
äußere <code>y</code> hat, indem wir <code>n</code> mit <code>y</code> vergleichen.</p>
<p>Du kannst auch den <em>oder</em>-Operator <code>|</code> in einer Abgleichsbedingung verwenden,
um mehrere Muster anzugeben; die Abgleichsbedingung gilt dann für alle Muster.
Codeblock 18-28 zeigt den Vorrang der Kombination einer Abgleichsbedingung mit
einem Muster, das <code>|</code> verwendet. Der wichtige Teil dieses Beispiels ist, dass
die Abgleichsbedingung <code>if y</code> auf <code>4</code>, <code>5</code> <em>und</em> <code>6</code> zutrifft, auch wenn es so
aussehen mag, als ob <code>if y</code> nur auf <code>6</code> zutrifft.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;ja&quot;),
        _ =&gt; println!(&quot;nein&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-28: Kombinieren mehrerer Muster mit einer
Abgleichsbedingung</span></p>
<p>Die Abgleichsbedingung besagt, dass der Zweig nur dann passt, wenn der Wert von
<code>x</code> gleich <code>4</code>, <code>5</code> oder <code>6</code> ist <em>und</em> wenn <code>y</code> <code>wahr</code> ist. Wenn dieser Code
ausgeführt wird, passt das Muster des ersten Zweigs, weil <code>x</code> gleich <code>4</code> ist,
allerdings ist die Abgleichsbedingung <code>if y</code> falsch, sodass der erste Zweig
nicht ausgewählt wird. Der Code geht weiter zum zweiten Zweig, der passt, und
dieses Programm gibt <code>nein</code> aus. Der Grund dafür ist, dass die <code>if</code>-Bedingung
für das gesamte Muster <code>4 | 5 | 6</code> gilt, nicht nur für den letzten Wert <code>6</code>.
Mit anderen Worten, der Vorrang einer Abgleichsbedingung in Bezug auf ein
Muster verhält sich wie folgt:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>und nicht so:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>Nach dem Ausführen des Codes ist das Vorrangsverhalten offensichtlich: Würde
die Abgleichsbedingung nur auf den Endwert in der mit dem <code>|</code>-Operator
angegebenen Werteliste angewendet, hätte der Zweig gepasst und das Programm
hätte <code>ja</code> ausgegeben.</p>
<h3 id="-bindungen"><a class="header" href="#-bindungen"><code>@</code>-Bindungen</a></h3>
<p>Mit dem <em>at</em>-Operator <code>@</code> können wir eine Variable erstellen, die einen Wert
enthält, während wir gleichzeitig diesen Wert testen, um festzustellen, ob er
zu einem Muster passt. Codeblock 18-29 zeigt ein Beispiel, bei dem wir testen
wollen, dass ein <code>Message::Hello</code>-Feld <code>id</code> innerhalb des Bereichs <code>3..=7</code>
liegt. Wir wollen den Wert auch an die Variable <code>id_variable</code> binden, damit wir
ihn in dem mit dem Zweig verbundenen Code verwenden können. Wir könnten diese
Variable <code>id</code> nennen, so wie das Feld, aber für dieses Beispiel werden wir
einen anderen Namen verwenden.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;id im Bereich gefunden: {}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;id in einem anderen Bereich gefunden&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Eine andere id gefunden: {}&quot;, id),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-29: Verwenden von <code>@</code>, um an einen Wert in
einem Muster zu binden und ihn gleichzeitig zu testen</span></p>
<p>In diesem Beispiel wird <code>id im Bereich gefunden: 5</code> ausgegeben. Durch das
Angeben von <code>id_variable @</code> vor dem Bereich <code>3..=7</code> erfassen wir den Wert, der
mit dem Bereich übereinstimmt, und testen gleichzeitig, ob der Wert zum
Bereichsmuster passt.</p>
<p>Im zweiten Zweig, wo wir im Muster nur einen Bereich spezifiziert haben, hat
der zum Zweig gehörende Code keine Variable, die den tatsächlichen Wert des
<code>id</code>-Feldes enthält. Der Wert des <code>id</code>-Feldes hätte 10, 11 oder 12 sein können,
aber der Code, der zu diesem Muster gehört, weiß nicht, welcher es ist. Der
Code des Musters ist nicht in der Lage, den Wert des <code>id</code>-Feldes zu verwenden,
weil wir den <code>id</code>-Wert nicht in einer Variablen gespeichert haben.</p>
<p>Im letzten Zweig, in dem wir eine Variable ohne Bereich angegeben haben, haben
wir den Wert, der im Code des Zweigs verfügbar ist, in einer Variablen namens
<code>id</code>. Der Grund dafür ist, dass wir die Syntax des Struktur-Feldes in
Kurznotation verwendet haben. Aber wir haben keinen Test auf den Wert im Feld
<code>id</code> in diesem Zweig angewandt, wie wir es bei den ersten beiden Zweigen getan
haben: Jeder Wert würde zu diesem Muster passen.</p>
<p>Mit <code>@</code> können wir einen Wert testen und ihn in einer Variablen innerhalb eines
Musters speichern.</p>
<h2 id="zusammenfassung-17"><a class="header" href="#zusammenfassung-17">Zusammenfassung</a></h2>
<p>Die Muster in Rust sind sehr nützlich, um zwischen verschiedenen Arten von
Daten zu unterscheiden. Wenn sie in <code>match</code>-Ausdrücken verwendet werden, stellt
Rust sicher, dass deine Muster jeden möglichen Wert abdecken oder dein Programm
sich nicht kompilieren lässt. Muster in <code>let</code>-Anweisungen und
Funktionsparametern machen diese Konstrukte nützlicher und ermöglichen das
Destrukturieren von Werten in kleinere Teile und gleichzeitig das Zuweisen an
Variablen. Wir können einfache oder komplexe Muster erstellen, die unseren
Bedürfnissen entsprechen.</p>
<p>Als nächstes werden wir uns im vorletzten Kapitel des Buches mit einigen
fortgeschrittenen Aspekten einer Vielzahl von Rusts Funktionalitäten befassen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fortgeschrittene-sprachelemente"><a class="header" href="#fortgeschrittene-sprachelemente">Fortgeschrittene Sprachelemente</a></h1>
<p>Inzwischen hast du die am häufigsten verwendeten Teile der Programmiersprache
Rust gelernt. Bevor wir in Kapitel 20 ein weiteres Projekt durchführen, werden
wir uns einige Aspekte der Sprache ansehen, auf die du hin und wieder stoßen
könntest, aber nicht jeden Tag verwenden wirst. Du kannst dieses Kapitel als
Referenz verwenden, wenn du auf Unbekanntes stößt. Die hier beschriebenen
Funktionalitäten sind in ganz bestimmten Situationen nützlich. Auch wenn du sie
vielleicht nicht oft brauchst, möchten wir sicherstellen, dass du alle
Funktionen von Rust kennst. </p>
<p>In diesem Kapitel werden wir behandeln:</p>
<ul>
<li>Unsicheres Rust: Wie kann man einige der Garantien von Rust ausschalten und
Verantwortung für das manuelle Aufrechterhalten dieser Garantien übernehmen?</li>
<li>Fortgeschrittene Merkmale (traits): Assoziierte Typen, Standardtypparameter,
voll qualifizierte Syntax, Supermerkmale (supertraits) und das Newtype-Muster
in Bezug auf Merkmale</li>
<li>Fortgeschrittene Typen: Mehr über das Newtype-Muster, Typ-Aliase, den Typ
never und Typen dynamischer Größe</li>
<li>Erweiterte Funktionen und Funktionsabschlüsse: Funktionszeiger und
Zurückgeben von Funktionsabschlüssen</li>
<li>Makros: Möglichkeiten, Code zu definieren, der zur Kompilierzeit mehr Code
definiert</li>
</ul>
<p>Es ist eine Reihe von Rust-Funktionalitäten, die für jeden etwas bietet! Lass
uns eintauchen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsicheres-unsafe-rust"><a class="header" href="#unsicheres-unsafe-rust">Unsicheres (unsafe) Rust</a></h2>
<p>Bei allem Code, den wir bisher besprochen haben, wurden Rusts
Speichersicherheitsgarantien zur Kompilierzeit erzwungen. Allerdings ist in
Rust eine zweite Sprache versteckt, die diese Speichersicherheitsgarantien
nicht erzwingt: Sie heißt <em>unsicheres Rust</em> (unsafe Rust) und funktioniert
genau wie das normale Rust, gibt uns aber zusätzliche Superkräfte.</p>
<p>Unsicheres Rust existiert, weil die statische Analyse von Natur aus konservativ
ist. Wenn der Compiler versucht festzustellen, ob der Code die Garantien
einhält oder nicht, ist es besser für ihn, einige gültige Programme
zurückzuweisen, als einige ungültige Programme zu akzeptieren. Obwohl der Code
<em>möglicherweise</em> in Ordnung ist, wird der Rust-Compiler den Code ablehnen, wenn
er nicht genügend Informationen hat, um sicher zu sein. In diesen Fällen kannst
du unsicheren Code verwenden, um dem Compiler zu sagen: „Vertraue mir, ich
weiß, was ich tue.“ Sei jedoch gewarnt, dass du unsicheres Rust auf eigenes
Risiko verwendest: Wenn du unsicheren Code falsch verwendest, können Probleme
aufgrund von Speicherunsicherheiten auftreten, z.B. Dereferenzierung von
Null-Zeigern.</p>
<p>Ein weiterer Grund, warum Rust ein unsicheres zweites Ich hat, ist, dass die
zugrunde liegende Computer-Hardware von Natur aus unsicher ist. Wenn Rust dich
keine unsicheren Operationen durchführen ließe, könntest du bestimmte Aufgaben
nicht ausführen. Rust muss es dir ermöglichen, Low-Level-Systemprogrammierung
zu machen, z.B. direkt mit dem Betriebssystem zu interagieren oder sogar dein
eigenes Betriebssystem zu schreiben. Arbeiten mit
Low-Level-Systemprogrammierung ist eines der Ziele der Sprache. Lass uns
untersuchen, was wir mit unsicherem Rust tun können und wie wir es tun können.</p>
<h3 id="unsichere-superkräfte"><a class="header" href="#unsichere-superkräfte">Unsichere Superkräfte</a></h3>
<p>Um auf unsicheres Rust umzuschalten, verwendest du das Schlüsselwort <code>unsafe</code>
und startest dann einen neuen Block, der den unsicheren Code enthält. In
unsicherem Rust kannst du fünf Aktionen ausführen, die du in sicherem Rust
nicht ausführen kannst, die wir <em>unsichere Superkräfte</em> nennen. Zu diesen
Superkräften gehören folgende Fähigkeiten:</p>
<ul>
<li>Dereferenzieren eines Rohzeigers</li>
<li>Aufrufen einer unsicheren Funktion oder Methode</li>
<li>Zugreifen auf oder Ändern einer veränderbaren statischen Variablen</li>
<li>Implementieren eines unsicheren Merkmals (trait)</li>
<li>Zugreifen auf Feldern in <code>union</code></li>
</ul>
<p>Es ist wichtig zu verstehen, dass <code>unsafe</code> weder den Ausleihenprüfer (borrow
checker) abschaltet noch andere Sicherheitsprüfungen von Rust deaktiviert: Wenn
du eine Referenz in einem unsicheren Code verwendest, wird diese trotzdem
geprüft. Das Schlüsselwort <code>unsafe</code> gibt dir nur Zugriff auf diese fünf
Funktionalitäten, die dann vom Compiler nicht auf Speichersicherheit geprüft
werden. In einem unsicheren Block erhältst du immer noch ein gewisses Maß an
Sicherheit.</p>
<p>Darüber hinaus bedeutet <code>unsafe</code> nicht, dass der Code innerhalb des Blocks
notwendigerweise gefährlich ist oder dass er definitiv
Speichersicherheitsprobleme haben wird: Das Ziel ist, dass du als Programmierer
sicherstellst, dass der Code innerhalb eines <code>unsafe</code>-Blocks auf gültige Weise
auf den Speicher zugreifen wird.</p>
<p>Menschen sind fehlbar und Fehler werden passieren, aber wenn du verlangst, dass
diese fünf unsicheren Operationen innerhalb von Blöcken mit dem Vermerk
<code>unsafe</code> durchgeführt werden müssen, weißt du, dass alle Fehler im Zusammenhang
mit der Speichersicherheit innerhalb eines <code>unsafe</code>-Blocks liegen müssen. Halte
<code>unsafe</code>-Blöcke klein; du wirst später dankbar sein, wenn du Speicherfehler
untersuchst.</p>
<p>Um unsicheren Code so weit wie möglich zu isolieren, ist es am besten,
unsicheren Code in eine sichere Abstraktion einzupacken und eine sichere API
bereitzustellen, auf die wir später im Kapitel eingehen werden, wenn wir
unsichere Funktionen und Methoden untersuchen. Teile der Standardbibliothek
sind als sichere Abstraktionen über unsicheren, geprüften Code implementiert.
Das Einpacken von unsicherem Code in eine sichere Abstraktion verhindert, dass
sich die Verwendung von <code>unsafe</code> auf alle Stellen auswirkt, an denen du oder
deine Benutzer die mit <code>unsafe</code>-Code implementierte Funktionalität verwenden
möchtest, da das Verwenden einer sicheren Abstraktion sicher ist.</p>
<p>Betrachten wir der Reihe nach jede der fünf unsicheren Superkräfte. Wir werden
uns auch einige Abstraktionen ansehen, die eine sichere Schnittstelle zu
unsicheren Codes bieten.</p>
<h3 id="dereferenzieren-eines-rohzeigers"><a class="header" href="#dereferenzieren-eines-rohzeigers">Dereferenzieren eines Rohzeigers</a></h3>
<p>In Kapitel 4 haben wir im Abschnitt <a href="ch04-02-references-and-borrowing.html#h%C3%A4ngende-referenzen">„Hängende
Referenzen“</a> erwähnt, dass der Compiler sicherstellt,
dass Referenzen immer gültig sind. Unsicheres Rust hat zwei neue Typen namens
<em>Rohzeiger</em> (raw pointers), die ähnlich wie Referenzen sind. Wie bei Referenzen
können Rohzeiger unveränderbar oder veränderbar sein und werden als <code>*const T</code> bzw. <code>*mut T</code> geschrieben. Das Sternchen ist nicht der
Dereferenzierungsoperator (dereference operator); es ist Teil des Typnamens. Im
Zusammenhang mit Rohzeigern bedeutet <em>unveränderbar</em> (immutable), dass der
Zeiger nach der Dereferenzierung nicht direkt zugewiesen werden kann.</p>
<p>Rohzeiger sind anders als Referenzen und intelligente Zeiger:</p>
<ul>
<li>Sie dürfen die Ausleihregeln ignorieren, indem sie sowohl unveränderbare als
auch veränderbare Zeiger oder mehrere veränderbare Zeiger auf die gleiche
Stelle haben.</li>
<li>Sie zeigen nicht garantiert auf gültigen Speicher.</li>
<li>Sie dürfen null sein.</li>
<li>Sie implementieren keine automatische Bereinigung.</li>
</ul>
<p>Wenn du dich dagegen entscheidest, diese Garantien von Rust erzwingen zu
lassen, kannst du auf garantierte Sicherheit verzichten und stattdessen eine
höhere Performanz oder die Möglichkeit der Interaktion mit einer anderen
Sprache oder Hardware erhalten, für die die Rust-Garantien nicht gelten.</p>
<p>Codeblock 19-1 zeigt, wie man aus Referenzen einen unveränderbaren und einen
veränderbaren Rohzeiger erzeugt.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-1: Erstellen von Rohzeigern aus
Referenzen</span></p>
<p>Beachte, dass wir das Schlüsselwort <code>unsafe</code> in diesem Code nicht verwenden.
Wir können Rohzeiger in sicherem Code erzeugen; wir können nur keine Rohzeiger
außerhalb eines unsicheren Blocks dereferenzieren, wie du gleich sehen wirst.</p>
<p>Wir haben Rohzeiger erstellt, indem wir <code>as</code> angegeben haben, um eine
unveränderbare und eine veränderbare Referenz in die entsprechenden
Rohzeigertypen umzuwandeln (cast). Da wir sie direkt aus Referenzen erstellt
haben, deren Gültigkeit garantiert ist, wissen wir, dass diese speziellen
Rohzeiger gültig sind, aber wir können diese Annahme nicht für jeden beliebigen
Rohzeiger treffen.</p>
<p>Um das zu demonstrieren, werden wir als Nächstes einen Rohzeiger erstellen, bei
dem wir uns nicht sicher sein können, das er gültig ist. Codeblock 19-2 zeigt,
wie man einen Rohzeiger auf eine willkürliche Stelle im Speicher erstellt. Der
Versuch, willkürlichen Speicher zu verwenden, ist undefiniert: Es könnten Daten
an dieser Adresse vorhanden sein oder auch nicht, der Compiler könnte den Code
so optimieren, dass es keinen Speicherzugriff gibt, oder das Programm könnte
eine Schutzverletzung (segmentation fault) verursachen. Normalerweise gibt es
keinen guten Grund, Code wie diesen zu schreiben, aber es ist möglich.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-2: Erzeugen eines Rohzeigers auf eine
willkürliche Speicheradresse</span></p>
<p>Erinnere dich, dass wir Rohzeiger in sicherem Code erstellen können, aber wir
können keine Rohzeiger <em>dereferenzieren</em> und die Daten lesen, auf die gezeigt
wird. In Codeblock 19-3 wenden wir den Dereferenzierungsoperator <code>*</code> auf einen
Rohzeiger an, was einen <code>unsafe</code>-Block erfordert.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!(&quot;r1 ist: {}&quot;, *r1);
        println!(&quot;r2 ist: {}&quot;, *r2);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-3: Dereferenzieren von Rohzeigern innerhalb
eines <code>unsafe</code>-Blocks</span></p>
<p>Das Erstellen eines Zeigers schadet nicht; erst wenn wir versuchen, auf den
Wert zuzugreifen, auf den er zeigt, könnten wir es am Ende mit einem ungültigen
Wert zu tun haben.</p>
<p>Beachte auch, dass wir in Codeblock 19-1 und 19-3 die Rohzeiger <code>*const i32</code>
und <code>*mut i32</code> erstellt haben, die beide auf die gleiche Speicherstelle
zeigten, in der <code>num</code> gespeichert ist. Wenn wir stattdessen versucht hätten,
eine unveränderbare und einen veränderbare Referenz auf <code>num</code> zu erstellen,
hätte sich der Code nicht kompilieren lassen, weil die Eigentümerschaftsregeln
von Rust eine veränderbare Referenz nicht gleichzeitig mit unveränderbaren
Referenzen zulassen. Mit Rohzeigern können wir einen veränderbaren und
einen unveränderbaren Zeiger auf denselben Ort erstellen und Daten über den
veränderbaren Zeiger ändern, wodurch möglicherweise eine
Daten-Wettlaufsituation (data race) entsteht. Sei vorsichtig!</p>
<p>Warum solltest du bei all diesen Gefahren jemals Rohzeiger verwenden? Ein
Hauptanwendungsfall ist die Kopplung mit C-Code, wie du im nächsten Abschnitt
<a href="ch19-01-unsafe-rust.html#aufrufen-einer-unsicheren-funktion-oder-methode">„Aufrufen einer unsicheren Funktion oder
Methode“</a> sehen wirst. Ein
anderer Fall ist der Aufbau von sicheren Abstraktionen, die der Ausleihenprüfer
nicht versteht. Wir stellen unsichere Funktionen vor und betrachten dann ein
Beispiel für eine sichere Abstraktion, die unsicheren Code verwendet.</p>
<h3 id="aufrufen-einer-unsicheren-funktion-oder-methode"><a class="header" href="#aufrufen-einer-unsicheren-funktion-oder-methode">Aufrufen einer unsicheren Funktion oder Methode</a></h3>
<p>Die zweite Art von Operationen, die du in einem unsicheren Block ausführen
kannst, sind Aufrufe von unsicheren Funktionen. Unsichere Funktionen und
Methoden sehen genau wie reguläre Funktionen und Methoden aus, aber sie haben
ein zusätzliches <code>unsafe</code> vor dem Rest der Definition. Das Schlüsselwort
<code>unsafe</code> weist in diesem Zusammenhang darauf hin, dass die Funktion
Anforderungen hat, die wir einhalten müssen, wenn wir diese Funktion aufrufen,
denn Rust kann nicht garantieren, dass wir diese Anforderungen erfüllt haben.
Indem wir eine unsichere Funktion innerhalb eines <code>unsafe</code>-Blocks aufrufen,
sagen wir, dass wir die Dokumentation dieser Funktion gelesen haben und die
Verantwortung für die Einhaltung der Verträge der Funktion übernehmen.</p>
<p>Hier ist eine unsichere Funktion namens <code>dangerous</code>, die in ihrem Rumpf nichts
tut:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>Wir müssen die Funktion <code>dangerous</code> innerhalb eines separaten <code>unsafe</code>-Blocks
aufrufen. Wenn wir versuchen, <code>dangerous</code> ohne den <code>unsafe</code>-Block aufzurufen,
erhalten wir einen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p>Mit dem <code>unsafe</code>-Block versichern wir Rust, dass wir die Dokumentation der
Funktion gelesen haben, dass wir verstehen, wie sie richtig zu benutzen ist,
und dass wir überprüft haben, dass wir den Vertrag der Funktion erfüllen.</p>
<p>Rümpfe von unsicheren Funktionen sind effektiv <code>unsafe</code>-Blöcke, d.h. wir können
andere unsichere Operationen innerhalb einer unsicheren Funktion ausführen,
ohne einen weiteren <code>unsafe</code>-Block hinfügen zu müssen.</p>
<h4 id="erstellen-einer-sicheren-abstraktion-von-unsicherem-code"><a class="header" href="#erstellen-einer-sicheren-abstraktion-von-unsicherem-code">Erstellen einer sicheren Abstraktion von unsicherem Code</a></h4>
<p>Nur weil eine Funktion unsicheren Code enthält, bedeutet das nicht, dass wir
die gesamte Funktion als unsicher markieren müssen. Tatsächlich ist das
Einpacken von unsicherem Codes in eine sichere Funktion eine gängige
Abstraktion. Als Beispiel betrachten wir die Funktion <code>split_at_mut</code> aus der
Standardbibliothek, die unsicheren Code verwendet. Wir untersuchen, wie wir sie
implementieren könnten. Diese sichere Methode ist auf veränderbaren
Anteilstypen definiert: Sie nimmt einen Anteilstyp und macht zwei daraus, indem
sie den Anteilstyp an dem als Argument angegebenen Index teilt. Codeblock 19-4
zeigt, wie man <code>split_at_mut</code> verwendet.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-4: Verwenden der sicheren Funktion
<code>split_at_mut</code></span></p>
<p>Wir können diese Funktion nicht nur mit sicherem Rust implementieren. Ein
Versuch könnte in etwa wie in Codeblock 19-5 aussehen, der sich nicht
kompilieren lässt. Der Einfachheit halber implementieren wir <code>split_at_mut</code> als
Funktion und nicht als Methode und nur für Anteilstypen von <code>i32</code>-Werten, nicht
für einen generischen Typ <code>T</code>.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-5: Versuch einer Implementierung von
<code>split_at_mut</code> unter ausschließlicher Verwendung von sicherem Rust</span></p>
<p>Diese Funktion ermittelt zunächst die Gesamtlänge des Anteilstypen. Dann stellt
sie fest, dass der als Parameter angegebene Index innerhalb des Anteilstypen
liegt, indem sie prüft, ob er kleiner oder gleich der Länge ist. Die
Zusicherung (assertion) bedeutet, dass die Funktion abstürzt, wenn wir einen
Index übergeben, der größer als die Länge ist, bei der der Anteilstyp geteilt
werden soll, bevor sie versucht, diesen Index zu verwenden.</p>
<p>Dann geben wir zwei veränderbare Anteilstypen in einem Tupel zurück: Einen vom
Anfang des ursprünglichen Anteilstyps bis zum Index <code>mid</code> und einen weiteren
von <code>mid</code> bis zum Ende des Anteilstyps.</p>
<p>Wenn wir versuchen, den Code in Codeblock 19-5 zu kompilieren, erhalten wir
einen Fehler.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p>Der Ausleihenprüfer von Rust kann nicht verstehen, dass wir verschiedene Teile
des Anteilstyps ausleihen; er weiß nur, dass wir zweimal vom selben Anteilstyp
ausleihen. Das Ausleihen verschiedener Teile eines Anteilstyps ist
grundsätzlich in Ordnung, weil sich die beiden Anteilstypen nicht überlappen,
aber Rust ist nicht schlau genug, um das zu wissen. Wenn wir wissen, dass der
Code in Ordnung ist, Rust aber nicht, ist es an der Zeit, unsicheren Code zu
verwenden.</p>
<p>Codeblock 19-6 zeigt, wie man einen <code>unsafe</code>-Block, einen Rohzeiger und einige
Aufrufe unsicherer Funktionen verwendet, um die Implementierung von
<code>split_at_mut</code> zum Funktionieren zu bringen.</p>
<pre><pre class="playground"><code class="language-rust">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-6: Verwenden von unsicherem Codes bei der
Implementierung der Funktion <code>split_at_mut</code></span></p>
<p>Erinnere dich an Abschnitt <a href="ch04-03-slices.html">„Der Anteilstyp (slice)“</a> in
Kapitel 4, dass Anteilstypen Zeiger auf Daten und die Länge des Anteilstyps
sind. Wir verwenden die Methode <code>len</code>, um die Länge eines Anteilstyps zu
erhalten, und die Methode <code>as_mut_ptr</code>, um auf den Rohzeiger eines Anteilstyps
zuzugreifen. Da wir in diesem Fall einen veränderbaren Anteilstyp von
<code>i32</code>-Werten haben, gibt <code>as_mut_ptr</code> einen Rohzeiger vom Typ <code>*mut i32</code>
zurück, den wir in der Variable <code>ptr</code> gespeichert haben.</p>
<p>Wir halten an der Zusicherung fest, dass der Index <code>mid</code> innerhalb des
Anteilstyps liegt. Dann kommen wir zum unsicheren Code: Die Funktion
<code>slice::from_raw_parts_mut</code> nimmt einen Rohzeiger und eine Länge und erzeugt
einen Anteilstyp. Wir verwenden diese Funktion, um einen Anteilstyp zu
erstellen, der mit <code>ptr</code> beginnt und <code>mid</code> Elemente lang ist. Dann rufen wir
die Methode <code>add</code> auf <code>ptr</code> mit <code>mid</code> als Argument auf, um einen Rohzeiger
zu erhalten, der bei <code>mid</code> beginnt, und wir erzeugen einen Anteilstyp mit
diesem Zeiger und der verbleibenden Anzahl von Elementen nach <code>mid</code>.</p>
<p>Die Funktion <code>slice::from_raw_parts_mut</code> ist unsicher, weil sie einen Rohzeiger
nimmt und darauf vertrauen muss, dass dieser Zeiger gültig ist. Die Methode
<code>add</code> auf dem Rohzeiger ist ebenfalls unsicher, weil sie darauf vertrauen muss,
dass die Offset-Position ebenfalls ein gültiger Zeiger ist. Deshalb mussten wir
einen <code>unsafe</code>-Block um unsere Aufrufe von <code>slice::from_raw_parts_mut</code> und
<code>add</code> legen, damit wir sie aufrufen konnten. Wenn wir uns den Code ansehen und
die Zusicherung hinzufügen, dass <code>mid</code> kleiner oder gleich <code>len</code> sein muss,
können wir sagen, dass alle Rohzeiger innerhalb des <code>unsafe</code>-Blocks gültige
Zeiger auf Daten innerhalb des Anteilstyps sind. Dies ist eine akzeptable und
angemessene Verwendung von <code>unsafe</code>.</p>
<p>Beachte, dass wir die resultierende Funktion <code>split_at_mut</code> nicht als <code>unsafe</code>
markieren müssen, und wir können diese Funktion aus dem sicheren Rust aufrufen.
Wir haben eine sichere Abstraktion des unsicheren Codes mit einer
Implementierung der Funktion geschaffen, die <code>unsafe</code> Code auf sichere Weise
verwendet, weil sie nur gültige Zeiger aus den Daten erzeugt, auf die diese
Funktion Zugriff hat.</p>
<p>Im Gegensatz dazu würde die Verwendung von <code>slice::from_raw_parts_mut</code> in
Codeblock 19-7 wahrscheinlich abstürzen, wenn der Anteilstyp verwendet wird.
Dieser Code nimmt einen beliebigen Speicherplatz und erzeugt einen Anteilstyp
mit einer Länge von 10.000 Elementen.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-7: Erstellen eines Anteilstyps aus einer
beliebigen Speicherstelle</span></p>
<p>Wir besitzen den Speicher an dieser beliebigen Stelle nicht und es gibt keine
Garantie, dass der von diesem Code erzeugte Anteilstyp gültige <code>i32</code>-Werte
enthält. Der Versuch, <code>values</code> so zu benutzen, als ob er ein gültiger
Anteilstyp ist, führt zu undefiniertem Verhalten.</p>
<h4 id="verwenden-von-extern-funktionen-um-externen-code-aufzurufen"><a class="header" href="#verwenden-von-extern-funktionen-um-externen-code-aufzurufen">Verwenden von <code>extern</code>-Funktionen um externen Code aufzurufen</a></h4>
<p>Manchmal muss dein Rust-Code möglicherweise mit Code interagieren, der in einer
anderen Sprache geschrieben wurde. Hierfür hat Rust das Schlüsselwort <code>extern</code>,
das das Erstellen und Verwenden einer <em>Fremdfunktionsschnittstelle</em> (Foreign
Function Interface, kurz FFI) erleichtert. Eine FFI ist eine Möglichkeit für
eine Programmiersprache, Funktionen zu definieren und es einer anderen
(fremden) Programmiersprache zu ermöglichen, diese Funktionen aufzurufen.</p>
<p>In Codeblock 19-8 wird gezeigt, wie eine Integration der Funktion <code>abs</code> aus der
C-Standardbibliothek erfolgt. Funktionen, die in <code>extern</code>-Blöcken deklariert
sind, sind immer unsicher, wenn sie aus Rust Code aufgerufen werden. Der Grund
dafür ist, dass andere Sprachen die Regeln und Garantien von Rust nicht
erzwingen und Rust sie nicht überprüfen kann, sodass die Verantwortung für die
Sicherheit beim Programmierer liegt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolutwert von -3 gemäß C: {}&quot;, abs(-3));
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 19-8: Deklarieren und Aufrufen einer
<code>extern</code>-Funktion, die in einer anderen Sprache definiert wurde</span></p>
<p>Innerhalb des Blocks <code>extern &quot;C&quot;</code> listen wir die Namen und Signaturen von
externen Funktionen aus einer anderen Sprache auf, die wir aufrufen wollen. Der
Teil <code>&quot;C&quot;</code> definiert, welche <em>Binärschnittstelle</em> (application binary
interface, kurz ABI) die externe Funktion benutzt: Die ABI definiert, wie die
Funktion auf der technischen Ebene (assembly level) aufgerufen wird. Die ABI
<code>&quot;C&quot;</code> ist die gebräuchlichste und folgt der ABI der Programmiersprache C.</p>
<blockquote>
<h4 id="aufrufen-von-rust-funktionen-aus-anderen-sprachen"><a class="header" href="#aufrufen-von-rust-funktionen-aus-anderen-sprachen">Aufrufen von Rust-Funktionen aus anderen Sprachen</a></h4>
<p>Wir können auch <code>extern</code> verwenden, um eine Schnittstelle zu schaffen, die es
anderen Sprachen erlaubt, Rust-Funktionen aufzurufen. Anstelle eines
<code>extern</code>-Blocks fügen wir das Schlüsselwort <code>extern</code> hinzu und geben die zu
verwendende ABI unmittelbar vor dem Schlüsselwort <code>fn</code> der relevanten
Funktion an. Wir müssen auch eine Annotation <code>#[no_mangle]</code> hinzufügen, um
dem Rust-Compiler mitzuteilen, dass er den Namen dieser Funktion nicht
verändern soll. <em>Mangling</em> bedeutet, dass ein Compiler den Namen, den wir
einer Funktion gegeben haben, in einen anderen Namen ändert, der mehr
Informationen für andere Teile des Kompiliervorgangs enthält, aber weniger
menschenlesbar ist. Jeder Programmiersprachen-Compiler verändert Namen etwas
anders. Damit eine Rust-Funktion von anderen Sprachen aufgerufen werden kann,
müssen wir also die Namensveränderung des Rust-Compilers deaktivieren.</p>
<p>Im folgenden Beispiel machen wir die Funktion <code>call_from_c</code> von C-Code aus
zugänglich, nachdem sie in eine gemeinsame Bibliothek kompiliert und von C
gelinkt wurde:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Rust-Funktion von C aufgerufen!&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Diese Verwendung von <code>extern</code> erfordert kein <code>unsafe</code>.</p>
</blockquote>
<h3 id="zugreifen-oder-Ändern-einer-veränderbaren-statischen-variable"><a class="header" href="#zugreifen-oder-Ändern-einer-veränderbaren-statischen-variable">Zugreifen oder Ändern einer veränderbaren, statischen Variable</a></h3>
<p>In diesem Buch haben wir noch nicht über <em>globale Variablen</em> gesprochen, die
Rust zwar unterstützt, die aber wegen der Eigentümerschaftsregeln von Rust
problematisch sein können. Wenn zwei Stränge (threads) auf dieselbe
veränderbare, globale Variable zugreifen, kann dies zu einer
Daten-Wettlaufsituation (data race) führen.</p>
<p>In Rust werden globale Variablen als <em>statische</em> Variablen bezeichnet.
Codeblock 19-9 zeigt ein Beispiel für die Deklaration und Verwendung einer
statischen Variablen mit einem Zeichenkettenanteilstyp als Wert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hallo Welt!&quot;;

fn main() {
    println!(&quot;Name ist: {}&quot;, HELLO_WORLD);
}</code></pre></pre>
<p><span class="caption">Codeblock 19-9: Definieren und Verwenden einer
unveränderbaren, statischen Variablen</span></p>
<p>Statische Variablen ähneln Konstanten, die wir im Abschnitt <a href="ch03-01-variables-and-mutability.html#konstanten">„Unterschiede
zwischen Variablen und Konstanten“</a>
in Kapitel 3 besprochen haben. Die Namen von statischen Variablen stehen per
Konvention in <code>SCHREIENDER_SCHLANGENSCHRIFT</code>. Statische Variablen können nur
Referenzen mit der Lebensdauer <code>'static</code> speichern, was bedeutet, dass der
Rust-Compiler die Lebensdauer herausfinden kann, und wir brauchen sie nicht
explizit anzugeben. Der Zugriff auf eine unveränderbare, statische Variable
ist sicher.</p>
<p>Ein feiner Unterschied zwischen Konstanten und unveränderbaren, statischen
Variablen besteht darin, dass Werte in einer statischen Variable eine feste
Adresse im Speicher haben. Beim Verwenden des Wertes wird immer auf die
gleichen Daten zugegriffen. Konstanten hingegen dürfen ihre Daten duplizieren,
wann immer sie verwendet werden. Ein weiterer Unterschied besteht darin, dass
statische Variablen veränderbar sein können. Der Zugriff auf und die Änderung
von veränderbaren, statischen Variablen ist <em>unsicher</em>. Codeblock 19-10 zeigt,
wie man eine veränderbare, statische Variable namens <code>COUNTER</code> deklariert, auf
sie zugreift und sie modifiziert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 19-10: Lesen von und Schreiben in eine
veränderbare, statische Variable ist unsicher</span></p>
<p>Wie bei regulären Variablen spezifizieren wir die Veränderbarkeit mit dem
Schlüsselwort <code>mut</code>. Jeder Code, der <code>COUNTER</code> liest oder schreibt, muss
innerhalb eines <code>unsafe</code>-Blocks liegen. Dieser Code kompiliert und gibt
<code>COUNTER: 3</code> so, wie wir es erwarten würden, weil er nur einen einzigen Strang
hat. Wenn mehrere Stränge auf <code>COUNTER</code> zugreifen, würde dies wahrscheinlich zu
einer Daten-Wettlaufsituation führen.</p>
<p>Bei veränderbaren Daten, die global zugänglich sind, ist es schwierig,
sicherzustellen, dass es keine Daten-Wettlaufsituationen gibt, weshalb Rust
veränderbare, statische Variablen als unsicher betrachtet. Wann immer möglich,
ist es vorzuziehen, die in Kapitel 16 besprochenen Nebenläufigkeitstechniken
und Strang-sicheren, intelligenten Zeiger zu verwenden, damit der Compiler
prüft, ob der Datenzugriff von verschiedenen Strängen sicher ist.</p>
<h3 id="implementieren-eines-unsicheren-merkmals"><a class="header" href="#implementieren-eines-unsicheren-merkmals">Implementieren eines unsicheren Merkmals</a></h3>
<p>Wir können <code>unsafe</code> zum Implementieren eines unsicheren Merkmals (unsafe trait)
verwenden. Ein Merkmal ist unsicher, wenn mindestens eine ihrer Methoden eine
Invariante hat, die der Compiler nicht verifizieren kann. Wir können erklären,
dass ein Merkmal <code>unsafe</code> ist, indem wir das Schlüsselwort <code>unsafe</code> vor <code>trait</code>
einfügen und die Implementierung des Merkmals ebenfalls mit <code>unsafe</code> markieren,
wie in Codeblock 19-11 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // Methoden kommen hierhin
}

unsafe impl Foo for i32 {
    // Methoden-Implementierungen kommen hierhin
}

fn main() {}</code></pre></pre>
<p><span class="caption">Codeblock 19-11: Definition und Implementierung eines
unsicheren Merkmals</span></p>
<p>Indem wir <code>unsafe impl</code> verwenden, versprechen wir, dass wir die Invarianten
aufrechterhalten, die der Compiler nicht verifizieren kann.</p>
<p>Erinnere dich als Beispiel an die Marker-Merkmale <code>Sync</code> und <code>Send</code>, die wir im
Abschnitt <a href="ch16-04-extensible-concurrency-sync-and-send.html">„Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) <code>Sync</code> und
<code>Send</code>“</a> in Kapitel 16
besprochen haben: Der Compiler implementiert diese Merkmale automatisch, wenn
unsere Typen vollständig aus <code>Send</code>- und <code>Sync</code>-Typen zusammengesetzt sind.
Wenn wir einen Typ implementieren, der einen Typ enthält, der nicht <code>Send</code> oder
<code>Sync</code> ist, z.B. Rohzeiger, und wir diesen Typ als <code>Send</code> oder <code>Sync</code> markieren
wollen, müssen wir <code>unsafe</code> verwenden. Rust kann nicht überprüfen, ob unser Typ
die Garantien aufrechterhält, dass er sicher über Stränge gesendet oder von
mehreren Strängen aus zugegriffen werden kann; daher müssen wir diese Prüfungen
manuell durchführen und als solche mit <code>unsafe</code> kennzeichnen.</p>
<h3 id="zugreifen-auf-felder-einer-vereinigung-union"><a class="header" href="#zugreifen-auf-felder-einer-vereinigung-union">Zugreifen auf Felder einer Vereinigung (union)</a></h3>
<p>Die letzte Aktion, die nur mit <code>unsafe</code> funktioniert, ist der Zugriff auf
Felder einer <code>union</code>, die ähnlich zu einer <code>struct</code> ist, bei der aber immer nur
ein deklariertes Feld in einer bestimmten Instanz verwendet wird. Vereinigungen
werden hauptsächlich als Schnittstelle zu Vereinigungen in C-Code verwendet.
Der Zugriff auf Vereinigungsfelder ist unsicher, da Rust den Typ der Daten, die
derzeit in der Vereinigungsinstanz gespeichert sind, nicht garantieren kann.
Weitere Informationen über Vereinigung findest du in der
<a href="https://doc.rust-lang.org/reference/items/unions.html">Rust-Referenz</a>.</p>
<h3 id="wann-unsicheren-code-verwenden"><a class="header" href="#wann-unsicheren-code-verwenden">Wann unsicheren Code verwenden?</a></h3>
<p>Es ist nicht falsch oder gar verpönt, eine der fünf soeben besprochenen
Aktionen (Superkräfte) mit <code>unsafe</code> zu verwenden. Aber es ist kniffliger,
<code>unsafe</code> Code korrekt zu schreiben, weil der Compiler nicht helfen kann, die
Speichersicherheit aufrechtzuerhalten. Wenn du einen Grund hast, <code>unsafe</code> Code
zu verwenden, kannst du dies tun, und die explizite <code>unsafe</code>-Annotation macht
es einfacher, die Quelle von Problemen aufzuspüren, wenn sie auftreten.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fortgeschrittene-merkmale-traits"><a class="header" href="#fortgeschrittene-merkmale-traits">Fortgeschrittene Merkmale (traits)</a></h2>
<p>Merkmale behandelten wir als Erstes im Abschnitt <a href="ch10-02-traits.html">„Merkmale (traits):
Gemeinsames Verhalten definieren“</a> in Kapitel
10, aber wir haben die fortgeschrittenen Details nicht besprochen. Jetzt, da du
mehr über Rust weißt, können wir zum Kern der Sache kommen.</p>
<h3 id="spezifizieren-von-platzhaltertypen-in-merkmalsdefinitionen-mit-assoziierten-typen"><a class="header" href="#spezifizieren-von-platzhaltertypen-in-merkmalsdefinitionen-mit-assoziierten-typen">Spezifizieren von Platzhaltertypen in Merkmalsdefinitionen mit assoziierten Typen</a></h3>
<p><em>Assoziierte Typen</em> (associated types) verbinden einen Typ-Platzhalter mit
einem Merkmal, sodass die Definitionen der Merkmalsmethoden diese
Platzhaltertypen in ihren Signaturen verwenden können. Der Implementierer eines
Merkmals gibt den konkreten Typ an, der anstelle des Platzhaltertyps für die
jeweilige Implementierung verwendet werden soll. Auf diese Weise können wir ein
Merkmal definieren, das einige Typen verwendet, ohne dass wir genau wissen
müssen, um welche Typen es sich dabei handelt, bis das Merkmal implementiert
ist.</p>
<p>Wir haben die meisten der fortgeschrittenen Funktionalitäten in diesem Kapitel
als selten benötigt beschrieben. Assoziierte Typen liegen irgendwo dazwischen:
Sie werden seltener verwendet als die im Rest des Buches erläuterten
Funktionalitäten, aber häufiger als viele der anderen in diesem Kapitel
besprochenen Funktionalitäten.</p>
<p>Ein Beispiel für ein Merkmal mit einem assoziierten Typ ist das Merkmal
<code>Iterator</code>, das die Standardbibliothek zur Verfügung stellt. Der assoziierte
Typ wird <code>Item</code> genannt und steht für den Typ der Werte, über die der Typ, der
das Merkmal <code>Iterator</code> implementiert, iteriert. Die Definition des Merkmals
<code>Iterator</code> ist in Codeblock 19-12 zu sehen.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-12: Definition des Merkmals <code>Iterator</code>, das
einen assoziierten Typ <code>Item</code> hat</span></p>
<p>Der Typ <code>Item</code> ist ein Platzhalter und die Definition der Methode <code>next</code> zeigt,
dass sie Werte vom Typ <code>Option&lt;Self::Item&gt;</code> zurückgibt. Implementierungen des
Merkmals <code>Iterator</code> geben den konkreten Typ für <code>Item</code> an und die Methode
<code>next</code> gibt eine <code>Option</code> zurück, die einen Wert dieses konkreten Typs enthält.</p>
<p>Assoziierte Typen scheinen ein ähnliches Konzept wie generische Datentypen
(generics) zu sein, da letztere es uns ermöglichen, eine Funktion zu
definieren, ohne anzugeben, welche Typen sie handhaben kann. Um den Unterschied
zwischen den beiden Konzepten zu untersuchen, betrachten wir eine
Implementierung des Merkmals <code>Iterator</code> für einen Typ namens <code>Counter</code>, der
angibt, dass der <code>Item</code>-Typ <code>u32</code> ist:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --abschneiden--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Diese Syntax scheint mit der von generischen Datentypen vergleichbar zu sein.
Warum also nicht einfach das Merkmal <code>Iterator</code> mit generischen Datentypen
definieren, wie in Codeblock 19-13 gezeigt?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-13: Eine hypothetische Definition des
Merkmals <code>Iterator</code> unter Verwendung eines generischen Datentyps</span></p>
<p>Der Unterschied ist, dass wir beim Verwenden von generischen Datentypen, wie in
Codeblock 19-13, die Typen in jeder Implementierung annotieren müssen; da wir
auch <code>Iterator&lt;String&gt; for Counter</code> oder jeden anderen Typ implementieren
können, könnten wir mehrere Implementierungen von <code>Iterator</code> für <code>Counter</code>
haben. Mit anderen Worten, wenn ein Merkmal einen generischen Parameter hat,
kann es für einen Typ mehrfach implementiert werden, wobei die konkreten Typen
der generischen Typparameter jedes Mal geändert werden können. Wenn wir die
Methode <code>next</code> auf <code>Counter</code> verwenden, müssten wir Typ-Annotationen
bereitstellen, um anzugeben, welche Implementierung des <code>Iterators</code> wir
verwenden wollen.</p>
<p>Bei assoziierten Typen brauchen wir Typen nicht zu annotieren, weil wir ein
Merkmal auf einem Typ nicht mehrfach implementieren können. In Codeblock 19-12
mit der Definition, die assoziierte Typen verwendet, können wir nur einmal
wählen, was der Typ von <code>Item</code> sein wird, weil es nur einen <code>impl Iterator for Counter</code> geben kann. Wir müssen nicht angeben, dass wir einen Iterator von
<code>u32</code>-Werten überall dort haben wollen, wo wir <code>next</code> auf <code>Counter</code> aufrufen.</p>
<p>Assoziierte Typen werden auch Teil des Merkmal-Vertrags: Implementierer des
Merkmals müssen einen Typ bereitstellen, der für den Platzhalter des
assoziierten Typs steht. Assoziierte Typen haben oft einen Namen, der
beschreibt, wie der Typ verwendet werden soll, und das Dokumentieren des
assoziierten Typs in der API-Dokumentation ist eine gute Praxis.</p>
<h3 id="standardparameter-für-generische-typen-und-operatorüberladung"><a class="header" href="#standardparameter-für-generische-typen-und-operatorüberladung">Standardparameter für generische Typen und Operatorüberladung</a></h3>
<p>Wenn wir generische Typparameter verwenden, können wir einen konkreten
Standardtyp für den generischen Typ angeben. Dadurch entfällt die Notwendigkeit
für Implementierer des Merkmals, einen konkreten Typ anzugeben, wenn der
Standardtyp passt. Du gibst einen Standardtyp an, wenn du einen generischen Typ
mit der Syntax <code>&lt;PlaceholderType=ConcreteType&gt;</code> deklarierst.</p>
<p>Ein gutes Beispiel für eine Situation, in der diese Technik nützlich ist, ist
die <em>Operatorüberladung</em> (operator overloading), bei der du das Verhalten eines
Operators (wie <code>+</code>) in bestimmten Situationen anpasst.</p>
<p>Rust erlaubt es dir nicht, eigene Operatoren zu erstellen oder beliebige
Operatoren zu überladen. Aber du kannst die in <code>std::ops</code> aufgeführten
Operationen und entsprechenden Merkmale überladen, indem du die mit dem
Operator assoziierten Merkmale implementierst. Beispielsweise überladen wir in
Codeblock 19-14 den Operator <code>+</code>, um zwei <code>Point</code>-Instanzen zu addieren. Wir
tun dies, indem wir das Merkmal <code>Add</code> auf eine <code>Point</code>-Struktur implementieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
<p><span class="caption">Codeblock 19-14: Implementieren des Merkmals <code>Add</code>, um
den Operator <code>+</code> für <code>Point</code>-Instanzen zu überladen</span></p>
<p>Die Methode <code>add</code> addiert die <code>x</code>-Werte zweier <code>Point</code>-Instanzen und die
<code>y</code>-Werte zweier <code>Point</code>-Instanzen, um einen neuen <code>Point</code> zu erzeugen. Das
Merkmal <code>Add</code> hat einen assoziierten Typ namens <code>Output</code>, der den von der
Methode <code>add</code> zurückgegebenen Typ bestimmt.</p>
<p>Der generische Standardtyp in diesem Code befindet sich innerhalb des Merkmals
<code>Add</code>. Hier ist seine Definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code sollte allgemein bekannt aussehen: Ein Merkmal mit einer Methode
und einem assoziierten Typ. Der neue Teil ist <code>Rhs=Self</code>: Diese Syntax heißt
<em>Standardtypparameter</em> (default type parameters). Der generische Typparameter
<code>Rhs</code> (kurz für „right hand side“, engl. „rechte Seite“) definiert den Typ des
Parameters <code>rhs</code> in der Methode <code>add</code>. Wenn wir keinen konkreten Typ für <code>Rhs</code>
angeben, wenn wir das Merkmal <code>Add</code> implementieren, wird der Typ <code>Rhs</code>
standardmäßig auf <code>Self</code> gesetzt, was der Typ sein wird, auf dem wir <code>Add</code>
implementieren.</p>
<p>Als wir <code>Add</code> für <code>Point</code> implementiert haben, haben wir den Standardwert für
<code>Rhs</code> verwendet, weil wir zwei <code>Point</code>-Instanzen addieren wollten. Schauen wir
uns ein Beispiel für die Implementierung des Merkmals <code>Add</code> an, bei dem wir den
Typ <code>Rhs</code> anpassen wollen, anstatt den Standardwert zu verwenden.</p>
<p>Wir haben zwei Strukturen <code>Millimeters</code> und <code>Meters</code>, die Werte in
verschiedenen Einheiten enthalten. Diese dünne Umhüllung eines bestehenden Typs
in einer anderen Struktur ist als <em>Newtype-Muster</em> bekannt, das wir im
Abschnitt <a href="ch19-03-advanced-traits.html#verwenden-des-newtype-musters-zum-implementieren-von-externen-merkmalen-auf-externen-typen">„Verwenden des Newtype-Musters zum Implementieren von externen
Merkmalen auf externen Typen“</a> ausführlicher beschreiben. Wir wollen
Werte in Millimeter zu Werten in Meter addieren und die Implementierung von
<code>Add</code> die Umrechnung korrekt durchführen lassen. Wir können <code>Add</code> für
<code>Millimeters</code> mit <code>Meters</code> als <code>Rhs</code> implementieren, wie in Codeblock 19-15
gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-15: Implementieren des Merkmals <code>Add</code> auf
<code>Millimeters</code>, um <code>Millimeters</code> zu <code>Meters</code> zu addieren</span></p>
<p>Um <code>Millimeters</code> und <code>Meters</code> zu addieren, geben wir <code>impl Add&lt;Meters&gt;</code> an, um
den Wert des Parameters vom Typ <code>Rhs</code> zu setzen, anstatt den Standardwert
<code>Self</code> zu verwenden.</p>
<p>Du wirst Standardtypparameter auf zwei Arten verwenden:</p>
<ul>
<li>Um einen Typ zu erweitern, ohne bestehenden Code zu brechen.</li>
<li>Um eine Anpassung in bestimmten Fällen zu ermöglichen, die die meisten
Benutzer nicht benötigen.</li>
</ul>
<p>Das Merkmal <code>Add</code> der Standardbibliothek ist ein Beispiel für den zweiten
Zweck: Normalerweise addierst du zwei ähnliche Typen, aber das Merkmal <code>Add</code>
bietet die Möglichkeit, darüber hinausgehende Anpassungen vorzunehmen. Das
Verwenden eines Standardtypparameters in der Merkmalsdefinition <code>Add</code> bedeutet,
dass du den zusätzlichen Parameter die meiste Zeit nicht angeben musst. Mit
anderen Worten kann etwas Implementierungscode eingespart werden, was das
Verwenden des Merkmals erleichtert.</p>
<p>Der erste Zweck ist ähnlich zum zweiten, nur umgekehrt: Wenn du einem
vorhandenen Merkmal einen Typparameter hinzufügen möchtest, kannst du ihm einen
Standardwert geben, um eine Erweiterung der Funktionalität des Merkmals zu
ermöglichen, ohne den vorhandenen Implementierungscode zu brechen.</p>
<h3 id="vollständig-qualifizierte-syntax-zur-vereindeutigung-aufrufen-von-methoden-mit-gleichem-namen"><a class="header" href="#vollständig-qualifizierte-syntax-zur-vereindeutigung-aufrufen-von-methoden-mit-gleichem-namen">Vollständig qualifizierte Syntax zur Vereindeutigung: Aufrufen von Methoden mit gleichem Namen</a></h3>
<p>Nichts in Rust hindert ein Merkmal daran, eine Methode mit demselben Namen wie
die Methode eines anderen Merkmals zu haben, und Rust hindert dich auch nicht
daran, beide Merkmale auf einem Typ zu implementieren. Es ist auch möglich,
eine Methode direkt auf dem Typ mit dem gleichen Namen wie Methoden von
Merkmalen zu implementieren.</p>
<p>Wenn du Methoden mit dem gleichen Namen aufrufst, musst du Rust mitteilen,
welche du verwenden willst. Betrachte den Code in Codeblock 19-16, wo wir zwei
Merkmale <code>Pilot</code> und <code>Wizard</code> definiert haben, die beide eine Methode namens
<code>fly</code> haben. Wir implementieren dann beide Merkmale auf einem Typ <code>Human</code>, der
bereits eine Methode namens <code>fly</code> implementiert hat. Jede <code>fly</code>-Methode macht
etwas anderes.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;Hier spricht Ihr Kapitän.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Hoch!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*Wütend mit den Armen wedeln*&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-16: Zwei Merkmale sind so definiert, dass
sie eine Methode <code>fly</code> haben und auf dem Typ <code>Human</code> implementiert sind, und
eine Methode <code>fly</code> ist direkt auf dem Typ <code>Human</code> implementiert</span></p>
<p>Wenn wir <code>fly</code> auf einer Instanz von <code>Human</code> aufrufen, ruft der Compiler
standardmäßig die Methode auf, die direkt auf dem Typ implementiert ist, wie in
Codeblock 19-17 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Hier spricht Ihr Kapitän.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Hoch!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*Wütend mit den Armen wedeln*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
<p><span class="caption">Codeblock 19-17: Aufrufen von <code>fly</code> auf einer Instanz von
<code>Human</code></span></p>
<p>Wenn man diesen Code ausführt, wird <code>*Wütend mit den Armen wedeln*</code> ausgegeben,
was zeigt, dass Rust die Methode <code>fly</code>, die direkt auf <code>Human</code> implementiert
wurde, aufgerufen hat.</p>
<p>Um die Methoden <code>fly</code> entweder vom Merkmal <code>Pilot</code> oder vom Merkmal <code>Wizard</code>
aufzurufen, müssen wir eine explizitere Syntax verwenden, um anzugeben, welche
Methode <code>fly</code> wir meinen. Codeblock 19-18 demonstriert diese Syntax.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Hier spricht Ihr Kapitän.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Hoch!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*Wütend mit den Armen wedeln*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
<p><span class="caption">Codeblock 19-18: Angeben, welche Methode <code>fly</code> wir
aufrufen wollen</span></p>
<p>Das Angeben des Merkmalsnamens vor dem Methodennamen verdeutlicht Rust, welche
Implementierung von <code>fly</code> wir aufrufen wollen. Wir könnten auch
<code>Human::fly(&amp;person)</code> schreiben, was äquivalent zu <code>person.fly()</code> ist, das wir
in Codeblock 19-18 verwendet haben, aber das ist etwas länger zu schreiben, wenn
wir nicht vereindeutigen müssen.</p>
<p>Beim Ausführen dieses Codes wird Folgendes ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
Hier spricht Ihr Kapitän.
Hoch!
*Wütend mit den Armen wedeln*
</code></pre>
<p>Da die Methode <code>fly</code> einen Parameter <code>self</code> benötigt, könnte Rust, wenn wir
zwei <em>Typen</em> hätten, die beide ein <em>Merkmal</em> implementieren, herausfinden,
welche Implementierung eines Merkmals basierend auf dem Typ von <code>self</code> zu
verwenden ist.</p>
<p>Assoziierte Funktionen, die keine Methoden sind, haben jedoch keinen
<code>self</code>-Parameter. Wenn es mehrere Typen oder Merkmale gibt, die
Nicht-Methodenfunktionen mit demselben Funktionsnamen definieren, weiß Rust
nicht immer, welchen Typ du meinst, es sei denn, du verwendest eine
<em>voll-qualifizierte Syntax</em>. In Codeblock 19-19 erstellen wir zum Beispiel
ein Merkmal für ein Tierheim, das alle Hundebabys <em>Spot</em> nennen möchte. Wir
erstellen ein Merkmal <code>Animal</code> mit einer assoziierten Nicht-Methodenfunktion
<code>baby_name</code>. Das Merkmal <code>Animal</code> ist für die Struktur <code>Dog</code> implementiert, für
die wir auch direkt eine assoziierte Nicht-Methodenfunktionen <code>baby_name</code>
bereitstellen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Welpe&quot;)
    }
}

fn main() {
    println!(&quot;Ein Hundebaby wird {} genannt.&quot;, Dog::baby_name());
}</code></pre></pre>
<p><span class="caption">Codeblock 19-19: Ein Merkmal mit einer assoziierten
Funktion und ein Typ mit einer assoziierten Funktion desselben Namens, der das
Merkmal ebenfalls implementiert</span></p>
<p>Wir implementieren den Code für die Benennung aller Welpen Spot in der
assoziierten Funktion <code>baby_name</code>, die auf <code>Dog</code> definiert ist. Der Typ <code>Dog</code>
implementiert auch das Merkmal <code>Animal</code>, das Charakteristiken beschreibt, die
alle Tiere haben. Hundebabys werden Welpen genannt und das drückt sich in der
Implementierung des Merkmals <code>Animal</code> auf <code>Dog</code> in der Funktion <code>baby_name</code>
aus, die mit dem Merkmal <code>Animal</code> assoziiert ist.</p>
<p>In <code>main</code> rufen wir die Funktion <code>Dog::baby_name</code> auf, die die assoziierte
Funktion, die auf <code>Dog</code> definiert ist, direkt aufruft. Dieser Code gibt
Folgendes aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
Ein Hundebaby wird Spot genannt.
</code></pre>
<p>Diese Ausgabe ist nicht das, was wir wollten. Wir wollen die Funktion
<code>baby_name</code> aufrufen, die Teil des Merkmals <code>Animal</code> ist, das wir auf <code>Dog</code>
implementiert haben, sodass der Code <code>Ein Hundebaby wird Welpe genannt</code>
ausgibt. Die Technik der Angabe des Merkmalsnamens, die wir in Codeblock 19-18
verwendet haben, hilft hier nicht weiter; wenn wir <code>main</code> in den Code in
Codeblock 19-20 ändern, erhalten wir einen Kompilierfehler.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Welpe&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;Ein Hundebaby wird {} genannt.&quot;, Animal::baby_name());
}
</code></pre></pre>
<p><span class="caption">Codeblock 19-20: Versuch, die Funktion <code>baby_name</code> des
Merkmals <code>Animal</code> aufzurufen, aber Rust weiß nicht, welche Implementierung es
verwenden soll</span></p>
<p>Da <code>Animal::baby_name</code> keinen <code>self</code>-Parameter hat, und es andere Typen geben
könnte, die das Merkmal <code>Animal</code> implementieren, kann Rust nicht herausfinden,
welche Implementierung von <code>Animal::baby_name</code> wir wollen. Wir werden diesen
Kompilierfehler erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0283]: type annotations needed
  --&gt; src/main.rs:20:43
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^ cannot infer type
   |
   = note: cannot satisfy `_: Animal`

For more information about this error, try `rustc --explain E0283`.
error: could not compile `traits-example` due to previous error
</code></pre>
<p>Um zu vereindeutigen und Rust zu sagen, dass wir die Implementierung von
<code>Animal</code> für <code>Dog</code> verwenden wollen und nicht die Implementierung von <code>Animal</code>
für einen anderen Typ, müssen wir eine vollständig qualifizierte Syntax
verwenden. Codeblock 19-21 zeigt, wie man eine vollständig qualifizierte Syntax
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Welpe&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;Ein Hundebaby wird {} genannt.&quot;, &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
<p><span class="caption">Codeblock 19-21: Verwenden einer vollständig
qualifizierten Syntax, um anzugeben, dass wir die Funktion <code>baby_name</code> des
Merkmals <code>Animal</code> aufrufen wollen, wie sie auf <code>Dog</code> implementiert ist</span></p>
<p>Wir geben Rust mit einer Typ-Annotation innerhalb spitzer Klammern an, dass wir
die Methode <code>baby_name</code> des Merkmals <code>Animal</code>, die auf <code>Dog</code> implementiert ist,
aufrufen wollen, indem wir sagen, dass wir den Typ <code>Dog</code> für diesen
Funktionsaufruf als <code>Animal</code> behandeln wollen. Dieser Code wird nun ausgeben,
was wir wollen:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
Ein Hundebaby wird Welpe genannt.
</code></pre>
<p>Im Allgemeinen wird die vollständig qualifizierte Syntax wie folgt definiert:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>Für assoziierte Funktionen, die keine Methoden sind, gäbe es keinen <code>receiver</code>:
Es gäbe nur die Liste der anderen Argumente. Du könntest eine vollständig
qualifizierte Syntax überall dort verwenden, wo du Funktionen oder Methoden
aufrufst. Du darfst jedoch jeden Teil dieser Syntax weglassen, den Rust aus
anderen Informationen im Programm herausfinden kann. Du musst diese
ausführlichere Syntax nur in Fällen verwenden, in denen es mehrere
Implementierungen gibt, die denselben Namen verwenden, und Rust Hilfe benötigt,
um herauszufinden, welche Implementierung du aufrufen möchtest.</p>
<h3 id="verwenden-von-supermerkmalen-um-die-funktionalität-eines-merkmals-innerhalb-eines-anderen-merkmals-zu-erfordern"><a class="header" href="#verwenden-von-supermerkmalen-um-die-funktionalität-eines-merkmals-innerhalb-eines-anderen-merkmals-zu-erfordern">Verwenden von Supermerkmalen um die Funktionalität eines Merkmals innerhalb eines anderen Merkmals zu erfordern</a></h3>
<p>Manchmal kann es vorkommen, dass man eine Merkmals-Definition schreibt, die von
einem anderen Merkmal abhängt: Damit ein Typ das erste Merkmal implementieren
kann, muss dieser Typ auch das zweite Merkmal implementieren. Du würdest dies
tun, damit deine Merkmalsdefinition die zugehörigen Elemente des zweiten
Merkmals verwenden kann. Das Merkmal, auf das sich deine Merkmalsdefinition
stützt, wird als <em>Supermerkmal</em> (supertrait) deines Merkmals bezeichnet.</p>
<p>Nehmen wir zum Beispiel an, wir wollen ein Merkmal <code>OutlinePrint</code> mit einer
Methode <code>outline_print</code> erstellen, das einen bestimmten Wert so formatiert,
dass er in Sternchen eingerahmt ausgegeben wird. Das heißt, wenn wir eine
Struktur <code>Point</code> haben, die <code>Display</code> so implementiert, dass sie <code>(x, y)</code>
ausgibt, dann gibt der Aufruf von <code>outline_print</code> einer <code>Point</code>-Instanz, die
<code>1</code> für <code>x</code> und <code>3</code> für <code>y</code> hat, folgendes aus:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>Bei der Implementierung der Methode <code>outline_print</code> wollen wir die
Funktionalität des Merkmals <code>Display</code> nutzen. Daher müssen wir festlegen, dass
das Merkmal <code>OutlinePrint</code> nur bei Typen funktioniert, die auch <code>Display</code>
implementieren und die Funktionalität bieten, die <code>OutlinePrint</code> benötigt. Wir
können dies in der Merkmalsdefinition tun, indem wir <code>OutlinePrint: Display</code>
angeben. Diese Technik ähnelt dem Angeben einer Merkmalsabgrenzung (trait
bound) bei einem Merkmal. Codeblock 19-22 zeigt eine Implementierung des
Merkmals <code>OutlinePrint</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-22: Implementieren des Merkmals
<code>OutlinePrint</code>, das die Funktionalität von <code>Display</code> erfordert</span></p>
<p>Da wir festgelegt haben, dass <code>OutlinePrint</code> das Merkmal <code>Display</code> erfordert,
können wir die Funktion <code>to_string</code> verwenden, die automatisch für jeden Typ
implementiert wird, der <code>Display</code> implementiert. Wenn wir versuchen würden,
<code>to_string</code> zu verwenden, ohne einen Doppelpunkt und das Merkmal <code>Display</code> nach
dem Merkmalsnamen anzugeben, würden wir eine Fehlermeldung erhalten, die
besagt, dass keine Methode mit dem Namen <code>to_string</code> für den Typ <code>&amp;Self</code> im
aktuellen Gültigkeitsbereich gefunden wurde.</p>
<p>Lass uns sehen, was passiert, wenn wir versuchen, <code>OutlinePrint</code> auf einem Typ
zu implementieren, der <code>Display</code> nicht implementiert, z.B. die Struktur
<code>Point</code>:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
<p>Wir erhalten einen Fehler, der besagt, dass <code>Display</code> erforderlich, aber nicht
implementiert ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` due to previous error
</code></pre>
<p>Um dies zu beheben, implementieren wir <code>Display</code> auf <code>Point</code> und erfüllen die
Bedingung, die <code>OutlinePrint</code> erfordert, in etwa so:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
<p>Dann wird die Implementierung des Merkmals <code>OutlinePrint</code> auf <code>Point</code>
erfolgreich kompilieren und wir können <code>outline_print</code> auf einer
<code>Point</code>-Instanz aufrufen, um sie in Sternchen eingerahmt anzuzeigen.</p>
<h3 id="verwenden-des-newtype-musters-zum-implementieren-von-externen-merkmalen-auf-externen-typen"><a class="header" href="#verwenden-des-newtype-musters-zum-implementieren-von-externen-merkmalen-auf-externen-typen">Verwenden des Newtype-Musters zum Implementieren von externen Merkmalen auf externen Typen</a></h3>
<p>In Kapitel 10 im Abschnitt <a href="ch10-02-traits.html#ein-merkmal-f%C3%BCr-einen-typ-implementieren">„Ein Merkmal für einen Typ
implementieren“</a> erwähnten wir die Waisenregel,
die besagt, dass wir ein Merkmal nur dann auf einem Typ implementieren dürfen,
wenn entweder das Merkmal oder der Typ lokal in unserer Kiste (crate) vorhanden
ist. Es ist möglich, diese Einschränkung zu umgehen, indem man das
<em>Newtype-Muster</em> (newtype pattern) verwendet, bei dem ein neuer Typ in einer
Tupelstruktur erzeugt wird. (Wir haben Tupelstrukturen im Abschnitt <a href="ch05-01-defining-structs.html#verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen">„Verwenden
von Tupel-Strukturen ohne benannte Felder um verschiedene Typen zu
erzeugen“</a> in Kapitel 5 behandelt.) Die Tupelstruktur wird ein
Feld haben und eine dünne Verpackung um den Typ sein, für den wir ein Merkmal
implementieren wollen. Dann ist der Verpackungstyp lokal in unserer Kiste und
wir können das Merkmal auf dem Verpackungstyp (wrapper type) implementieren.
<em>Newtype</em> ist ein Begriff, der aus der Programmiersprache Haskell stammt. Beim
Verwenden dieses Musters gibt es keine Beeinträchtigung der Laufzeitperformanz
und der Verpackungstyp wird zur Kompilierzeit elidiert.</p>
<p>Nehmen wir als Beispiel an, wir wollen <code>Display</code> auf <code>Vec&lt;T&gt;</code> implementieren,
was uns die Waisenregel direkt verbietet, weil das Merkmal <code>Display</code> und der
Typ <code>Vec&lt;T&gt;</code> außerhalb unserer Kiste definiert sind. Wir können eine Struktur
<code>Wrapper</code> erstellen, die eine Instanz von <code>Vec&lt;T&gt;</code> enthält; dann können wir
<code>Display</code> auf <code>Wrapper</code> implementieren und den Wert <code>Vec&lt;T&gt;</code> verwenden, wie in
Codeblock 19-23 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;Hallo&quot;), String::from(&quot;Welt&quot;)]);
    println!(&quot;w = {}&quot;, w);
}</code></pre></pre>
<p><span class="caption">Codeblock 19-23: Erstellen eines Typs <code>Wrapper</code> um
<code>Vec&lt;String&gt;</code> zur Implementierung von <code>Display</code></span></p>
<p>Die Implementierung von <code>Display</code> verwendet <code>self.0</code>, um auf den inneren
<code>Vec&lt;T&gt;</code> zuzugreifen, da <code>Wrapper</code> eine Tupelstruktur ist und <code>Vec&lt;T&gt;</code> das
Element mit dem Index 0 im Tupel ist. Dann können wir die Funktionalität des
<code>Display</code>-Typs auf <code>Wrapper</code> verwenden.</p>
<p>Der Nachteil der Verwendung dieser Technik ist, dass <code>Wrapper</code> ein neuer Typ
ist, sodass er nicht die Methoden des Wertes hat, den er hält. Wir müssten alle
Methoden von <code>Vec&lt;T&gt;</code> direkt auf <code>Wrapper</code> implementieren, sodass die Methoden
an <code>self.0</code> delegieren, was uns erlauben würde, <code>Wrapper</code> genau wie einen
<code>Vec&lt;T&gt;</code> zu behandeln. Wenn wir wollten, dass der neue Typ jede Methode hat,
die der innere Typ hat, wäre es eine Lösung, das Merkmal <code>Deref</code> (das in
Kapitel 15 im Abschnitt <a href="ch15-02-deref.html">„Intelligente Zeiger wie normale Referenzen behandeln
mit dem Merkmal (trait) <code>Deref</code>“</a> behandelt wird) auf dem
<code>Wrapper</code> zu implementieren, um den inneren Typ zurückzugeben. Wenn wir nicht
wollen, dass der <code>Wrapper</code>-Typ alle Methoden des inneren Typs hat – zum
Beispiel, um das Verhalten des <code>Wrapper</code>-Typs einzuschränken – müssten
wir nur die Methoden manuell implementieren, die wir wollen.</p>
<p>Dieses Newtype-Muster ist auch dann nützlich, wenn keine Merkmale beteiligt
sind. Wechseln wir den Fokus und schauen wir uns einige fortgeschrittene
Möglichkeiten an, mit dem Typsystem von Rust zu interagieren.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fortgeschrittene-typen"><a class="header" href="#fortgeschrittene-typen">Fortgeschrittene Typen</a></h2>
<p>Das Rust-Typsystem weist einige Funktionalitäten auf, die wir bisher erwähnt,
aber noch nicht besprochen haben. Wir beginnen mit einer allgemeinen Diskussion
über Newtypes, während wir untersuchen, warum Newtypes als Typen nützlich sind.
Dann gehen wir zu Typ-Alias über, einer Funktionalität, die den Newtypes
ähnlich ist, aber eine etwas andere Semantik hat. Wir werden auch den Typ <code>!</code>
und dynamisch große Typen besprechen.</p>
<h3 id="verwenden-des-newtype-musters-für-typsicherheit-und-abstraktion"><a class="header" href="#verwenden-des-newtype-musters-für-typsicherheit-und-abstraktion">Verwenden des Newtype-Musters für Typsicherheit und Abstraktion</a></h3>
<blockquote>
<p>Hinweis: Der nächste Abschnitt geht davon aus, dass du den früheren Abschnitt
<a href="ch19-03-advanced-traits.html#verwenden-des-newtype-musters-zum-implementieren-von-externen-merkmalen-auf-externen-typen">„Verwenden des Newtype-Musters zum Implementieren von externen Merkmalen auf
externen Typen“</a> gelesen hast.</p>
</blockquote>
<p>Das Newtype-Muster ist auch für Aufgaben nützlich, die über die bisher
besprochenen hinausgehen, einschließlich statisch sicherzustellen, dass Werte
niemals verwechselt werden, und dem Angeben von Einheiten eines Wertes. Ein
Beispiel für die Verwendung von Newtypes zum Angeben von Einheiten hast du in
Codeblock 19-15 gesehen: Erinnere dich daran, dass die Strukturen <code>Millimeters</code>
und <code>Meters</code> <code>u32</code>-Werte in einem Newtype einpacken. Wenn wir eine Funktion mit
einem Parameter vom Typ <code>Millimeters</code> schreiben würden, könnten wir kein
Programm kompilieren, das versehentlich versucht, diese Funktion mit einem Wert
vom Typ <code>Meters</code> oder einem einfachen <code>u32</code> aufzurufen.</p>
<p>Wir können auch das Newtype-Muster verwenden, um einige Implementierungsdetails
eines Typs zu abstrahieren: Der neue Typ kann eine öffentliche API
bereitstellen, die sich von der API des privaten, inneren Typs unterscheidet.</p>
<p>Newtypes können auch die interne Implementierung verbergen. Zum Beispiel
könnten wir einen Typ <code>People</code> zur Verfügung stellen, um eine <code>HashMap&lt;i32, String&gt;</code> einzupacken, die die ID einer Person in Verbindung mit ihrem Namen
speichert. Code, der <code>People</code> verwendet, würde nur mit der öffentlichen API
interagieren, die wir zur Verfügung stellen, z.B. eine Methode, um eine
Namenszeichenkette zur <code>People</code>-Kollektion hinzuzufügen; dieser Code müsste
nicht wissen, dass wir Namen intern eine <code>i32</code>-ID zuordnen. Das Newtype-Muster
ist ein leichtgewichtiger Weg, eine Kapselung zu erreichen, um
Implementierungsdetails zu verbergen, die wir im Abschnitt <a href="ch17-01-what-is-oo.html#kapselung-die-implementierungsdetails-verbirgt">„Kapselung, die
Implementierungsdetails verbirgt“</a> in Kapitel 17 besprochen
haben.</p>
<h3 id="erstellen-von-typ-synonymen-mit-typ-alias"><a class="header" href="#erstellen-von-typ-synonymen-mit-typ-alias">Erstellen von Typ-Synonymen mit Typ-Alias</a></h3>
<p>Rust bietet die Möglichkeit, einen <em>Typ-Alias</em> zu deklarieren, um einem
vorhandenen Typ einen anderen Namen zu geben. Hierfür verwenden wir das
Schlüsselwort <code>type</code>. Zum Beispiel können wir den Alias <code>Kilometers</code> für <code>i32</code>
so anlegen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>Der Alias <code>Kilometers</code> ist ein <em>Synonym</em> für <code>i32</code>; im Gegensatz zu den Typen
<code>Millimeters</code> und <code>Meters</code>, die wir in Codeblock 19-15 erstellt haben, ist
<code>Kilometers</code> kein separater, neuer Typ. Werte, die den Typ <code>Kilometers</code> haben,
werden genauso behandelt wie Werte des Typs <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}</span></code></pre></pre>
<p>Da <code>Kilometers</code> und <code>i32</code> vom gleichen Typ sind, können wir Werte beider Typen
addieren und wir können <code>Kilometers</code>-Werte an Funktionen übergeben, die
<code>i32</code>-Parameter verwenden. Mit dieser Methode erhalten wir jedoch nicht die
Vorteile der Typprüfung, die wir vom zuvor besprochenen Newtype-Muster haben.
Mit anderen Worten, wenn wir irgendwo <code>Kilometers</code>- und <code>i32</code>-Werte
verwechseln, wird uns der Compiler keinen Fehler anzeigen.</p>
<p>Der Hauptanwendungsfall für Typ-Synonyme ist das Reduzieren von Wiederholungen.
Zum Beispiel könnten wir einen längeren Typ wie diesen haben:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>Das Schreiben dieses langen Typs in Funktionssignaturen und als
Typ-Annotationen im gesamten Code kann ermüdend und fehleranfällig sein. Stelle
dir vor, du hättest ein Projekt voller Code wie das in Codeblock 19-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hallo&quot;));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --abschneiden--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --abschneiden--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-24: Verwenden eines langen Typs an vielen
Stellen</span></p>
<p>Ein Typ-Alias macht diesen Code leichter handhabbar, indem er die Wiederholung
reduziert. In Codeblock 19-25 haben wir einen Alias namens <code>Thunk</code> für den
verbosen Typ eingeführt und können alle Verwendungen des Typs durch den
kürzeren Alias <code>Thunk</code> ersetzen.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;hallo&quot;));

    fn takes_long_type(f: Thunk) {
        // --abschneiden--
    }

    fn returns_long_type() -&gt; Thunk {
        // --abschneiden--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-25: Einführen eines Typ-Alias <code>Thunk</code> zur
Reduzierung von Wiederholungen</span></p>
<p>Dieser Code ist viel einfacher zu lesen und zu schreiben! Die Wahl eines
aussagekräftigen Namens für einen Typ-Alias kann auch helfen, deine Absicht zu
kommunizieren (<em>thunk</em> ist ein Wort für Code, der zu einem späteren Zeitpunkt
ausgewertet wird, also ein passender Name für einen Funktionsabschluss
(closure), der gespeichert wird).</p>
<p>Typ-Alias werden auch häufig mit dem Typ <code>Result&lt;T, E&gt;</code> verwendet, um
Wiederholungen zu reduzieren. Betrachte das Modul <code>std::io</code> in der
Standardbibliothek. E/A-Operationen geben oft ein <code>Result&lt;T, E&gt;</code> zurück, um
Situationen zu behandeln, in denen Operationen nicht funktionieren. Diese
Bibliothek hat eine Struktur <code>std::io::Error</code>, die alle möglichen E/A-Fehler
repräsentiert. Viele der Funktionen in <code>std::io</code> geben <code>Result&lt;T, E&gt;</code> zurück,
wobei für <code>E</code> der Typ <code>std::io::Error</code> verwendet wird, so wie bei diesen
Funktionen im Merkmal (trait) <code>Write</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>Result&lt;..., Error&gt;</code> wird oft wiederholt. Daher hat <code>std::io</code> diese Art von
Alias-Deklaration:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>Da sich diese Deklaration im Modul <code>std::io</code> befindet, können wir den
vollständig qualifizierten Alias <code>std::io::Result&lt;T&gt;</code> verwenden; das ist
ein <code>Result&lt;T, E&gt;</code> mit <code>E</code> als <code>std::io::Error</code>. Die Funktionssignaturen des
Merkmals <code>Write</code> sehen am Ende so aus:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>Der Typ-Alias hilft in zweierlei Hinsicht: Er macht es einfacher, Code zu
schreiben <em>und</em> er gibt uns eine konsistente Schnittstelle innerhalb <code>std::io</code>.
Weil es ein Alias ist, ist es nur ein weiteres <code>Result&lt;T, E&gt;</code>, was bedeutet,
dass wir alle Methoden, die mit <code>Result&lt;T, E&gt;</code> funktionieren, mit ihm verwenden
können, einschließlich spezieller Syntax wie der <code>?</code>-Operator.</p>
<h3 id="der-niemals-typ-der-niemals-zurückkehrt"><a class="header" href="#der-niemals-typ-der-niemals-zurückkehrt">Der Niemals-Typ, der niemals zurückkehrt</a></h3>
<p>Rust hat einen speziellen Typ namens <code>!</code>, der im Fachjargon der Typtheorie als
<em>leerer Typ</em> (empty type) bekannt ist, weil er keine Werte hat. Wir ziehen es
vor, ihn den <em>Niemals-Typ</em> (never type) zu nennen, weil er an der Stelle des
Rückgabetyps steht, wenn eine Funktion niemals zurückkehrt. Hier ist ein
Beispiel:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --abschneiden--
<span class="boring">    panic!();
</span>}</code></pre>
<p>Dieser Code wird als „die Funktion <code>bar</code> kehrt niemals zurück“ gelesen.
Funktionen, die niemals zurückkehren, werden <em>divergierende Funktionen</em>
(diverging functions) genannt. Wir können keine Werte vom Typ <code>!</code> erzeugen,
also kann <code>bar</code> niemals zurückkehren.</p>
<p>Aber was nützt ein Typ, für den man nie Werte erzeugen kann? Erinnere dich an
den Code aus Codeblock 2-5, der Teil des Zahlenratespiels ist; wir haben einen
Teil davon hier in Codeblock 19-26 wiedergegeben.</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Geheimzahl ist: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --abschneiden--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;Du hast geschätzt: {}&quot;, guess);
</span><span class="boring">
</span><span class="boring">        // --abschneiden--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Du hast gewonnen!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 19-26: Ein <code>match</code> mit einem Zweig, der in
<code>continue</code> endet</span></p>
<p>Damals haben wir einige Details in diesem Code übersprungen. In Kapitel 6 des
Abschnitts <a href="ch06-02-match.html">„Das Kontrollflusskonstrukt <code>match</code>“</a> haben wir
erwähnt, dass alle Zweige den gleichen Typ zurückgeben müssen. So funktioniert
zum Beispiel der folgende Code nicht:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">    let guess = &quot;3&quot;;
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;hallo&quot;,
    };
<span class="boring">}</span></code></pre></pre>
<p>Der Typ von <code>guess</code> in diesem Code müsste eine ganze Zahl <em>und</em> eine
Zeichenkette sein und Rust verlangt, dass <code>guess</code> nur einen Typ hat. Was gibt
also <code>continue</code> zurück? Wie war es uns erlaubt, ein <code>u32</code> von einem Zweig
zurückzugeben und einen anderen Zweig zu haben, der in Codeblock 19-26 mit
<code>continue</code> endet?</p>
<p>Wie du vielleicht schon vermutet hast, hat <code>continue</code> einen <code>!</code>-Wert. Das
heißt, wenn Rust den Typ von <code>guess</code> berechnet, betrachtet es beide
<code>match</code>-Zweige, den ersten mit einem Wert von <code>u32</code> und den zweiten mit einem
<code>!</code>-Wert. Da <code>!</code> niemals einen Wert haben kann, entscheidet Rust, dass <code>guess</code>
den Typ <code>u32</code> hat.</p>
<p>Der formale Weg, dieses Verhalten zu beschreiben, besteht darin, dass Ausdrücke
vom Typ <code>!</code> in jeden anderen Typ umgewandelt werden können. Es ist uns erlaubt,
diesen <code>match</code>-Zweig mit <code>continue</code> zu beenden, weil <code>continue</code> keinen Wert
zurückgibt; stattdessen bringt es die Kontrolle zurück an den Anfang der
Schleife, sodass wir im <code>Err</code>-Fall <code>guess</code> niemals einen Wert zuweisen.</p>
<p>Der Niemals-Typ ist auch beim Makro <code>panic!</code> nützlich. Erinnere dich an die
Funktion <code>unwrap</code>, die wir auf <code>Option&lt;T&gt;</code> Werte aufrufen, um einen Wert zu
erzeugen oder das Programm abstürzen zu lassen. Hier ist ihre Definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;Aufruf von `Option::unwrap()` auf einem `None`-Wert&quot;),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In diesem Code geschieht dasselbe wie bei <code>match</code> in Codeblock 19-26: Rust
sieht, dass <code>val</code> den Typ <code>T</code> und <code>panic!</code> den Typ <code>!</code> hat, sodass das Ergebnis
des gesamten <code>match</code>-Ausdrucks <code>T</code> ist. Dieser Code funktioniert, weil <code>panic!</code>
keinen Wert produziert; es beendet das Programm. Im Fall von <code>None</code> geben wir
keinen Wert von <code>unwrap</code> zurück, also ist dieser Code gültig.</p>
<p>Ein letzter Ausdruck, der den Typ <code>!</code> hat, ist <code>loop</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    print!(&quot;für immer &quot;);

    loop {
        print!(&quot;und ewig &quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p>Hier endet die Schleife nie, also ist <code>!</code> der Typ des Ausdrucks. Dies wäre
jedoch nicht der Fall, wenn wir <code>break</code> einfügen würden, da die Schleife enden
würde, wenn sie bei <code>break</code> ankommt.</p>
<h3 id="dynamisch-große-typen-und-das-merkmal-sized"><a class="header" href="#dynamisch-große-typen-und-das-merkmal-sized">Dynamisch große Typen und das Merkmal <code>Sized</code></a></h3>
<p>Rusts muss bestimmte Details über seine Typen kennen, z.B. wie viel Platz für
einen Wert eines bestimmten Typs zuzuweisen ist. Das lässt eine Ecke des
Typsystems zunächst etwas verwirrend erscheinen: Das Konzept der <em>dynamisch
großen Typen</em> (dynamically sized types). Diese Typen, die manchmal als <em>DSTs</em>
oder <em>Typen ohne Größe</em> (unsized types) bezeichnet werden, erlauben es uns,
Code mit Werten zu schreiben, deren Größe wir nur zur Laufzeit kennen können.</p>
<p>Schauen wir uns die Details eines dynamisch großen Typs namens <code>str</code> an, den
wir im ganzen Buch verwendet haben. Das stimmt, nicht <code>&amp;str</code>, sondern <code>str</code> an
sich ist ein DST. Wir können nicht wissen, wie lang die Zeichenkette zur
Laufzeit ist, d.h. wir können weder eine Variable vom Typ <code>str</code> erzeugen, noch
können wir ein Argument vom Typ <code>str</code> nehmen. Betrachte den folgenden Code, der
nicht funktioniert:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s1: str = &quot;Guten Tag!&quot;;
    let s2: str = &quot;Wie geht es dir?&quot;;

<span class="boring">}</span></code></pre></pre>
<p>Rust muss wissen, wie viel Speicher jedem Wert eines bestimmten Typs zuzuweisen
ist, und alle Werte eines Typs müssen die gleiche Speichermenge verwenden. Wenn
Rust uns erlauben würde, diesen Code zu schreiben, müssten diese beiden
<code>str</code>-Werte die gleiche Speichermenge beanspruchen. Aber sie haben
unterschiedliche Längen: <code>s1</code> benötigt 10 Bytes Speicherplatz und <code>s2</code> 16
Bytes. Aus diesem Grund ist es nicht möglich, eine Variable zu erzeugen, die
einen dynamisch großen Typ enthält.</p>
<p>Was sollen wir also tun? In diesem Fall kennst du die Antwort bereits: Wir
machen die Typen <code>s1</code> und <code>s2</code> zu einem <code>&amp;str</code> anstatt zu einem <code>str</code>. Erinnere
dich, dass wir im Abschnitt <a href="ch04-03-slices.html#zeichenkettenanteilstypen-string-slices">„Zeichenkettenanteilstypen
(string slices)“</a> in Kapitel 4 gesagt haben, dass die
Anteilstypen-Datenstruktur die Startposition und die Länge des Anteilstyps
speichert.</p>
<p>Obwohl also <code>&amp;T</code> ein einzelner Wert ist, der die Speicheradresse des Ortes
speichert, an dem sich <code>T</code> befindet, hat <code>&amp;str</code> <em>zwei</em> Werte: Die Adresse von
<code>str</code> und seine Länge. Als solches können wir die Größe eines <code>&amp;str</code>-Wertes zur
Kompilierzeit kennen: Er ist doppelt so lang wie ein <code>usize</code>. Das heißt, wir
wissen immer die Größe einer <code>&amp;str</code>, egal wie lang die Zeichenkette ist, auf
die sie sich bezieht. Im Allgemeinen werden in Rust Typen mit dynamischer Größe
auf diese Weise verwendet: Sie haben ein zusätzliches Stück Metadaten, das die
Größe der dynamischen Information speichert. Die goldene Regel für Typen
dynamischer Größe lautet, dass wir Werte von Typen mit dynamischer Größe immer
hinter eine Art Zeiger stellen müssen.</p>
<p>Wir können <code>str</code> mit allen Arten von Zeigern kombinieren: Zum Beispiel
<code>Box&lt;str&gt;</code> oder <code>Rc&lt;str&gt;</code>. Tatsächlich hast du das schon einmal gesehen, aber
mit einem anderen dynamisch großen Typ: Merkmale (traits). Jedes Merkmal ist
ein dynamisch großer Typ, auf den wir uns beziehen können, indem wir den Namen
des Merkmals verwenden. In Kapitel 17 im Abschnitt <a href="ch17-02-trait-objects.html">„Merkmalsobjekte (trait
objects) die Werte unterschiedlicher Typen erlauben“</a>
haben wir erwähnt, dass wir, um Merkmale als Merkmalsobjekte zu verwenden,
diese hinter einen Zeiger setzen müssen, z.B. <code>&amp;dyn Trait</code> oder <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> würde auch funktionieren).</p>
<p>Um mit DSTs zu arbeiten, hat Rust das Merkmal <code>Sized</code>, um zu bestimmen, ob die
Größe eines Typs zur Kompilierzeit bekannt ist oder nicht. Dieses Merkmal wird
automatisch für alles implementiert, dessen Größe zur Kompilierzeit bekannt
ist. Zusätzlich fügt Rust implizit jeder generischen Funktion eine
Merkmalsabgrenzung auf <code>Sized</code> hinzu. Das heißt, eine generische
Funktionsdefinition wie diese:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T&gt;(t: T) {
    // --abschneiden--
}
<span class="boring">}</span></code></pre></pre>
<p>wird tatsächlich so behandelt, als hätten wir das geschrieben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: Sized&gt;(t: T) {
    // --abschneiden--
}
<span class="boring">}</span></code></pre></pre>
<p>Standardmäßig funktionieren generische Funktionen nur bei Typen, die zur
Kompilierzeit eine bekannte Größe haben. Du kannst jedoch die folgende
spezielle Syntax verwenden, um diese Einschränkung zu lockern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --abschneiden--
}
<span class="boring">}</span></code></pre></pre>
<p>Eine Merkmalsabgrenzung durch <code>?Sized</code> bedeutet „<code>T</code> kann <code>Sized</code> sein oder
nicht“ und diese Notation hebt die Vorgabe auf, dass generische Typen zur
Kompilierzeit eine bekannte Größe haben müssen. Die Syntax <code>?Trait</code> mit dieser
Bedeutung ist nur für <code>Sized</code> verfügbar, nicht für andere Merkmale.</p>
<p>Beachte auch, dass wir den Typ des Parameters <code>t</code> von <code>T</code> auf <code>&amp;T</code> geändert
haben. Da der Typ möglicherweise nicht <code>Sized</code> ist, müssen wir ihn hinter einer
Art Zeiger verwenden. In diesem Fall haben wir eine Referenz gewählt.</p>
<p>Als nächstes werden wir über Funktionen und Funktionsabschlüsse sprechen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="erweiterte-funktionen-und-funktionsabschlüsse-closures"><a class="header" href="#erweiterte-funktionen-und-funktionsabschlüsse-closures">Erweiterte Funktionen und Funktionsabschlüsse (closures)</a></h2>
<p>Dieser Abschnitt befasst sich mit fortgeschrittenen Funktionalitäten im
Zusammenhang mit Funktionen und Funktionsabschlüsse, einschließlich
Funktionszeigern und Zurückgeben von Funktionsabschlüssen.</p>
<h3 id="funktionszeiger"><a class="header" href="#funktionszeiger">Funktionszeiger</a></h3>
<p>Wir haben darüber gesprochen, wie man Funktionsabschlüsse an Funktionen
übergibt; man kann auch reguläre Funktionen an Funktionen übergeben! Diese
Technik ist nützlich, wenn du eine Funktion, die du bereits definiert hast,
übergeben willst, anstatt einen neuen Funktionsabschluss zu definieren.
Funktionen haben den Typ <code>fn</code> (mit kleinem f), nicht zu verwechseln mit dem
Funktionsabschlussmerkmal (closure trait) <code>Fn</code>. Der Typ <code>fn</code> wird
<em>Funktionszeiger</em> (function pointer) genannt. Die Übergabe von Funktionen mit
Funktionszeigern ermöglicht es dir, Funktionen als Argumente für andere
Funktionen zu verwenden.</p>
<p>Die Syntax für die Angabe, dass ein Parameter ein Funktionszeiger ist, ähnelt
der von Funktionsabschlüssen, wie in Codeblock 19-27 gezeigt, wo wir eine
Funktion <code>add_one</code> definiert haben, die ihrem Parameter eins hinzufügt. Die
Funktion <code>do_twice</code> nimmt zwei Parameter entgegen: Einen Funktionszeiger auf
eine beliebige Funktion mit einem <code>i32</code>-Parameter und einem <code>i32</code>-Rückgabewert,
und einen <code>i32</code>-Parameter. Die Funktion <code>do_twice</code> ruft die Funktion <code>f</code>
zweimal auf, übergibt ihr den Wert <code>arg</code> und addiert dann die Ergebnisse der
beiden Funktionsaufrufe zusammen. Die Funktion <code>main</code> ruft <code>do_twice</code> mit den
Argumenten <code>add_one</code> und <code>5</code> auf.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;Die Antwort ist: {}&quot;, answer);
}</code></pre></pre>
<p><span class="caption">Codeblock 19-27: Verwenden des Typs <code>fn</code> zum
Entgegennehmen eines Funktionszeigers als Argument</span></p>
<p>Dieser Code gibt <code>Die Antwort ist: 12</code> aus. Wir spezifizieren, dass der
Parameter <code>f</code> in <code>do_twice</code> ein <code>fn</code> ist, das einen Parameter vom Typ <code>i32</code>
nimmt und ein <code>i32</code> zurückgibt. Wir können dann <code>f</code> im Rumpf von <code>do_twice</code>
aufrufen. In <code>main</code> können wir den Funktionsnamen <code>add_one</code> als erstes Argument
an <code>do_twice</code> übergeben.</p>
<p>Im Gegensatz zu Funktionsabschlüssen ist <code>fn</code> ein Typ, nicht ein Merkmal, daher
spezifizieren wir <code>fn</code> direkt als Parametertyp, anstatt einen generischen
Typparameter mit einem Merkmal <code>Fn</code> als Merkmalsabgrenzung (trait bound) zu
deklarieren.</p>
<p>Funktionszeiger implementieren alle drei Funktionsabschlussmerkmale (<code>Fn</code>,
<code>FnMut</code> und <code>FnOnce</code>), was bedeutet, dass du immer einen Funktionszeiger als
Argument an eine Funktion übergeben kannst, die einen Funktionsabschluss
erwartet. Es ist am besten, Funktionen mit einem generischen Typ und einer der
Funktionsabschlussmerkmale zu schreiben, sodass deine Funktionen entweder
Funktionen oder Funktionsabschlüsse akzeptieren können.</p>
<p>Ein Beispiel, bei dem du nur <code>fn</code> und keine Funktionsabschlüsse akzeptieren
möchtest, ist die Schnittstelle zu externem Code, der keine Funktionsabschlüsse
hat: C-Funktionen können Funktionen als Argumente akzeptieren, aber C hat keine
Funktionsabschlüsse.</p>
<p>Als Beispiel dafür, wo du entweder einen inline definierten Funktionsabschluss
oder eine benannte Funktion verwenden könntest, sehen wir uns die Verwendung
der Methode <code>map</code> an, die vom Merkmal <code>Iterator</code> in der Standardbibliothek
bereitgestellt wird. Um die Funktion <code>map</code> zu verwenden, um einen Vektor von
Zahlen in einen Vektor von Zeichenketten zu verwandeln, könnten wir einen
Funktionsabschluss wie diesen verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<p>Oder wir könnten eine Funktion als Argument für <code>map</code> angeben anstelle des
Funktionsabschlusses, so wie hier:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<p>Beachte, dass wir die vollständig qualifizierte Syntax verwenden müssen, über
die wir vorhin im Abschnitt <a href="ch19-03-advanced-traits.html">„Fortgeschrittene Merkmale
(traits)“</a> gesprochen haben, weil es mehrere Funktionen namens
<code>to_string</code> gibt. Hier verwenden wir die Funktion <code>to_string</code>, die im Merkmal
<code>ToString</code> definiert ist, welche die Standardbibliothek für jeden Typ
implementiert hat, der <code>Display</code> implementiert.</p>
<p>Aus dem Abschnitt <a href="ch06-01-defining-an-enum.html#werte-in-aufz%C3%A4hlungen">„Werte in Aufzählungen“</a> in Kapitel 6 wissen
wir, dass der Name jeder definierten Aufzählungsvariante auch eine
Initialisierungsfunktion ist. Wir können diese Initialisierungsfunktionen als
Funktionszeiger verwenden, die die Funktionsabschlussmerkmale implementieren,
was bedeutet, dass wir die Initialisierungsfunktionen als Argumente für
Methoden angeben können, die Funktionsabschlüsse wie diese nehmen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<p>Hier erzeugen wir <code>Status::Value</code>-Instanzen für die <code>u32</code>-Werte im Bereich, für
den <code>map</code> aufgerufen wird, indem wir die Initialisierungsfunktion von
<code>Status::Value</code> verwenden. Einige Leute bevorzugen diesen Stil und einige Leute
ziehen es vor, Funktionsabschlüsse zu verwenden. Sie kompilieren zum gleichen
Code, also verwende den Stil, der für dich am klarsten ist.</p>
<h3 id="zurückgeben-von-funktionsabschlüssen"><a class="header" href="#zurückgeben-von-funktionsabschlüssen">Zurückgeben von Funktionsabschlüssen</a></h3>
<p>Funktionsabschlüsse werden durch Merkmale repräsentiert, was bedeutet, dass du
Funktionsabschlüsse nicht direkt zurückgeben kannst. In den meisten Fällen, in
denen du ein Merkmal zurückgeben möchtest, kannst du stattdessen den konkreten
Typ, der das Merkmal implementiert, als Rückgabewert der Funktion verwenden.
Aber das kannst du bei Funktionsabschlüssen nicht tun, weil sie keinen
konkreten Typ haben, der rückgabefähig ist; es ist dir beispielsweise nicht
erlaubt, den Funktionszeiger <code>fn</code> als Rückgabetyp zu verwenden.</p>
<p>Der folgende Code versucht, einen Funktionsabschluss direkt zurückzugeben, aber
er lässt sich nicht kompilieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}</span></code></pre></pre>
<p>Der Kompilierfehler ist folgender:</p>
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0746]: return type cannot have an unboxed trait object
 --&gt; src/lib.rs:1:25
  |
1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = note: for information on `impl Trait`, see &lt;https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits&gt;
help: use `impl Fn(i32) -&gt; i32` as the return type, as all return paths are of type `[closure@src/lib.rs:2:5: 2:14]`, which implements `Fn(i32) -&gt; i32`
  |
1 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
  |                         ~~~~~~~~~~~~~~~~~~~

For more information about this error, try `rustc --explain E0746`.
error: could not compile `functions-example` due to previous error
</code></pre>
<p>Der Fehler bezieht sich wieder auf das Merkmal <code>Sized</code>! Rust weiß nicht, wie
viel Platz benötigt wird, um den Funktionsabschluss zu speichern. Wir haben
vorhin eine Lösung für dieses Problem gesehen. Wir können ein Merkmalsobjekt
(trait object) verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}</span></code></pre></pre>
<p>Dieser Code lässt sich sehr gut kompilieren. Weitere Informationen über
Merkmalsobjekte findest du im Abschnitt <a href="ch17-02-trait-objects.html">„Merkmalsobjekte (trait objects) die
Werte unterschiedlicher Typen erlauben“</a> in Kapitel 17.</p>
<p>Als nächstes wollen wir uns Makros ansehen!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="makros"><a class="header" href="#makros">Makros</a></h2>
<p>Wir haben in diesem Buch Makros wie <code>println!</code> verwendet, aber wir haben noch
nicht vollständig erforscht, was ein Makro ist und wie es funktioniert. Der
Begriff <em>Makro</em> bezieht sich auf eine Familie von Funktionalitäten in Rust:
<em>Deklarative</em> Makros mit <code>macro_rules!</code> und drei Arten <em>prozeduraler</em> Makros:</p>
<ul>
<li>Benutzerdefinierte Makros mit <code>#[derive]</code>, die Code spezifizieren, der mit
dem Attribut <code>derive</code> hinzugefügt wurde, das bei Strukturen (structs) und
Aufzählungen (enums) verwendet wird</li>
<li>Attribut-ähnliche Makros, die benutzerdefinierte Attribute definieren, die
bei jedem Element verwendet werden können</li>
<li>Funktions-ähnliche Makros, die wie Funktionsaufrufe aussehen, aber auf den
als Argument angegebenen Token operieren</li>
</ul>
<p>Wir werden der Reihe nach über jedes dieser Themen sprechen, aber zuerst wollen
wir uns ansehen, warum wir Makros überhaupt brauchen, wenn wir bereits
Funktionen haben.</p>
<h3 id="der-unterschied-zwischen-makros-und-funktionen"><a class="header" href="#der-unterschied-zwischen-makros-und-funktionen">Der Unterschied zwischen Makros und Funktionen</a></h3>
<p>Im Grunde genommen sind Makros eine Möglichkeit, Code zu schreiben, der anderen
Code schreibt, was als <em>Metaprogrammierung</em> bekannt ist. In Anhang C besprechen
wir das Attribut <code>derive</code>, das dir eine Implementierung verschiedener Merkmale
(traits) generiert. Wir haben im ganzen Buch auch die Makros <code>println!</code> und
<code>vec!</code> verwendet. All diese Makros werden <em>expandiert</em>, um mehr Code zu
erzeugen als der Code, den du manuell geschrieben hast.</p>
<p>Metaprogrammierung ist nützlich, um die Menge an Code zu reduzieren, die du
schreiben und pflegen musst, was auch eine der Aufgaben von Funktionen ist.
Makros haben jedoch einige zusätzliche Fähigkeiten, die Funktionen nicht haben.</p>
<p>Eine Funktionssignatur muss die Anzahl und den Typ der Parameter deklarieren,
die die Funktion hat. Makros hingegen können eine variable Anzahl von
Parametern entgegennehmen: Wir können <code>println!(&quot;Hallo&quot;)</code> mit einem Argument
oder <code>println!(&quot;Hallo {}&quot;, name)</code> mit zwei Argumenten aufrufen. Außerdem werden
Makros expandiert, bevor der Compiler die Bedeutung des Codes interpretiert,
sodass ein Makro beispielsweise ein Merkmal auf einen bestimmten Typ
implementieren kann. Eine Funktion kann das nicht, weil sie zur Laufzeit
aufgerufen wird und ein Merkmal zur Kompilierzeit implementiert werden muss.</p>
<p>Der Nachteil des Implementierens eines Makros anstelle einer Funktion besteht
darin, dass Makrodefinitionen komplexer sind als Funktionsdefinitionen, weil du
Rust-Code schreibst, der Rust-Code schreibt. Aufgrund dieser Indirektion sind
Makrodefinitionen im Allgemeinen schwieriger zu lesen, zu verstehen und zu
pflegen als Funktionsdefinitionen.</p>
<p>Ein weiterer wichtiger Unterschied zwischen Makros und Funktionen besteht
darin, dass du Makros definieren oder in den Gültigkeitsbereich bringen musst,
<em>bevor</em> du sie in einer Datei aufrufst, im Gegensatz zu Funktionen, die du
überall definieren und überall aufrufen kannst.</p>
<h3 id="deklarative-makros-mit-macro_rules-für-allgemeine-metaprogrammierung"><a class="header" href="#deklarative-makros-mit-macro_rules-für-allgemeine-metaprogrammierung">Deklarative Makros mit <code>macro_rules!</code> für allgemeine Metaprogrammierung</a></h3>
<p>Die am häufigsten verwendete Form von Makros in Rust ist das <em>deklarative
Makro</em>. Diese werden manchmal auch als „Makros am Beispiel“ (macros by
example), „<code>macro_rules!</code>-Makros“ oder einfach nur „Makros“ bezeichnet. In
ihrem Kern erlauben deklarative Makros, etwas Ähnliches wie einen Rust-Ausdruck
zu schreiben. Wie in Kapitel 6 besprochen, sind <code>match</code>-Ausdrücke
Kontrollstrukturen, die einen Ausdruck entgegennehmen, den resultierenden Wert
des Ausdrucks mit Mustern abgleichen und dann den Code ausführen, der mit dem
passenden Muster verknüpft ist. Makros vergleichen ebenfalls einen Wert mit
Mustern, die mit einem bestimmten Code verknüpft sind: In diesem Fall ist
der Wert der literale Rust-Quellcode, der an das Makro übergeben wird; die
Muster werden mit der Struktur dieses Quellcodes verglichen; und der mit jedem
Muster verküpften Code ersetzt, wenn er passt, den an das Makro übergebenen
Code. Dies alles geschieht während der Kompilierung.</p>
<p>Um ein Makro zu definieren, verwendest du das Konstrukt <code>macro_rules!</code>. Lass
uns untersuchen, wie man <code>macro_rules!</code> benutzt, indem wir uns ansehen, wie das
Makro <code>vec!</code> definiert wird. Kapitel 8 behandelte, wie wir das Makro <code>vec!</code>
verwenden können, um einen neuen Vektor mit bestimmten Werten zu erzeugen. Zum
Beispiel erzeugt das folgende Makro einen neuen Vektor mit drei ganze Zahlen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>Wir könnten auch das Makro <code>vec!</code> verwenden, um einen Vektor aus zwei ganzen
Zahlen oder einen Vektor aus fünf Zeichenkettenanteilstypen (string slices) zu
erstellen. Mit einer Funktion wäre das nicht möglich,
da uns weder die Anzahl noch den Typ der Werte im Voraus bekannt ist.</p>
<p>Codeblock 19-28 zeigt eine leicht vereinfachte Definition des Makros <code>vec!</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 19-28: Eine vereinfachte Version der
Makrodefinition <code>vec!</code></span></p>
<blockquote>
<p>Hinweis: Die eigentliche Definition des Makros <code>vec!</code> in der
Standardbibliothek enthält Code zum Vorbelegen der korrekten Speichermenge.
Dieser Code ist eine Optimierung, die wir hier zur Vereinfachung des 
Beispiels nicht darstellen.</p>
</blockquote>
<p>Die Annotation <code>#[macro_export]</code> gibt an, dass dieses Makro immer dann zur
Verfügung gestellt werden soll, wenn die Kiste (crate), in der das Makro
definiert ist, in den Gültigkeitsbereich gebracht wird. Ohne diese Annotation
kann das Makro nicht in den Gültigkeitsbereich gebracht werden.</p>
<p>Dann beginnen wir die Makrodefinition mit <code>macro_rules!</code> und dem Namen des
Makros, das wir definieren, <em>ohne</em> Ausrufezeichen. Auf den Name, in diesem Fall
<code>vec</code>, folgen geschweifte Klammern, die den Rumpf der
Makrodefinition kennzeichnen.</p>
<p>Die Struktur im <code>vec!</code> -Rumpf ähnelt der Struktur eines <code>match</code>-Ausdrucks. Hier
haben wir einen Zweig mit dem Muster <code>( $( $x:expr ),* )</code>, gefolgt von <code>=&gt;</code> und
dem mit diesem Muster verknüpften Codeblock. Wenn das Muster passt, wird der
zugehörige Codeblock ausgegeben. Da dies das einzige Muster in diesem Makro
ist, kann es nur einen passenden Zweig geben; jedes andere Muster führt
zu einem Fehler. Komplexere Makros werden mehr als einen Zweig haben.</p>
<p>Die gültige Mustersyntax in Makrodefinitionen unterscheidet sich von der in
Kapitel 18 behandelten Mustersyntax, da Makromuster mit der Rust-Codestruktur
und nicht mit Werten abgeglichen werden. Lass uns im Folgenden die Bedeutung
der Musterteile in Listing 19-28 betrachten; die vollständige Makromustersyntax
findest du in <a href="https://doc.rust-lang.org/reference/macros-by-example.html">der Rust-Referenz</a>.</p>
<p>Zunächst verwenden wir ein äußeres Klammernpaar, um das gesamte Muster zu
umfassen. Wir verwenden ein Dollarzeichen (<code>$</code>), um eine Variable im
Makrosystem zu deklarieren, die den Rust-Code enthält, der zum Muster passt.
Das Dollarzeichen macht deutlich, dass es sich um eine Makrovariable und nicht
um eine normale Rust-Variable handelt. Danach folgt eine Reihe von Klammern,
die Werte erfassen, die mit dem Muster innerhalb der Klammern übereinstimmen,
um sie im Ersetzungscode zu verwenden. Innerhalb von <code>$()</code> befindet sich
<code>$x:expr</code>, das mit jedem beliebigen Rust-Ausdruck übereinstimmt und dem
Ausdruck den Namen <code>$x</code> gibt.</p>
<p>Das Komma nach <code>$()</code> gibt an, dass ein literales Komma-Trennzeichen optional
nach dem Code erscheinen könnte, der mit dem Code in <code>$()</code> übereinstimmt. Der
<code>*</code> besagt, dass das Muster keinmal oder mehrmals zu dem passt, was vor dem <code>*</code>
steht.</p>
<p>Wenn wir dieses Makro mit <code>vec![1, 2, 3];</code> aufrufen, passt das Muster <code>$x</code>
dreimal zu den drei Ausdrücken <code>1</code>, <code>2</code> und <code>3</code>.</p>
<p>Betrachten wir nun das Muster im Hauptteil des mit diesem Zweig verknüpften
Codes: <code>temp_vec.push()</code> innerhalb von <code>$()*</code> wird für jeden Teil erzeugt, der
keinmal oder mehrmals mit <code>$()</code> im Muster übereinstimmt, je nachdem, wie oft
das Muster passt. Das <code>$x</code> wird durch jeden passenden Ausdruck ersetzt. Wenn
wir dieses Makro mit <code>vec![1, 2, 3];</code> aufrufen, wird durch diesen Aufruf 
folgender Code generierte:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>Wir haben ein Makro definiert, das eine beliebige Anzahl von Argumenten
beliebigen Typs aufnehmen und Code zur Erstellung eines Vektors erzeugen 
kann, der die angegebenen Elemente enthält.</p>
<p>Um mehr darüber zu erfahren, wie man Makros schreibt, konsultiere die
Online-Dokumentation oder andere Ressourcen, wie zum Beispiel <a href="https://veykril.github.io/tlborm/">„The Little Book
of Rust Macros“</a> (engl. „Das kleine Buch der Rust-Makros“).</p>
<h3 id="prozedurale-makros-zur-code-generierung-aus-attributen"><a class="header" href="#prozedurale-makros-zur-code-generierung-aus-attributen">Prozedurale Makros zur Code-Generierung aus Attributen</a></h3>
<p>Die zweite Form von Makros ist das <em>prozedurale Makro</em>, das sich eher wie eine
Funktion verhält (und eine Art Prozedur ist). Prozedurale Makros akzeptieren
etwas Code als Eingabe, operieren mit diesem Code und erzeugen etwas Code als
Ausgabe, anstatt gegen Muster abzugleichen und den Code durch anderen Code zu
ersetzen, wie es deklarative Makros tun. Die drei Arten von prozeduralen Makros
(benutzerdefinierte derive-Makros, Attribut-ähnliche und Funktions-ähnliche)
arbeiten alle auf ähnliche Weise.</p>
<p>Beim Erstellen von prozeduralen Makros müssen sich die Definitionen in einer
eigenen Kiste mit einem speziellen Kistentyp befinden. Dies geschieht aus
komplexen technischen Gründen, die wir hoffentlich in Zukunft eliminieren
werden. In Codeblock 19-29 zeigen wir, wie man ein prozedurales Makro
definiert, wobei <code>some_attribute</code> ein Platzhalter für die Verwendung einer
bestimmten Makro-Variante ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<p><span class="caption">Codeblock 19-29: Beispiel für die Definition eines
prozeduralen Makros</span></p>
<p>Die Funktion, die ein prozedurales Makro definiert, nimmt einen <code>TokenStream</code>
als Eingabe und erzeugt einen <code>TokenStream</code> als Ausgabe. Der Typ <code>TokenStream</code>
wird durch die Kiste <code>proc_macro</code> definiert, die in Rust enthalten ist und eine
Folge von Token darstellt. Dies ist der Kern des Makros: Der Quellcode, mit dem
das Makro arbeitet, bildet die Eingabe <code>TokenStream</code>, und der Code, den das
Makro erzeugt, ist die Ausgabe <code>TokenStream</code>. Die Funktion hat auch ein
Attribut, das angibt, welche Art prozedurales Makro wir erstellen. Wir können
mehrere Arten prozeduraler Makros in derselben Kiste haben.</p>
<p>Schauen wir uns die verschiedenen Arten prozeduraler Makros an. Wir beginnen
mit einem benutzerdefinierten derive-Makro und erklären dann die kleinen
Unterschiede, in denen sich die anderen Formen unterscheiden.</p>
<h3 id="wie-man-ein-benutzerdefiniertes-makro-mit-derive-schreibt"><a class="header" href="#wie-man-ein-benutzerdefiniertes-makro-mit-derive-schreibt">Wie man ein benutzerdefiniertes Makro mit <code>derive</code> schreibt</a></h3>
<p>Lass uns eine Kiste namens <code>hello_macro</code> erstellen, die ein Merkmal namens
<code>HelloMacro</code> mit einer assoziierten Funktion namens <code>hello_macro</code> definiert.
Anstatt unsere Benutzer dazu zu bringen, das Merkmal <code>HelloMacro</code> für jeden
ihrer Typen zu implementieren, werden wir ein prozedurales Makro zur Verfügung
stellen, damit die Benutzer ihren Typ mit <code>#[derive(HelloMacro)]</code> annotieren
können, um eine Standardimplementierung der Funktion <code>hello_macro</code> zu erhalten.
Die Standardimplementierung gibt <code>Hallo Makro! Mein Name ist TypeName!</code> aus,
wobei <code>TypeName</code> der Name des Typs ist, auf dem dieses Merkmal definiert wurde.
Mit anderen Worten, wir werden eine Kiste schreiben, die es einem anderen
Programmierer ermöglicht, mit unserer Kiste Code wie Codeblock 19-30 zu
schreiben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p><span class="caption">Codeblock 19-30: Code, den ein Benutzer unserer Kiste
schreiben kann, wenn er unser prozedurales Makro benutzt</span></p>
<p>Dieser Code gibt <code>Hallo Makro! Mein Name ist Pancakes!</code> aus, wenn wir fertig
sind. Der erste Schritt ist das Erstellen einer neuen Bibliothekskiste (library
crate), etwa so:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Als Nächstes definieren wir das Merkmal <code>HelloMacro</code> und die damit assoziierte
Funktion:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}</span></code></pre></pre>
<p>Wir haben ein Merkmal und seine Funktion. An diesem Punkt könnte unser
Kistenbenutzer das Merkmal so implementieren, dass die gewünschte
Funktionalität erreicht wird:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hallo Makro! Mein Name ist Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p>Allerdings müssten sie den Implementierungsblock für jeden Typ, den sie mit
<code>hello_macro</code> verwenden wollten, schreiben; wir wollen ihnen diese Arbeit
ersparen.</p>
<p>Außerdem können wir die Funktion <code>hello_macro</code> noch nicht mit einer
Standardimplementierung versehen, die den Namen des Typs ausgibt, auf dem das
Merkmal implementiert ist: Rust hat keine Reflektionsfähigkeiten, sodass es den
Namen des Typs zur Laufzeit nicht nachschlagen kann. Wir benötigen ein Makro,
um zur Kompilierzeit Code zu generieren.</p>
<p>Der nächste Schritt ist das Definieren des prozeduralen Makros. Zum Zeitpunkt
der Abfassung dieses Dokuments müssen sich die prozeduralen Makros in einer
eigenen Kiste befinden. Irgendwann könnte diese Einschränkung aufgehoben
werden. Die Konvention für die Strukturierung von Kisten und Makrokisten lautet
wie folgt: Für eine Kiste mit dem Namen <code>foo</code> wird eine prozedurale Makrokiste
mit einem benutzerdefinierten derive-Makro als <code>foo_derive</code> bezeichnet.
Beginnen wir eine neue Kiste mit dem Namen <code>hello_macro_derive</code> innerhalb
unseres <code>hello_macro</code>-Projekts:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Unsere beiden Kisten sind eng miteinander verwandt, daher erstellen wir die
prozedurale Makrokiste innerhalb des Verzeichnisses unserer Kiste
<code>hello_macro</code>. Wenn wir die Merkmalsdefinition in <code>hello_macro</code> ändern, müssen
wir auch die Implementierung des prozeduralen Makros in <code>hello_macro_derive</code>
ändern. Die beiden Kisten müssen getrennt veröffentlicht werden und
Programmierer, die diese Kisten verwenden, müssen beide als Abhängigkeiten
hinzufügen und beide in den Gültigkeitsbereich bringen. Wir könnten stattdessen
die Kiste <code>hello_macro</code> als Abhängigkeit <code>hello_macro_derive</code> verwenden lassen
und den prozeduralen Makrocode erneut exportieren. Wie auch immer, die Art und
Weise, wie wir das Projekt strukturiert haben, ermöglicht es den
Programmierern, <code>hello_macro</code>  zu benutzen, selbst wenn sie die
<code>derive</code>-Funktionalität nicht wollen.</p>
<p>Wir müssen die Kiste <code>hello_macro_derive</code> als prozedurale Makro-Kiste
deklarieren. Wie du gleich sehen wirst, benötigen wir auch Funktionalität von
den Kisten <code>syn</code> und <code>quote</code>, also müssen wir sie als Abhängigkeiten angeben.
Füge das Folgende zur Datei <em>Cargo.toml</em> für <code>hello_macro_derive</code> hinzu:</p>
<p><span class="filename">Dateiname: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<p>Um mit der Definition des prozeduralen Makros zu beginnen, platziere den Code
in Codeblock 19-31 in deine Datei <em>src/lib.rs</em> der Kiste <code>hello_macro_derive</code>.
Beachte, dass dieser Code nicht kompiliert werden kann, bis wir eine Definition
für die Funktion <code>impl_hello_macro</code> hinzufügen.</p>
<p><span class="filename">Dateiname: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Konstruiere eine Repräsentation des Rust-Codes als Syntaxbaum,
    // den wir manipulieren können
    let ast = syn::parse(input).unwrap();

    // Baue die Merkmal-Implementierung
    impl_hello_macro(&amp;ast)
}</code></pre>
<p><span class="caption">Codeblock 19-31: Code, den die meisten prozeduralen
Makrokisten benötigen, um Rust-Code zu verarbeiten</span></p>
<p>Beachte, dass wir den Code aufgeteilt haben in die Funktion
<code>hello_macro_derive</code>, die für das Parsen des <code>TokenStream</code> verantwortlich ist,
und die Funktion <code>impl_hello_macro</code>, die für die Transformation des Syntaxbaums
verantwortlich ist: Dies macht das Schreiben eines prozeduralen Makros
bequemer. Der Code in der äußeren Funktion (in diesem Fall
<code>hello_macro_derive</code>) wird für fast jede prozedurale Makro-Kiste, die du siehst
oder erstellst, derselbe sein. Der Code, den du im Rumpf der inneren Funktion
(in diesem Fall <code>impl_hello_macro</code>) angibst, wird je nach Zweck deines
prozeduralen Makros unterschiedlich sein.</p>
<p>Wir haben drei neue Kisten eingeführt: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a> und
<a href="https://crates.io/crates/quote"><code>quote</code></a>. Die Kiste <code>proc_macro</code> kommt mit Rust, sodass wir das
nicht zu den Abhängigkeiten in <em>Cargo.toml</em> hinzufügen mussten. Die Kiste
<code>proc_macro</code> ist die API des Compilers, die es uns erlaubt, den Rust-Code aus
unserem Code zu lesen und zu manipulieren.</p>
<p>Die Kiste <code>syn</code> parst den Rust-Code von einer Zeichenkette in eine
Datenstruktur, auf der wir Operationen durchführen können. Die Kiste <code>quote</code>
wandelt <code>syn</code>-Datenstrukturen wieder in Rust-Code um. Diese Kisten machen es
viel einfacher, jede Art von Rust-Code zu parsen, den wir vielleicht
verarbeiten wollen: Einen vollständigen Parser für Rust-Code zu schreiben, ist
keine einfache Aufgabe.</p>
<p>Die Funktion <code>hello_macro_derive</code> wird aufgerufen, wenn ein Benutzer unserer
Bibliothek <code>#[derive(HelloMacro)]</code> an einen Typ spezifiziert. Dies ist möglich,
weil wir die Funktion <code>hello_macro_derive</code> hier mit <code>proc_macro_derive</code>
annotiert und den Namen <code>HelloMacro</code> angegeben haben, der unserem Merkmalsnamen
entspricht; dies ist die Konvention, der die meisten prozeduralen Makros
folgen.</p>
<p>Die Funktion <code>hello_macro_derive</code> wandelt zunächst <code>input</code> aus einem
<code>TokenStream</code> in eine Datenstruktur um, die wir dann interpretieren und
Operationen darauf ausführen können. Hier kommt <code>syn</code> ins Spiel. Die Funktion
<code>parse</code> in <code>syn</code> nimmt einen <code>TokenStream</code> und gibt eine <code>DeriveInput</code>-Struktur
zurück, die den geparsten Rust-Code repräsentiert. Codeblock 19-32 zeigt die
relevanten Teile der Struktur <code>DeriveInput</code>, die wir vom Parsen der
Zeichenkette <code>struct Pancakes;</code> erhalten:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --abschneiden--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<p><span class="caption">Codeblock 19-32: Die <code>DeriveInput</code>-Instanz erhalten wir
beim Parsen des Codes, den das Attribut des Makros in Codeblock 19-30
hat</span></p>
<p>Die Felder dieser Struktur zeigen, dass der Rust-Code, den wir geparst haben,
eine Einheitsstruktur (unit struct) mit dem <code>ident</code> (identifier, engl.
Bezeichner, d.h. dem Namen) von <code>Pancakes</code> ist. Es gibt weitere Felder in
dieser Struktur zur Beschreibung aller Arten von Rust-Code; weitere
Informationen findest du in der <a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html"><code>syn</code>-Dokumentation für
<code>DeriveInput</code></a>.</p>
<p>Bald werden wir die Funktion <code>impl_hello_macro</code> definieren, wo wir den neuen
Rust-Code bauen werden, den wir einbinden wollen. Aber bevor wir das tun,
beachte, dass die Ausgabe für unser derive-Makro ebenfalls ein <code>TokenStream</code>
ist. Der zurückgegebene <code>TokenStream</code> wird dem Code hinzugefügt, den unsere
Kisten-Benutzer schreiben. Wenn sie also ihre Kiste kompilieren, erhalten sie
die zusätzliche Funktionalität, die wir im modifizierten <code>TokenStream</code> zur
Verfügung stellen.</p>
<p>Du hast vielleicht bemerkt, dass wir <code>unwrap</code> aufrufen, um die Funktion
<code>hello_macro_derive</code> abstürzen zu lassen, wenn der Aufruf der Funktion
<code>syn::parse</code> hier fehlschlägt. Es ist notwendig, dass unser prozedurales Makro
bei Fehlern abstürzt, weil <code>proc_macro_derive</code>-Funktionen einen <code>TokenStream</code>
zurückgeben müssen, kein <code>Result</code>, um mit der prozeduralen Makro-API konform zu
sein. Wir haben dieses Beispiel vereinfacht, indem wir <code>unwrap</code> verwendet
haben; in Produktionscode solltest du spezifischere Fehlermeldungen darüber
angeben, was schief gelaufen ist, indem du <code>panic!</code> oder <code>expect</code> verwendest.</p>
<p>Da wir nun den Code haben, um den annotierten Rust-Code aus einem <code>TokenStream</code>
in eine <code>DeriveInput</code>-Instanz zu verwandeln, lass uns den Code generieren, der
das Merkmal <code>HelloMacro</code> auf dem annotierten Typ implementiert, wie in
Codeblock 19-33 gezeigt.</p>
<p><span class="filename">Dateiname: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">extern crate proc_macro;
</span><span class="boring">
</span><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Konstruiere eine Repräsentation des Rust-Codes als Syntaxbaum,
</span><span class="boring">    // den wir manipulieren können
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Baue die Merkmal-Implementierung
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hallo Makro! Mein Name ist {}!&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}</code></pre>
<p><span class="caption">Codeblock 19-33: Implementierung des Merkmals
<code>HelloMacro</code> unter Verwendung des geparsten Rust-Codes</span></p>
<p>Wir erhalten eine <code>Ident</code>-Strukturinstanz, die den Namen (Bezeichner) des
annotierten Typs enthält, indem wir <code>ast.ident</code> verwenden. Die Struktur in
Codeblock 19-32 zeigt, dass, wenn wir die Funktion <code>impl_hello_macro</code> auf den
Code in Codeblock 19-30 anwenden, das erhaltene <code>ident</code> ein Feld <code>ident</code> mit
dem Wert <code>&quot;Pancakes&quot;</code> enthält. So wird die Variable <code>name</code> in Codeblock 19-33
eine Instanz der Struktur <code>Ident</code> enthalten, die die Zeichenkette <code>&quot;Pancakes&quot;</code>
ausgibt, der Name der Struktur in Codeblock 19-30.</p>
<p>Mit dem Makro <code>quote!</code> können wir den Rust-Code definieren, den wir zurückgeben
wollen. Der Compiler erwartet etwas anderes als das direkte Ergebnis der
Ausführung des <code>quote!</code>-Makros, also müssen wir es in einen <code>TokenStream</code>
konvertieren. Wir tun dies, indem wir die <code>into</code>-Methode aufrufen, die diese
Zwischendarstellung konsumiert und einen Wert des erforderlichen Typs
<code>TokenStream</code> zurückgibt.</p>
<p>Das Makro <code>quote!</code> bietet auch einige sehr coole Vorlage-Mechanismen: Wir
können <code>#name</code> eingeben und <code>quote!</code> wird es durch den Wert in der Variablen
<code>name</code> ersetzen. Du kannst sogar einige Wiederholungen machen, ähnlich wie
normale Makros funktionieren. Schaue dir die <a href="https://docs.rs/quote">Dokumentation der Kiste
<code>quote!</code></a> für eine gründliche Einführung an.</p>
<p>Wir wollen, dass unser prozedurales Makro eine Implementierung unseres Merkmals
<code>HelloMacro</code> für den Typ, den der Benutzer annotiert hat, erzeugt, die wir mit
<code>#name</code> erhalten können. Die Merkmalssimplementierung hat eine Funktion
<code>hello_macro</code>, deren Rumpf die Funktionalität enthält, die wir zur Verfügung
stellen wollen: Ausgeben von <code>Hallo Makro! Mein Name ist</code> und dann der Name des
annotierten Typs.</p>
<p>Das hier verwendete Makro <code>stringify!</code> ist in Rust eingebaut. Es nimmt einen
Rust-Ausdruck, z.B. <code>1 + 2</code>, und verwandelt diesen zur Kompilierzeit in ein
Zeichenketten-Literal, z.B. <code>&quot;1 + 2&quot;</code>. Dies unterscheidet sich von <code>format!</code>
oder <code>println!</code>; Makros, die den Ausdruck auswerten und dann das Ergebnis in
einen <code>String</code> umwandeln. Es besteht die Möglichkeit, dass die Eingabe <code>#Name</code>
ein Ausdruck ist, der literal auszugeben ist, also verwenden wir <code>stringify!</code>.
Die Verwendung von <code>stringify!</code> erspart zudem eine Speicherzuweisung, indem
<code>#name</code> zur Kompilierzeit in ein Zeichenketten-Literal umgewandelt wird.</p>
<p>An diesem Punkt sollte <code>cargo build</code> sowohl bei <code>hello_macro</code> als auch bei
<code>hello_macro_derive</code> erfolgreich durchlaufen. Schließen wir diese Kisten an den
Code in Codeblock 19-30 an, um das prozedurale Makro in Aktion zu sehen!
Erstelle ein neues Binärprojekt in deinem <em>projects</em>-Verzeichnis durch Aufrufen
von <code>cargo new pancakes</code>. Wir müssen <code>hello_macro</code> und <code>hello_macro_derive</code> als
Abhängigkeiten in der Datei <em>Cargo.toml</em> der Kiste <code>pancakes</code> hinzufügen. Wenn
du deine Versionen von <code>hello_macro</code> und <code>hello_macro_derive</code> in
<a href="https://crates.io/">crates.io</a> veröffentlichst, wären das reguläre Abhängigkeiten; wenn
nicht, kannst du sie wie folgt als <code>path</code>-Abhängigkeiten angeben:</p>
<pre><code class="language-toml">hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>Gib den Code in Codeblock 19-30 in <em>src/main.rs</em> ein und rufe <code>cargo run</code> auf:
Es sollte <code>Hallo Makro! Mein Name ist Pancakes!</code> ausgeben. Die Implementierung
des Merkmals <code>HelloMacro</code> aus dem prozeduralen Makro wurde eingefügt, ohne dass
die Kiste <code>pancakes</code> es implementieren musste; <code>#[derive(HelloMacro)]</code> fügte
die Merkmalsimplementierung hinzu.</p>
<p>Als Nächstes wollen wir untersuchen, inwiefern sich die anderen Arten
prozeduraler Makros von den benutzerdefinierten derive-Makros unterscheiden.</p>
<h3 id="attribut-ähnliche-makros"><a class="header" href="#attribut-ähnliche-makros">Attribut-ähnliche Makros</a></h3>
<p>Attribut-ähnliche Makros ähneln den benutzerdefinierten derive-Makros, aber
anstatt Code für das <code>derive</code>-Attribut zu generieren, erlauben sie dir, neue
Attribute zu erstellen. Sie sind auch flexibler: <code>derive</code> funktioniert nur bei
Strukturen und Aufzählungen; Attribute können auch auf andere Elemente, z.B.
Funktionen, angewendet werden. Hier ist ein Beispiel für die Verwendung eines
Attribut-ähnlichen Makros: Nehmen wir an, du hast ein Attribut namens <code>route</code>,
das Funktionen annotiert, wenn du ein Webapplikations-Framework verwendest:</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {</code></pre>
<p>Dieses Attribut <code>#[route]</code> würde durch das Framework als prozedurales Makro
definiert werden. Die Signatur der Makrodefinitionsfunktion würde wie folgt
aussehen:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Hier haben wir zwei Parameter vom Typ <code>TokenStream</code>. Der erste ist für die
Inhalte <code>GET, &quot;/&quot;</code> des Attributs. Der zweite ist für den Rumpf des Elements, an
den das Attribut angehängt ist: In diesem Fall <code>fn index() {}</code> und der Rest des
Funktionsrumpfs.</p>
<p>Abgesehen davon funktionieren Attribut-ähnliche Makros auf die gleiche Weise
wie benutzerdefinierte derive-Makros: Sie erstellen eine Kiste mit dem
Kistentyp <code>proc-macro</code> und implementieren eine Funktion, die den gewünschten
Code generiert!</p>
<h3 id="funktions-ähnliche-makros"><a class="header" href="#funktions-ähnliche-makros">Funktions-ähnliche Makros</a></h3>
<p>Funktions-ähnliche Makros definieren Makros, die wie Funktionsaufrufe aussehen.
Ähnlich wie <code>macro_rules!</code>-Makros sind sie flexibler als Funktionen; sie können
zum Beispiel eine unbekannte Anzahl von Argumenten aufnehmen. Makros können
jedoch nur mit der <code>match</code>-ähnlichen Syntax definiert werden, die wir im
Abschnitt <a href="ch19-06-macros.html#deklarative-makros-mit-macro_rules-f%C3%BCr-allgemeine-metaprogrammierung">„Deklarative Makros mit <code>macro_rules!</code> für allgemeine
Metaprogrammierung“</a> besprochen haben. Funktions-ähnliche Makros nehmen
einen <code>TokenStream</code>-Parameter und ihre Definition manipuliert diesen
<code>TokenStream</code> unter Verwendung von Rust-Code, wie es die beiden anderen Arten
prozeduraler Makros tun. Ein Beispiel für ein Funktions-ähnliches Makro ist ein
Makro <code>sql!</code>, das auf diese Weise aufgerufen werden könnte:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>Dieses Makro würde die darin enthaltene SQL-Anweisung parsen und prüfen, ob sie
syntaktisch korrekt ist, was eine viel komplexere Verarbeitung ist, als es ein
<code>macro_rules!</code>-Makro tun kann. Das Makro <code>sql!</code> würde wie folgt definiert
werden:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>Diese Definition ähnelt der Signatur des benutzerdefinierten derive-Makros: Wir
erhalten die Token, die sich innerhalb der Klammern befinden, und geben den
Code zurück, den wir generieren wollen.</p>
<h2 id="zusammenfassung-18"><a class="header" href="#zusammenfassung-18">Zusammenfassung</a></h2>
<p>Puh! Jetzt hast du einige Rust-Funktionalitäten in deinem Werkzeugkasten, die
du nicht oft verwenden wirst, aber du wirst wissen, dass sie unter ganz
bestimmten Umständen verfügbar sind. Wir haben mehrere komplexe Themen
eingeführt, sodass du diese Konzepte und Syntax erkennen kannst, wenn du ihnen
in Vorschlägen für Fehlermeldungen oder im Code anderer Leute begegnest.
Verwende dieses Kapitel als Referenz, um Lösungen zu finden.</p>
<p>Als Nächstes werden wir alles, was wir im Laufe des Buches besprochen haben, in
die Praxis umsetzen und ein weiteres Projekt durchführen!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abschlussprojekt-einen-mehrsträngigen-multi-threaded-webserver-erstellen"><a class="header" href="#abschlussprojekt-einen-mehrsträngigen-multi-threaded-webserver-erstellen">Abschlussprojekt: Einen mehrsträngigen (multi-threaded) Webserver erstellen</a></h1>
<p>Es war eine lange Reise, aber wir haben das Ende des Buches erreicht. In diesem
Kapitel werden wir gemeinsam ein weiteres Projekt aufbauen, um einige der
Konzepte zu demonstrieren, die wir in den letzten Kapiteln behandelt haben, und
einige frühere Lektionen zusammenfassen.</p>
<p>Für unser Abschlussprojekt werden wir einen Webserver erstellen, der „Hallo“
sagt und in einem Webbrowser wie Abbildung 20-1 aussieht.</p>
<p><img src="img/trpl20-01.png" alt="Hallo von Rust" /></p>
<p><span class="caption">Abbildung 20-1: Unser letztes gemeinsames Projekt</span></p>
<p>Hier ist unser Plan zum Bauen des Webservers:</p>
<ol>
<li>Lerne ein wenig über TCP und HTTP.</li>
<li>Lausche auf TCP-Verbindungen an einem Netzwerkknoten (socket).</li>
<li>Parse eine kleine Anzahl von HTTP-Anfragen.</li>
<li>Erstelle eine korrekte HTTP-Antwort.</li>
<li>Verbessere den Durchsatz unseres Servers mit einem Strang-Vorrat (thread
pool).</li>
</ol>
<p>Bevor wir anfangen, sollten wir ein Detail erwähnen: Die Methode, die wir
verwenden werden, wird nicht der beste Weg sein, einen Webserver mit Rust zu
bauen. Gemeinschaftsmitglieder haben eine Reihe von produktionsreifen Kisten
auf <a href="https://crates.io/">crates.io</a> veröffentlicht, die umfassendere Webserver- und
Strang-Vorrats-Implementierungen bereitstellen, als wir sie bauen werden.
Unsere Absicht in diesem Kapitel ist es jedoch, dir beim Lernen zu helfen, und
nicht, den einfachen Weg zu gehen. Da es sich bei Rust um eine
Systemprogrammiersprache handelt, können wir die Abstraktionsebene wählen, mit
der wir arbeiten wollen, und können auf eine niedrigere Ebene gehen, als dies
in anderen Sprachen möglich oder zweckmäßig ist. Wir werden daher den
grundlegenden HTTP-Server und den Strang-Vorrat manuell schreiben, damit du die
allgemeinen Ideen und Techniken hinter den Kisten lernst, die du in Zukunft
verwenden kannst.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="einen-einsträngigen-single-threaded-webserver-erstellen"><a class="header" href="#einen-einsträngigen-single-threaded-webserver-erstellen">Einen einsträngigen (single-threaded) Webserver erstellen</a></h2>
<p>Wir beginnen damit, einen einsträngigen Webserver zum Laufen zu bringen. Bevor
wir beginnen, wollen wir uns einen kurzen Überblick über die Protokolle
verschaffen, die beim Aufbau von Webservern eine Rolle spielen. Die
Einzelheiten dieser Protokolle sprengen den Rahmen dieses Buches, aber ein
kurzer Überblick wird dir die Informationen geben, die du benötigst.</p>
<p>Die beiden wichtigsten Protokolle, die bei Webservern zum Einsatz kommen, sind
das <em>Hypertext-Übertragungsprotokoll</em> (Hypertext Transfer Protocol, kurz
<em>HTTP</em>) und das <em>Übertragungssteuerungsprotokoll</em> (Transmission Control
Protocol, kurz <em>TCP</em>). Beide Protokolle sind <em>Anfrage-Antwort-Protokolle</em>, d.h.
ein <em>Client</em> initiiert Anfragen und ein <em>Server</em> hört auf die Anfragen und gibt
eine Antwort an den Client. Der Inhalt dieser Anfragen und Antworten wird durch
die Protokolle definiert.</p>
<p>TCP ist das Protokoll der untergeordneten Ebene, das im Detail beschreibt, wie
Informationen von einem Server zu einem anderen gelangen, aber nicht
spezifiziert, um welche Informationen es sich dabei handelt. HTTP baut auf TCP
auf, indem es den Inhalt der Anfragen und Antworten definiert. Es ist technisch
möglich, HTTP mit anderen Protokollen zu verwenden, aber in den allermeisten
Fällen sendet HTTP seine Daten über TCP. Wir werden mit den Roh-Bytes von TCP-
und HTTP-Anfragen und -Antworten arbeiten.</p>
<h3 id="lauschen-auf-eine-tcp-verbindung"><a class="header" href="#lauschen-auf-eine-tcp-verbindung">Lauschen auf eine TCP-Verbindung</a></h3>
<p>Unser Webserver muss auf eine TCP-Verbindung lauschen (listen), also ist das
der erste Teil, an dem wir arbeiten werden. Die Standardbibliothek bietet ein
Modul <code>std::net</code> an, mit dem wir dies tun können. Lass uns ein neues Projekt
auf die übliche Art und Weise erstellen:</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Gib nun den Code in Codeblock 20-1 in <em>src/main.rs</em> ein, um zu beginnen. Dieser
Code lauscht unter der lokalen Adresse <code>127.0.0.1:7878</code> auf eingehende
TCP-Ströme (TCP streams). Wenn er einen eingehenden Strom erhält, wird er
<code>Verbindung hergestellt!</code> ausgeben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Verbindung hergestellt!&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 20-1: Warten auf eingehende Ströme und Ausgeben
einer Nachricht, wenn wir einen Strom empfangen</span></p>
<p>Mit <code>TcpListener</code> können wir unter der Adresse <code>127.0.0.1:7878</code> auf
TCP-Verbindungen warten. In der Adresse ist der Abschnitt vor dem Doppelpunkt
eine IP-Adresse, die deinen Computer repräsentiert (dies ist auf jedem Computer
gleich und gilt nicht nur speziell für den Computer der Autoren), und <code>7878</code>
ist der Port. Wir haben diesen Port aus zwei Gründen gewählt: HTTP wird auf
diesem Port normalerweise nicht akzeptiert, sodass unser Server wahrscheinlich
nicht mit anderen Webservern in Konflikt geraten wird, die du auf deinem
Rechner hast, und 7878 steht für <em>rust</em>, wenn du es auf einem Telefon tippst.</p>
<p>Die Funktion <code>bind</code> in diesem Szenario arbeitet wie die Funktion <code>new</code>, indem
sie eine neue <code>TcpListener</code>-Instanz zurückgibt. Die Funktion wird <code>bind</code>
genannt, weil in Netzwerken das Verbinden mit einem Port zum Lauschen als
„Binden (binding) an einen Port“ bezeichnet wird.</p>
<p>Die Funktion <code>bind</code> gibt ein <code>Result&lt;T, E&gt;</code> zurück, was anzeigt, dass es
möglich ist, dass das Binden fehlschlagen könnte. Zum Beispiel erfordert das
Binden an Port 80 Administrator-Rechte (Nicht-Administratoren können nur auf
Ports größer als 1023 lauschen). Wenn wir also versuchen würden, an Port 80 zu
lauschen, ohne Administrator zu sein, würde das Binden nicht funktionieren. Das
Binden wäre beispielsweise auch nicht möglich, wenn wir zwei Instanzen unseres
Programms laufen lassen und somit zwei Programme auf dem gleichen Port lauschen
würden. Da wir einen einfachen Server nur für Lernzwecke schreiben, werden wir
uns nicht um die Behandlung dieser Art von Fehlern kümmern; stattdessen
verwenden wir <code>unwrap</code>, um das Programm zu stoppen, wenn Fehler auftreten.</p>
<p>Die Methode <code>incoming</code> von <code>TcpListener</code> gibt einen Iterator zurück, der uns
eine Sequenz von Strömen (genauer gesagt Ströme vom Typ <code>TcpStream</code>) liefert.
Ein einzelner <em>Strom</em> (stream) stellt eine offene Verbindung zwischen dem
Client und dem Server dar. Eine <em>Verbindung</em> (connection) ist der Name für den
vollständigen Anfrage- und Antwortprozess, bei dem sich ein Client mit dem
Server verbindet, der Server eine Antwort erzeugt und der Server die Verbindung
schließt. Daher werden wir aus dem <code>TcpStream</code> lesen, um zu sehen, was der
Client gesendet hat, und dann unsere Antwort in den Strom schreiben, um Daten
zurück an den Client zu senden. Insgesamt wird diese <code>for</code>-Schleife jede
Verbindung der Reihe nach verarbeiten und eine Reihe von Strömen erzeugen, die
wir verarbeiten müssen.</p>
<p>Im Moment besteht unsere Behandlung des Stroms darin, dass wir <code>unwrap</code>
aufrufen, um unser Programm zu beenden, wenn der Strom Fehler aufweist; wenn
keine Fehler vorliegen, gibt das Programm eine Nachricht aus. Wir werden im
nächsten Codeblock mehr Funktionalität für den Erfolgsfall hinzufügen. Der
Grund, warum wir Fehler von der <code>incoming</code>-Methode erhalten könnten, wenn sich
ein Client mit dem Server verbindet, ist, dass wir nicht wirklich über
Verbindungen iterieren. Stattdessen iterieren wir über <em>Verbindungsversuche</em>.
Die Verbindung kann aus einer Reihe von Gründen nicht erfolgreich sein, viele
davon sind betriebssystemspezifisch. Zum Beispiel haben viele Betriebssysteme
ein Limit für die Anzahl der gleichzeitig offenen Verbindungen, die sie
unterstützen können; neue Verbindungsversuche über diese Anzahl hinaus führen
zu einem Fehler, bis einige der offenen Verbindungen geschlossen werden.</p>
<p>Lass uns versuchen, diesen Code auszuführen! Rufe <code>cargo run</code> im Terminal auf
und öffne dann <em>127.0.0.1:7878</em> in einem Web-Browser. Der Browser sollte eine
Fehlermeldung wie „Verbindung abgebrochen“ anzeigen, da der Server derzeit
keine Daten zurücksendet. Aber wenn du auf dein Terminal siehst, solltest du
mehrere Meldungen sehen, die ausgegeben wurden, als der Browser eine Verbindung
mit dem Server herstellte!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Verbindung hergestellt!
Verbindung hergestellt!
Verbindung hergestellt!
</code></pre>
<p>Manchmal werden mehrere Nachrichten für eine Browser-Anfrage ausgegeben; der
Grund dafür könnte sein, dass der Browser sowohl eine Anfrage für die Seite als
auch eine Anfrage für andere Ressourcen stellt, z.B. das Symbol <em>favicon.ico</em>,
das in der Browser-Registerkarte erscheint.</p>
<p>Es könnte auch sein, dass der Browser mehrmals versucht, eine Verbindung mit
dem Server herzustellen, weil der Server nicht mit Daten antwortet. Wenn
<code>stream</code> den Gültigkeitsbereich verlässt und am Ende der Schleife aufgeräumt
wird, wird die Verbindung als Teil der <code>drop</code>-Implementierung geschlossen.
Browser reagieren auf geschlossene Verbindungen manchmal damit, es erneut zu
versuchen, weil das Problem möglicherweise nur vorübergehend ist. Der wichtige
Punkt ist, dass wir erfolgreich eine TCP-Verbindung hergestellt haben!</p>
<p>Denke daran, das Programm durch Drücken von <span
class="keystroke">Strg+c</span> zu beenden, wenn du mit der Ausführung einer
bestimmten Version des Codes fertig bist. Starte dann das Programm neu, indem
du den Befehl <code>cargo run</code> aufrufst, nachdem du die einzelnen Codeänderungen
vorgenommen hast, um sicherzustellen, dass du den neuesten Code ausführst.</p>
<h3 id="lesen-der-anfrage"><a class="header" href="#lesen-der-anfrage">Lesen der Anfrage</a></h3>
<p>Lass uns die Funktionalität zum Lesen der Anfrage vom Browser implementieren!
Um die Zuständigkeiten zu trennen, also zuerst eine Verbindung entgegenzunehmen
und dann mit der Verbindung etwas zu machen, werden wir eine neue Funktion zur
Verarbeitung von Verbindungen anfangen. In dieser neuen Funktion
<code>handle_connection</code> lesen wir Daten aus dem TCP-Strom und geben sie aus, sodass
wir sehen können, welche Daten vom Browser gesendet werden. Ändere den Code so,
dass er wie Codeblock 20-2 aussieht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&amp;mut buffer).unwrap();

    println!(&quot;Request: {}&quot;, String::from_utf8_lossy(&amp;buffer[..]));
}</code></pre></pre>
<p><span class="caption">Codeblock 20-2: Lesen aus dem <code>TcpStream</code> und Ausgeben
der Daten</span></p>
<p>Wir bringen <code>std::io::prelude</code> und <code>std::io::BufReader</code> in den
Gültigkeitsbereich, um Zugang zu Merkmalen (traits) und Typen zu erhalten, die
es uns ermöglichen, aus dem Strom zu lesen und in den Strom zu schreiben. In
der <code>for</code>-Schleife in der Funktion <code>main</code> rufen wir jetzt, statt eine Nachricht
auszugeben, dass wir eine Verbindung hergestellt haben, die neue Funktion
<code>handle_connection</code> auf und übergeben ihr den <code>stream</code>.</p>
<p>In der Funktion <code>handle_connection</code> erstellen wir eine neue
<code>BufReader</code>-Instanz, die eine veränderbare Referenz auf den <code>stream</code> enthält.
<code>BufReader</code> sorgt für die Pufferung, indem es die Aufrufe der Merkmals-Methoden
von <code>std::io::Read</code> für uns verwaltet.</p>
<p>Wir erstellen eine Variable namens <code>http_request</code>, um die Zeilen der Anfrage zu
aufzusammeln, die der Browser an unseren Server sendet. Wir geben an, dass wir
diese Zeilen in einem Vektor sammeln wollen, indem wir die Typ-Annotation
<code>Vec&lt;_&gt;</code> hinzufügen.</p>
<p><code>BufReader</code> implementiert das Merkmal <code>std::io::BufRead</code>, das die Methode
<code>lines</code> bereitstellt. Die Methode <code>lines</code> gibt einen Iterator von
<code>Result&lt;String, std::io::Error&gt;</code> zurück, indem sie den Datenstrom immer dann
aufteilt, wenn sie ein Neue-Zeile-Byte sieht. Um jeden <code>String</code> zu erhalten,
wird jedes <code>Result</code> abgebildet und <code>unwrap</code> aufgerufen. Das <code>Result</code> könnte
einen Fehler darstellen, wenn die Daten kein gültiges UTF-8 sind oder wenn es
ein Problem beim Lesen aus dem Strom gab. Auch hier sollte ein
Produktivprogramm diese Fehler besser behandeln, aber der Einfachheit halber
brechen wir das Programm im Fehlerfall ab.</p>
<p>Der Browser signalisiert das Ende einer HTTP-Anfrage, indem er zwei
Zeilenumbrüche hintereinander sendet. Um also eine Anfrage aus dem Strom zu
erhalten, nehmen wir so lange Zeilen an, bis wir eine leere Zeile erhalten.
Sobald wir die Zeilen im Vektor gesammelt haben, geben wir sie mit einer
hübschen Debug-Formatierung aus, damit wir einen Blick auf die Anweisungen
werfen können, die der Webbrowser an unseren Server sendet.</p>
<p>Lass uns diesen Code ausprobieren! Starte das Programm und stelle erneut eine
Anfrage in einem Webbrowser. Beachte, dass wir immer noch eine Fehlerseite im
Browser erhalten, aber die Ausgabe unseres Programms im Terminal wird nun
ähnlich aussehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    &quot;GET / HTTP/1.1&quot;,
    &quot;Host: 127.0.0.1:7878&quot;,
    &quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0&quot;,
    &quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&quot;,
    &quot;Accept-Language: en-US,en;q=0.5&quot;,
    &quot;Accept-Encoding: gzip, deflate, br&quot;,
    &quot;DNT: 1&quot;,
    &quot;Connection: keep-alive&quot;,
    &quot;Upgrade-Insecure-Requests: 1&quot;,
    &quot;Sec-Fetch-Dest: document&quot;,
    &quot;Sec-Fetch-Mode: navigate&quot;,
    &quot;Sec-Fetch-Site: none&quot;,
    &quot;Sec-Fetch-User: ?1&quot;,
    &quot;Cache-Control: max-age=0&quot;,
]
</code></pre>
<p>Je nach Browser erhältst du möglicherweise eine etwas andere Ausgabe. Jetzt, wo
wir die Anfragedaten ausgeben, können wir sehen, warum wir mehrere Verbindungen
von einer Browser-Anfrage erhalten, wenn wir uns den Pfad nach <code>GET</code> in der
ersten Zeile der Anfrage ansehen. Wenn die wiederholten Verbindungen alle <code>/</code>
anfordern, wissen wir, dass der Browser wiederholt versucht, <code>/</code> abzurufen,
weil er keine Antwort von unserem Programm erhält.</p>
<p>Lass uns diese Anfragedaten aufschlüsseln, um zu verstehen, was der Browser von
unserem Programm will.</p>
<h3 id="ein-genauerer-blick-auf-eine-http-anfrage"><a class="header" href="#ein-genauerer-blick-auf-eine-http-anfrage">Ein genauerer Blick auf eine HTTP-Anfrage</a></h3>
<p>HTTP ist ein textbasiertes Protokoll und eine Anfrage hat dieses Format an:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>Die erste Zeile ist die <em>Anfragezeile</em> (request line), die Informationen
darüber enthält, was der Client anfragt. Der erste Teil der Anfragezeile gibt
die <em>Methode</em> an, die verwendet wird, z.B. <code>GET</code> oder <code>POST</code>, die beschreibt,
wie der Client diese Anfrage stellt. Unser Client benutzte eine <code>GET</code>-Anfrage,
was bedeutet, dass er nach Informationen fragt.</p>
<p>Der nächste Teil der Anfragezeile ist <code>/</code>, der den <em>einheitlichen
Ressourcenbezeichner</em> (Uniform Resource Identifier, kurz <em>URI</em>) angibt, den der
Client anfragt: Ein URI ist fast, aber nicht ganz dasselbe wie ein
<em>einheitlicher Ressourcenzeiger</em> (Uniform Resource Locator, kurz <em>URL</em>). Der
Unterschied zwischen URIs und URLs ist für unsere Zwecke in diesem Kapitel
nicht wichtig, aber die HTTP-Spezifikation verwendet den Begriff URI, sodass
wir hier einfach gedanklich URL durch URI ersetzen können.</p>
<p>Der letzte Teil ist die HTTP-Version, die der Client verwendet, und dann endet
die Anfragezeile mit einer <em>CRLF-Sequenz</em>. (CRLF steht für <em>carriage return</em>
(Wagenrücklauf) und <em>line feed</em> (Zeilenvorschub), das sind Begriffe aus der
Schreibmaschinenzeit!) Die CRLF-Sequenz kann auch als <code>\r\n</code> geschrieben
werden, wobei <code>\r</code> ein Wagenrücklauf und <code>\n</code> ein Zeilenvorschub ist. Die
CRLF-Sequenz trennt die Anfragezeile von den restlichen Anfragedaten. Beachte,
dass wir beim Ausgeben von CRLF eine neue Zeile sehen und nicht <code>\r\n</code>.</p>
<p>Wenn wir uns die Daten der Anfragezeile ansehen, die wir bisher beim Ausführen
unseres Programms erhalten haben, sehen wir, dass <code>GET</code> die Methode, <code>/</code> die
Anfrage-URI und <code>HTTP/1.1</code> die Version ist.</p>
<p>Nach der Anfragezeile sind die restlichen Zeilen ab <code>Host:</code> Kopfzeilen.
<code>GET</code>-Anfragen haben keinen Rumpf (body).</p>
<p>Versuche, eine Anfrage von einem anderen Browser aus zu stellen oder nach einer
anderen Adresse zu fragen, z.B. <em>127.0.0.1:7878/test</em>, um zu sehen, wie sich
die Anfragedaten ändern.</p>
<p>Jetzt, da wir wissen, was der Browser anfragt, schicken wir ein paar Daten
zurück!</p>
<h3 id="schreiben-einer-antwort"><a class="header" href="#schreiben-einer-antwort">Schreiben einer Antwort</a></h3>
<p>Wir implementieren das Senden von Daten als Antwort auf eine Clientanfrage. Die
Antworten haben das folgende Format:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>Die erste Zeile ist eine <em>Statuszeile</em>, die die in der Antwort verwendete
HTTP-Version, einen numerischen Statuscode, der das Ergebnis der Anfrage
zusammenfasst, und eine Begründungsphrase, die eine Textbeschreibung des
Statuscodes liefert, enthält. Nach der CRLF-Sequenz folgen beliebige
Kopfzeilen, eine weitere CRLF-Sequenz und der Rumpf der Antwort.</p>
<p>Hier ist eine Beispielantwort, die HTTP-Version 1.1 verwendet, den Statuscode
200, eine OK-Begründungsphrase, keine Kopfzeilen und keinen Rumpf hat:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>Der Statuscode 200 ist die Standard-Erfolgsantwort. Der Text ist eine winzige
erfolgreiche HTTP-Antwort. Lass uns dies als Antwort auf eine erfolgreiche
Anfrage in den Strom schreiben! Entferne aus der Funktion <code>handle_connection</code>
das <code>println!</code>, das die Anfragedaten ausgegeben hat, und ersetze es durch den
Code in Codeblock 20-3.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&amp;mut buffer).unwrap();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 20-3: Schreiben einer kleinen erfolgreichen
HTTP-Antwort in den Strom</span></p>
<p>Die erste neue Zeile definiert die Variable <code>response</code>, die die Daten der
Erfolgsmeldung enthält. Dann rufen wir <code>as_bytes</code> auf unserer <code>response</code> auf,
um die Zeichenkettendaten in Bytes zu konvertieren. Die Methode <code>write_all</code> auf
<code>stream</code> nimmt ein <code>&amp;[u8]</code> und sendet diese Bytes direkt in die Verbindung. Da
die Operation <code>write_all</code> fehlschlagen könnte, verwenden wir wie bisher bei
jedem Fehlerergebnis <code>unwrap</code> . Auch hier würdest du in einer echten Anwendung
eine Fehlerbehandlung hinzufügen.</p>
<p>Lass uns mit diesen Änderungen unseren Code ausführen und eine Anfrage stellen.
Wir geben keine Daten mehr im Terminal aus, sodass wir außer der Ausgabe von
Cargo keine weiteren Ausgaben sehen werden. Wenn du <em>127.0.0.1:7878</em> in einem
Webbrowser lädst, solltest du statt eines Fehlers eine leere Seite sehen. Du
hast soeben das Empfangen einer HTTP-Anfrage und das Senden einer Antwort von
Hand programmiert!</p>
<h3 id="echtes-html-zurückgeben"><a class="header" href="#echtes-html-zurückgeben">Echtes HTML zurückgeben</a></h3>
<p>Lass uns die Funktionalität für die Rückgabe von mehr als einer leeren Seite
implementieren. Erstelle die neue Datei <em>hello.html</em> in der Wurzel deines
Projektverzeichnisses, nicht im Verzeichnis <em>src</em>. Du kannst beliebiges HTML
eingeben, das du willst; Codeblock 20-4 zeigt eine Möglichkeit.</p>
<p><span class="filename">Dateiname: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hallo!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hallo!&lt;/h1&gt;
    &lt;p&gt;Hallo von Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Codeblock 20-4: Eine Beispiel-HTML-Datei, die in einer
Antwort zurückgegeben werden soll</span></p>
<p>Dies ist ein minimales HTML5-Dokument mit einer Überschrift und etwas Text. Um
dies vom Server zurückzugeben, wenn eine Anfrage empfangen wird, modifizieren
wir <code>handle_connection</code> wie in Codeblock 20-5 gezeigt, um die HTML-Datei zu
lesen, sie der Antwort als Rumpf hinzuzufügen und sie zu senden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::fs;
// --abschneiden--

<span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();

    let response = format!(
        &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 20-5: Senden des Inhalts von <em>hello.html</em> als
Rumpf der Antwort</span></p>
<p>Wir haben <code>fs</code> zur <code>use</code>-Deklaration hinzugefügt, um das Dateisystemmodul der
Standardbibliothek in den Gültigkeitsbereich zu bringen. Der Code zum Lesen des
Inhalts einer Datei in eine Zeichenkette sollte vertraut aussehen; wir haben
ihn in Kapitel 12 verwendet, als wir den Inhalt einer Datei für unser
E/A-Projekt in Codeblock 12-4 gelesen haben.</p>
<p>Als Nächstes verwenden wir <code>format!</code>, um den Inhalt der Datei als Rumpf der
Erfolgsantwort hinzuzufügen. Um eine gültige HTTP-Antwort zu gewährleisten,
fügen wir den Header <code>Content-Length</code> hinzu, der auf die Größe unseres
Antwortrumpfs gesetzt wird, in diesem Fall auf die Größe von <code>hello.html</code>. </p>
<p>Führe diesen Code mit <code>cargo run</code> aus und lade <em>127.0.0.1:7878</em> im Browser; du
solltest dein HTML gerendert sehen!</p>
<p>Gegenwärtig ignorieren wir die Anfragedaten in <code>http_request</code> und senden
einfach den Inhalt der HTML-Datei bedingungslos zurück. Das heißt, wenn du
versuchst, <em>127.0.0.1:7878/something-else</em> in deinem Browser anzufragen,
erhältst du immer noch dieselbe HTML-Antwort zurück. Unser Server ist im Moment
sehr begrenzt und macht nicht das, was die meisten Webserver tun. Wir wollen
unsere Antworten je nach Anfrage anpassen und nur die HTML-Datei für eine
wohlgeformte Anfrage an <code>/</code> zurücksenden.</p>
<h3 id="validieren-der-anfrage-und-selektives-beantworten"><a class="header" href="#validieren-der-anfrage-und-selektives-beantworten">Validieren der Anfrage und selektives Beantworten</a></h3>
<p>Im Moment wird unser Webserver das HTML in der Datei zurückgeben, unabhängig
davon, was der Client angefragt hat. Fügen wir Funktionen hinzu, um zu
überprüfen, ob der Browser <code>/</code> anfragt, bevor er die HTML-Datei zurückgibt, und
um einen Fehler zurückzugeben, wenn der Browser etwas anderes anfragt. Dazu
müssen wir <code>handle_connection</code> modifizieren, wie in Codeblock 20-6 gezeigt.
Dieser neue Code prüft den Inhalt der erhaltenen Anfrage, ob <code>/</code> angefragt
wird, und fügt <code>if</code>- und <code>else</code>-Blöcke hinzu, um die Anfragen unterschiedlich
zu behandeln.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == &quot;GET / HTTP/1.1&quot; {
        let status_line = &quot;HTTP/1.1 200 OK&quot;;
        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // eine andere Anfrage
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 20-6: Behandlung von Anfragen an <code>/</code> anders als
andere Anfragen</span></p>
<p>Wir werden uns nur die erste Zeile der HTTP-Anfrage ansehen. Anstatt also die
gesamte Anfrage in einen Vektor zu lesen, rufen wir <code>next</code> auf, um das erste
Element aus dem Iterator zu erhalten. Das erste <code>unwrap</code> kümmert sich um die
<code>Option</code> und hält das Programm an, wenn der Iterator keine Elemente hat. Das
zweite <code>unwrap</code> behandelt das <code>Result</code> und hat den gleichen Effekt wie das
<code>unwrap</code> in  <code>map</code> in Codeblock 20-2.</p>
<p>Als nächstes überprüfen wir <code>request_line</code>, um zu sehen, ob es der Anfragezeile
einer GET-Anfrage mit dem Pfad <code>/</code> entspricht. Ist dies der Fall, gibt der
<code>if</code>-Block den Inhalt unserer HTML-Datei zurück.</p>
<p>Wenn <code>request_line</code> <em>nicht</em> der GET-Anfrage mit dem <code>/</code> Pfad entspricht,
bedeutet das, dass wir eine andere Anfrage erhalten haben. Wir werden dem
<code>else</code>-Block gleich Code hinzufügen, um auf alle anderen Anfragen zu reagieren.</p>
<p>Führe diesen Code jetzt aus und frage <em>127.0.0.1:7878</em> an; du solltest das HTML
in <em>hello.html</em> erhalten. Wenn du eine andere Anfrage stellst, z.B.
<em>127.0.0.1:7878/something-else</em>, erhältst du einen Verbindungsfehler, wie du
ihn beim Ausführen des Codes in Codeblock 20-1 und Codeblock 20-2 gesehen hast.</p>
<p>Fügen wir nun den Code in Codeblock 20-7 in den <code>else</code>-Block ein, um eine
Antwort mit dem Statuscode 404 zurückzugeben, der signalisiert, dass der Inhalt
für die Anfrage nicht gefunden wurde. Wir geben auch etwas HTML für eine Seite
zurück, die im Browser dargestellt werden soll, um dem Endbenutzer die Antwort
anzuzeigen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == &quot;GET / HTTP/1.1&quot; {
</span><span class="boring">        let status_line = &quot;HTTP/1.1 200 OK&quot;;
</span><span class="boring">        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --abschneiden--
    } else {
        let status_line = &quot;HTTP/1.1 404 NOT FOUND&quot;;
        let contents = fs::read_to_string(&quot;404.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-7: Antworten mit Statuscode 404 und einer
Fehlerseite, wenn etwas anderes als <code>/</code> angefragt wurde</span></p>
<p>Hier hat unsere Antwort eine Statuszeile mit Statuscode 404 und der
Begründungsphrase <code>NOT FOUND</code> (nicht gefunden). Der Rumpf der Antwort wird das
HTML in der Datei <em>404.html</em> sein. Du musst neben <em>hallo.html</em> eine Datei
<em>404.html</em> für die Fehlerseite erstellen; auch hier kannst du jedes beliebige
HTML verwenden oder das Beispiel-HTML in Codeblock 20-8.</p>
<p><span class="filename">Dateiname: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hallo!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Ups!&lt;/h1&gt;
    &lt;p&gt;Entschuldige, ich weiß nicht wonach du gefragt hast.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Codeblock 20-8: Beispielinhalt für die Seite, die mit
jeder 404-Antwort zurückgesendet werden soll</span></p>
<p>Lass deinen Server mit diesen Änderungen erneut laufen. Die Anfrage
<em>127.0.0.1:7878</em> sollte den Inhalt von <em>hallo.html</em> zurückgeben und jede andere
Anfrage, wie <em>127.0.0.1:7878/foo</em>, sollte das Fehler-HTML von <em>404.html</em>
zurückgeben.</p>
<h3 id="ein-hauch-von-refaktorierung"><a class="header" href="#ein-hauch-von-refaktorierung">Ein Hauch von Refaktorierung</a></h3>
<p>Im Moment haben die <code>if</code>- und <code>else</code>-Blöcke eine Menge Wiederholungen: Sie
lesen beide Dateien und schreiben den Inhalt der Dateien in den Strom. Die
einzigen Unterschiede sind die Statuszeile und der Dateiname. Lass uns den Code
prägnanter gestalten, indem wir diese Unterschiede in separate <code>if</code>- und
<code>else</code>-Zeilen herausziehen, die die Werte der Statuszeile und des Dateinamens
Variablen zuweisen; wir können diese Variablen dann bedingungslos im Code
verwenden, um die Datei zu lesen und die Antwort zu schreiben. Codeblock 20-9
zeigt den resultierenden Code nach dem Ersetzen der großen <code>if</code>- und
<code>else</code>-Blöcke.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--

fn handle_connection(mut stream: TcpStream) {
    // --abschneiden--

<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = if request_line == &quot;GET / HTTP/1.1&quot; {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 20-9: Refaktorieren der <code>if</code>- und
<code>else</code>-Blöcke, sodass sie nur den Code enthalten, der sich zwischen den beiden
Fällen unterscheidet</span></p>
<p>Die Blöcke <code>if</code> und <code>else</code> geben jetzt nur noch die entsprechenden Werte für
die Statuszeile und den Dateinamen in einem Tupel zurück; wir verwenden dann
die Destrukturierung, um diese beiden Werte den Variablen <code>status_line</code> und
<code>filename</code> zuzuweisen, unter Verwendung eines Musters in der <code>let</code>-Anweisung,
wie in Kapitel 18 besprochen.</p>
<p>Der zuvor duplizierte Code befindet sich jetzt außerhalb der Blöcke <code>if</code> und
<code>else</code> und verwendet die Variablen <code>status_line</code> und <code>filename</code>. Dies macht es
einfacher, den Unterschied zwischen den beiden Fällen zu erkennen, und es
bedeutet, dass wir nur einen Ort haben, an dem wir den Code aktualisieren
müssen, wenn wir ändern wollen, wie das Lesen der Datei und das Schreiben der
Antwort funktionieren. Das Verhalten des Codes in Codeblock 20-9 ist dasselbe
wie in Codeblock 20-8.</p>
<p>Fantastisch! Wir haben jetzt einen einfachen Webserver mit etwa 40 Zeilen
Rust-Code, der auf eine Anfrage mit einer Inhaltsseite antwortet und auf alle
anderen Anfragen mit einer 404-Antwort.</p>
<p>Derzeit läuft unser Server in einem einzigen Strang (thread), d.h. er kann
immer nur eine Anfrage gleichzeitig bedienen. Lass uns untersuchen, warum das
ein Problem sein kann, indem wir einige langsame Anfragen simulieren. Dann
werden wir es beheben, indem unser Server mehrere Anfragen auf einmal
bearbeiten kann.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unseren-einsträngigen-single-threaded-webserver-in-einen-mehrsträngigen-multi-threaded-webserver-verwandeln"><a class="header" href="#unseren-einsträngigen-single-threaded-webserver-in-einen-mehrsträngigen-multi-threaded-webserver-verwandeln">Unseren einsträngigen (single-threaded) Webserver in einen mehrsträngigen (multi-threaded) Webserver verwandeln</a></h2>
<p>Im Moment verarbeitet der Server jede Anfrage der Reihe nach, d.h. er wird erst
dann eine zweite Verbindung verarbeiten, wenn die erste abgeschlossen ist.
Würde der Server mehr und mehr Anfragen erhalten, wäre diese serielle
Ausführung immer weniger optimal. Wenn der Server eine Anfrage erhält, deren
Bearbeitung sehr lange dauert, müssen nachfolgende Anfragen warten, bis die
lange dauernde Anfrage beendet ist, auch wenn die neuen Anfragen schnell
bearbeitet werden können. Das müssen wir beheben, aber zuerst werden wir uns
das Problem in Aktion ansehen.</p>
<h3 id="simulieren-einer-langsamen-anfrage-in-der-aktuellen-server-implementierung"><a class="header" href="#simulieren-einer-langsamen-anfrage-in-der-aktuellen-server-implementierung">Simulieren einer langsamen Anfrage in der aktuellen Server-Implementierung</a></h3>
<p>Wir werden untersuchen, wie sich eine Anfrage mit langsamer Verarbeitung auf
andere Anfragen an unsere aktuelle Server-Implementierung auswirken kann.
Codeblock 20-10 implementiert die Behandlung einer Anfrage an <em>/sleep</em> mit
einer simulierten langsamen Antwort, die den Server veranlasst, 5 Sekunden lang
zu schlafen, bevor er antwortet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --abschneiden--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    // --abschneiden--

<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
            thread::sleep(Duration::from_secs(5));
            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
        }
        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
    };

    // --abschneiden--
<span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre></pre>
<p><span class="caption">Codeblock 20-10: Simulieren einer langsamen Anfrage durch
Schlafen von 5 Sekunden</span></p>
<p>Wir haben von <code>if</code> zu <code>match</code> gewechselt, da wir nun drei Fälle haben. Wir
müssen explizit auf ein Stück von <code>request_line</code> abgleichen, um einen
Musterabgleich mit den Zeichenketten-Literalwerten durchzuführen; <code>match</code> führt
keine automatische Referenzierung und Dereferenzierung durch, wie es die
Gleichheitsmethode tut.</p>
<p>Der erste Zweig ist der gleiche wie der <code>if</code>-Block aus Codeblock 20-9. Der
zweite Zweig entspricht einer Anfrage an <em>/sleep</em>. Wenn diese Anfrage empfangen
wird, schläft der Server für 5 Sekunden, bevor er die erfolgreiche HTML-Seite
rendert. Der dritte Zweig entspricht dem <code>else</code>-Block aus Codeblock 20-9.</p>
<p>Du kannst sehen, wie primitiv unser Server ist: Echte Bibliotheken würden das
Erkennen mehrerer Anfragen viel weniger wortreich handhaben!</p>
<p>Starte den Server mit <code>cargo run</code>. Öffne dann zwei Browser-Fenster: Eines für
<em>http://127.0.0.1:7878/</em> und das andere für <em>http://127.0.0.1:7878/sleep</em>. Wenn
du die URI <code>/</code> wie bisher ein paar Mal eingibst, wirst du sehen, dass er
schnell reagiert. Aber wenn du <em>/sleep</em> eingibst und dann <code>/</code> lädst, wirst du
sehen, dass <code>/</code> wartet, bis <code>sleep</code> für volle 5 Sekunden geschlafen hat, bevor
es geladen wird.</p>
<p>Es gibt mehrere Techniken, um zu vermeiden, dass sich Anfragen hinter einer
langsamen Anfrage stauen; diejenige, die wir implementieren werden, ist ein
Strang-Vorrat (thread pool).</p>
<h3 id="verbessern-des-durchsatzes-mit-einem-strang-vorrat"><a class="header" href="#verbessern-des-durchsatzes-mit-einem-strang-vorrat">Verbessern des Durchsatzes mit einem Strang-Vorrat</a></h3>
<p>Ein <em>Strang-Vorrat</em> (thread pool) ist eine Gruppe von erzeugten Strängen, die
warten und bereit sind, eine Aufgabe zu bearbeiten. Wenn das Programm eine neue
Aufgabe erhält, ordnet es einen der Stränge im Pool der Aufgabe zu, und dieser
Strang wird die Aufgabe bearbeiten. Die verbleibenden Stränge im Pool stehen
für alle anderen Aufgaben zur Verfügung, die während der Verarbeitung des
ersten Strangs hereinkommen. Wenn der erste Strang mit der Verarbeitung seiner
Aufgabe fertig ist, kehrt er in den Vorrat der unbeschäftigten Stränge zurück
und ist bereit, eine neue Aufgabe zu bearbeiten. Ein Strang-Vorrat ermöglicht
es dir, Verbindungen gleichzeitig zu verarbeiten und so den Durchsatz deines
Servers zu erhöhen.</p>
<p>Wir beschränken die Anzahl der Stränge im Vorrat auf eine kleine Anzahl, um uns
vor Dienstverweigerungsangriffen (Denial-of-Service, kurz DoS) zu schützen;
wenn unser Programm für jede eingehende Anfrage einen neuen Strang erstellen
würde, könnte jemand, der 10 Millionen Anfragen an unseren Server stellt, ein
Chaos anrichten, indem er alle Ressourcen unseres Servers aufbraucht und die
Bearbeitung der Anfragen zum Erliegen bringt.</p>
<p>Anstatt unbegrenzt viele Stränge zu erzeugen, werden wir eine feste Anzahl von
Strängen im Vorrat warten lassen. Wenn Anfragen eingehen, werden sie zur
Verarbeitung an den Vorrat geschickt. Der Vorrat verwaltet eine Warteschlange
für eingehende Anfragen. Jeder der Stränge im Vorrat wird eine Anfrage aus
dieser Warteschlange holen, die Anfrage bearbeiten und dann die Warteschlange
um eine weitere Anfrage fragen. Mit diesem Design können wir bis zu <code>N</code>
Anfragen gleichzeitig bearbeiten, wobei <code>N</code> die Anzahl der Stränge ist. Wenn
jeder Strang auf eine lang laufende Anfrage antwortet, können sich nachfolgende
Anfragen immer noch in der Warteschlange rückstauen, aber wir haben die Anzahl
der lang laufenden Anfragen erhöht, die wir bearbeiten können, bevor wir diesen
Punkt erreichen.</p>
<p>Diese Technik ist nur eine von vielen Möglichkeiten, den Durchsatz eines
Webservers zu verbessern. Weitere Optionen, die du untersuchen könntest, sind
das <em>Fork/Join-Modell</em>, das <em>asynchrone E/A-Modell mit einem Strang</em> und das
<em>asynchrone E/A-Modell mit mehreren Strängen</em>. Wenn du an diesem Thema
interessiert bist, kannst du mehr über andere Lösungen lesen und versuchen, sie
in Rust zu implementieren; mit einer systemnahen Sprache wie Rust sind alle
diese Optionen möglich.</p>
<p>Bevor wir mit der Implementierung eines Strang-Vorrats beginnen, lass uns
darüber sprechen, wie die Verwendung des Vorrats aussehen sollte. Wenn du
versuchst, Code zu entwerfen, kann das Schreiben der Client-Benutzeroberfläche
beim Entwurf helfen. Schreibe die API des Codes so, dass sie so strukturiert
ist, wie du sie aufrufen möchtest; implementiere dann die Funktionalität
innerhalb dieser Struktur, anstatt zuerst die Funktionalität zu implementieren
und danach die öffentliche API zu entwerfen.</p>
<p>Ähnlich wie wir die testgetriebene Entwicklung im Projekt in Kapitel 12
angewendet haben, werden wir hier die compilergetriebene Entwicklung verwenden.
Wir werden den Code schreiben, der die von uns gewünschten Funktionen aufruft,
und dann schauen wir uns Fehler des Compilers an, um zu bestimmen, was wir als
Nächstes ändern sollten, damit der Code funktioniert. Bevor wir das tun, werden
wir jedoch die Technik erkunden, die wir nicht als Ausgangspunkt verwenden
werden.</p>
<h4 id="für-jede-anfrage-einen-eigenen-strang-erstellen"><a class="header" href="#für-jede-anfrage-einen-eigenen-strang-erstellen">Für jede Anfrage einen eigenen Strang erstellen</a></h4>
<p>Lass uns zunächst untersuchen, wie unser Code aussehen könnte, wenn er für jede
Verbindung einen neuen Strang erstellen würde. Wie bereits erwähnt, ist dies
nicht unser endgültiger Plan, da es Probleme mit dem potenziellen Erzeugen
einer unbegrenzten Anzahl von Strängen gibt, aber es ist ein Ausgangspunkt, um
zunächst einen funktionierenden mehrsträngigen Server zu erhalten. Dann fügen
wir den Strang-Vorrat als Verbesserung hinzu, und es wird einfacher, die beiden
Lösungen zu vergleichen. Codeblock 20-11 zeigt die Änderungen, die an <code>main</code>
vorgenommen werden müssen, um einen neuen Strang zu erzeugen, der jeden Strom
innerhalb der <code>for</code>-Schleife verarbeitet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-11: Erstellen eines neuen Strangs für jeden
Strom</span></p>
<p>Wie du in Kapitel 16 gelernt hast, wird <code>thread::spawn</code> einen neuen Strang
erstellen und dann den Code im Funktionsabschluss (closure) im neuen Strang
ausführen. Wenn du diesen Code ausführst und <em>/sleep</em> in deinem Browser lädst,
dann <code>/</code> in zwei weiteren Browser-Tabs, wirst du in der Tat sehen, dass die
Anfragen an <code>/</code> nicht auf die Beendigung von <em>/sleep</em> warten müssen. Aber wie
wir bereits erwähnt haben, wird dies letztendlich das System überfordern, weil
du neue Stränge ohne jede Begrenzung erstellen würdest.</p>
<h4 id="erstellen-einer-endliche-anzahl-von-strängen"><a class="header" href="#erstellen-einer-endliche-anzahl-von-strängen">Erstellen einer endliche Anzahl von Strängen</a></h4>
<p>Wir möchten, dass unser Strang-Vorrat in einer ähnlichen, vertrauten Weise
arbeitet, sodass der Wechsel von Strängen zu einem Strang-Vorrat keine großen
Änderungen am Code erfordert, der unsere API verwendet. Codeblock 20-12 zeigt
die hypothetische Schnittstelle für eine Struktur (struct) <code>ThreadPool</code>, die
wir anstelle von <code>thread::spawn</code> verwenden wollen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 20-12: Unsere ideale
<code>ThreadPool</code>-Schnittstelle</span></p>
<p>Wir verwenden <code>ThreadPool::new</code>, um einen neuen Strang-Vorrat mit einer
konfigurierbaren Anzahl von Strängen zu erstellen, in diesem Fall vier. In der
<code>for</code>-Schleife hat <code>pool.execute</code> eine ähnliche Schnittstelle wie
<code>thread::spawn</code>, indem es einen Funktionsabschluss entgegennimmt, den der
Vorrat für jeden Strom ausführen soll. Wir müssen <code>pool.execute</code>
implementieren, sodass es den Funktionsabschluss entgegennimmt und ihn einem
Strang im Vorrat zur Ausführung übergibt. Dieser Code lässt sich noch nicht
kompilieren, aber wir werden es versuchen, damit der Compiler uns anleiten
kann, wie wir das Problem beheben können.</p>
<h4 id="aufbau-von-threadpool-mit-compilergetriebener-entwicklung"><a class="header" href="#aufbau-von-threadpool-mit-compilergetriebener-entwicklung">Aufbau von <code>ThreadPool</code> mit compilergetriebener Entwicklung</a></h4>
<p>Nimm die Änderungen in Codeblock 20-12 an <em>src/main.rs</em> vor und lass uns dann
die Kompilierfehler von <code>cargo check</code> verwenden, um unsere Entwicklung
voranzutreiben. Hier ist der erste Fehler, den wir erhalten:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Großartig! Dieser Fehler sagt uns, dass wir einen Typ oder ein Modul
<code>ThreadPool</code> benötigen, also werden wir jetzt eines bauen. Unsere
<code>ThreadPool</code>-Implementierung wird unabhängig von der Art der Arbeit unseres
Webservers sein. Lass uns also die Kiste (crate) <code>hello</code> von einer Binär-Kiste
(binary crate) auf eine Bibliotheks-Kiste (library crate) umstellen, um unsere
<code>ThreadPool</code>-Implementierung aufzunehmen. Nachdem wir zu einer Bibliothekskiste
umgestellt haben, könnten wir die separate Strang-Vorrats-Bibliothek auch für
alle Arbeiten verwenden, die wir mit einem Strang-Vorrat durchführen wollen,
nicht nur für die Bedienung von Webanfragen.</p>
<p>Erstelle eine Datei <em>src/lib.rs</em>, die das Folgende enthält, was die einfachste
Definition einer <code>ThreadPool</code>-Struktur ist, die wir im Moment haben können:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
<p>Bearbeite dann die Datei <em>main.rs</em>, um <code>ThreadPool</code> in den Gültigkeitsbereich
der Bibliothekskiste zu bringen, indem du den folgenden Code am Anfang von
<em>src/main.rs</em> hinzufügst:</p>
<p><span class="filename">Dateiname: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(
</span><span class="boring">        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">        status_line,
</span><span class="boring">        contents.len(),
</span><span class="boring">        contents
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    stream.write(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}</span></code></pre>
<p>Dieser Code wird immer noch nicht funktionieren, aber lass uns ihn noch einmal
überprüfen, um den nächsten Fehler zu erhalten, den wir beheben müssen:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/bin/main.rs:11:28
   |
11 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Dieser Fehler deutet darauf hin, dass wir als Nächstes eine zugehörige Funktion
namens <code>new</code> für <code>ThreadPool</code> erstellen müssen. Wir wissen auch, dass <code>new</code>
einen Parameter haben muss, der <code>4</code> als Argument akzeptieren kann und eine
<code>ThreadPool</code>-Instanz zurückgeben sollte. Lass uns die einfachste Funktion <code>new</code>
implementieren, die diese Eigenschaften haben wird:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}</code></pre>
<p>Wir haben <code>usize</code> als Typ des Parameters <code>size</code> gewählt, weil wir wissen, dass
eine negative Anzahl von Strängen keinen Sinn macht. Wir wissen auch, dass wir
diese 4 als die Anzahl der Elemente in einer Kollektion von Strängen verwenden
werden, wofür der Typ <code>usize</code> gedacht ist, wie im Abschnitt
<a href="ch03-02-data-types.html#ganzzahl-typen">„Ganzzahl-Typen“</a> in Kapitel 3 besprochen.</p>
<p>Lass uns den Code noch einmal überprüfen:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/bin/main.rs:16:14
   |
16 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `hello::ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Der Fehler tritt jetzt auf, weil wir keine Methode <code>execute</code> auf <code>ThreadPool</code>
haben. Erinnere dich an den Abschnitt <a href="ch20-02-multithreaded.html#erstellen-einer-endliche-anzahl-von-str%C3%A4ngen">„Erstellen einer endlichen Anzahl von
Strängen“</a>, dass wir beschlossen haben, dass unser
Strang-Vorrat eine ähnliche Schnittstelle wie <code>thread::spawn</code> haben sollte.
Zusätzlich werden wir die Funktion <code>execute</code> implementieren, sodass sie den
Funktionsabschluss, der ihr gegeben wird, nimmt und sie einem unbeschäftigten
Strang im Vorrat zur Ausführung übergibt.</p>
<p>Wir werden die Methode <code>execute</code> auf <code>ThreadPool</code> definieren, um einen
Funktionsabschluss als Parameter zu nehmen. Aus dem Abschnitt <a href="ch13-01-closures.html#verschieben-erfasster-werte-aus-funktionsabschl%C3%BCssen-und-fn-merkmalen">„Verschieben
erfasster Werte aus Funktionsabschlüssen und Fn-Merkmalen“</a>
in Kapitel 13 erinnern wir uns, dass wir Funktionsabschlüsse als Parameter mit
drei verschiedenen Merkmalen nehmen können: <code>Fn</code>, <code>FnMut</code> und <code>FnOnce</code>. Wir
müssen entscheiden, welche Art von Funktionsabschluss wir hier verwenden. Wir
wissen, dass wir am Ende etwas Ähnliches wie die Implementierung
<code>thread::spawn</code> der Standardbibliothek tun werden, sodass wir uns ansehen
können, welche Abgrenzungen die Signatur von <code>thread::spawn</code> in ihrem Parameter
hat. Die Dokumentation zeigt uns Folgendes:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static</code></pre>
<p>Der Parameter vom Typ <code>F</code> ist derjenige, um den es hier geht; der Parameter vom
Typ <code>T</code> bezieht sich auf den Rückgabewert, und darum geht es uns nicht. Wir
können sehen, dass <code>spawn</code> <code>FnOnce</code> als Merkmal (trait) verwendet, das an <code>F</code>
gebunden ist. Das ist wahrscheinlich auch das, was wir wollen, denn wir werden
das Argument, das wir bei <code>execute</code> bekommen, letztendlich an <code>spawn</code>
weitergeben. Wir können weiterhin zuversichtlich sein, dass <code>FnOnce</code> das
Merkmal ist, das wir verwenden wollen, weil der Strang zum Ausführen einer
Anfrage den Funktionsabschluss dieser Anfrage nur einmal ausführt, was zu
<code>Once</code> in <code>FnOnce</code> passt.</p>
<p>Der Parameter vom Typ <code>F</code> hat auch die Merkmalsabgrenzung <code>Send</code> und die
Lebensdauer <code>'static</code>, die in unserer Situation nützlich sind: Wir brauchen
<code>Send</code>, um die Merkmalsabgrenzung von einem Strang zu einem anderen zu
übertragen und <code>'static</code>, weil wir nicht wissen, wie lange die Ausführung des
Strangs dauern wird. Lass uns eine Methode <code>execute</code> auf <code>ThreadPool</code>
erstellen, die einen generischen Parameter vom Typ <code>F</code> mit diesen Abgrenzungen
annimmt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --abschneiden--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Wir verwenden immer noch <code>()</code> nach <code>FnOnce</code>, weil dieses <code>FnOnce</code> einen
Funktionsabschluss darstellt, der keine Parameter benötigt und den Einheitstyp
<code>()</code> zurückgibt. Genau wie bei Funktionsdefinitionen kann der Rückgabetyp in
der Signatur weggelassen werden, aber selbst wenn wir keine Parameter haben,
benötigen wir immer noch die Klammern.</p>
<p>Auch hier handelt es sich um die einfachste Implementierung der Methode
<code>execute</code>: Sie tut nichts, aber wir versuchen nur, unseren Code kompilieren zu
lassen. Lass es uns noch einmal überprüfen:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>Er kompiliert! Aber beachte, dass du, wenn du <code>cargo run</code> versuchst und eine
Anfrage im Browser stellst, die Fehler im Browser sehen wirst, die wir am
Anfang des Kapitels gesehen haben. Unsere Bibliothek ruft den
Funktionsabschluss, den wir an <code>execute</code> übergeben, noch nicht wirklich auf!</p>
<blockquote>
<p>Hinweis: Ein Sprichwort, das man möglicherweise über Sprachen mit strengen
Compilern wie Haskell und Rust hört, lautet: „Wenn der Code kompiliert,
funktioniert er.“ Aber dieses Sprichwort ist nicht universell wahr. Unser
Projekt kompiliert, aber es tut absolut nichts! Wenn wir ein echtes,
vollständiges Projekt aufbauen würden, wäre dies ein guter Zeitpunkt, mit dem
Schreiben von Modultests zu beginnen, um zu überprüfen, ob der Code
kompiliert <em>und</em> das von uns gewünschte Verhalten aufweist.</p>
</blockquote>
<h4 id="validieren-der-anzahl-der-stränge-in-new"><a class="header" href="#validieren-der-anzahl-der-stränge-in-new">Validieren der Anzahl der Stränge in <code>new</code></a></h4>
<p>Wir tun nichts mit den Parametern von <code>new</code> und <code>execute</code>. Lass uns die Rümpfe
dieser Funktionen mit dem Verhalten implementieren, das wir wollen. Lass uns
zunächst über <code>new</code> nachdenken. Früher wählten wir einen vorzeichenlosen Typ
für den Parameter <code>size</code>, weil ein Vorrat mit einer negativen Anzahl von
Strängen keinen Sinn ergibt. Ein Vorrat mit null Strängen ergibt jedoch auch
keinen Sinn, dennoch ist null ein vollkommen gültiges <code>usize</code>. Wir fügen Code
hinzu, um zu prüfen, ob <code>size</code> größer als null ist, bevor wir eine
<code>ThreadPool</code>-Instanz zurückgeben, und das Programm abstürzen lassen, wenn er
eine Null erhält, indem wir das Makro <code>assert!</code> verwenden, wie in Codeblock
20-13 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Erzeuge einen neuen ThreadPool.
    ///
    /// Die Größe ist die Anzahl der Stränge im Vorrat.
    ///
    /// # Panics
    ///
    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Codeblock 20-13: Implementierung von <code>ThreadPool::new</code>
stürzt ab, wenn <code>size</code> gleich Null ist</span></p>
<p>Wir haben auch etwas Dokumentation für unseren <code>ThreadPool</code> mit
Dokumentationskommentaren (doc comments) hinzugefügt. Beachte, dass wir uns an
gute Dokumentationspraktiken gehalten haben, indem wir einen Abschnitt
hinzugefügt haben, der die Situationen aufzeigt, in denen unsere Funktion
abstürzen kann, wie in Kapitel 14 besprochen. Versuche, <code>cargo doc --open</code>
auszuführen und die Struktur <code>ThreadPool</code> anzuklicken, um zu sehen, wie die
generierte Dokumentation für <code>new</code> aussieht!</p>
<p>Anstatt das Makro <code>assert!</code> hinzuzufügen, wie wir es hier getan haben, könnten
wir <code>new</code> zu <code>build</code> ändern und ein <code>Result</code> zurückgeben lassen, wie wir es mit
<code>Config::build</code> im E/A-Projekt in Codeblock 12-9 getan haben. Aber wir haben in
diesem Fall entschieden, dass der Versuch, einen Strang-Vorrat ohne Stränge zu
erstellen, ein nicht behebbarer Fehler sein sollte. Wenn du ehrgeizig bist,
versuche, eine Funktion namens <code>build</code> mit der folgenden Signatur zu schreiben,
um sie mit der Funktion <code>new</code> zu vergleichen:</p>
<pre><code class="language-rust ignore">pub fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="platz-zum-speichern-der-stränge-schaffen"><a class="header" href="#platz-zum-speichern-der-stränge-schaffen">Platz zum Speichern der Stränge schaffen</a></h4>
<p>Jetzt, da wir eine Möglichkeit haben, zu wissen, dass wir eine gültige Anzahl
von Strängen im Vorrat haben, können wir diese Stränge erstellen und sie in der
Struktur <code>ThreadPool</code> speichern, bevor wir die Struktur zurückgeben. Aber wie
„speichern“ wir einen Strang? Werfen wir noch einmal einen Blick auf die
Signatur von <code>Thread::spawn</code>:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static</code></pre>
<p>Die Funktion <code>spawn</code> gibt einen <code>JoinHandle&lt;T&gt;</code> zurück, wobei <code>T</code> der Typ ist,
den der Funktionsabschluss zurückgibt. Lass uns versuchen, auch <code>JoinHandle</code> zu
benutzen und sehen, was passiert. In unserem Fall werden die
Funktionsabschlüsse, die wir an den Strang-Vorrat übergeben, die Verbindung
behandeln und nichts zurückgeben, also wird <code>T</code> der Unit-Typ <code>()</code> sein.</p>
<p>Der Code in Codeblock 20-14 lässt sich kompilieren, erzeugt aber noch keine
Stränge. Wir haben die Definition von <code>ThreadPool</code> so geändert, dass sie einen
Vektor von <code>thread::JoinHandle&lt;()&gt;</code>-Instanzen enthält, den Vektor mit der
Kapazität <code>size</code> initialisiert, eine <code>for</code>-Schleife eingerichtet, die etwas
Code zum Erzeugen der Stränge ausführt, und eine <code>ThreadPool</code>-Instanz
zurückgibt, die diese enthält.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // einige Stränge erstellen und im Vektor speichern
        }

        ThreadPool { threads }
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Codeblock 20-14: Erstellen eines Vektors für <code>ThreadPool</code>
zum Aufnehmen der Stränge</span></p>
<p>Wir haben <code>std::thread</code> in der Bibliothekskiste in den Gültigkeitsbereich
gebracht, weil wir <code>thread::JoinHandle</code> als den Typ der Elemente im Vektor in
<code>ThreadPool</code> verwenden.</p>
<p>Sobald wir eine gültige Größe erhalten haben, erzeugt unser <code>ThreadPool</code> einen
neuen Vektor, der <code>size</code> Elemente aufnehmen kann. Die Funktion <code>with_capacity</code>
erfüllt die gleiche Aufgabe wie <code>Vec::new</code>, aber mit einem wichtigen
Unterschied: Sie weist dem Vektor Platz im Voraus zu. Da wir wissen, dass wir
<code>size</code> Elemente im Vektor speichern müssen, ist diese Allokation im Voraus
etwas effizienter als die Verwendung von <code>Vec::new</code>, das sich selbst in der
Größe verändert, wenn Elemente eingefügt werden.</p>
<p>Wenn du <code>cargo check</code> erneut ausführst, sollte es erfolgreich sein.</p>
<h4 id="struktur-worker-zum-senden-von-code-vom-threadpool-an-einen-strang"><a class="header" href="#struktur-worker-zum-senden-von-code-vom-threadpool-an-einen-strang">Struktur <code>Worker</code> zum Senden von Code vom <code>ThreadPool</code> an einen Strang</a></h4>
<p>Wir haben einen Kommentar in der <code>for</code>-Schleife in Codeblock 20-14 bezüglich
der Erstellung von Strängen hinterlassen. Hier werden wir uns ansehen, wie wir
tatsächlich Stränge erstellen. Die Standardbibliothek bietet <code>thread::spawn</code>
als eine Möglichkeit, Stränge zu erstellen, und <code>thread::spawn</code> erwartet, dass
es Code erhält, den der Strang ausführen soll, sobald der Strang erstellt ist.
In unserem Fall wollen wir jedoch die Stränge erstellen und sie auf Code
<em>warten</em> lassen, den wir später senden werden. Die Implementierung von Strängen
in der Standardbibliothek enthält keine Möglichkeit, dies zu tun; wir müssen
sie manuell implementieren.</p>
<p>Wir werden dieses Verhalten implementieren, indem wir eine neue Datenstruktur
zwischen dem <code>ThreadPool</code> und den Strängen, die dieses neue Verhalten verwalten
werden, einführen. Wir nennen diese Datenstruktur <code>Worker</code>, was ein gängiger
Begriff in Vorrats-Implementierungen ist. Der <code>Worker</code> holt den Code ab, der
ausgeführt werden muss, und führt ihn im Strang des <code>Worker</code> aus. Denke an
Menschen, die in der Küche eines Restaurants arbeiten: Die Arbeiter warten, bis
Bestellungen von Kunden eingehen, und dann sind sie dafür verantwortlich, diese
Bestellungen entgegenzunehmen und auszuführen.</p>
<p>Anstatt einen Vektor von <code>JoinHandle&lt;()&gt;</code>-Instanzen im Strang-Vorrat zu
speichern, werden wir Instanzen der <code>Worker</code>-Struktur speichern. Jeder <code>Worker</code>
wird eine einzelne <code>JoinHandle&lt;()&gt;</code>-Instanz speichern. Dann werden wir eine
Methode auf <code>Worker</code> implementieren, die einen Funktionsabschluss zur
Ausführung benötigt und ihn zur Ausführung an den bereits laufenden Strang
sendet. Wir werden auch jedem <code>Worker</code> eine <code>id</code> geben, damit wir beim
Protokollieren oder Debuggen zwischen den verschiedenen <code>Worker</code> im Vorrat
unterscheiden können.</p>
<p>Hier ist der neue Prozess, der abläuft, wenn wir einen <code>ThreadPool</code> erstellen.
Wir werden den Code implementieren, der den Funktionsabschluss an den Strang
sendet, nachdem wir <code>Worker</code> auf diese Weise eingerichtet haben:</p>
<ol>
<li>Definiere eine Struktur <code>Worker</code>, die eine <code>id</code> und einen <code>JoinHandle&lt;()&gt;</code>
enthält.</li>
<li>Ändere <code>ThreadPool</code>, um einen Vektor von <code>Worker</code>-Instanzen zu halten.</li>
<li>Definiere eine Funktion <code>Worker::new</code>, die eine <code>id</code>-Nummer nimmt und eine
<code>Worker</code>-Instanz zurückgibt, die die <code>id</code> enthält, sowie einen Strang, der
mit einem leeren Funktionsabschluss erzeugt wurde.</li>
<li>Verwende in <code>ThreadPool::new</code> den <code>for</code>-Schleifenzähler, um eine <code>id</code> zu
erzeugen, erzeuge einen neuen <code>Worker</code> mit dieser <code>id</code> und speichere den
<code>Worker</code> im Vektor.</li>
</ol>
<p>Wenn du zu einer Herausforderung bereit bist, versuche, diese Änderungen selbst
zu implementieren, bevor du dir den Code in Codeblock 20-15 ansiehst.</p>
<p>Bereit? Hier ist Codeblock 20-15 mit einer Möglichkeit, die vorhergehenden
Änderungen vorzunehmen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Codeblock 20-15: Modifizieren von <code>ThreadPool</code>, um
<code>Worker</code>-Instanzen zu halten, anstatt Stränge direkt zu halten</span></p>
<p>Wir haben den Namen des Feldes in <code>ThreadPool</code> von <code>threads</code> in <code>workers</code>
geändert, weil es jetzt <code>Worker</code>-Instanzen statt <code>JoinHandle&lt;()&gt;</code>-Instanzen
enthält. Wir benutzen den Zähler in der <code>for</code>-Schleife als Argument für
<code>Worker::new</code> und wir speichern jeden neuen <code>Worker</code> im Vektor mit dem Namen
<code>workers</code>.</p>
<p>Externer Code (wie unser Server in <em>src/main.rs</em>) muss die
Implementierungsdetails bezüglich der Verwendung einer <code>Worker</code>-Struktur
innerhalb von <code>ThreadPool</code> nicht kennen, also machen wir die <code>Worker</code>-Struktur
und ihre Funktion <code>new</code> privat. Die Funktion <code>Worker::new</code> verwendet die <code>id</code>,
die wir ihr geben, und speichert eine <code>JoinHandle&lt;()&gt;</code>-Instanz, die durch das
Erzeugen eines neuen Strangs unter Verwendung eines leeren Funktionsabschlusses
erzeugt wird.</p>
<p>Dieser Code kompiliert und speichert die Anzahl der <code>Worker</code>-Instanzen, die wir
als Argument für <code>ThreadPool::new</code> angegeben haben. Aber wir <em>verarbeiten</em> noch
nicht den Funktionsabschluss, den wir in <code>execute</code> erhalten. Schauen wir uns
als Nächstes an, wie wir das machen.</p>
<h4 id="senden-von-anfragen-an-stränge-über-kanäle"><a class="header" href="#senden-von-anfragen-an-stränge-über-kanäle">Senden von Anfragen an Stränge über Kanäle</a></h4>
<p>Das nächste Problem, das wir angehen, ist dass die Funktionsabschlüsse bei
<code>thread::spawn</code> absolut nichts bewirken. Gegenwärtig erhalten wir den
Funktionsabschluss, den wir ausführen wollen, mit der Methode <code>execute</code>. Aber
wir müssen <code>thread::spawn</code> einen Funktionsabschluss geben, der ausgeführt
werden soll, wenn wir jeden <code>Worker</code> während der Erstellung des <code>ThreadPool</code>
erstellen.</p>
<p>Wir möchten, dass die Struktur <code>Worker</code>, die wir gerade erstellt haben, um den
Code aus einer Warteschlange im <code>ThreadPool</code> zu holen, diesen Code zur
Ausführung an seinen Strang sendet.</p>
<p>In Kapitel 16 hast du etwas über <em>Kanäle</em> (channels) gelernt – eine
einfache Art der Kommunikation zwischen zwei Strängen –, die für diesen
Anwendungsfall perfekt geeignet ist. Wir verwenden einen Kanal, der als
Warteschlange von Aufträgen fungiert, und <code>execute</code> sendet einen Auftrag aus
dem <code>ThreadPool</code> an die <code>Worker</code>-Instanzen, die den Auftrag an ihren Strang
sendet. Hier ist der Plan:</p>
<ol>
<li>Der <code>ThreadPool</code> erstellt einen Kanal und hält den Sender.</li>
<li>Jeder <code>Worker</code> hält den Empfänger.</li>
<li>Wir werden eine neue Struktur <code>Job</code> erstellen, die den Funktionsabschluss
aufnimmt, den wir über den Kanal senden wollen.</li>
<li>Die Methode <code>execute</code> sendet den Auftrag, der ausgeführt werden soll, durch
den Sender.</li>
<li>In seinem Strang wird der <code>Worker</code> auf den Empfänger warten und die
Funktionsabschlüsse aller Aufträge, die er erhält, ausführen.</li>
</ol>
<p>Beginnen wir damit, einen Kanal in <code>ThreadPool::new</code> zu erstellen und den
Sender in der <code>ThreadPool</code>-Instanz zu halten, wie in Codeblock 20-16
gezeigt. Die Struktur <code>Job</code> enthält vorerst nichts, aber sie wird die Art von
Element sein, die wir in den Kanal senden.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 20-16: Ändern von <code>ThreadPool</code>, um den Sender
zu speichern, der <code>Job</code>-Instanzen übermittelt</span></p>
<p>In <code>ThreadPool::new</code> erstellen wir unseren neuen Kanal und lassen den Pool das
sendende Ende halten. Dies kompiliert erfolgreich.</p>
<p>Lass uns versuchen, einen Empfänger an jeden <code>Worker</code> weiterzugeben, während
der Strang-Vorrat den Kanal erstellt. Wir wissen, dass wir den Empfänger
verwenden wollen, den der <code>Worker</code> hat, also werden wir den Parameter
<code>receiver</code> im Funktionsabschluss referenzieren. Der Code in Codeblock 20-17
lässt sich noch nicht ganz kompilieren.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --abschneiden--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Codeblock 20-17: Übergeben des Empfängers an die
<code>Worker</code></span></p>
<p>Wir haben einige kleine und unkomplizierte Änderungen vorgenommen: Wir geben
den Empfänger an <code>Worker::new</code> und dann verwenden wir ihn innerhalb des
Funktionsabschlusses.</p>
<p>Wenn wir versuchen, diesen Code zu überprüfen, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
22 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Der Code versucht, <code>receiver</code> an mehrere <code>Worker</code>-Instanzen weiterzugeben. Das
wird nicht funktionieren, wie du dich aus Kapitel 16 erinnern wirst: Die
Kanalimplementierung, die Rust bietet, erlaubt mehrere <em>Produzenten</em> und einen
einzigen <em>Konsumenten</em>. Das bedeutet, dass wir nicht einfach das konsumierende
Ende des Kanals klonen können, um diesen Code zu reparieren. Selbst wenn wir
das könnten, ist das nicht die Technik, die wir anwenden wollen; stattdessen
wollen wir die Aufträge auf mehrere Stränge verteilen, indem wir den einzigen
<code>receiver</code> unter allen <code>Worker</code> aufteilen.</p>
<p>Außerdem erfordert das Entfernen eines Auftrags aus der Warteschlange des
Kanals eine Mutation von <code>receiver</code>, sodass die Stränge einen sicheren Weg
benötigen, um <code>receiver</code> gemeinsam zu nutzen und zu modifizieren; andernfalls
könnten wir Wettlaufsituationen (race conditions) erhalten (wie in Kapitel 16
behandelt).</p>
<p>Erinnere dich an die Strang-sicheren intelligenten Zeiger, die in Kapitel 16
besprochen wurden: Um die Eigentümerschaft über mehrere Stränge zu teilen und
den Strängen zu erlauben, den Wert zu mutieren, müssen wir <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>
verwenden. Der Typ <code>Arc</code> ermöglicht es mehreren <code>Worker</code>, den Empfänger zu
besitzen, und <code>Mutex</code> stellt sicher, dass immer nur ein <code>Worker</code> zur gleichen
Zeit einen Auftrag vom Empfänger erhält. Der Codeblock 20-18 zeigt die
Änderungen, die wir vornehmen müssen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --abschneiden--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --abschneiden--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --abschneiden--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
<p><span class="caption">Codeblock 20-18: Den Empfänger unter den <code>Worker</code>
teilen, die <code>Arc</code> und <code>Mutex</code> benutzen</span></p>
<p>In <code>ThreadPool::new</code> setzen wir den Empfänger in einen <code>Arc</code> und einen
<code>Mutex</code>. Für jeden neuen <code>Worker</code> klonen wir den <code>Arc</code>, um die Referenzzählung
zu erhöhen, sodass die <code>Worker</code> die Eigentümerschaft des Empfängers teilen
können.</p>
<p>Mit diesen Änderungen kompiliert der Code! Wir haben es geschafft!</p>
<h4 id="implementieren-der-methode-execute"><a class="header" href="#implementieren-der-methode-execute">Implementieren der Methode <code>execute</code></a></h4>
<p>Lass uns endlich die Methode <code>execute</code> auf <code>ThreadPool</code> implementieren. Wir
werden auch <code>Job</code> von einer Struktur in einen Typ-Alias für ein Merkmalsobjekt
(trait object) ändern, das den Typ des Funktionsabschlusses enthält, den
<code>execute</code> erhält. Wie im Abschnitt <a href="ch19-04-advanced-types.html#erstellen-von-typ-synonymen-mit-typ-alias">„Erstellen von Typ-Synonymen mit
Typ-Alias“</a> in Kapitel 19 besprochen, ermöglichen uns
Typ-Aliase, lange Typen kürzer zu machen, um sie einfacher nutzen zu können.
Siehe Codeblock 20-19.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --abschneiden--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 20-19: Erstellen eines Alias vom Typ <code>Job</code> für
eine <code>Box</code>, die jeden Funktionsabschluss enthält, und danach Senden des
Auftrags in den Kanal</span></p>
<p>Nachdem wir eine neue <code>Job</code>-Instanz unter Verwendung des Funktionsabschlusses,
den wir in <code>execute</code> erhalten, erstellt haben, senden wir diesen Auftrag an das
sendende Ende des Kanals. Wir rufen <code>unwrap</code> auf <code>send</code> auf für den Fall, dass
das Senden fehlschlägt. Das kann zum Beispiel passieren, wenn wir alle unsere
Stränge von der Ausführung abhalten, was bedeutet, dass das empfangende Ende
keine neuen Nachrichten mehr empfängt. Im Moment können wir die Ausführung
unserer Stränge nicht stoppen: Unsere Stränge werden so lange ausgeführt, wie
der Vorrat existiert. Der Grund, warum wir <code>unwrap</code> verwenden, ist, dass wir
wissen, dass der Fehlerfall nicht passieren wird, aber der Compiler das nicht
weiß.</p>
<p>Aber wir sind noch nicht ganz fertig! Im <code>Worker</code> wird unser Funktionsabschluss
an <code>thread::spawn</code> weitergereicht, der immer noch nur auf das empfangende Ende
des Kanals <em>referenziert</em>. Stattdessen müssen wir den Funktionsabschluss für
immer in einer Schleife laufen lassen, indem wir das empfangende Ende des
Kanals um einen Auftrag bitten und den Auftrag ausführen, wenn er einen
bekommt. Lass uns die in Codeblock 20-20 gezeigte Änderung in <code>Worker::new</code>
vornehmen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!(&quot;Worker {id} hat einen Auftrag erhalten; führe ihn aus.&quot;);

            job();
        });

        Worker { id, thread }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-20: Empfangen und Ausführen der Aufträge im
Strang des <code>Worker</code></span></p>
<p>Hier rufen wir zuerst <code>lock</code> auf <code>receiver</code> auf, um den Mutex zu erwerben, und
dann rufen wir <code>unwrap</code> auf, um das Programm bei eventuellen Fehlern abstürzen
zu lassen. Das Akquirieren einer Sperre kann fehlschlagen, wenn sich der Mutex
in einem <em>vergifteten</em> Zustand befindet, was passieren kann, wenn ein anderer
Strang abstürzt, während er die Sperre hält, anstatt sie freizugeben. In dieser
Situation ist der Aufruf von <code>unwrap</code>, damit dieser Strang abstürzt, die
richtige Maßnahme. Fühle dich frei, dieses <code>unwrap</code> in ein <code>expect</code> mit einer
Fehlermeldung zu ändern, die für dich von Bedeutung ist.</p>
<p>Wenn wir die Sperre auf dem Mutex erhalten, rufen wir <code>recv</code> auf, um einen
<code>Job</code> vom Kanal zu empfangen. Ein abschließendes <code>unwrap</code> geht auch hier an
eventuellen Fehlern vorbei, die auftreten könnten, wenn sich der Strang, der
den Sender hält, beendet hat, ähnlich wie die <code>send</code>-Methode <code>Err</code> zurückgibt,
wenn der Empfänger abschaltet.</p>
<p>Der Aufruf von <code>recv</code> blockiert, wenn also noch kein Auftrag vorhanden ist,
wartet der aktuelle Strang, bis ein Auftrag verfügbar wird. Der <code>Mutex&lt;T&gt;</code>
stellt sicher, dass immer nur ein <code>Worker</code>-Strang zur gleichen Zeit versucht,
einen Auftrag anzufordern.</p>
<p>Unser Strang-Vorrat ist jetzt in einem funktionierenden Zustand! Führe <code>cargo run</code> aus und stelle einige Anfragen:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --&gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --&gt; src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: 3 warnings emitted

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 hat einen Auftrag erhalten; führe ihn aus.
Worker 2 hat einen Auftrag erhalten; führe ihn aus.
Worker 1 hat einen Auftrag erhalten; führe ihn aus.
Worker 3 hat einen Auftrag erhalten; führe ihn aus.
Worker 0 hat einen Auftrag erhalten; führe ihn aus.
Worker 2 hat einen Auftrag erhalten; führe ihn aus.
Worker 1 hat einen Auftrag erhalten; führe ihn aus.
Worker 3 hat einen Auftrag erhalten; führe ihn aus.
Worker 0 hat einen Auftrag erhalten; führe ihn aus.
Worker 2 hat einen Auftrag erhalten; führe ihn aus.
</code></pre>
<p>Erfolg! Wir haben jetzt einen Strang-Vorrat, der Verbindungen asynchron
ausführt. Es werden nie mehr als vier Stränge erzeugt, sodass unser System
nicht überlastet wird, wenn der Server viele Anfragen erhält. Wenn wir eine
Anfrage an <em>/sleep</em> stellen, ist der Server immer noch in der Lage, andere
Anfragen zu bedienen, indem er sie von einem anderen Strang ausführen lässt.</p>
<blockquote>
<p>Hinweis: Wenn du <em>/sleep</em> in mehreren Browser-Fenstern gleichzeitig öffnest,
werden diese möglicherweise in 5-Sekunden-Intervallen nacheinander geladen.
Einige Web-Browser führen aus Gründen der Zwischenspeicherung mehrere
Instanzen der gleichen Anfrage nacheinander aus. Diese Beschränkung wird
nicht durch unseren Webserver verursacht.</p>
</blockquote>
<p>Nachdem du die <code>while let</code>-Schleife in Kapitel 18 kennengelernt hast, fragst du
dich vielleicht, warum wir den Code für den <code>Worker</code>-Strang nicht geschrieben
haben, wie in Codeblock 20-21 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --abschneiden--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {id} hat einen Auftrag erhalten; führe ihn aus.&quot;);

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Codeblock 20-21: Eine alternative Implementierung von
<code>Worker::new</code> unter Verwendung von <code>while let</code></span></p>
<p>Dieser Code wird kompiliert und ausgeführt, führt aber nicht zum gewünschten
Strang-Verhalten: Eine langsame Anfrage führt immer noch dazu, dass andere
Anfragen auf ihre Bearbeitung warten. Der Grund dafür ist etwas subtil: Die
Struktur <code>Mutex</code> hat keine öffentliche Methode <code>unlock</code>, weil die
Eigentümerschaft der Sperre auf der Lebensdauer von <code>MutexGuard&lt;T&gt;</code> innerhalb
von <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> basiert, die die Methode <code>lock</code> zurückgibt. Zur
Kompilierzeit kann der Ausleihenprüfer (borrow checker) dann die Regel
durchsetzen, dass auf eine von einem <code>Mutex</code> bewachte Ressource nicht
zugegriffen werden kann, wenn wir die Sperre nicht halten. Diese
Implementierung kann aber auch dazu führen, dass die Sperre länger als
beabsichtigt gehalten wird, wenn wir nicht sorgfältig über die Lebensdauer von
<code>MutexGuard&lt;T&gt;</code> nachdenken. </p>
<p>Der Code in Codeblock 20-20, der <code>let job = receiver.lock().unwrap().recv().unwrap();</code> verwendet, funktioniert, weil mit
<code>let</code> alle temporären Werte, die in dem Ausdruck auf der rechten Seite des
Gleichheitszeichens verwendet werden, sofort verworfen werden, wenn die
<code>let</code>-Anweisung endet. Allerdings gibt <code>while let</code> (und <code>if let</code> und <code>match</code>)
temporäre Werte erst am Ende des zugehörigen Blocks frei. In Codeblock 20-21
bleibt die Sperre für die Dauer des Aufrufs von <code>job()</code> erhalten, was bedeutet,
dass andere <code>Worker</code> keine Aufträge erhalten können.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kontrolliertes-beenden-und-aufräumen"><a class="header" href="#kontrolliertes-beenden-und-aufräumen">Kontrolliertes Beenden und Aufräumen</a></h2>
<p>Der Code in Codeblock 20-20 antwortet auf Anfragen asynchron durch die
Verwendung eines Strang-Vorrats (thread pool), wie von uns beabsichtigt. Wir
erhalten einige Warnungen über die Felder <code>workers</code>, <code>id</code> und <code>thread</code>, die wir
nicht direkt benutzen, was uns daran erinnert, dass wir nichts aufräumen. Wenn
wir die weniger elegante Methode <span class="keystroke">Strg+c</span>
verwenden, um den Hauptstrang (main thread) anzuhalten, werden auch alle
anderen Stränge sofort gestoppt, selbst wenn sie gerade dabei sind, eine
Anfrage zu bedienen.</p>
<p>Als Nächstes werden wir das Merkmal (trait) <code>Drop</code> implementieren, um <code>join</code>
für jeden der Stränge im Vorrat aufzurufen, damit sie die Anfragen, an denen
sie arbeiten, vor dem Schließen beenden können. Dann werden wir einen Weg
implementieren, um den Strängen mitzuteilen, dass sie keine neuen Anfragen mehr
annehmen und herunterfahren sollen. Um diesen Code in Aktion zu sehen, werden
wir unseren Server so modifizieren, dass er nur zwei Anfragen annimmt, bevor er
seinen Strang-Vorrat kontrolliert herunterfährt.</p>
<h3 id="implementieren-des-merkmals-drop-auf-threadpool"><a class="header" href="#implementieren-des-merkmals-drop-auf-threadpool">Implementieren des Merkmals <code>Drop</code> auf <code>ThreadPool</code></a></h3>
<p>Lass uns damit beginnen, <code>Drop</code> auf unseren Strang-Vorrat zu implementieren.
Wenn der Vorrat aufgeräumt wird, sollten wir auf das Ende unsere Stränge
warten, um sicherzustellen, dass sie ihre Arbeit beenden. Codeblock 20-22 zeigt
einen ersten Versuch einer <code>Drop</code>-Implementierung; dieser Code wird noch nicht
ganz funktionieren.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Worker {} herunterfahren&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} hat einen Auftrag erhalten; führe ihn aus.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-22: Warten auf das Ende der einzelnen
Stränge, wenn der Strang-Vorrat den Gültigkeitsbereich verlässt</span></p>
<p>Zuerst iterieren wir über alle <code>workers</code> im Strang-Vorrat. Wir verwenden dafür
<code>&amp;mut</code>, weil <code>self</code> eine veränderbare Referenz ist und wir auch in der Lage
sein müssen, <code>worker</code> zu verändern. Für jeden <code>worker</code> geben wir eine Nachricht
aus, die besagt, dass dieser bestimmte <code>worker</code> heruntergefahren wird, und dann
rufen wir auf dem Strang <code>join</code> auf. Wenn der Aufruf von <code>join</code> fehlschlägt,
benutzen wir <code>unwrap</code>, um das Programm abstürzen zu lassen.</p>
<p>Hier ist der Fehler, den wir erhalten, wenn wir diesen Code kompilieren:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
    --&gt; src/lib.rs:52:13
     |
52   |             worker.thread.join().unwrap();
     |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
     |             |
     |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
     |
note: this function takes ownership of the receiver `self`, which moves `worker.thread`

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Der Fehler sagt uns, dass wir <code>join</code> nicht aufrufen können, weil wir nur eine
veränderbare Ausleihe von jedem <code>worker</code> haben und <code>join</code> die Eigentümerschaft
für sein Argument übernimmt. Um dieses Problem zu lösen, müssen wir den Strang
<code>thread</code> aus der <code>Worker</code>-Instanz herausnehmen, damit <code>join</code> den Strang
konsumieren kann. Wir haben dies in Codeblock 17-15 getan: Wenn <code>Worker</code>
stattdessen ein <code>Option&lt;Thread::JoinHandle&lt;()&gt;&gt;</code> hält, können wir die Methode
<code>take</code> auf <code>Option</code> aufrufen, um den Wert aus der Variante <code>Some</code>
herauszuverschieben und eine Variante <code>None</code> an ihrer Stelle zu belassen. Mit
anderen Worten, ein <code>Worker</code>, der läuft, wird eine Variante <code>Some</code> in <code>thread</code>
haben, und wenn wir einen <code>Worker</code> aufräumen wollen, ersetzen wir <code>Some</code> durch
<code>None</code>, sodass der <code>Worker</code> keinen Strang zum Laufen hat.</p>
<p>Wir wissen also, dass wir die Definition von <code>Worker</code> so aktualisieren wollen:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Worker {} herunterfahren&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} hat einen Auftrag erhalten; führe ihn aus.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Nun wollen wir uns auf den Compiler stützen, um die anderen Stellen zu finden,
die geändert werden müssen. Wenn wir diesen Code überprüfen, erhalten wir zwei
Fehler:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for enum `Option` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `Option&lt;JoinHandle&lt;()&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^ expected enum `Option`, found struct `JoinHandle`
   |
   = note: expected enum `Option&lt;JoinHandle&lt;()&gt;&gt;`
            found struct `JoinHandle&lt;_&gt;`
help: try wrapping the expression in `Some`
   |
72 |         Worker { id, thread: Some(thread) }
   |                      +++++++++++++      +

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello` due to 2 previous errors
</code></pre>
<p>Lass uns den zweiten Fehler beheben, der auf den Code am Ende von <code>Worker::new</code>
verweist; wir müssen den Wert <code>thread</code> in <code>Some</code> einpacken, wenn wir einen
neuen <code>Worker</code> erstellen. Nimm die folgenden Änderungen vor, um diesen Fehler
zu beheben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Worker {} herunterfahren&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --abschneiden--

<span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} hat einen Auftrag erhalten; führe ihn aus.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span>        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p>Der erste Fehler liegt in unserer <code>Drop</code>-Implementierung. Wir haben bereits
erwähnt, dass wir beabsichtigten, <code>take</code> auf dem <code>Option</code>-Wert aufzurufen, um
<code>thread</code> aus <code>worker</code> heraus zu verschieben. Die folgenden Änderungen werden
dies tun:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Worker {} herunterfahren&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} hat einen Auftrag erhalten; führe ihn aus.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Wie in Kapitel 17 besprochen, nimmt die Methode <code>take</code> auf <code>Option</code> die
Variante <code>Some</code> heraus und lässt an ihrer Stelle <code>None</code> stehen. Wir benutzen
<code>if let</code>, um die <code>Some</code> zu destrukturieren und den Strang zu erhalten; dann
rufen wir <code>join</code> auf dem Strang auf. Wenn der Strang eines <code>Worker</code> bereits
<code>None</code> ist, wissen wir, dass der Strang bereits aufgeräumt wurde, also passiert
in diesem Fall nichts.</p>
<h3 id="den-strängen-signalisieren-nicht-mehr-nach-aufträgen-zu-lauschen"><a class="header" href="#den-strängen-signalisieren-nicht-mehr-nach-aufträgen-zu-lauschen">Den Strängen signalisieren, nicht mehr nach Aufträgen zu lauschen</a></h3>
<p>Mit all den Änderungen, die wir vorgenommen haben, lässt sich unser Code ohne
jede Warnung kompilieren. Aber die schlechte Nachricht ist, dass dieser Code
noch nicht so funktioniert, wie wir es uns wünschen. Der Schlüssel ist die
Logik in den Funktionsabschlüssen, die von den Strängen der <code>Worker</code>-Instanzen
ausgeführt werden: Im Moment rufen wir <code>join</code> auf, aber das wird die Stränge
nicht herunterfahren, weil sie sich in einer Endlosschleife auf der Suche nach
Aufträgen befinden. Wenn wir versuchen, unseren <code>ThreadPool</code> mit unserer
aktuellen Implementierung von <code>Drop</code> aufräumen zu lassen, wird der Hauptstrang
für immer blockieren und auf das Beenden des ersten Strangs warten.</p>
<p>Um dieses Problem zu beheben, brauchen wir eine Änderung in der Implementierung
von <code>drop</code> in <code>ThreadPool</code> und dann eine Änderung in der <code>Worker</code>-Schleife.</p>
<p>Zuerst ändern wir die Implementierung von <code>drop</code> in <code>ThreadPool</code>, um den
<code>Sender</code> explizit zu aufzuräumen, bevor wir auf das Ende der Stränge warten.
Codeblock 20-23 zeigt die Änderungen an <code>ThreadPool</code>, um den <code>Absender</code>
explizit aufzuräumen. Wir verwenden die gleiche <code>Option</code> und <code>take</code>-Technik wie
beim Strang, um <code>sender</code> aus dem <code>ThreadPool</code> herauszuverschieben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}
// --abschneiden--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span>          // --abschneiden--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
<span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Worker {} herunterfahren&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">         
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">         
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-23: <code>sender</code> vor dem Warten auf die
<code>Worker</code>-Stränge explizit aufräumen</span></p>
<p>Das Aufräumen von <code>sender</code> schließt den Kanal, was bedeutet, dass keine
weiteren Nachrichten gesendet werden. Wenn das passiert, geben alle Aufrufe
von <code>recv</code>, die die <code>Worker</code> in der Endlosschleife machen, einen Fehler zurück.
In Codeblock 20-24 ändern wir die <code>Worker</code>-Schleife so, dass die Schleife in
diesem Fall ordnungsgemäß beendet wird, was bedeutet, dass die Stränge beendet
werden, wenn die Implementierung von <code>drop</code> in <code>ThreadPool</code> <code>join</code> für sie
aufruft.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Message&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(Message::NewJob(job)).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Worker {} herunterfahren&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            match receiver.lock().unwrap().recv() {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} hat einen Auftrag erhalten; führe ihn aus.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} nicht mehr verbunden, wird beendet.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p><span class="caption">Codeblock 20-24: Explizites Verlassen der Schleife, wenn
<code>recv</code> einen Fehler zurückgibt</span></p>
<p>Um diesen Code in Aktion zu sehen, modifizieren wir <code>main</code> so, dass nur zwei
Anfragen akzeptiert werden, bevor der Server kontrolliert heruntergefahren
wird, wie in Codeblock 20-25 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Fahre herunter.&quot;);
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(
</span><span class="boring">        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">        status_line,
</span><span class="boring">        contents.len(),
</span><span class="boring">        contents
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    stream.write(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 20-25: Herunterfahren des Servers, nachdem er
zwei Anfragen bearbeitet hat, durch Verlassen der Schleife</span></p>
<p>Du würdest nicht wollen, dass ein Webserver aus der realen Welt
heruntergefahren wird, nachdem er nur zwei Anfragen bearbeitet hat. Dieser Code
zeigt nur, dass das kontrollierte Herunterfahren und Aufräumen funktioniert.</p>
<p>Die Methode <code>take</code> ist im Merkmal <code>Iterator</code> definiert und beschränkt die
Iteration auf die ersten beiden Elemente. Der <code>ThreadPool</code> wird am Ende von
<code>main</code> den Gültigkeitsbereich verlassen und die <code>drop</code>-Implementierung
ausgeführt werden.</p>
<p>Starte den Server mit <code>cargo run</code> und stelle drei Anfragen. Die dritte Anfrage
sollte fehlerhaft sein und in deinem Terminal solltest du eine ähnliche Ausgabe
wie diese sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 hat einen Auftrag erhalten; führe ihn aus.
Fahre herunter.
Worker 0 herunterfahren
Worker 3 hat einen Auftrag erhalten; führe ihn aus.
Worker 1 nicht mehr verbunden, wird beendet.
Worker 2 nicht mehr verbunden, wird beendet.
Worker 3 nicht mehr verbunden, wird beendet.
Worker 0 nicht mehr verbunden, wird beendet.
Worker 1 herunterfahren
Worker 2 herunterfahren
Worker 3 herunterfahren
</code></pre>
<p>Möglicherweise siehst du eine andere Reihenfolge der <code>Worker</code> und der
ausgegebenen Nachrichten. Wir können anhand der Nachrichten sehen, wie dieser
Code funktioniert: Die <code>Worker</code> 0 und 3 haben die ersten beiden Anfragen
erhalten. Der Server hat nach der zweiten Verbindung aufgehört, Verbindungen
anzunehmen, und die <code>Drop</code>-Implementierung auf <code>ThreadPool</code> beginnt mit der
Ausführung, bevor <code>Worker</code> 3 überhaupt seinen Job beginnt. Wenn man den
<code>sender</code> aufräumt, werden alle <code>Worker</code> getrennt und angewiesen, sich zu
beenden. Die <code>Worker</code> geben jeweils eine Nachricht aus, wenn sie die Verbindung
trennen, und dann ruft der Strang-Vorrat <code>join</code> auf, um das Ende jedes
<code>Worker</code>-Strangs zu warten.</p>
<p>Beachte einen interessanten Aspekt diesem speziellen Programmlauf: Der
<code>ThreadPool</code> hat den <code>sender</code> aufgeräumt, und bevor ein <code>Worker</code> einen Fehler
erhalten hat, haben wir versucht, auf <code>Worker</code> 0 zu warten. <code>Worker</code> 0 hatte
noch keinen Fehler von <code>recv</code> erhalten, also blockierte der Hauptstrang und
wartete darauf, dass <code>Worker</code> 0 fertig wird. In der Zwischenzeit erhielt
<code>Worker</code> 3 einen Auftrag, und dann erhielten alle Stränge einen Fehler. Als
<code>Worker</code> 0 fertig war, wartete der Hauptstrang darauf, dass die restlichen
<code>Worker</code> fertig wurden. Zu diesem Zeitpunkt hatten sie alle ihre Schleifen
verlassen und konnten sich beenden.</p>
<p>Herzlichen Glückwunsch! Wir haben jetzt unser Projekt abgeschlossen; wir haben
einen einfachen Webserver, der einen Strang-Vorrat verwendet, um asynchron zu
antworten. Wir sind in der Lage, den Server kontrolliert herunterzufahren,
wodurch alle Stränge im Vorrat aufgeräumt werden.</p>
<p>Hier ist der vollständige Code als Referenz:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Fahre herunter.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(
        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
        status_line,
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}</code></pre>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Erzeuge einen neuen ThreadPool.
    ///
    /// Die Größe ist die Anzahl der Stränge im Vorrat.
    ///
    /// # Panics
    ///
    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Worker {} herunterfahren&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Ok(job) =&gt; {
                    println!(&quot;Worker {} hat einen Auftrag erhalten; führe ihn aus.&quot;, id);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {} nicht mehr verbunden, wird beendet.&quot;, id);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Wir könnten hier mehr tun! Wenn du dieses Projekt weiter verbessern willst,
findest du hier einige Ideen:</p>
<ul>
<li>Füge weitere Dokumentation zu <code>ThreadPool</code> und seinen öffentlichen Methoden
hinzu.</li>
<li>Füge Tests der Funktionalität der Bibliothek hinzu.</li>
<li>Ändere Aufrufe von <code>unwrap</code> in eine robustere Fehlerbehandlung.</li>
<li>Verwende <code>ThreadPool</code>, um eine andere Aufgabe als das Beantworten von
Web-Anfragen durchzuführen.</li>
<li>Suche eine Strang-Vorrats-Kiste auf <a href="https://crates.io/">crates.io</a> und
implementiere damit einen ähnlichen Webserver unter Verwendung der Kiste.
Vergleiche dann dessen API und Robustheit mit dem von uns implementierten
Strang-Vorrat.</li>
</ul>
<h2 id="zusammenfassung-19"><a class="header" href="#zusammenfassung-19">Zusammenfassung</a></h2>
<p>Gut gemacht! Du hast es bis ans Ende des Buchs geschafft! Wir möchten dir
danken, dass du uns auf dieser Tour durch Rust begleitet hast. Du bist nun
bereit, deine eigenen Rust-Projekte umzusetzen und bei den Projekten anderer zu
helfen. Denke daran, dass es eine gastfreundliche Gemeinschaft von anderen
Rust-Entwicklern gibt, die dir bei allen Herausforderungen, denen du auf deiner
Rust-Reise begegnest, gerne helfen würden.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anhang"><a class="header" href="#anhang">Anhang</a></h1>
<p>Die folgenden Abschnitte enthalten Referenzmaterial, das dir auf deiner
Rust-Reise nützlich sein könnten.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-a-schlüsselwörter"><a class="header" href="#anhang-a-schlüsselwörter">Anhang A: Schlüsselwörter</a></h2>
<p>Die folgende Liste enthält Schlüsselwörter, die für die gegenwärtige oder
zukünftige Verwendung durch die Sprache Rust reserviert sind. Als solche können
sie nicht als Bezeichner verwendet werden (außer als Roh-Bezeichner, die wir im
Abschnitt <a href="appendix-01-keywords.html#roh-bezeichner">„Roh-Bezeichner“</a> besprechen werden). Bezeichner
sind Namen von Funktionen, Variablen, Parametern, Strukturfeldern
(struct fields), Modulen, Kisten (crates), Konstanten, Makros, statischen
Werten, Attributen, Typen, Merkmalen (traits) und Lebensdauern (lifetimes).</p>
<h3 id="derzeit-verwendete-schlüsselwörter"><a class="header" href="#derzeit-verwendete-schlüsselwörter">Derzeit verwendete Schlüsselwörter</a></h3>
<p>Nachstehend findest du eine Liste der derzeit verwendeten Schlüsselwörter mit
einer Beschreibung ihrer Funktion.</p>
<ul>
<li><code>as</code> – primitive Typen umwandeln; ein spezifisches Merkmal mit einem
Element eindeutig machen; Elemente in <code>use</code>-Anweisungen umbenennen </li>
<li><code>async</code> – ein <code>Future</code> zurückgeben, anstatt den aktuellen Strang
(thread) zu blockieren</li>
<li><code>await</code> – Ausführung anhalten, bis das Ergebnis eines <code>Future</code> vorliegt</li>
<li><code>break</code> – Schleife sofort verlassen</li>
<li><code>const</code> – konstante Elemente oder konstante Roh-Referenzen definieren</li>
<li><code>continue</code> – weiter zur nächsten Schleifeniteration</li>
<li><code>crate</code> – in einem Modulpfad verweist auf das Stammverzeichnis der Kiste (crate)</li>
<li><code>dyn</code> – dynamischer Aufruf (dispatch) eines Merkmalsobjekts (trait
object)</li>
<li><code>else</code> – Ersatzkontrollflusszweig bei <code>if</code> und <code>if let</code></li>
<li><code>enum</code> – eine Aufzählung (enumeration) definieren</li>
<li><code>extern</code> – externe Funktion oder Variable verlinken</li>
<li><code>false</code> – Boolesches Literal für „falsch“</li>
<li><code>fn</code> – Funktion oder Funktionsreferenztyp definieren</li>
<li><code>for</code> – wiederhole über Elemente einer Iteration; ein Merkmal (trait)
implementieren; eine höherrangige Lebensdauer angeben</li>
<li><code>if</code> – Verzweigen abhängig vom Ergebnis eines Bedingungsausdrucks</li>
<li><code>impl</code> – Implementieren einer inhärenten oder Merkmalsfunktionalität
(trait functionality)</li>
<li><code>in</code> – Teil der <code>for</code>-Schleifensyntax</li>
<li><code>let</code> – eine Variable binden</li>
<li><code>loop</code> – wiederhole bedingungslos</li>
<li><code>match</code> – einen Wert mit Muster abgleichen</li>
<li><code>mod</code> – ein Modul definieren</li>
<li><code>move</code> – Funktionsabschluss (closure) übernimmt Eigentümerschaft
(ownership) all seiner Parameter</li>
<li><code>mut</code> – Referenzen, Roh-Referenzen und Variablenbindungen als
veränderbar kennzeichnen</li>
<li><code>pub</code> – Strukturfelder (struct fields), <code>impl</code>-Blöcke und Module als
öffentlich sichtbar kennzeichnen </li>
<li><code>ref</code> – als Referenz binden</li>
<li><code>return</code> – aus Funktion zurückkehren</li>
<li><code>Self</code> – Typ-Alias für den zu definierenden oder implementierenden Typ</li>
<li><code>self</code> – Methoden-Instanzobjekt; aktuelles Modul</li>
<li><code>static</code> – globale Variable oder Lebensdauer während der gesamten
Programmausführung</li>
<li><code>struct</code> – eine Struktur definieren</li>
<li><code>super</code> – Elternmodul des aktuellen Moduls</li>
<li><code>trait</code> – ein Merkmal (trait) definieren</li>
<li><code>true</code> – Boolesches Literal für „wahr“</li>
<li><code>type</code> – einen Typ-Alias oder assoziierten Typ definieren</li>
<li><code>union</code> – eine <a href="https://doc.rust-lang.org/reference/items/unions.html">Vereinigung (union)</a> definieren; ist nur ein
Schlüsselwort innerhalb einer Vereinigungdeklaration</li>
<li><code>unsafe</code> – Code, Funktionen, Merkmale (traits) und Implementierungen
als unsicher kennzeichnen</li>
<li><code>use</code> – Symbole in den Gültigkeitsbereich bringen</li>
<li><code>where</code> – Klauseln zur Typabgrenzung angeben</li>
<li><code>while</code> – wiederhole abhängig vom Ergebnis eines Bedingungsausdrucks</li>
</ul>
<h3 id="schlüsselwörter-reserviert-für-zukünftige-verwendung"><a class="header" href="#schlüsselwörter-reserviert-für-zukünftige-verwendung">Schlüsselwörter reserviert für zukünftige Verwendung</a></h3>
<p>Die folgenden Schlüsselwörter haben noch keine Funktionalität, sondern sind von
Rust für eine mögliche zukünftige Verwendung reserviert.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="roh-bezeichner"><a class="header" href="#roh-bezeichner">Roh-Bezeichner</a></h3>
<p><em>Roh-Bezeichner</em> (raw identifiers) sind eine Syntax, die es dir ermöglicht,
Schlüsselwörter dort zu verwenden, wo sie normalerweise nicht erlaubt wären. Du
verwendest einen Roh-Bezeichner, indem du einem Schlüsselwort das Präfix <code>r#</code>
voranstellst.</p>
<p>Zum Beispiel ist <code>match</code> ein Schlüsselwort. Versuche, folgende Funktion zu
kompilieren, die <code>match</code> als Namen benutzt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
<span class="boring">}</span></code></pre></pre>
<p>Dann erhältst du diesen Fehler:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>Der Fehler zeigt, dass du das Schlüsselwort <code>match</code> nicht als
Funktionsbezeichner verwenden kannst. Um <code>match</code> als Funktionsnamen zu
verwenden, musst du die Syntax für Roh-Bezeichner wie folgt verwenden:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}</code></pre></pre>
<p>Dieser Code lässt sich fehlerfrei kompilieren. Beachte das <code>r#</code>-Präfix im
Funktionsnamen in seiner Definition sowie an der Stelle, an der die Funktion in
<code>main</code> aufgerufen wird.</p>
<p>Roh-Bezeichner erlauben es dir, jedes beliebige Wort als Bezeichner zu
verwenden, auch wenn dieses Wort ein reserviertes Schlüsselwort ist. Dies gibt
uns mehr Freiheit bei der Wahl der Bezeichner und ermöglicht uns die
Integration in Programme, die in einer Sprache geschrieben wurden, in der diese
Wörter keine Schlüsselwörter sind. Darüber hinaus ermöglicht dir der
Roh-Bezeichner das Verwenden von Bibliotheken, die in einer anderen
Rust-Ausgabe, als deine Kiste verwendet, geschrieben wurden. Zum Beispiel ist
<code>try</code> in Ausgabe 2015 kein Schlüsselwort, aber in Ausgabe 2018 schon. Wenn du
auf eine Bibliothek angewiesen bist, die mit Ausgabe 2015 geschrieben wurde und
eine Funktion <code>try</code> hat, musst du die Roh-Bezeichner-Syntax verwenden, in
diesem Fall <code>r#try</code>, um diese Funktion von deinem Code der Ausgabe 2018 aus
aufzurufen. Siehe <a href="appendix-05-editions.html">Anhang E</a> für weitere Informationen zu Ausgaben.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-b-operatoren-und-symbole"><a class="header" href="#anhang-b-operatoren-und-symbole">Anhang B: Operatoren und Symbole</a></h2>
<p>Dieser Anhang enthält ein Glossar der Rust-Syntax, einschließlich Operatoren
und anderer Symbole, die allein oder im Zusammenhang mit Pfaden, generischen
Datentypen (generics), Merkmalsabgrenzungen (trait bounds), Makros, Attributen,
Kommentaren, Tupeln und Klammern auftreten.</p>
<h3 id="operatoren"><a class="header" href="#operatoren">Operatoren</a></h3>
<p>Tabelle B-1 enthält die Operatoren in Rust, ein Beispiel, wie der Operator im
Kontext erscheinen würde, eine kurze Erklärung und ob dieser Operator überladen
werden kann. Wenn ein Operator überladen werden kann, wird das relevante
Merkmal (trait) aufgeführt, mit dem dieser Operator überladen werden kann.</p>
<p><span class="caption">Tabelle B-1: Operatoren</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Operator</th><th style="text-align: left">Beispiel</th><th style="text-align: left">Erklärung</th><th style="text-align: left">Überladbar?</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>!</code></td><td style="text-align: left"><code>ident!(...)</code>,<br> <code>ident!{...}</code>,<br> <code>ident![...]</code></td><td style="text-align: left">Makro-Expansion</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>!</code></td><td style="text-align: left"><code>!expr</code></td><td style="text-align: left">Bitweises oder logisches Komplement</td><td style="text-align: left"><code>Not</code></td></tr>
<tr><td style="text-align: left"><code>!=</code></td><td style="text-align: left"><code>expr != expr</code></td><td style="text-align: left">Vergleich auf Ungleichheit</td><td style="text-align: left"><code>PartialEq</code></td></tr>
<tr><td style="text-align: left"><code>%</code></td><td style="text-align: left"><code>expr % expr</code></td><td style="text-align: left">Arithmetischer Restbetrag</td><td style="text-align: left"><code>Rem</code></td></tr>
<tr><td style="text-align: left"><code>%=</code></td><td style="text-align: left"><code>var %= expr</code></td><td style="text-align: left">Arithmetischer Restbetrag und Zuweisung</td><td style="text-align: left"><code>RemAssign</code></td></tr>
<tr><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left"><code>&amp;expr</code>,<br> <code>&amp;mut expr</code></td><td style="text-align: left">Ausleihe</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left"><code>&amp;type</code>,<br> <code>&amp;mut type</code>,<br> <code>&amp;'a type</code>,<br> <code>&amp;'a mut type</code></td><td style="text-align: left">Ausleih-Referenz-Typ</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left"><code>expr &amp; expr</code></td><td style="text-align: left">Bitweises UND</td><td style="text-align: left"><code>BitAnd</code></td></tr>
<tr><td style="text-align: left"><code>&amp;=</code></td><td style="text-align: left"><code>var &amp;= expr</code></td><td style="text-align: left">Bitweises UND und Zuweisung</td><td style="text-align: left"><code>BitAndAssign</code></td></tr>
<tr><td style="text-align: left"><code>&amp;&amp;</code></td><td style="text-align: left"><code>expr &amp;&amp; expr</code></td><td style="text-align: left">Logisches UND mit Kurzschlussauswertung</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left"><code>expr * expr</code></td><td style="text-align: left">Arithmetische Multiplikation</td><td style="text-align: left"><code>Mul</code></td></tr>
<tr><td style="text-align: left"><code>*=</code></td><td style="text-align: left"><code>var *= expr</code></td><td style="text-align: left">Arithmetische Multiplikation und Zuweisung</td><td style="text-align: left"><code>MulAssign</code></td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left"><code>*expr</code></td><td style="text-align: left">Dereferenzierung</td><td style="text-align: left"><code>Deref</code></td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left"><code>*const type</code>,<br> <code>*mut type</code></td><td style="text-align: left">Roh-Referenz</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>+</code></td><td style="text-align: left"><code>trait + trait</code>,<br> <code>'a + trait</code></td><td style="text-align: left">Verbundtypabgrenzung</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>+</code></td><td style="text-align: left"><code>expr + expr</code></td><td style="text-align: left">Arithmetische Addition</td><td style="text-align: left"><code>Add</code></td></tr>
<tr><td style="text-align: left"><code>+=</code></td><td style="text-align: left"><code>var += expr</code></td><td style="text-align: left">Arithmetische Addition und Zuweisung</td><td style="text-align: left"><code>AddAssign</code></td></tr>
<tr><td style="text-align: left"><code>,</code></td><td style="text-align: left"><code>expr, expr</code></td><td style="text-align: left">Argument- und Elementseparator</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>-</code></td><td style="text-align: left"><code>- expr</code></td><td style="text-align: left">Arithmetische Negation</td><td style="text-align: left"><code>Neg</code></td></tr>
<tr><td style="text-align: left"><code>-</code></td><td style="text-align: left"><code>expr - expr</code></td><td style="text-align: left">Arithmetische Subtraktion</td><td style="text-align: left"><code>Sub</code></td></tr>
<tr><td style="text-align: left"><code>-=</code></td><td style="text-align: left"><code>var -= expr</code></td><td style="text-align: left">Arithmetische Subtraktion und Zuweisung</td><td style="text-align: left"><code>SubAssign</code></td></tr>
<tr><td style="text-align: left"><code>-&gt;</code></td><td style="text-align: left"><code>fn(...) -&gt; type</code>,<br> <code>|...| -&gt; type</code></td><td style="text-align: left">Funktion und Funktionsabschlussrückgabetyp</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>.</code></td><td style="text-align: left"><code>expr.ident</code></td><td style="text-align: left">Elementzugriff</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>..</code></td><td style="text-align: left"><code>..</code>,<br> <code>expr..</code>,<br> <code>..expr</code>,<br> <code>expr..expr</code></td><td style="text-align: left">Rechts-ausschließendes Bereichsliteral</td><td style="text-align: left"><code>PartialOrd</code></td></tr>
<tr><td style="text-align: left"><code>..=</code></td><td style="text-align: left"><code>..=expr</code>,<br> <code>expr..=expr</code></td><td style="text-align: left">Rechts-einschließendes Bereichsliteral</td><td style="text-align: left"><code>PartialOrd</code></td></tr>
<tr><td style="text-align: left"><code>..</code></td><td style="text-align: left"><code>..expr</code></td><td style="text-align: left">Aktualisierungssyntax für Strukturliterale</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>..</code></td><td style="text-align: left"><code>variant(x, ..)</code>,<br> <code>struct_type { x, .. }</code></td><td style="text-align: left">„Und der Rest“-Musterbindung</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>...</code></td><td style="text-align: left"><code>expr...expr</code></td><td style="text-align: left">(Veraltet, verwende stattdessen <code>..=</code>) In einem Muster: inklusives Bereichsmuster</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>/</code></td><td style="text-align: left"><code>expr / expr</code></td><td style="text-align: left">Arithmetische Division</td><td style="text-align: left"><code>Div</code></td></tr>
<tr><td style="text-align: left"><code>/=</code></td><td style="text-align: left"><code>var /= expr</code></td><td style="text-align: left">Arithmetische Division und Zuweisung</td><td style="text-align: left"><code>DivAssign</code></td></tr>
<tr><td style="text-align: left"><code>:</code></td><td style="text-align: left"><code>pat: type</code>,<br> <code>ident: type</code></td><td style="text-align: left">Typabgrenzung</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>:</code></td><td style="text-align: left"><code>ident: expr</code></td><td style="text-align: left">Struktur-Feld-Initialisierer</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>:</code></td><td style="text-align: left"><code>'a: loop {...}</code></td><td style="text-align: left">Schleifen-Label</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>;</code></td><td style="text-align: left"><code>expr;</code></td><td style="text-align: left">Anweisungs- und Element-Endezeichen</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>;</code></td><td style="text-align: left"><code>[...; len]</code></td><td style="text-align: left">Syntaxteil für Array fester Größe</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>&lt;&lt;</code></td><td style="text-align: left"><code>expr &lt;&lt; expr</code></td><td style="text-align: left">Bitweise Links-Schiebung</td><td style="text-align: left"><code>Shl</code></td></tr>
<tr><td style="text-align: left"><code>&lt;&lt;=</code></td><td style="text-align: left"><code>var &lt;&lt;= expr</code></td><td style="text-align: left">Bitweise Links-Schiebung und Zuweisung</td><td style="text-align: left"><code>ShlAssign</code></td></tr>
<tr><td style="text-align: left"><code>&lt;</code></td><td style="text-align: left"><code>expr &lt; expr</code></td><td style="text-align: left">Kleiner-als-Vergleich</td><td style="text-align: left"><code>PartialOrd</code></td></tr>
<tr><td style="text-align: left"><code>&lt;=</code></td><td style="text-align: left"><code>expr &lt;= expr</code></td><td style="text-align: left">Kleiner-gleich-Vergleich</td><td style="text-align: left"><code>PartialOrd</code></td></tr>
<tr><td style="text-align: left"><code>=</code></td><td style="text-align: left"><code>var = expr</code>,<br> <code>ident = type</code></td><td style="text-align: left">Zuweisung/Äquivalenz</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>==</code></td><td style="text-align: left"><code>expr == expr</code></td><td style="text-align: left">Gleichheitsvergleich</td><td style="text-align: left"><code>PartialEq</code></td></tr>
<tr><td style="text-align: left"><code>=&gt;</code></td><td style="text-align: left"><code>pat =&gt; expr</code></td><td style="text-align: left">Teilsyntax im Abgleichs-Zweig (match arm)</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>&gt;</code></td><td style="text-align: left"><code>expr &gt; expr</code></td><td style="text-align: left">Größer-als-Vergleich</td><td style="text-align: left"><code>PartialOrd</code></td></tr>
<tr><td style="text-align: left"><code>&gt;=</code></td><td style="text-align: left"><code>expr &gt;= expr</code></td><td style="text-align: left">Größer-gleich-Vergleich</td><td style="text-align: left"><code>PartialOrd</code></td></tr>
<tr><td style="text-align: left"><code>&gt;&gt;</code></td><td style="text-align: left"><code>expr &gt;&gt; expr</code></td><td style="text-align: left">Bitweise Rechts-Schiebung</td><td style="text-align: left"><code>Shr</code></td></tr>
<tr><td style="text-align: left"><code>&gt;&gt;=</code></td><td style="text-align: left"><code>var &gt;&gt;= expr</code></td><td style="text-align: left">Bitweise Rechts-Schiebung und Zuweisung</td><td style="text-align: left"><code>ShrAssign</code></td></tr>
<tr><td style="text-align: left"><code>@</code></td><td style="text-align: left"><code>ident @ pat</code></td><td style="text-align: left">Muster-Bindung</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>^</code></td><td style="text-align: left"><code>expr ^ expr</code></td><td style="text-align: left">Bitweises exklusives ODER</td><td style="text-align: left"><code>BitXor</code></td></tr>
<tr><td style="text-align: left"><code>^=</code></td><td style="text-align: left"><code>var ^= expr</code></td><td style="text-align: left">Bitweises exklusives ODER und Zuweisung</td><td style="text-align: left"><code>BitXorAssign</code></td></tr>
<tr><td style="text-align: left"><code>|</code></td><td style="text-align: left"><code>pat | pat</code></td><td style="text-align: left">Muster-Alternativen</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>|</code></td><td style="text-align: left"><code>expr | expr</code></td><td style="text-align: left">Bitweises ODER</td><td style="text-align: left"><code>BitOr</code></td></tr>
<tr><td style="text-align: left"><code>|=</code></td><td style="text-align: left"><code>var |= expr</code></td><td style="text-align: left">Bitweises ODER und Zuweisung</td><td style="text-align: left"><code>BitOrAssign</code></td></tr>
<tr><td style="text-align: left"><code>||</code></td><td style="text-align: left"><code>expr || expr</code></td><td style="text-align: left">Logisches ODER mit Kurzschlussauswertung</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>?</code></td><td style="text-align: left"><code>expr?</code></td><td style="text-align: left">Fehler-Weitergabe</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<h3 id="nicht-operator-symbole"><a class="header" href="#nicht-operator-symbole">Nicht-Operator-Symbole</a></h3>
<p>Die folgende Liste enthält alle Symbole, die nicht als Operatoren fungieren,
d.h. sich nicht wie ein Funktions- oder Methodenaufruf verhalten.</p>
<p>Tabelle B-2 zeigt Symbole, die für sich allein stehen und an verschiedenen
Stellen gültig sind.</p>
<p><span class="caption">Tabelle B-2: Eigenständige Syntax</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>'ident</code></td><td style="text-align: left">Benannte Lebensdauer oder Schleifenbeschriftung</td></tr>
<tr><td style="text-align: left"><code>...u8</code>,<br> <code>...i32</code>,<br> <code>...f64</code>,<br> <code>...usize</code><br> usw.</td><td style="text-align: left">Numerisches Literal eines bestimmten Typs</td></tr>
<tr><td style="text-align: left"><code>&quot;...&quot;</code></td><td style="text-align: left">Zeichenketten-Literal</td></tr>
<tr><td style="text-align: left"><code>r&quot;...&quot;</code>,<br> <code>r#&quot;...&quot;#</code>,<br> <code>r##&quot;...&quot;##</code><br> usw.</td><td style="text-align: left">Roh-Zeichenketten-Literal, Escape-Zeichen werden nicht verarbeitet</td></tr>
<tr><td style="text-align: left"><code>b&quot;...&quot;</code></td><td style="text-align: left">Byte-Zeichenkettenliteral, erzeugt ein Byte-Array anstelle einer Zeichenkette</td></tr>
<tr><td style="text-align: left"><code>br&quot;...&quot;</code>,<br> <code>br#&quot;...&quot;#</code>,<br> <code>br##&quot;...&quot;##</code><br> usw.</td><td style="text-align: left">Roh-Byte-Zeichenkettenliteral, Kombination aus Roh- und Byte-Zeichenkettenliteral</td></tr>
<tr><td style="text-align: left"><code>'...'</code></td><td style="text-align: left">Zeichen-Literal</td></tr>
<tr><td style="text-align: left"><code>b'...'</code></td><td style="text-align: left">ASCII-Byte-Literal</td></tr>
<tr><td style="text-align: left"><code>|...| expr</code></td><td style="text-align: left">Funktionsabschluss (closure)</td></tr>
<tr><td style="text-align: left"><code>!</code></td><td style="text-align: left">Leerer Typ (bottom type) für nicht-endende Funktionen</td></tr>
<tr><td style="text-align: left"><code>_</code></td><td style="text-align: left">Musterbindung für „sonstige“; wird auch verwendet, um Ganzzahl-Literale lesbar zu machen</td></tr>
</tbody></table>
</div>
<p>Tabelle B-3 zeigt Symbole, die im Zusammenhang mit Pfaden für die
Modulhierarchie eines Elements vorkommen.</p>
<p><span class="caption">Tabelle B-3: Pfad-bezogene Syntax</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ident::ident</code></td><td style="text-align: left">Namensraum-Pfad</td></tr>
<tr><td style="text-align: left"><code>::path</code></td><td style="text-align: left">Pfad relativ zur Kistenwurzel<br> (d.h. ein explizit absoluter Pfad)</td></tr>
<tr><td style="text-align: left"><code>self::path</code></td><td style="text-align: left">Pfad relativ zum aktuellen Modul<br> (d.h. ein explizit relativer Pfad)</td></tr>
<tr><td style="text-align: left"><code>super::path</code></td><td style="text-align: left">Pfad relativ zum Elternmodul</td></tr>
<tr><td style="text-align: left"><code>type::ident</code>,<br> <code>&lt;type as trait&gt;::ident</code></td><td style="text-align: left">Zugehörige Konstanten, Funktionen<br> und Typen</td></tr>
<tr><td style="text-align: left"><code>&lt;type&gt;::...</code></td><td style="text-align: left">Zugehöriges Element für einen Typ,<br> der nicht direkt benannt werden kann<br> (z.B. <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;:::...</code> usw.)</td></tr>
<tr><td style="text-align: left"><code>trait::method(...)</code></td><td style="text-align: left">Methodenaufruf durch Angeben des<br> Merkmals eindeutig machen</td></tr>
<tr><td style="text-align: left"><code>type::method(...)</code></td><td style="text-align: left">Methodenaufruf durch Angeben des<br> Typs eindeutig machen</td></tr>
<tr><td style="text-align: left"><code>&lt;type as trait&gt;::method(...)</code></td><td style="text-align: left">Methodenaufruf durch Angeben des<br> Merkmals und Typs eindeutig machen</td></tr>
</tbody></table>
</div>
<p>Tabelle B-4 zeigt Symbole, die im Zusammenhang mit generischen Typparametern
auftreten.</p>
<p><span class="caption">Tabelle B-4: Generische Datentypen</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>path&lt;...&gt;</code></td><td style="text-align: left">Spezifiziert Parameter zum generischen Typ in einem Typ (z.B. <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td style="text-align: left"><code>path::&lt;...&gt;</code>,<br> <code>method::&lt;...&gt;</code></td><td style="text-align: left">Spezifiziert Parameter zu einem generischen Typ, einer Funktion oder Methode in einem Ausdruck; oft als „turbofish“ bezeichnet (z.B. <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td style="text-align: left"><code>fn ident&lt;...&gt; ...</code></td><td style="text-align: left">Generische Funktion definieren</td></tr>
<tr><td style="text-align: left"><code>struct ident&lt;...&gt; ...</code></td><td style="text-align: left">Generische Struktur definieren</td></tr>
<tr><td style="text-align: left"><code>enum ident&lt;...&gt; ...</code></td><td style="text-align: left">Generische Aufzählung definieren</td></tr>
<tr><td style="text-align: left"><code>impl&lt;...&gt; ...</code></td><td style="text-align: left">Generische Implementierung definieren</td></tr>
<tr><td style="text-align: left"><code>for&lt;...&gt; type</code></td><td style="text-align: left">Höherstufige Lebensdauerbegrenzungen</td></tr>
<tr><td style="text-align: left"><code>type&lt;ident=type&gt;</code></td><td style="text-align: left">Generischer Typ, bei dem ein oder mehrere assoziierte Typen bestimmte Zuordnungen haben (z.B. <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div>
<p>Tabelle B-5 zeigt Symbole, die im Zusammenhang mit generischen Typparametern
mit Merkmalsabgrenzung (trait bounds) auftreten.</p>
<p><span class="caption">Tabelle B-5: Merkmalsabgrenzungen</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>T: U</code></td><td style="text-align: left">Generischer Parameter <code>T</code>, beschränkt auf Typen,<br> die <code>U</code> implementieren</td></tr>
<tr><td style="text-align: left"><code>T: 'a</code></td><td style="text-align: left">Generischer Typ <code>T</code>, der die Lebensdauer <code>'a</code> überdauert<br> (d.h. der Typ darf transitiv keine Referenzen mit einer<br> kürzeren Lebensdauer als <code>'a</code> enthalten)</td></tr>
<tr><td style="text-align: left"><code>T: 'static</code></td><td style="text-align: left">Generischer Typ <code>T</code> mit Lebensdauer <code>'static</code></td></tr>
<tr><td style="text-align: left"><code>'b: 'a</code></td><td style="text-align: left">Generische Lebensdauer <code>'b</code>, muss Lebensdauer <code>'a</code> überdauern</td></tr>
<tr><td style="text-align: left"><code>T: ?Sized</code></td><td style="text-align: left">Erlaube einen generischen Typparameter, der ein<br> dynamisch dimensionierter Typ ist</td></tr>
<tr><td style="text-align: left"><code>'a + trait</code>,<br> <code>trait + trait</code></td><td style="text-align: left">Zusammengesetzte Typabgrenzung</td></tr>
</tbody></table>
</div>
<p>Tabelle B-6 zeigt Symbole, die im Zusammenhang mit dem Aufruf oder der
Definition von Makros und der Angabe von Attributen an einem Element
vorkommen.</p>
<p><span class="caption">Tabelle B-6: Makros und Attribute</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>#[meta]</code></td><td style="text-align: left">Äußeres Attribut</td></tr>
<tr><td style="text-align: left"><code>#![meta]</code></td><td style="text-align: left">Inneres Attribut</td></tr>
<tr><td style="text-align: left"><code>$ident</code></td><td style="text-align: left">Makro-Ersetzung</td></tr>
<tr><td style="text-align: left"><code>$ident:kind</code></td><td style="text-align: left">Makro-Erfassung</td></tr>
<tr><td style="text-align: left"><code>$(…)…</code></td><td style="text-align: left">Makro-Wiederholung</td></tr>
<tr><td style="text-align: left"><code>ident!(...)</code>,<br> <code>ident!{...}</code>,<br> <code>ident![...]</code></td><td style="text-align: left">Makro-Aufruf</td></tr>
</tbody></table>
</div>
<p>Tabelle B-7 zeigt Symbole, die Kommentare erzeugen.</p>
<p><span class="caption">Tabelle B-7: Kommentare</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>//</code></td><td style="text-align: left">Einzeiliger Kommentar</td></tr>
<tr><td style="text-align: left"><code>//!</code></td><td style="text-align: left">Einzeiliger Dokumentationskommentar innen</td></tr>
<tr><td style="text-align: left"><code>///</code></td><td style="text-align: left">Einzeiliger Dokumentationskommentar außen</td></tr>
<tr><td style="text-align: left"><code>/*...*/</code></td><td style="text-align: left">Block-Kommentar</td></tr>
<tr><td style="text-align: left"><code>/*!...*/</code></td><td style="text-align: left">Mehrzeiliger Dokumentationskommentar innen</td></tr>
<tr><td style="text-align: left"><code>/**...*/</code></td><td style="text-align: left">Mehrzeiliger Dokumentationskommentar außen</td></tr>
</tbody></table>
</div>
<p>Tabelle B-8 zeigt Symbole, die im Zusammenhang mit der Verwendung von Tupeln
auftreten.</p>
<p><span class="caption">Tabelle B-8: Tupel</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>()</code></td><td style="text-align: left">Leeres Tupel (auch Einheit (unit) genannt), Literal und Typ</td></tr>
<tr><td style="text-align: left"><code>(expr)</code></td><td style="text-align: left">Eingeklammerter Ausdruck</td></tr>
<tr><td style="text-align: left"><code>(expr,)</code></td><td style="text-align: left">Ein-Element-Tupel-Ausdruck</td></tr>
<tr><td style="text-align: left"><code>(type,)</code></td><td style="text-align: left">Ein-Element-Tupel-Typ</td></tr>
<tr><td style="text-align: left"><code>(expr, ...)</code></td><td style="text-align: left">Tupel-Ausdruck</td></tr>
<tr><td style="text-align: left"><code>(type, ...)</code></td><td style="text-align: left">Tupel-Typ</td></tr>
<tr><td style="text-align: left"><code>expr(expr, ...)</code></td><td style="text-align: left">Funktionsaufruf-Ausdruck; wird auch zur Initialisierung von Tupel-Strukturen und Tupel-Aufzählungs-Varianten verwendet</td></tr>
<tr><td style="text-align: left"><code>expr.0</code>,<br> <code>expr.1</code> usw.</td><td style="text-align: left">Tupel-Indexierung</td></tr>
</tbody></table>
</div>
<p>Tabelle B-9 zeigt die Kontexte, in denen geschweifte Klammern verwendet werden.</p>
<p><span class="caption">Tabelle B-9: Geschweifte Klammern</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Context</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>{...}</code></td><td style="text-align: left">Block-Ausdruck</td></tr>
<tr><td style="text-align: left"><code>Type {...}</code></td><td style="text-align: left"><code>struct</code>-Literal</td></tr>
</tbody></table>
</div>
<p>Tabelle B-10 zeigt die Kontexte, in denen eckige Klammern verwendet werden.</p>
<p><span class="caption">Tabelle B-10: Eckige Klammern</span></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Context</th><th style="text-align: left">Erklärung</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>[...]</code></td><td style="text-align: left">Array-Literal</td></tr>
<tr><td style="text-align: left"><code>[expr; len]</code></td><td style="text-align: left">Array-Literal mit <code>len</code> Kopien von <code>expr</code></td></tr>
<tr><td style="text-align: left"><code>[type; len]</code></td><td style="text-align: left">Array-Typ mit <code>len</code> Instanzen von <code>type</code></td></tr>
<tr><td style="text-align: left"><code>expr[expr]</code></td><td style="text-align: left">Sammlungs-Indexierung, ist überladbar (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td style="text-align: left"><code>expr[..]</code>,<br> <code>expr[a..]</code>,<br> <code>expr[..b]</code>,<br> <code>expr[a..b]</code></td><td style="text-align: left">Sammlungs-Indexierung, die wie ein Sammlungsanteil aussieht, unter Verwendung von <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code> oder <code>RangeFull</code> als „Index“</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-c-ableitbare-merkmale-traits"><a class="header" href="#anhang-c-ableitbare-merkmale-traits">Anhang C: Ableitbare Merkmale (traits)</a></h2>
<p>An verschiedenen Stellen im Buch haben wir das Attribut <code>derive</code> besprochen,
das du auf eine Struktur- oder Aufzählungsdefinition anwenden kannst. Das
Attribut <code>derive</code> generiert Code, der ein Merkmal (trait) mit seiner eigenen
Standard-Implementierung auf dem Typ implementiert, den du mit der
<code>derive</code>-Syntax annotiert hast.</p>
<p>In diesem Anhang findest du eine Referenz aller Merkmale in der
Standardbibliothek, die du mit <code>derive</code> verwenden kannst. Jeder Abschnitt
umfasst:</p>
<ul>
<li>Welche Operatoren und Methoden nach Ableiten dieses Merkmals ermöglicht
werden</li>
<li>Was die Implementierung des durch <code>derive</code> bereitgestellten Merkmals bewirkt</li>
<li>Was die Implementierung des Merkmals über den Typ aussagt</li>
<li>Die Bedingungen, unter denen du das Merkmal implementieren darfst oder nicht</li>
<li>Beispiele für Operationen, die dieses Merkmal erfordern</li>
</ul>
<p>Wenn du ein anderes Verhalten wünschst als das, das durch das Attribut <code>derive</code>
bereitgestellt wird, schaue in die <a href="https://doc.rust-lang.org/std/index.html">Standardbibliotheksdokumentation</a>
zu den Merkmalen, um zu erfahren, wie sie manuell implementiert werden können.</p>
<p>Diese hier aufgelisteten Merkmale sind die einzigen, die von der
Standardbibliothek definiert werden und die mit <code>derive</code> in deinen Typen
implementiert werden können. Andere in der Standardbibliothek definierte
Merkmale haben kein sinnvolles Standardverhalten, sodass es an dir liegt, sie
so zu implementieren, wie es für dein Vorhaben sinnvoll ist.</p>
<p>Ein Beispiel für ein Merkmal, das nicht abgeleitet werden kann, ist <code>Display</code>,
das die Formatierung für Endbenutzer übernimmt. Du solltest immer eine
geeignete Art und Weise in Betracht ziehen, einen Typ für einen Endbenutzer
anzuzeigen. Welche Teile des Typs sollte ein Endbenutzer sehen dürfen? Welche
Teile würden sie für relevant halten? Welches Datenformat wäre für sie am
relevantesten? Der Rust-Compiler verfügt nicht über dieses Wissen, sodass er
kein angemessenes Standardverhalten für dich bereitstellen kann.</p>
<p>Die Liste der ableitbaren Merkmale in diesem Anhang ist nicht vollständig:
Bibliotheken können <code>derive</code> für ihre eigenen Merkmale implementieren, sodass
die Liste der Merkmale, die du mit <code>derive</code> verwenden kannst, wahrlich
unbegrenzt ist. Das Implementieren von <code>derive</code> verwendet ein prozedurales
Makro, das im Abschnitt <a href="ch19-06-macros.html">„Makros“</a> in Kapitel 19 behandelt wird.</p>
<h3 id="debug-für-die-programmierer-ausgabe"><a class="header" href="#debug-für-die-programmierer-ausgabe"><code>Debug</code> für die Programmierer-Ausgabe</a></h3>
<p>Das Merkmal <code>Debug</code> ermöglicht das Debuggen von Formatierungen in
Formatierungszeichenketten, die du durch Angeben von <code>:?</code> innerhalb Platzhalter
<code>{}</code> angibst.</p>
<p>Das Merkmal <code>Debug</code> erlaubt es dir, Instanzen eines Typs zu Debugging-Zwecken
auszugeben, sodass du und andere Programmierer, die deinen Typ verwenden, eine
Instanz zu einem bestimmten Zeitpunkt der Programmausführung untersuchen
können.</p>
<p>Das Merkmal <code>Debug</code> ist beispielsweise beim Verwenden des Makros <code>assert_eq!</code>
erforderlich. Dieses Makro gibt die Werte der Instanzen, die als Argumente
angegeben wurden, aus, wenn die Gleichheitszusicherung fehlschlägt, damit
Programmierer sehen können, warum die beiden Instanzen nicht gleich waren.</p>
<h3 id="partialeq-und-eq-für-gleichheitsvergleiche"><a class="header" href="#partialeq-und-eq-für-gleichheitsvergleiche"><code>PartialEq</code> und <code>Eq</code> für Gleichheitsvergleiche</a></h3>
<p>Das Merkmal <code>PartialEq</code> erlaubt dir, Instanzen eines Typs auf Gleichheit zu
prüfen und ermöglicht das Verwenden der Operatoren <code>==</code> und <code>!=</code>.</p>
<p>Das Ableiten von <code>PartialEq</code> implementiert die Methode <code>eq</code>. Wenn <code>PartialEq</code>
für Strukturen abgeleitet wird, sind zwei Instanzen nur dann gleich, wenn
<em>alle</em> Felder gleich sind, und die Instanzen sind nicht gleich, wenn wenigstens
ein Feld nicht gleich ist. Beim Ableiten für Aufzählungen ist jede Variante
gleich sich selbst und nicht gleich den anderen Varianten.</p>
<p>Das Merkmal <code>PartialEq</code> ist beispielsweise beim Verwenden des Makros
<code>assert_eq!</code> erforderlich, das in der Lage sein muss, zwei Instanzen eines Typs
auf Gleichheit zu prüfen.</p>
<p>Das Merkmal <code>Eq</code> hat keine Methoden. Sein Zweck ist es, zu signalisieren, dass
für jeden Wert des annotierten Typs der Wert gleich sich selbst ist. Das
Merkmal <code>Eq</code> kann nur auf Typen angewandt werden, die auch <code>PartialEq</code>
implementieren, obwohl nicht alle Typen, die <code>PartialEq</code> implementieren, <code>Eq</code>
implementieren können. Ein Beispiel dafür sind Fließkomma-Zahlentypen: Die
Implementierung von Fließkomma-Zahlen besagt, dass zwei Instanzen des
Keine-Zahl-Wertes (<code>NaN</code>) nicht gleichwertig sind.</p>
<p>Ein Beispiel dafür, wann <code>Eq</code> erforderlich ist, ist für Schlüssel in einer
<code>HashMap&lt;K, V&gt;</code>, damit <code>HashMap&lt;K, V&gt;</code> erkennen kann, ob zwei Schlüssel gleich
sind.</p>
<h3 id="partialord-und-ord-für-sortiervergleiche"><a class="header" href="#partialord-und-ord-für-sortiervergleiche"><code>PartialOrd</code> und <code>Ord</code> für Sortiervergleiche</a></h3>
<p>Das Merkmal <code>PartialOrd</code> erlaubt dir, Instanzen eines Typs zum Sortieren zu
vergleichen. Ein Typ, der <code>PartialOrd</code> implementiert, kann mit den Operatoren
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> und <code>&gt;=</code> verwendet werden. Du kannst das Merkmal <code>PartialOrd</code>
nur auf Typen anwenden, die auch <code>PartialEq</code> implementieren.</p>
<p>Das Ableiten von <code>PartialOrd</code> implementiert die Methode <code>partial_cmp</code>, die eine
<code>Option&lt;Ordering&gt;</code> zurückgibt, die <code>None</code> ist, wenn die angegebenen Werte nicht
vergleichbar sind. Ein Beispiel für einen Wert, der nicht vergleichbar ist,
obwohl die meisten Werte dieses Typs verglichen werden können, ist die
Fließkommazahl <code>NaN</code>. Der Aufruf von <code>partial_cmp</code> mit einer beliebigen
Fließkommazahl und dem Fließkommawert <code>NaN</code> ergibt <code>None</code>.</p>
<p>Beim Ableiten auf Strukturen vergleicht <code>PartialOrd</code> zwei Instanzen, indem es
den Wert in jedem Feld in der Reihenfolge vergleicht, in der die Felder in der
Strukturdefinition erscheinen. Beim Ableiten auf Aufzählungen werden Varianten,
die in der Aufzählungsdefinition früher deklariert sind, als kleiner als die
später aufgeführten Varianten betrachtet.</p>
<p>Das Merkmal <code>PartialOrd</code> ist z.B. für die Methode <code>gen_range</code> aus der Kiste
<code>rand</code> erforderlich, die einen Zufallswert aus einem Wertebereich erzeugt, der
durch einen Bereichsausdruck festgelegt wird.</p>
<p>Das Merkmal <code>Ord</code> erlaubt dir zu wissen, dass für zwei beliebige Werte des
annotierten Typs eine gültige Reihenfolge existiert. Das Merkmal <code>Ord</code>
implementiert die Methode <code>cmp</code>, die <code>Ordering</code> statt <code>Option&lt;Ordering&gt;</code>
zurückgibt, weil eine gültige Reihenfolge immer möglich sein wird. Du kannst
das Merkmal <code>Ord</code> nur auf Typen anwenden, die auch <code>PartialOrd</code> und <code>Eq</code>
implementieren (und <code>Eq</code> erfordert <code>PartialEq</code>). Beim Ableiten auf Strukturen
und Aufzählungen verhält sich <code>cmp</code> genauso wie die abgeleitete Implementierung
für <code>partial_cmp</code> mit <code>PartialOrd</code>.</p>
<p>Ein Beispiel dafür, wann <code>Ord</code> erforderlich ist, ist das Speichern von Werten
in einem <code>BTreeSet&lt;T&gt;</code>, einer Datenstruktur, die Daten auf Grundlage der
Sortierreihenfolge der Werte speichert.</p>
<h3 id="clone-und-copy-zum-duplizieren-von-werten"><a class="header" href="#clone-und-copy-zum-duplizieren-von-werten"><code>Clone</code> und <code>Copy</code> zum Duplizieren von Werten</a></h3>
<p>Das Merkmal <code>Clone</code> erlaubt es dir, explizit eine tiefe Kopie eines Wertes zu
erstellen, und der Vervielfältigungsprozess könnte die Ausführung von
beliebigem Code und das Kopieren von Daten im Haldenspeicher beinhalten. Siehe
den Abschnitt <a href="ch04-01-what-is-ownership.html#variablen-und-daten-im-zusammenspiel-mit-clone">„Variablen und Daten im Zusammenspiel mit
Clone“</a> in Kapitel 4 für weitere
Informationen zu <code>Clone</code>.</p>
<p>Das Ableiten von <code>Clone</code> implementiert die Methode <code>clone</code>, die, wenn sie für
den gesamten Typ implementiert ist, <code>clone</code> auf jedem der Teile des Typs
aufruft. Das bedeutet, dass alle Felder oder Werte des Typs auch <code>Clone</code>
implementieren müssen, um <code>Clone</code> abzuleiten.</p>
<p>Ein Beispiel dafür, wann <code>Clone</code> erforderlich ist, ist der Aufruf der Methode
<code>to_vec</code> auf einem Anteilstyp. Der Anteilstyp besitzt die Typ-Instanzen nicht,
die er enthält, aber der von <code>to_vec</code> zurückgegebene Vektor muss seine
Instanzen besitzen, also ruft <code>to_vec</code> bei jedem Element <code>clone</code> auf. Daher
muss der im Anteilstyp gespeicherte Typ <code>Clone</code> implementieren.</p>
<p>Das Merkmal <code>Copy</code> erlaubt es dir, einen Wert zu duplizieren, indem nur die auf
dem Stapelspeicher gespeicherten Bits kopiert werden; es ist kein spezieller
Code notwendig. Weitere Informationen zu <code>Copy</code> findest du im Abschnitt <a href="ch04-01-what-is-ownership.html#nur-stapelspeicher-daten-kopieren-copy">„Nur
Stapelspeicher-Daten: Kopieren (copy)“</a> in Kapitel 4.</p>
<p>Das Merkmal <code>Copy</code> definiert keine Methoden, um Programmierer daran zu hindern,
diese Methoden zu überladen und die Annahme zu verletzen, dass kein spezieller
Code ausgeführt wird. Auf diese Weise können alle Programmierer davon ausgehen,
dass das Kopieren eines Wertes sehr schnell gehen wird.</p>
<p>Du kannst <code>Copy</code> auf jeden Typ ableiten, dessen Teile alle <code>Copy</code>
implementieren. Du kannst das Merkmal <code>Copy</code> nur auf Typen anwenden, die auch
<code>Clone</code> implementieren, weil ein Typ, der <code>Copy</code> implementiert, eine triviale
Implementierung von <code>Clone</code> hat, das die gleiche Aufgabe wie <code>Copy</code> erfüllt.</p>
<p>Das Merkmal <code>Copy</code> ist selten erforderlich; Typen, die <code>Copy</code> implementieren,
verfügen über Optimierungen, d.h. du mussst nicht <code>clone</code> aufrufen, was den
Code prägnanter macht.</p>
<p>Alles, was mit <code>Copy</code> möglich ist, kannst du auch mit <code>Clone</code> erreichen, aber
der Code könnte langsamer sein oder an manchen Stellen <code>clone</code> erforderlich
machen.</p>
<h3 id="hash-für-die-abbildung-eines-wertes-auf-einen-wert-fester-größe"><a class="header" href="#hash-für-die-abbildung-eines-wertes-auf-einen-wert-fester-größe"><code>Hash</code> für die Abbildung eines Wertes auf einen Wert fester Größe</a></h3>
<p>Das Merkmal <code>Hash</code> erlaubt es dir, eine Instanz eines Typs beliebiger Größe zu
nehmen und diese Instanz mithilfe einer Hash-Funktion auf einen Wert fester
Größe abzubilden. Das Ableiten von <code>Hash</code> implementiert die Methode <code>hash</code>. Die
abgeleitete Implementierung der Methode <code>hash</code> kombiniert das Ergebnis des
Aufrufs von <code>hash</code> für alle Teile des Typs, d.h. alle Felder oder Werte müssen
ebenfalls <code>Hash</code> implementieren, um <code>Hash</code> abzuleiten.</p>
<p>Ein Beispiel dafür, wann <code>Hash</code> erforderlich ist, ist das Speichern von
Schlüsseln in einer <code>HashMap&lt;K, V&gt;</code>, um Daten effizient zu speichern.</p>
<h3 id="default-für-standardwerte"><a class="header" href="#default-für-standardwerte"><code>Default</code> für Standardwerte</a></h3>
<p>Das Merkmal <code>Default</code> erlaubt es dir, einen Standardwert für einen Typ zu
definieren. Das Ableiten von <code>Default</code> implementiert die Funktion <code>default</code>.
Die abgeleitete Implementierung der Funktion <code>default</code> ruft die Funktion
<code>default</code> für jeden Teil des Typs auf, d.h. alle Felder oder Werte in dem Typ
müssen auch <code>Default</code> implementieren, um <code>Default</code> abzuleiten.</p>
<p>Die Funktion <code>Default::default</code> wird häufig in Kombination mit der Syntax zur
Aktualisierung von Strukturen verwendet, die im Abschnitt <a href="ch05-01-defining-structs.html#instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax">„Instanzen aus
anderen Instanzen erzeugen mit der
Strukturaktualisierungssyntax“</a>
in Kapitel 5 besprochen wird. Du kannst einige Felder einer Struktur anpassen
und dann einen Standardwert für den Rest der Felder festlegen und verwenden,
indem du <code>...Default::default()</code> schreibst.</p>
<p>Das Merkmal <code>Default</code> ist erforderlich, wenn du die Methode <code>unwrap_or_default</code>
z.B. auf Instanzen von <code>Option&lt;T&gt;</code> verwendest. Wenn die <code>Option&lt;T&gt;</code> den Wert
<code>None</code> hat, gibt die Methode <code>unwrap_or_default</code> das Ergebnis von
<code>Default::default</code> für den Typ <code>T</code> zurück, der in <code>Option&lt;T&gt;</code> gespeichert ist.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-d---nützliche-entwicklungswerkzeuge"><a class="header" href="#anhang-d---nützliche-entwicklungswerkzeuge">Anhang D - Nützliche Entwicklungswerkzeuge</a></h2>
<p>In diesem Anhang sprechen wir über einige nützliche Entwicklungswerkzeuge, die
das Rust-Projekt bietet. Wir werden uns mit automatischer Formatierung,
schnellen Möglichkeiten zum Beheben von Warnhinweisen, einem Tool zur
statischen Code-Analyse (linter) und der Integration in integrierte
Entwicklungsumgebungen (IDEs) befassen.</p>
<h3 id="automatische-formatierung-mit-rustfmt"><a class="header" href="#automatische-formatierung-mit-rustfmt">Automatische Formatierung mit <code>rustfmt</code></a></h3>
<p>Das Tool <code>rustfmt</code> formatiert deinen Code entsprechend des
Gemeinschafts-Codestils. Viele kollaborative Projekte verwenden <code>rustfmt</code>, um
Diskussionen zum Stil beim Schreiben von Rust zu vermeiden: Jeder formatiert
seinen Code mithilfe des Tools.</p>
<p>Um <code>rustfmt</code> zu installieren, gib folgendes ein:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>Dieser Befehl stellt dir <code>rustfmt</code> und <code>cargo-fmt</code> zur Verfügung, ähnlich wie
Rust sowohl <code>rustc</code> als auch <code>cargo</code> bereitstellt. Um ein beliebiges
Cargo-Projekt zu formatieren, gib folgendes ein:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Durch Ausführen dieses Befehls wird der gesamte Rust-Code in der aktuellen
Kiste (crate) neu formatiert. Dies sollte nur den Codestil, nicht aber die
Codesemantik ändern. Weitere Informationen zu <code>rustfmt</code> findest du in <a href="https://github.com/rust-lang/rustfmt">seiner
Dokumentation</a>.</p>
<h3 id="korrigiere-deinen-code-mit-rustfix"><a class="header" href="#korrigiere-deinen-code-mit-rustfix">Korrigiere deinen Code mit <code>rustfix</code></a></h3>
<p>Das Werkzeug rustfix ist in Rust-Installationen enthalten und kann automatisch
Compiler-Warnungen beheben, die eine klare Möglichkeit haben, das Problem zu
beheben, was wahrscheinlich das ist, was du willst. Wahrscheinlich hast du
schon einmal Compiler-Warnungen gesehen. Betrachte zum Beispiel diesen Code:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>Hier rufen wir die Funktion <code>do_something</code> 100 Mal auf, aber wir verwenden die
Variable <code>i</code> im Rumpf der <code>for</code>-Schleife nicht. Rust warnt uns davor:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>Die Warnung empfiehlt, stattdessen <code>_i</code> als Namen zu verwenden: Der Unterstrich
zeigt an, dass wir diese Variable nicht verwenden wollen. Wir können diesen
Vorschlag mit dem Werkzeug <code>rustfix</code> automatisch übernehmen, indem wir das
Kommando <code>cargo fix</code> ausführen:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Wenn wir uns <em>src/main.rs</em> noch einmal ansehen, werden wir sehen, dass
<code>cargo fix</code> den Code geändert hat:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>Die <code>for</code>-Schleifenvariable heißt jetzt <code>_i</code> und die Warnung erscheint nicht
mehr.</p>
<p>Du kannst den Befehl <code>cargo fix</code> auch dazu verwenden, deinen Code zwischen
verschiedenen Rust-Ausgaben zu konvertieren. Die Ausgaben sind in <a href="appendix-05-editions.html">Anhang
E</a> aufgeführt.</p>
<h3 id="mehr-statische-codeanalyse-mit-clippy"><a class="header" href="#mehr-statische-codeanalyse-mit-clippy">Mehr statische Codeanalyse mit Clippy</a></h3>
<p>Das Tool Clippy ist eine Sammlung von Tools zur statischen Codeanalyse, mit dem
du häufige Fehler aufspüren und deinen Rust-Code verbessern kannst.</p>
<p>Um Clippy zu installieren, gib folgendes ein:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>Um Clippy bei einem Cargo-Projekt auszuführen, gib folgendes ein:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>Angenommen, du schreibst ein Programm, das eine Annäherung an eine
mathematische Konstante wie Pi verwendet, wie dieses Programm es tut:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;Die Kreisfläche ist {}&quot;, x * r * r);
}</code></pre></pre>
<p>Das Ausführen von <code>cargo clippy</code> in diesem Projekt führt zu diesem Fehler:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>Dieser Fehler weist dich darauf hin, dass in Rust bereits eine präzisere
Konstante <code>PI</code> definiert ist und dass dein Programm korrekter wäre, wenn du
stattdessen diese Konstante verwenden würdest. Du würdest dann deinen Code
ändern, um die Konstante <code>PI</code> zu verwenden. Der folgende Code führt zu keinen
Fehlern oder Warnungen von Clippy:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;Die Kreisfläche ist {}&quot;, x * r * r);
}</code></pre></pre>
<p>Für weitere Informationen über Clippy siehe <a href="https://github.com/rust-lang/rust-clippy">seine Dokumentation</a>.</p>
<h3 id="ide-integration-mittels-rust-analyzer"><a class="header" href="#ide-integration-mittels-rust-analyzer">IDE-Integration mittels <code>rust-analyzer</code></a></h3>
<p>Um die IDE-Integration zu erleichtern, empfiehlt die Rust-Gemeinschaft die
Verwendung des <a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a>. Bei diesem Werkzeug handelt es
sich um eine Reihe von Compiler-zentrierten Hilfsprogrammen, die das
<a href="http://langserver.org/">Sprach-Server-Protokoll (Language Server Protocol)</a> beherrschen, eine
Spezifikation für IDEs und Programmiersprachen zur Kommunikation untereinander.
Verschiedene Clients können <code>rust-analyzer</code> verwenden, wie zum Beispiel <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">das
Rust-Plugin für Visual Studio Code</a>.</p>
<p>Besuche die <a href="https://rust-analyzer.github.io">Homepage</a> des Projekts <code>rust-analyzer</code>, um
Installationsanweisungen zu erhalten, und installiere dann die
Sprachserver-Unterstützung in deiner speziellen IDE. Deine IDE wird
Fähigkeiten wie Autovervollständigung, Sprung zur Definition und im Code
eingeblendete Fehlermeldungen erhalten.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-e---ausgaben"><a class="header" href="#anhang-e---ausgaben">Anhang E - Ausgaben</a></h2>
<p>In Kapitel 1 hast du gesehen, dass <code>cargo new</code> Metadaten zur Ausgabe (edition)
in deiner Datei <em>Cargo.toml</em> hinzufügt. Dieser Anhang erläutert, was das
bedeutet!</p>
<p>Die Sprache Rust und der Compiler haben einen sechswöchigen
Veröffentlichungszyklus, was bedeutet, dass die Nutzer einen konstanten Strom
neuer Funktionen erhalten. Andere Programmiersprachen geben weniger oft größere
Änderungen heraus; Rust gibt häufiger kleinere Aktualisierungen heraus. Nach
einer Weile summieren sich all diese kleinen Änderungen. Aber von
Veröffentlichung zu Veröffentlichung kann es schwierig sein, zurückzublicken
und zu sagen: &quot;Wow, zwischen Rust 1.10 und Rust 1.31 hat sich Rust sehr
verändert!</p>
<p>Alle zwei oder drei Jahre gibt das Rust-Team eine neue <em>Rust-Ausgabe</em> (edition)
heraus. Jede Ausgabe fasst die neuen Funktionalitäten in einem übersichtlichen
Paket mit vollständig aktualisierter Dokumentation und Werkzeugausstattung
zusammen. Neue Ausgaben werden im Rahmen des üblichen sechswöchigen
Freigabeprozesses ausgeliefert.</p>
<p>Ausgaben dienen unterschiedlichen Zwecken für verschiedene Menschen:</p>
<ul>
<li>Für aktive Rust-Nutzer fasst eine neue Ausgabe inkrementelle Änderungen in
einem leicht verständlichen Paket zusammen.</li>
<li>Für Nicht-Nutzer signalisiert eine neue Ausgabe, dass einige wichtige
Fortschritte hinzugekommen sind, sodass sich ein erneuter Blick auf Rust
lohnen könnte.</li>
<li>Für diejenigen, die Rust entwickeln, stellt eine neue Ausgabe einen
Treffpunkt für das gesamte Projekt dar.</li>
</ul>
<p>Zum Verfassungszeitpunkt dieses Artikels sind drei Rust-Ausgaben verfügbar:
Rust 2015, Rust 2018 und Rust 2021. Dieses Buch wurde unter Verwendung der
Rust-Ausgabe 2021 geschrieben.</p>
<p>Der Schlüssel <code>edition</code> in <em>Cargo.toml</em> gibt an, welche Ausgabe der Compiler
für deinen Code verwenden soll. Wenn der Schlüssel nicht existiert, verwendet
Rust aus Gründen der Abwärtskompatibilität die Edition <code>2015</code>.</p>
<p>Jedes Projekt kann sich für eine Ausgabe abweichend von der Standardausgabe
2015 entscheiden. Ausgaben können inkompatible Änderungen enthalten, z.B. die
Aufnahme eines neuen Schlüsselworts, das mit Bezeichnern im Code in Konflikt
steht. Selbst wenn du dich nicht für diese Änderungen entscheidest, wird dein
Code weiterhin kompilieren, auch wenn du die verwendete
Rust-Compiler-Version aktualisierst.</p>
<p>Alle Rust-Compiler-Versionen unterstützen jede Ausgabe, die vor der
Veröffentlichung dieses Compilers existierte, und es können Kisten (crates)
aller unterstützten Ausgaben miteinander verknüpft werden. Ausgabenänderungen
wirken sich nur auf die Art und Weise aus, wie der Compiler anfangs den Code
analysiert. Wenn du also Rust 2015 verwendest und eine deiner Abhängigkeiten
Rust 2018 verwendet, wird dein Projekt diese Abhängigkeit kompilieren und
nutzen können. Die umgekehrte Situation, in der dein Projekt Rust 2018
und eine Abhängigkeit Rust 2015 verwendet, funktioniert ebenfalls.</p>
<p>Um es klar zu sagen: Die meisten Funktionen werden in allen Ausgaben verfügbar
sein. Entwickler, die eine beliebige Rust-Ausgabe verwenden, werden auch
weiterhin Verbesserungen sehen, wenn neue stabile Versionen erstellt werden. In
einigen Fällen, vor allem wenn neue Schlüsselwörter hinzugefügt werden, sind
einige neue Funktionalitäten jedoch möglicherweise erst in späteren Ausgaben
verfügbar. Du wirst die Ausgabe wechseln müssen, wenn du die Vorteile solcher
Funktionalitäten nutzen möchtest.</p>
<p>Für weitere Einzelheiten schaue in den <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Ausgabe-Leitfaden</em> (Edition
Guide)</a>, einem vollständigen Buch über Ausgaben, das die
Unterschiede zwischen den Ausgaben aufzählt und erklärt, wie du deinen Code
automatisch per <code>cargo fix</code> auf eine neue Ausgabe aktualisieren kannst.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-f-Übersetzungen-des-buchs"><a class="header" href="#anhang-f-Übersetzungen-des-buchs">Anhang F: Übersetzungen des Buchs</a></h2>
<p>Für Ressourcen in anderen Sprachen als Englisch. Die meisten sind noch in
Arbeit; siehe das <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">Label <code>Translations</code></a>, um zu helfen oder uns über
eine neue Übersetzung zu informieren!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português (BR)</a></li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português (PT)</a></li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a></li>
<li><a href="https://github.com/rust-tw/book-tw">正體中文</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">Español</a></li>
<li><a href="https://github.com/EmanueleGurini/book_it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">हिंदी</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">ไทย</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anhang-g---wie-rust-erstellt-wird-und-nächtliches-rust"><a class="header" href="#anhang-g---wie-rust-erstellt-wird-und-nächtliches-rust">Anhang G - Wie Rust erstellt wird und „nächtliches Rust“</a></h2>
<p>In diesem Anhang geht es darum, wie Rust erstellt wird und wie sich das auf
dich als Rust-Entwickler auswirkt.</p>
<h3 id="stabilität-ohne-stillstand"><a class="header" href="#stabilität-ohne-stillstand">Stabilität ohne Stillstand</a></h3>
<p>Als Sprache kümmert sich Rust <em>viel</em> um die Stabilität deines Codes. Wir
wollen, dass Rust ein felsenfestes Fundament ist, auf dem du aufbauen kannst,
und wenn sich die Dinge ständig ändern würden, wäre das unmöglich. Gleichzeitig
werden wir, wenn wir nicht mit neuen Funktionen experimentieren können,
wichtige Mängel vielleicht erst nach ihrer Veröffentlichung entdecken, wenn wir
die Dinge nicht mehr ändern können.</p>
<p>Unsere Lösung für dieses Problem ist das, was wir „Stabilität ohne Stillstand“
nennen, und unser Leitsatz lautet: Du solltest niemals Angst vor einem Upgrade
auf eine neue Version des stabilen Rust haben müssen. Jedes Upgrade sollte
schmerzlos sein, aber auch neue Funktionalitäten, weniger Fehler und schnellere
Kompilierzeiten mit sich bringen.</p>
<h3 id="tüff-tüff-veröffentlichungs-kanäle-und-zugfahren"><a class="header" href="#tüff-tüff-veröffentlichungs-kanäle-und-zugfahren">Tüff, tüff! Veröffentlichungs-Kanäle und Zugfahren</a></h3>
<p>Die Rust-Entwicklung erfolgt nach einem <em>Zugfahrplan</em> (train schedule). Das
bedeutet, dass die gesamte Entwicklung auf dem <code>master</code>-Zweig der
Rust-Versionsverwaltung durchgeführt wird. Die Veröffentlichungen folgen einem
Software-Veröffentlichungs-Zugmodell, das von Cisco IOS und anderen
Softwareprojekten verwendet wurde. Es gibt drei <em>Veröffentlichungskanäle</em>
(release channels) für Rust:</p>
<ul>
<li>Nächtlich (nightly)</li>
<li>Beta</li>
<li>Stabil (stable)</li>
</ul>
<p>Die meisten Rust-Entwickler verwenden in erster Linie den stabilen Kanal, aber
diejenigen, die experimentelle neue Funktionen ausprobieren wollen, können
nächtlich oder beta verwenden.</p>
<p>Hier ist ein Beispiel dafür, wie der Entwicklungs- und Veröffentlichungsprozess
funktioniert: Nehmen wir an, das Rust-Team arbeitet an der Veröffentlichung von
Rust 1.5. Diese Veröffentlichung erfolgte im Dezember 2015, aber sie wird uns
realistische Versionsnummern liefern. Eine neue Funktionalität wird zu Rust
hinzugefügt: Eine neue Änderung (commit) kommt in den <code>master</code>-Zweig. Jede
Nacht wird eine neue nächtliche Version von Rust produziert. Jeder Tag ist ein
Veröffentlichungs-Tag und diese Veröffentlichungen werden automatisch von
unserer Veröffentlichungs-Infrastruktur erstellt. Mit der Zeit sehen unsere
Veröffentlichungen also so aus, einmal pro Nacht:</p>
<pre><code class="language-text">nächtlich: * - - * - - *
</code></pre>
<p>Alle sechs Wochen ist es an der Zeit, eine neue Version vorzubereiten! Der
<code>beta</code>-Zweig der Rust-Versionsverwaltung verzweigt vom <code>master</code>-Zweig, der von
„nächtlich“ benutzt wird. Jetzt gibt es zwei Versionen:</p>
<pre><code class="language-text">nächtlich: * - - * - - *
                       |
beta:                  *
</code></pre>
<p>Die meisten Rust-Nutzer verwenden Beta-Versionen nicht aktiv, sondern testen
gegen die Beta-Version in ihrem CI-System, um Rust bei der Entdeckung möglicher
Regressionen zu unterstützen. In der Zwischenzeit gibt es immer noch jede Nacht
eine nächtliche Veröffentlichung:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - *
                       |
beta:                  *
</code></pre>
<p>Sagen wir, es wird eine Regression gefunden. Gut, dass wir etwas Zeit hatten,
die Beta-Version zu testen, bevor sich die Regression in eine stabile Version
eingeschlichen hat! Die Fehlerkorrektur wird auf <code>master</code> angewendet, sodass
„nächtlich“ korrigiert wird, und dann wird die Fehlerkorrektur in den
<code>beta</code>-Zweig zurückportiert und eine neue Version der Beta erzeugt:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - * - - *
                       |
beta:                  * - - - - - - - - *
</code></pre>
<p>Sechs Wochen nachdem die erste Beta-Version erstellt wurde, ist es Zeit für
eine stabile Veröffentlichung! Der <code>stable</code>-Zweig wird aus dem <code>beta</code>-Zweig
erstellt:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - * - - * - * - *
                       |
beta:                  * - - - - - - - - *
                                         |
stabil:                                  *
</code></pre>
<p>Hurra! Rust 1.5 ist geschafft! Eines haben wir jedoch vergessen: Da die sechs
Wochen vergangen sind, brauchen wir auch eine neue Beta der <em>nächsten</em> Version,
Rust 1.6. Nachdem also <code>stable</code> von <code>beta</code> abzweigt, zweigt die nächste Version
von <code>beta</code> wieder von <code>nightly</code> ab:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - * - - * - * - *
                       |                         |
beta:                  * - - - - - - - - *       *
                                         |
stabil:                                  *
</code></pre>
<p>Dies wird als „Zugmodell“ (train model) bezeichnet, weil alle sechs Wochen eine
Veröffentlichung „den Bahnhof verlässt“, aber immer noch eine Reise durch den
Betakanal machen muss, bevor sie als stabile Version ankommt.</p>
<p>Alle sechs Wochen veröffentlicht Rust eine Version, wie ein Uhrwerk. Wenn du
das Datum einer Rust-Veröffentlichung kennst, kennst du auch das Datum der
nächsten: Sie ist sechs Wochen später. Ein schöner Aspekt der alle sechs Wochen
geplanten Veröffentlichungen ist, dass der nächste Zug bald kommt. Wenn eine
Funktionalität eine bestimmte Veröffentlichung verpasst, brauchst du dir keine
Sorgen zu machen: In kurzer Zeit kommt die nächste! Dies trägt dazu bei, den
Druck zu verringern, bevor sich möglicherweise unausgefeilte Funktionalitäten
kurz vor Ablauf der Veröffentlichungsfrist einschleichen.</p>
<p>Dank dieses Prozesses kannst du jederzeit die nächste Rust-Version ausprobieren
und dich selbst davon überzeugen, dass ein Upgrade leicht möglich ist: Wenn
eine Beta-Version nicht wie erwartet funktioniert, kannst du dies dem Team
melden und sie vor der nächsten stabilen Version korrigieren lassen! Ein Bruch
in einer Beta-Version ist relativ selten, aber <code>rustc</code> ist immer noch ein Stück
Software und es gibt Fehler.</p>
<h3 id="instabile-funktionalitäten"><a class="header" href="#instabile-funktionalitäten">Instabile Funktionalitäten</a></h3>
<p>Bei diesem Veröffentlichungsmodell gibt es noch einen weiteren Haken: Instabile
Funktionalitäten. Rust verwendet eine Technik namens „Funktionalitäts-Schalter“
(feature flags), um festzulegen, welche Funktionalitäten in einer bestimmten
Version aktiviert sind. Wenn eine neue Funktionalität aktiv entwickelt wird,
landet sie auf dem <code>master</code> und damit in „nächtlich“, aber hinter einem
<em>Funktionalitäts-Schalter</em>. Wenn du als Nutzer eine in Entwicklung befindliche
Funktionalität ausprobieren möchtest, kannst du dies tun, aber du musst eine
nächtliche Version von Rust verwenden und deinen Quellcode mit dem
entsprechenden Schalter versehen, um sie nutzen zu können.</p>
<p>Wenn du eine Beta- oder stabile Version von Rust verwendest, kannst du keine
Funktionalitäts-Schalter verwenden. Dies ist der Schlüssel, der es uns
ermöglicht, neue Funktionen praktisch zu nutzen, bevor wir sie für immer für
stabil erklären. Diejenigen, die sich für das Allerneueste entscheiden wollen,
können dies tun, und diejenigen, die eine felsenfeste Erfahrung machen wollen,
können bei der stabilen Version bleiben und wissen, dass ihr Code nicht brechen
wird. Stabilität ohne Stillstand. Dieses Buch enthält nur Informationen über
stabile Funktionalitäten, da sich in Entwicklung befindliche Funktionalitäten
noch ändern, und sicherlich werden sie sich zwischen dem Zeitpunkt, an dem
dieses Buch geschrieben wurde, und dem Zeitpunkt, an dem sie in stabilen
Versionen aktiviert werden, unterscheiden. Die Dokumentation für die nur
nächtlich verfügbaren Funktionalitäten findest du online.</p>
<h3 id="rustup-und-die-rolle-des-nächtlichen-rust"><a class="header" href="#rustup-und-die-rolle-des-nächtlichen-rust">Rustup und die Rolle des nächtlichen Rust</a></h3>
<p>Rustup macht es einfach, zwischen verschiedenen Veröffentlichungskanälen von
Rust zu wechseln, auf globaler oder projektbezogener Basis. Standardmäßig hast
du stabiles Rust installiert. Um die nächtliche Version zu installieren, mache
folgenden Aufruf:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>Du kannst auch alle <em>Werkzeugketten</em> (toolchains) (Versionen von Rust und
zugehörigen Komponenten) sehen, die du mit <code>rustup</code> installiert hast. Hier ist
ein Beispiel auf dem Windows-Rechner einer deiner Autoren:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>Wie du sehen kannst, ist die stabile Werkzeugkette die Standardeinstellung. Die
meisten Rust-Nutzer verwenden meistens die stabile Version. Vielleicht möchtest
du die meiste Zeit die stabile Version verwenden, aber für ein bestimmtes
Projekt mit der nächtlichen Version arbeiten, weil dir eine innovative
Funktionalität wichtig ist. Um dies zu tun, kannst du <code>rustup override</code> im
Verzeichnis dieses Projekts benutzen, um die nächtliche Werkzeugkette als
diejenige zu setzen, die <code>rustup</code> benutzen soll, wenn du dich in diesem
Verzeichnis befindest:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Jedes Mal, wenn du nun <code>rustc</code> oder <code>cargo</code> innerhalb von
<em>~/projects/needs-nightly</em> aufrufst, stellt <code>rustup</code> sicher, dass du das
nächtliche Rust verwendest und nicht dein standardmäßiges, stabiles Rust. Das
ist praktisch, wenn du viele Rust-Projekte hast!</p>
<h3 id="der-rfc-prozess-und-die-teams"><a class="header" href="#der-rfc-prozess-und-die-teams">Der RFC-Prozess und die Teams</a></h3>
<p>Wie erfährst du also von diesen neuen Funktionalitäten? Das Entwicklungsmodell
von Rust folgt einem <em>Bitte-um-Kommentare-Prozess</em> (Request For Comments, RFC). 
Wenn du eine Verbesserung von Rust wünschst, kannst du einen Vorschlag
schreiben, einen sogenannten RFC.</p>
<p>Jeder kann RFCs zur Verbesserung von Rust schreiben und die Vorschläge werden
vom Rust-Team, das aus vielen thematischen Unterteams besteht, geprüft und
diskutiert. Es gibt eine vollständige Liste der Teams auf der
<a href="https://www.rust-lang.org/governance">Rust-Website</a>, in der die Teams für jeden Projektbereich
aufgeführt sind: Sprachdesign, Compiler-Implementierung, Infrastruktur,
Dokumentation und weitere. Das zuständige Team liest den Vorschlag und die
Kommentare, schreibt einige eigene Kommentare und schließlich gibt es einen
Konsens, die Funktionalität anzunehmen oder abzulehnen.</p>
<p>Wenn die Funktionalität angenommen wird, wird ein Ticket (issue) in der
Rust-Versionsverwaltung eröffnet, und jemand kann es implementieren. Die
Person, die es sehr gut umsetzt, ist möglicherweise nicht die Person, die die
Funktionalität ursprünglich vorgeschlagen hat! Wenn die Implementierung fertig
ist, landet sie auf dem <code>master</code>-Zweig hinter einem Funktionalitäts-Schalter,
wie wir im Abschnitt <a href="appendix-07-nightly-rust.html#instabile-funktionalit%C3%A4ten">„Instabile
Funktionalitäten“</a> besprochen haben.</p>
<p>Nach einiger Zeit, in der Rust-Entwickler die neue Funktionalität in den
nächtlichen Veröffentlichungen ausprobieren konnten, werden die Teammitglieder
die Ausarbeitung der Funktionalität im nächtlichen Zweig diskutieren und
entscheiden, ob sie ins stabile Rust kommen soll oder nicht. Wenn die
Entscheidung positiv ist, wird das Funktionalitätstor (feature gate) entfernt
und die Funktionalität gilt jetzt als stabil! Sie fährt mit den Zügen in eine
neue stabile Version von Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
