<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Testverwaltung - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="testverwaltung"><a class="header" href="#testverwaltung">Testverwaltung</a></h2>
<p>Wie zu Beginn des Kapitels erwähnt, ist das Testen eine komplexe Disziplin, und
verschiedene Personen verwenden unterschiedliche Terminologien und
Organisationen. Die Rust-Gemeinschaft teilt Tests in zwei Hauptkategorien ein:
Modultests und Integrationstests. <em>Modultests</em> (unit tests) sind klein und
zielgerichteter, testen jeweils ein Modul isoliert und können private
Schnittstellen testen. <em>Integrationstests</em> (integration tests) sind völlig
außerhalb deiner Bibliothek und verwenden deinen Code auf die gleiche Weise wie
jeder andere externe Code, wobei nur die öffentliche Schnittstelle verwendet
wird und möglicherweise mehrere Module pro Test ausgeführt werden.</p>
<p>Es ist wichtig, beide Testarten zu schreiben, um sicherzustellen, dass die
Teile deiner Bibliothek einzeln und zusammen das tun, was du von ihnen
erwartest.</p>
<h3 id="modultests"><a class="header" href="#modultests">Modultests</a></h3>
<p>Der Zweck von Modultests besteht darin, jede Code-Einheit isoliert vom Rest des
Codes zu testen, um schnell herauszufinden, welcher Code wie erwartet
funktioniert und welcher nicht. Modultests befinden sich im Verzeichnis <em>src</em>
in den Quellcodedateien, den sie testen. Die Konvention besteht darin, in jeder
Datei ein Modul namens <code>tests</code> zu erstellen, das die Testfunktionen enthält,
und das Modul mit <code>cfg(test)</code> zu annotieren.</p>
<h4 id="das-testmodul-und-cfgtest"><a class="header" href="#das-testmodul-und-cfgtest">Das Testmodul und <code>#[cfg(test)]</code></a></h4>
<p>Die Annotation <code>#[cfg(test)]</code> am Testmodul weist Rust an, den Testcode nur dann
zu kompilieren und auszuführen, wenn du <code>cargo test</code> ausführst, nicht aber,
wenn du <code>cargo build</code> ausführst. Dies spart Kompilierzeit, wenn du nur die
Bibliothek erstellen möchtest, und spart Platz im resultierenden, kompilierten
Artefakt, da die Tests nicht enthalten sind. Du wirst feststellen, dass
Integrationstests die Annotation <code>#[cfg(test)]</code> nicht benötigen, weil sie in
einem anderen Verzeichnis liegen. Da Modultests jedoch in den gleichen Dateien
wie der Code sind, wirst du <code>#[cfg(test)]</code> verwenden, um anzugeben, dass sie
nicht im kompilierten Ergebnis enthalten sein sollen.</p>
<p>Erinnere dich daran, dass Cargo diesen Code für uns generiert hat, als wir das
neue Projekt <code>adder</code> im ersten Abschnitt dieses Kapitels erstellt haben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Im automatisch generierten Modul <code>tests</code> steht das Attribut <code>cfg</code> für
<em>Konfiguration</em> und teilt Rust mit, dass das folgende Element nur bei einer
bestimmten Konfigurationsoption eingebunden werden soll. In diesem Fall ist die
Konfigurationsoption <code>test</code>, die von Rust beim Kompilieren und Ausführen von
Tests verwendet wird. Durch das Verwenden des Attributs <code>cfg</code> kompiliert Cargo
unseren Testcode nur dann, wenn wir die Tests aktiv mit <code>cargo test</code> ausführen.
Dies schließt alle Hilfsfunktionen ein, die sich innerhalb dieses Moduls
befinden könnten, zusätzlich zu den mit <code>#[test]</code> annotierten Funktionen.</p>
<h4 id="testen-privater-funktionen"><a class="header" href="#testen-privater-funktionen">Testen privater Funktionen</a></h4>
<p>In der Testgemeinschaft wird darüber diskutiert, ob private Funktionen direkt
getestet werden sollten oder nicht, und andere Sprachen machen es schwierig
oder gar unmöglich, private Funktionen zu testen. Unabhängig davon, an welcher
Testideologie du festhältst, erlauben dir Rusts Datenschutzregeln, private
Funktionen zu testen. Betrachte den Code in Codeblock 11-12 mit der privaten
Funktion <code>internal_adder</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn add_two(a: usize) -&gt; usize {
    internal_adder(a, 2)
}

fn internal_adder(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p><span class="caption">Codeblock 11-12: Testen einer privaten Funktion</span></p>
<p>Beachte, dass die Funktion <code>internal_adder</code> nicht mit <code>pub</code> markiert ist. Tests
sind einfach nur Rust-Code, und das Modul <code>tests</code> ist nur ein weiteres Modul.
Wie in <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit Pfaden auf ein Element im Modulbaum verweisen“</a>
beschrieben, können Elemente in Kind-Modulen die Elemente ihrer Eltern-Module
verwenden. In diesem Test bringen wir alle Elemente des Eltern-Moduls von
<code>tests</code> mit <code>use super::*</code> in den Gültigkeitsbereich, und dann kann der Test
<code>internal_adder</code> aufrufen. Wenn du der Meinung bist, dass private Funktionen
nicht getestet werden sollten, gibt es in Rust nichts, was dich dazu zwingen
würde.</p>
<h3 id="integrationstests"><a class="header" href="#integrationstests">Integrationstests</a></h3>
<p>In Rust sind Integrationstests völlig außerhalb deiner Bibliothek angesiedelt.
Du verwendest deine Bibliothek auf die gleiche Weise wie jeder andere Code,
d.h. es können nur Funktionen aufgerufen werden, die Teil der öffentlichen
Programmierschnittstelle (API) deiner Bibliothek sind. Ihr Zweck ist es, zu
testen, ob viele Teile deiner Bibliothek korrekt zusammenarbeiten.
Code-Einheiten, die alleine korrekt funktionieren, könnten Probleme nach deren
Integration haben, daher ist auch die Testabdeckung des integrierten Codes
wichtig. Um Integrationstests zu erstellen, benötigst du zunächst ein
Verzeichnis <em>tests</em>.</p>
<h4 id="das-verzeichnis-tests"><a class="header" href="#das-verzeichnis-tests">Das Verzeichnis <em>tests</em></a></h4>
<p>Wir erstellen ein Verzeichnis <em>tests</em> auf der obersten Ebene unseres
Projektverzeichnisses, neben <em>src</em>. Cargo weiß, dass es in diesem Verzeichnis
nach Integrationstestdateien suchen soll. Wir können dann so viele Testdateien
erstellen, wie wir wollen, und Cargo wird jede dieser Dateien als eine
individuelle Kiste (crate) kompilieren.</p>
<p>Lass uns einen Integrationstest erstellen. Wenn sich der Code in Codeblock
11-12 noch in der Datei <em>src/lib.rs</em> befindet, erstelle ein Verzeichnis
<em>tests</em> und eine neue Datei mit dem Namen <em>tests/integration_test.rs</em>. Deine
Verzeichnisstruktur sollte folgendermaßen aussehen:</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>Gib den Code in Codeblock 11-13 in die Datei <em>tests/integration_test.rs</em> ein.</p>
<p><span class="filename">Dateiname: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p><span class="caption">Codeblock 11-13: Integrationstest einer Funktion in der
Kiste <code>adder</code></span></p>
<p>Jede Datei im Verzeichnis <code>tests</code> ist eine separate Kiste, also müssen wir
unsere Bibliothek in den Gültigkeitsbereich jeder Test-Kiste bringen. Aus
diesem Grund fügen wir <code>use adder::add_two;</code> am Anfang des Codes hinzu, was wir
in den Modultests nicht brauchten.</p>
<p>Wir brauchen den Code in <em>tests/integration_test.rs</em> nicht mit <code>#[cfg(test)]</code>
zu annotieren. Cargo behandelt das Verzeichnis <code>tests</code> speziell und kompiliert
Dateien in diesem Verzeichnis nur dann, wenn wir <code>cargo test</code> ausführen. Führe
<code>cargo test</code> jetzt aus:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Die drei Abschnitte der Ausgabe umfassen die Modultests, den Integrationstest
und die Dokumentationstests. Beachte, wenn ein Test in einem Abschnitt
fehlschlägt, dann werden die folgenden Abschnitte nicht ausgeführt. Wenn zum
Beispiel ein Modultest fehlschlägt, gibt es keine Ausgabe für Integrations- und
Dokumentations-Tests, da diese Tests nur ausgeführt werden, wenn alle
Modultests erfolgreich sind.</p>
<p>Der erste Abschnitt für die Modultests ist derselbe, wie wir ihn gesehen haben:
Eine Zeile für jeden Modultest (eine Zeile mit der Bezeichnung <code>internal</code>, die
wir in Codeblock 11-12 hinzugefügt haben) und dann eine zusammenfassende Zeile
für die Modultests.</p>
<p>Der Abschnitt zu den Integrationstests beginnt mit der Zeile <code>Running tests/integration_test.rs</code>. Als nächstes kommt eine Zeile für jede Testfunktion
in diesem Integrationstest und eine Zusammenfassung für die Ergebnisse des
Integrationstests, kurz bevor der Abschnitt <code>Doc-tests adder</code> beginnt.</p>
<p>Jede Integrationstestdatei hat ihren eigenen Abschnitt, wenn wir also weitere
Dateien im Verzeichnis <em>tests</em> hinzufügen, wird es mehr
Integrationstest-Abschnitte geben.</p>
<p>Wir können immer noch eine bestimmte Integrationstestfunktion ausführen, indem
wir den Namen der Testfunktion als Argument bei <code>cargo test</code> angeben. Um alle
Tests in einer bestimmten Integrationstestdatei auszuführen, verwenden bei
<code>cargo test</code> das Argument <code>--test</code>, gefolgt vom Namen der Datei:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Dieses Kommando führt nur die Tests in der Datei <em>tests/integration_test.rs</em>
aus.</p>
<h4 id="untermodule-in-integrationstests"><a class="header" href="#untermodule-in-integrationstests">Untermodule in Integrationstests</a></h4>
<p>Wenn du weitere Integrationstests hinzufügst, möchtest du vielleicht mehr als
eine Datei im Verzeichnis <em>tests</em> erstellen, um sie besser organisieren zu
können; beispielsweise kannst du die Testfunktionen nach der Funktionalität
gruppieren, die sie testen. Wie bereits erwähnt, wird jede Datei im Verzeichnis
<em>tests</em> als eigene Kiste kompiliert, was nützlich ist, um getrennte Bereiche zu
erstellen, um die Art und Weise, wie die Endbenutzer deine Kiste verwenden
werden, besser zu imitieren. Das bedeutet jedoch, dass Dateien im Verzeichnis
<em>tests</em> nicht dasselbe Verhalten aufweisen wie Dateien im Verzeichnis <em>src</em>,
wie du in Kapitel 7 über die Trennung von Code in Module und Dateien gelernt
hast.</p>
<p>Das unterschiedliche Verhalten von Dateien im Verzeichnis <em>tests</em> ist am
deutlichsten, wenn du eine Reihe Hilfsfunktionen hast, die bei mehreren
Integrationstestdateien verwendest, und du versuchst, die Schritte in <a href="ch07-05-separating-modules-into-different-files.html">„Module
in verschiedene Dateien aufteilen“</a> in Kapitel 7
zu befolgen, um sie in ein gemeinsames Modul zu extrahieren. Wenn wir zum
Beispiel <em>tests/common.rs</em> erstellen und eine Funktion namens <code>setup</code> darin
platzieren, können wir <code>setup</code> etwas Code hinzufügen, den wir von mehreren
Testfunktionen in mehreren Testdateien aufrufen wollen:</p>
<p><span class="filename">Dateiname: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // Vorbereitungscode speziell für die Tests deiner Bibliothek
}</code></pre>
<p>Wenn wir die Tests erneut ausführen, werden wir für die Datei <em>common.rs</em> einen
neuen Abschnitt in der Testausgabe sehen, obwohl diese Datei keine
Testfunktionen enthält und wir die Funktion <code>setup</code> nicht von irgendwo
aufgerufen haben:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Dass in den Testergebnissen <code>common</code> erscheint und dabei <code>running 0 tests</code>
angezeigt wird, ist nicht das, was wir wollten. Wir wollten nur etwas Code mit
den anderen Integrationstestdateien teilen. Um zu vermeiden, dass <code>common</code> in
der Testausgabe erscheint, werden wir statt <em>tests/common.rs</em> die Datei
<em>tests/common/mod.rs</em> erstellen. Das Projektverzeichnis sieht nun wie folgt
aus:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
</code></pre>
<p>Dies ist die ältere Namenskonvention, die auch Rust versteht, die wir in
<a href="ch07-05-separating-modules-into-different-files.html#alternative-dateipfade">„Alternative Dateipfade“</a> in Kapitel 7 erwähnt haben. Durch diese
Benennung der Datei wird Rust angewiesen, das Modul <code>common</code> nicht als
Integrationstestdatei zu behandeln. Wenn wir den Funktionscode <code>setup</code> in
<em>tests/common/mod.rs</em> verschieben und die Datei <em>tests/common.rs</em> löschen,
erscheint der Abschnitt in der Testausgabe nicht mehr. Dateien in
Unterverzeichnissen des Verzeichnisses <em>tests</em> werden nicht als separate Kisten
kompiliert und erzeugen keine Abschnitte in der Testausgabe.</p>
<p>Nachdem wir <em>tests/common/mod.rs</em> erstellt haben, können wir es von jeder der
Integrationstestdateien als Modul verwenden. Hier ist ein Beispiel für den
Aufruf der Funktion <code>setup</code> aus dem Test <code>it_adds_two</code> in
<em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Dateiname: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p>Beachte, dass die Deklaration <code>mod common;</code> die gleiche ist wie die
Moduldeklaration, die wir in Codeblock 7-21 gezeigt haben. In der Testfunktion
können wir dann die Funktion <code>common::setup()</code> aufrufen.</p>
<h4 id="integrationstests-für-binäre-kisten"><a class="header" href="#integrationstests-für-binäre-kisten">Integrationstests für binäre Kisten</a></h4>
<p>Wenn unser Projekt eine binäre Kiste ist, die nur eine Datei <em>src/main.rs</em>
enthält und keine Datei <em>src/lib.rs</em>, können wir keine Integrationstests im
<em>tests</em>-Verzeichnis erstellen und Funktionen, die in der <em>src/main.rs</em>-Datei
definiert sind, mit einer <code>use</code>-Anweisung in den Gültigkeitsbereich bringen.
Nur Bibliothekskisten stellen Funktionen zur Verfügung, die auch von anderen
Kisten verwendet werden können; binäre Kisten sind für den eigenständigen
Betrieb gedacht.</p>
<p>Dies ist einer der Gründe, warum Rust-Projekte, die eine Binärdatei
bereitstellen, eine einfache <em>src/main.rs</em>-Datei haben, die Logik aufruft, die
in der <em>src/lib.rs</em>-Datei lebt. Unter Verwendung dieser Struktur können
Integrationstests die Bibliothekskiste mit <code>use</code> testen, um wichtige
Funktionalität verfügbar zu machen. Wenn die Hauptfunktionalität korrekt ist,
funktionieren auch die kleinen Codestücke in der Datei <em>src/main.rs</em>, und diese
kleinen Codestücke müssen nicht getestet werden.</p>
<h2 id="zusammenfassung"><a class="header" href="#zusammenfassung">Zusammenfassung</a></h2>
<p>Die Testfunktionalitäten von Rust bieten eine Möglichkeit, zu spezifizieren,
wie der Code funktionieren soll, um sicherzustellen, dass er weiterhin so
funktioniert, wie du es erwartest, auch wenn du Änderungen vornimmst. Modultests prüfen
verschiedene Teile einer Bibliothek separat und können private
Implementierungsdetails testen. Integrationstests prüfen, ob viele Teile der
Bibliothek korrekt zusammenarbeiten, und sie verwenden die öffentliche
Programmierschnittstelle (API) der Bibliothek, um den Code auf die gleiche
Weise zu testen, wie externer Code ihn verwenden wird. Auch wenn das Typsystem
und die Eigentumsregeln von Rust dazu beitragen, einige Fehlerarten zu
verhindern, sind Tests immer noch wichtig, um Logikfehler zu reduzieren, die
damit zu tun haben, wie sich dein Code voraussichtlich verhalten wird.</p>
<p>Lass uns das Wissen, das du in diesem und in den vorhergehenden Kapiteln
gelernt hast, für die Arbeit an einem Projekt einsetzen!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-02-running-tests.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-00-an-io-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-02-running-tests.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-00-an-io-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
