<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Funktionen - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="funktionen"><a class="header" href="#funktionen">Funktionen</a></h2>
<p>Funktionen sind im Rust-Code weit verbreitet. Du hast bereits eine der
wichtigsten Funktionen in der Sprache gesehen: Die Funktion <code>main</code>, die der
Einstiegspunkt vieler Programme ist. Du hast auch das Schlüsselwort <code>fn</code>
gesehen, mit dem du neue Funktionen deklarieren kannst.</p>
<p>Rust-Code verwendet die <em>Schlangenschrift</em>-Stil-Konvention (snake case) für
Funktions- und Variablennamen, bei der alle Buchstaben klein geschrieben sind
und Unterstriche Wörter separieren. Hier ist ein Programm, das eine
Beispiel-Funktionsdefinition enthält:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    println!("Hallo Welt!");

    another_function();
}

fn another_function() {
    println!("Eine andere Funktion.");
}</code></pre></pre>
<p>Wir definieren eine Funktion in Rust durch die Eingabe von <code>fn</code>, gefolgt von
einem Funktionsnamen und einem Satz Klammern. Die geschweiften Klammern teilen
dem Compiler mit, wo der Funktionsrumpf beginnt und endet.</p>
<p>Wir können jede Funktion, die wir definiert haben, aufrufen, indem wir ihren
Namen gefolgt von einem Satz Klammern eingeben. Da <code>another_function</code> im
Programm definiert ist, kann sie von innerhalb der Funktion <code>main</code> aufgerufen
werden. Beachte, dass wir <code>another_function</code> <em>nach</em> der Funktion <code>main</code> im
Quellcode definiert haben; wir hätten sie auch vorher definieren können. Rust
interessiert es nicht, wo du deine Funktionen definierst, nur dass sie irgendwo
definiert sind.</p>
<p>Lass uns ein neues Binärprojekt namens „functions“ anfangen, um Funktionen
weiter zu erforschen. Platziere das Beispiel <code>another_function</code> in
<em>src/main.rs</em> und lass es laufen. Du solltest die folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hallo Welt!
Eine andere Funktion.
</code></pre>
<p>Die Zeilen werden in der Reihenfolge ausgeführt, in der sie in der Funktion
<code>main</code> erscheinen. Zuerst wird die Nachricht „Hallo Welt!“ ausgegeben und dann
wird <code>another_function</code> aufgerufen und ihre Nachricht ausgegeben.</p>
<h3 id="parameter"><a class="header" href="#parameter">Parameter</a></h3>
<p>Wir können Funktionen auch so definieren, dass sie <em>Parameter</em> haben, das
sind spezielle Variablen, die Teil der Funktionssignatur sind. Wenn eine
Funktion Parameter hat, kannst du sie mit konkreten Werten für diese Parameter
versehen. Technisch gesehen werden die konkreten Werte <em>Argumente</em> genannt,
aber in lockeren Gesprächen neigen Leute dazu, die Worte <em>Parameter</em> und
<em>Argument</em> entweder für die Variablen in der Definition einer Funktion oder für
die konkreten Werte, die beim Aufruf einer Funktion übergeben werden,
synonym zu verwenden.</p>
<p>In dieser Version von <code>another_function</code> fügen wir einen Parameter hinzu:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("Der Wert von x ist: {x}");
}</code></pre></pre>
<p>Versuche, dieses Programm auszuführen; du solltest die folgende Ausgabe
erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
Der Wert von x ist: 5
</code></pre>
<p>Die Deklaration <code>another_function</code> hat einen Parameter namens <code>x</code>. Der Typ von
<code>x</code> wird als <code>i32</code> angegeben. Wenn wir <code>5</code> an <code>another_function</code> übergeben,
setzt das Makro <code>println!</code> den Wert <code>5</code> an die Stelle, an der sich das Paar
geschweifter Klammern mit dem <code>x</code> darin in der Formatierungszeichenkette
befand.</p>
<p>In Funktionssignaturen <em>musst</em> du den Typ jedes Parameters deklarieren. Dies
ist eine bewusste Designentscheidung von Rust: Das Erfordernis von
Typ-Annotationen in Funktionsdefinitionen bedeutet, dass der Compiler sie
fast nie an anderer Stelle im Code benötigt, um herauszufinden, welchen Typ du
meinst. Der Compiler ist auch in der Lage, hilfreichere Fehlermeldungen zu
geben, wenn er weiß, welche Typen die Funktion erwartet.</p>
<p>Wenn wir mehrere Parameter definieren, trennen wir die Parameterdeklarationen
mit Kommas, so wie hier:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("Das Maß ist: {value}{unit_label}");
}</code></pre></pre>
<p>Dieses Beispiel erzeugt eine Funktion namens <code>print_labeled_measurement</code> mit
zwei Parametern. Der erste Parameter heißt <code>value</code> und ist ein <code>i32</code>. Der
zweite heißt <code>unit_label</code> und ist vom Typ <code>char</code>. Die Funktion gibt dann einen
Text aus, der sowohl <code>value</code> als auch <code>unit_label</code> enthält.</p>
<p>Lass uns versuchen, diesen Code auszuführen. Ersetze das Programm, das sich
derzeit in der Datei <em>src/main.rs</em> deines „functions“-Projekts befindet, durch
das vorhergehende Beispiel und führe es mit <code>cargo run</code> aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
Das Maß ist: 5h
</code></pre>
<p>Da wir die Funktion mit <code>5</code> als Wert für <code>value</code> und <code>'h'</code> als Wert für
<code>unit_label</code> aufgerufen haben, enthält die Programmausgabe diese Werte.</p>
<h4 id="anweisungen-und-ausdrücke"><a class="header" href="#anweisungen-und-ausdrücke">Anweisungen und Ausdrücke</a></h4>
<p>Funktionsrümpfe bestehen aus einer Reihe von Anweisungen, die optional mit
einem Ausdruck enden können. Bisher haben wir nur Funktionen ohne einen
endenden Ausdruck behandelt, aber du hast einen Ausdruck als Teil einer
Anweisung gesehen. Da Rust eine auf Ausdrücken basierende Sprache ist, ist dies
eine wichtige Unterscheidung, die es zu verstehen gilt. Andere Sprachen haben
nicht dieselben Unterscheidungen, deshalb wollen wir uns ansehen, was
Anweisungen und Ausdrücke sind und wie sich ihre Unterschiede auf die
Funktionsrümpfe auswirken.</p>
<ul>
<li><strong>Anweisungen</strong> (statements) sind Instruktionen, die eine Aktion ausführen
und keinen Wert zurückgeben.</li>
<li><strong>Ausdrücke</strong> (expressions) werden zu einem Ergebniswert ausgewertet.
Schauen wir uns einige Beispiele an.</li>
</ul>
<p>Eine Variable zu erstellen und ihr mit dem Schlüsselwort <code>let</code> einen Wert
zuzuweisen, ist eine Anweisung. In Codeblock 3-1 ist <code>let y = 6;</code> eine
Anweisung.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let y = 6;
}</code></pre></pre>
<p><span class="caption">Codeblock 3-1: Eine Funktionsdeklaration <code>main</code>, die eine
Anweisung enthält</span></p>
<p>Auch Funktionsdefinitionen sind Anweisungen; das gesamte vorhergehende Beispiel
ist eine Anweisung für sich. (Wie wir weiter unten sehen werden, ist der
<em>Aufruf</em> einer Funktion keine Anweisung.)</p>
<p>Anweisungen geben keine Werte zurück. Daher kannst du keine <code>let</code>-Anweisung
einer anderen Variablen zuweisen, wie es der folgende Code versucht; du wirst
einen Fehler erhalten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let x = (let y = 6);
}</code></pre></pre>
<p>Wenn du dieses Programm ausführst, wirst du in etwa folgenden Fehler erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` (bin "functions") due to 1 previous error; 1 warning emitted
</code></pre>
<p>Die Anweisung <code>let y = 6</code> gibt keinen Wert zurück, also gibt es für <code>x</code> nichts,
woran <code>x</code> gebunden werden kann. Dies unterscheidet sich von dem, was in anderen
Sprachen wie C und Ruby geschieht, wo die Zuweisung den Wert der Zuweisung
zurückgibt. In diesen Sprachen kannst du <code>x = y = 6</code> schreiben und sowohl <code>x</code>
als auch <code>y</code> haben den Wert <code>6</code>; das ist in Rust nicht der Fall.</p>
<p>Ausdrücke werten zu einem Wert aus und machen den größten Teil des restlichen
Codes aus, den du in Rust schreiben wirst. Betrachte eine mathematische
Operation, z.B. <code>5 + 6</code>, die ein Ausdruck ist, der zum Wert <code>11</code> ausgewertet
wird. Ausdrücke können Teil von Anweisungen sein: In Codeblock 3-1 ist die <code>6</code>
in der Anweisung <code>let y = 6;</code> ein Ausdruck, der den Wert <code>6</code> ergibt. Der Aufruf
einer Funktion ist ein Ausdruck. Der Aufruf eines Makros ist ein Ausdruck. Ein
neuer Gültigkeitsbereichsblock, der mit geschweiften Klammern erstellt wird,
ist ein Ausdruck, zum Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("Der Wert von y ist: {y}");
}</code></pre></pre>
<p>Der Ausdruck</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>ist ein Block, der in diesem Fall zu <code>4</code> ausgewertet wird. Dieser Wert wird als
Teil der <code>let</code>-Anweisung an <code>y</code> gebunden. Beachte, dass die Zeile <code>x + 1</code> am
Ende kein Semikolon hat, was sich von den meisten Zeilen, die du bisher gesehen
hast, unterscheidet. Ausdrücke enthalten keine abschließenden Semikolons. Wenn
du ein Semikolon an das Ende eines Ausdrucks anfügst, machst du daraus eine
Anweisung, und sie gibt keinen Wert zurück.  Behalte dies im Hinterkopf, wenn
du als nächstes die Rückgabewerte von Funktionen und Ausdrücken untersuchst.</p>
<h3 id="funktionen-mit-rückgabewerten"><a class="header" href="#funktionen-mit-rückgabewerten">Funktionen mit Rückgabewerten</a></h3>
<p>Funktionen können Werte an den Code zurückgeben, der sie aufruft. Wir benennen
keine Rückgabewerte, aber wir müssen ihren Typ nach einem Pfeil (<code>-&gt;</code>)
deklarieren. In Rust ist der Rückgabewert der Funktion gleichbedeutend mit dem
Wert des letzten Ausdrucks im Block des Funktionsrumpfs. Du kannst frühzeitig
von einer Funktion zurückkehren, indem du das Schlüsselwort <code>return</code> verwendest
und einen Wert angibst, aber die meisten Funktionen geben den letzten Ausdruck
implizit zurück. Hier ist ein Beispiel für eine Funktion, die einen Wert
zurückgibt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("Der Wert von x ist: {x}");
}</code></pre></pre>
<p>Es gibt keine Funktionsaufrufe, Makros oder gar <code>let</code>-Anweisungen in der
Funktion <code>five</code> – nur die Zahl <code>5</code> selbst. Das ist eine vollkommen
gültige Funktion in Rust. Beachte, dass der Rückgabetyp der Funktion ebenfalls
angegeben ist, mit <code>-&gt; i32</code>. Versuche diesen Code auszuführen; die Ausgabe
sollte wie folgt aussehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
Der Wert von x ist: 5
</code></pre>
<p>Die <code>5</code> in <code>five</code> ist der Rückgabewert der Funktion, weshalb der Rückgabetyp
<code>i32</code> ist. Lass uns dies genauer untersuchen. Es gibt zwei wichtige Teile:
Erstens zeigt die Zeile <code>let x = five();</code>, dass wir den Rückgabewert einer
Funktion verwenden, um eine Variable zu initialisieren. Da die Funktion <code>five</code>
den Wert <code>5</code> zurückgibt, ist diese Zeile die gleiche wie die folgende:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Zweitens hat die Funktion <code>five</code> keine Parameter und definiert den Typ des
Rückgabewertes, aber der Funktionsrumpf ist eine einsame <code>5</code> ohne Semikolon,
weil es ein Ausdruck ist, dessen Wert wir zurückgeben wollen.</p>
<p>Sehen wir uns ein weiteres Beispiel an:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = plus_one(5);

    println!("Der Wert von x ist: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre></pre>
<p>Beim Ausführen dieses Codes wird <code>Der Wert von x ist: 6</code> ausgegeben. Wenn wir
aber ein Semikolon an das Ende der Zeile mit <code>x + 1</code> setzen und es von einem
Ausdruck in eine Anweisung ändern, erhalten wir einen Fehler:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">fn main() {
    let x = plus_one(5);

    println!("Der Wert von x ist: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}</code></pre></pre>
<p>Das Kompilieren dieses Codes führt zum folgenden Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin "functions") due to 1 previous error
</code></pre>
<p>Die Hauptfehlermeldung <code>mismatched types</code> offenbart das Kernproblem dieses
Codes. Die Definition der Funktion <code>plus_one</code> besagt, dass sie ein <code>i32</code>
zurückgibt, aber Anweisungen werden nicht zu einem Wert ausgewertet, was durch
den Einheitstyp <code>()</code> ausgedrückt wird. Daher wird nichts zurückgegeben, was der
Funktionsdefinition widerspricht und zu einem Fehler führt. In dieser Ausgabe
gibt Rust eine Meldung aus, die möglicherweise helfen kann, dieses Problem zu
beheben: Es wird vorgeschlagen, das Semikolon zu entfernen, was den Fehler
beheben würde.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-02-data-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-04-comments.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-02-data-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-04-comments.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
