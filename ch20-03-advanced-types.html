<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fortgeschrittene Typen - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="fortgeschrittene-typen"><a class="header" href="#fortgeschrittene-typen">Fortgeschrittene Typen</a></h2>
<p>Das Rust-Typsystem weist einige Funktionalitäten auf, die wir bisher erwähnt,
aber noch nicht besprochen haben. Wir beginnen mit einer allgemeinen Diskussion
über Newtypes, während wir untersuchen, warum Newtypes als Typen nützlich sind.
Dann gehen wir zu Typ-Alias über, einer Funktionalität, die den Newtypes
ähnlich ist, aber eine etwas andere Semantik hat. Wir werden auch den Typ <code>!</code>
und dynamisch große Typen besprechen.</p>
<h3 id="verwenden-des-newtype-musters-für-typsicherheit-und-abstraktion"><a class="header" href="#verwenden-des-newtype-musters-für-typsicherheit-und-abstraktion">Verwenden des Newtype-Musters für Typsicherheit und Abstraktion</a></h3>
<p>Der nächste Abschnitt geht davon aus, dass du den früheren Abschnitt
<a href="ch20-02-advanced-traits.html#verwenden-des-newtype-musters-zum-implementieren-von-externen-merkmalen-auf-externen-typen">„Verwenden des Newtype-Musters zum Implementieren von externen Merkmalen auf
externen Typen“</a> gelesen hast. Das Newtype-Muster
ist auch für Aufgaben nützlich, die über die bisher besprochenen hinausgehen,
einschließlich statisch sicherzustellen, dass Werte niemals verwechselt werden,
und dem Angeben von Einheiten eines Wertes. Ein Beispiel für die Verwendung von
Newtypes zum Angeben von Einheiten hast du in Codeblock 20-16 gesehen: Erinnere
dich daran, dass die Strukturen <code>Millimeters</code> und <code>Meters</code> <code>u32</code>-Werte in einem
Newtype einpacken. Wenn wir eine Funktion mit einem Parameter vom Typ
<code>Millimeters</code> schreiben würden, könnten wir kein Programm kompilieren, das
versehentlich versucht, diese Funktion mit einem Wert vom Typ <code>Meters</code> oder
einem einfachen <code>u32</code> aufzurufen.</p>
<p>Wir können auch das Newtype-Muster verwenden, um einige Implementierungsdetails
eines Typs zu abstrahieren: Der neue Typ kann eine öffentliche API
bereitstellen, die sich von der API des privaten, inneren Typs unterscheidet.</p>
<p>Newtypes können auch die interne Implementierung verbergen. Zum Beispiel
könnten wir einen Typ <code>People</code> zur Verfügung stellen, um eine <code>HashMap&lt;i32, String&gt;</code> einzupacken, die die ID einer Person in Verbindung mit ihrem Namen
speichert. Code, der <code>People</code> verwendet, würde nur mit der öffentlichen API
interagieren, die wir zur Verfügung stellen, z.B. eine Methode, um eine
Namenszeichenkette zur <code>People</code>-Kollektion hinzuzufügen; dieser Code müsste
nicht wissen, dass wir Namen intern eine <code>i32</code>-ID zuordnen. Das Newtype-Muster
ist ein leichtgewichtiger Weg, eine Kapselung zu erreichen, um
Implementierungsdetails zu verbergen, die wir in <a href="ch18-01-what-is-oo.html#kapselung-die-implementierungsdetails-verbirgt">„Kapselung, die
Implementierungsdetails verbirgt“</a> in Kapitel 18 besprochen
haben.</p>
<h3 id="erstellen-von-typ-synonymen-mit-typ-alias"><a class="header" href="#erstellen-von-typ-synonymen-mit-typ-alias">Erstellen von Typ-Synonymen mit Typ-Alias</a></h3>
<p>Rust bietet die Möglichkeit, einen <em>Typ-Alias</em> zu deklarieren, um einem
vorhandenen Typ einen anderen Namen zu geben. Hierfür verwenden wir das
Schlüsselwort <code>type</code>. Zum Beispiel können wir den Alias <code>Kilometers</code> für <code>i32</code>
so anlegen:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>Der Alias <code>Kilometers</code> ist ein <em>Synonym</em> für <code>i32</code>; im Gegensatz zu den Typen
<code>Millimeters</code> und <code>Meters</code>, die wir in Codeblock 20-16 erstellt haben, ist
<code>Kilometers</code> kein separater, neuer Typ. Werte, die den Typ <code>Kilometers</code> haben,
werden genauso behandelt wie Werte des Typs <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre></pre>
<p>Da <code>Kilometers</code> und <code>i32</code> vom gleichen Typ sind, können wir Werte beider Typen
addieren und wir können <code>Kilometers</code>-Werte an Funktionen übergeben, die
<code>i32</code>-Parameter verwenden. Mit dieser Methode erhalten wir jedoch nicht die
Vorteile der Typprüfung, die wir vom zuvor besprochenen Newtype-Muster haben.
Mit anderen Worten, wenn wir irgendwo <code>Kilometers</code>- und <code>i32</code>-Werte
verwechseln, wird uns der Compiler keinen Fehler anzeigen.</p>
<p>Der Hauptanwendungsfall für Typ-Synonyme ist das Reduzieren von Wiederholungen.
Zum Beispiel könnten wir einen längeren Typ wie diesen haben:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>Das Schreiben dieses langen Typs in Funktionssignaturen und als
Typ-Annotationen im gesamten Code kann ermüdend und fehleranfällig sein. Stelle
dir vor, du hättest ein Projekt voller Code wie das in Codeblock 20-25.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("hallo"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --abschneiden--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --abschneiden--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-25: Verwenden eines langen Typs an vielen
Stellen</span></p>
<p>Ein Typ-Alias macht diesen Code leichter handhabbar, indem er die Wiederholung
reduziert. In Codeblock 20-26 haben wir einen Alias namens <code>Thunk</code> für den
verbosen Typ eingeführt und können alle Verwendungen des Typs durch den
kürzeren Alias <code>Thunk</code> ersetzen.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("hallo"));

    fn takes_long_type(f: Thunk) {
        // --abschneiden--
    }

    fn returns_long_type() -&gt; Thunk {
        // --abschneiden--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-26: Einführen eines Typ-Alias <code>Thunk</code> zur
Reduzierung von Wiederholungen</span></p>
<p>Dieser Code ist viel einfacher zu lesen und zu schreiben! Die Wahl eines
aussagekräftigen Namens für einen Typ-Alias kann auch helfen, deine Absicht zu
kommunizieren (<em>thunk</em> ist ein Wort für Code, der zu einem späteren Zeitpunkt
ausgewertet wird, also ein passender Name für einen Funktionsabschluss
(closure), der gespeichert wird).</p>
<p>Typ-Alias werden auch häufig mit dem Typ <code>Result&lt;T, E&gt;</code> verwendet, um
Wiederholungen zu reduzieren. Betrachte das Modul <code>std::io</code> in der
Standardbibliothek. E/A-Operationen geben oft ein <code>Result&lt;T, E&gt;</code> zurück, um
Situationen zu behandeln, in denen Operationen nicht funktionieren. Diese
Bibliothek hat eine Struktur <code>std::io::Error</code>, die alle möglichen E/A-Fehler
repräsentiert. Viele der Funktionen in <code>std::io</code> geben <code>Result&lt;T, E&gt;</code> zurück,
wobei für <code>E</code> der Typ <code>std::io::Error</code> verwendet wird, so wie bei diesen
Funktionen im Merkmal (trait) <code>Write</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>Result&lt;..., Error&gt;</code> wird oft wiederholt. Daher hat <code>std::io</code> diese Art von
Alias-Deklaration:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>Da sich diese Deklaration im Modul <code>std::io</code> befindet, können wir den
vollständig qualifizierten Alias <code>std::io::Result&lt;T&gt;</code> verwenden; das ist
ein <code>Result&lt;T, E&gt;</code> mit <code>E</code> als <code>std::io::Error</code>. Die Funktionssignaturen des
Merkmals <code>Write</code> sehen am Ende so aus:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>Der Typ-Alias hilft in zweierlei Hinsicht: Er macht es einfacher, Code zu
schreiben <em>und</em> er gibt uns eine konsistente Schnittstelle innerhalb <code>std::io</code>.
Weil es ein Alias ist, ist es nur ein weiteres <code>Result&lt;T, E&gt;</code>, was bedeutet,
dass wir alle Methoden, die mit <code>Result&lt;T, E&gt;</code> funktionieren, mit ihm verwenden
können, einschließlich spezieller Syntax wie der <code>?</code>-Operator.</p>
<h3 id="der-niemals-typ-der-niemals-zurückkehrt"><a class="header" href="#der-niemals-typ-der-niemals-zurückkehrt">Der Niemals-Typ, der niemals zurückkehrt</a></h3>
<p>Rust hat einen speziellen Typ namens <code>!</code>, der im Fachjargon der Typtheorie als
<em>leerer Typ</em> (empty type) bekannt ist, weil er keine Werte hat. Wir ziehen es
vor, ihn den <em>Niemals-Typ</em> (never type) zu nennen, weil er an der Stelle des
Rückgabetyps steht, wenn eine Funktion niemals zurückkehrt. Hier ist ein
Beispiel:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --abschneiden--
<span class="boring">    panic!();
</span>}</code></pre>
<p>Dieser Code wird als „die Funktion <code>bar</code> kehrt niemals zurück“ gelesen.
Funktionen, die niemals zurückkehren, werden <em>divergierende Funktionen</em>
(diverging functions) genannt. Wir können keine Werte vom Typ <code>!</code> erzeugen,
also kann <code>bar</code> niemals zurückkehren.</p>
<p>Aber was nützt ein Typ, für den man nie Werte erzeugen kann? Erinnere dich an
den Code aus Codeblock 2-5, der Teil des Zahlenratespiels ist; wir haben einen
Teil davon hier in Codeblock 20-27 wiedergegeben.</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Rate die Zahl!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!("Die Geheimzahl ist: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Bitte gib deine Schätzung ein.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --abschneiden--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Fehler beim Lesen der Zeile");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("Du hast geschätzt: {guess}");
</span><span class="boring">
</span><span class="boring">        // --abschneiden--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Zu klein!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Zu groß!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("Du hast gewonnen!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 20-27: Ein <code>match</code> mit einem Zweig, der in
<code>continue</code> endet</span></p>
<p>Damals haben wir einige Details in diesem Code übersprungen. In <a href="ch06-02-match.html">„Das
Kontrollflusskonstrukt <code>match</code>“</a> in Kapitel 6 haben wir
erwähnt, dass alle Zweige den gleichen Typ zurückgeben müssen. So funktioniert
zum Beispiel der folgende Code nicht:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hallo",
    };
<span class="boring">}</span></code></pre></pre>
<p>Der Typ von <code>guess</code> in diesem Code müsste eine ganze Zahl <em>und</em> eine
Zeichenkette sein und Rust verlangt, dass <code>guess</code> nur einen Typ hat. Was gibt
also <code>continue</code> zurück? Wie war es uns erlaubt, ein <code>u32</code> von einem Zweig
zurückzugeben und einen anderen Zweig zu haben, der in Codeblock 20-26 mit
<code>continue</code> endet?</p>
<p>Wie du vielleicht schon vermutet hast, hat <code>continue</code> einen <code>!</code>-Wert. Das
heißt, wenn Rust den Typ von <code>guess</code> berechnet, betrachtet es beide
<code>match</code>-Zweige, den ersten mit einem Wert von <code>u32</code> und den zweiten mit einem
<code>!</code>-Wert. Da <code>!</code> niemals einen Wert haben kann, entscheidet Rust, dass <code>guess</code>
den Typ <code>u32</code> hat.</p>
<p>Der formale Weg, dieses Verhalten zu beschreiben, besteht darin, dass Ausdrücke
vom Typ <code>!</code> in jeden anderen Typ umgewandelt werden können. Es ist uns erlaubt,
diesen <code>match</code>-Zweig mit <code>continue</code> zu beenden, weil <code>continue</code> keinen Wert
zurückgibt; stattdessen bringt es die Kontrolle zurück an den Anfang der
Schleife, sodass wir im <code>Err</code>-Fall <code>guess</code> niemals einen Wert zuweisen.</p>
<p>Der Niemals-Typ ist auch beim Makro <code>panic!</code> nützlich. Erinnere dich an die
Funktion <code>unwrap</code>, die wir auf <code>Option&lt;T&gt;</code> Werte aufrufen, um einen Wert zu
erzeugen oder das Programm abstürzen zu lassen. Hier ist ihre Definition:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!("Aufruf von `Option::unwrap()` auf einem `None`-Wert"),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In diesem Code geschieht dasselbe wie bei <code>match</code> in Codeblock 20-27: Rust
sieht, dass <code>val</code> den Typ <code>T</code> und <code>panic!</code> den Typ <code>!</code> hat, sodass das Ergebnis
des gesamten <code>match</code>-Ausdrucks <code>T</code> ist. Dieser Code funktioniert, weil <code>panic!</code>
keinen Wert produziert; es beendet das Programm. Im Fall von <code>None</code> geben wir
keinen Wert von <code>unwrap</code> zurück, also ist dieser Code gültig.</p>
<p>Ein letzter Ausdruck, der den Typ <code>!</code> hat, ist <code>loop</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    print!("für immer ");

    loop {
        print!("und ewig ");
    }
<span class="boring">}</span></code></pre></pre>
<p>Hier endet die Schleife nie, also ist <code>!</code> der Typ des Ausdrucks. Dies wäre
jedoch nicht der Fall, wenn wir <code>break</code> einfügen würden, da die Schleife enden
würde, wenn sie bei <code>break</code> ankommt.</p>
<h3 id="dynamisch-große-typen-und-das-merkmal-sized"><a class="header" href="#dynamisch-große-typen-und-das-merkmal-sized">Dynamisch große Typen und das Merkmal <code>Sized</code></a></h3>
<p>Rusts muss bestimmte Details über seine Typen kennen, z.B. wie viel Platz für
einen Wert eines bestimmten Typs zuzuweisen ist. Das lässt eine Ecke des
Typsystems zunächst etwas verwirrend erscheinen: Das Konzept der <em>dynamisch
großen Typen</em> (dynamically sized types). Diese Typen, die manchmal als <em>DSTs</em>
oder <em>Typen ohne Größe</em> (unsized types) bezeichnet werden, erlauben es uns,
Code mit Werten zu schreiben, deren Größe wir nur zur Laufzeit kennen können.</p>
<p>Schauen wir uns die Details eines dynamisch großen Typs namens <code>str</code> an, den
wir im ganzen Buch verwendet haben. Das stimmt, nicht <code>&amp;str</code>, sondern <code>str</code> an
sich ist ein DST. Wir können nicht wissen, wie lang die Zeichenkette zur
Laufzeit ist, d.h. wir können weder eine Variable vom Typ <code>str</code> erzeugen, noch
können wir ein Argument vom Typ <code>str</code> nehmen. Betrachte den folgenden Code, der
nicht funktioniert:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s1: str = "Guten Tag!";
    let s2: str = "Wie geht es dir?";

<span class="boring">}</span></code></pre></pre>
<p>Rust muss wissen, wie viel Speicher jedem Wert eines bestimmten Typs zuzuweisen
ist, und alle Werte eines Typs müssen die gleiche Speichermenge verwenden. Wenn
Rust uns erlauben würde, diesen Code zu schreiben, müssten diese beiden
<code>str</code>-Werte die gleiche Speichermenge beanspruchen. Aber sie haben
unterschiedliche Längen: <code>s1</code> benötigt 10 Bytes Speicherplatz und <code>s2</code> 16
Bytes. Aus diesem Grund ist es nicht möglich, eine Variable zu erzeugen, die
einen dynamisch großen Typ enthält.</p>
<p>Was sollen wir also tun? In diesem Fall kennst du die Antwort bereits: Wir
machen die Typen <code>s1</code> und <code>s2</code> zu einem <code>&amp;str</code> anstatt zu einem <code>str</code>. Erinnere
dich, dass wir in <a href="ch04-03-slices.html#zeichenkettenanteilstypen-string-slices">„Zeichenkettenanteilstypen (string slices)“</a>
in Kapitel 4 gesagt haben, dass die Anteilstypen-Datenstruktur die
Startposition und die Länge des Anteilstyps speichert. Obwohl also <code>&amp;T</code> ein
einzelner Wert ist, der die Speicheradresse des Ortes speichert, an dem sich
<code>T</code> befindet, hat <code>&amp;str</code> <em>zwei</em> Werte: Die Adresse von <code>str</code> und seine Länge.
Als solches können wir die Größe eines <code>&amp;str</code>-Wertes zur Kompilierzeit kennen:
Er ist doppelt so lang wie ein <code>usize</code>. Das heißt, wir wissen immer die Größe
einer <code>&amp;str</code>, egal wie lang die Zeichenkette ist, auf die sie sich bezieht. Im
Allgemeinen werden in Rust Typen mit dynamischer Größe auf diese Weise
verwendet: Sie haben ein zusätzliches Stück Metadaten, das die Größe der
dynamischen Information speichert. Die goldene Regel für Typen dynamischer
Größe lautet, dass wir Werte von Typen mit dynamischer Größe immer hinter eine
Art Zeiger stellen müssen.</p>
<p>Wir können <code>str</code> mit allen Arten von Zeigern kombinieren: Zum Beispiel
<code>Box&lt;str&gt;</code> oder <code>Rc&lt;str&gt;</code>. Tatsächlich hast du das schon einmal gesehen, aber
mit einem anderen dynamisch großen Typ: Merkmale (traits). Jedes Merkmal ist
ein dynamisch großer Typ, auf den wir uns beziehen können, indem wir den Namen
des Merkmals verwenden. In <a href="ch18-02-trait-objects.html">„Merkmalsobjekte (trait objects) die Werte
unterschiedlicher Typen erlauben“</a> in Kapitel 18 haben wir
erwähnt, dass wir, um Merkmale als Merkmalsobjekte zu verwenden, diese hinter
einen Zeiger setzen müssen, z.B. <code>&amp;dyn Trait</code> oder <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> würde auch funktionieren).</p>
<p>Um mit DSTs zu arbeiten, hat Rust das Merkmal <code>Sized</code>, um zu bestimmen, ob die
Größe eines Typs zur Kompilierzeit bekannt ist oder nicht. Dieses Merkmal wird
automatisch für alles implementiert, dessen Größe zur Kompilierzeit bekannt
ist. Zusätzlich fügt Rust implizit jeder generischen Funktion eine
Merkmalsabgrenzung auf <code>Sized</code> hinzu. Das heißt, eine generische
Funktionsdefinition wie diese:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T&gt;(t: T) {
    // --abschneiden--
}
<span class="boring">}</span></code></pre></pre>
<p>wird tatsächlich so behandelt, als hätten wir das geschrieben:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: Sized&gt;(t: T) {
    // --abschneiden--
}
<span class="boring">}</span></code></pre></pre>
<p>Standardmäßig funktionieren generische Funktionen nur bei Typen, die zur
Kompilierzeit eine bekannte Größe haben. Du kannst jedoch die folgende
spezielle Syntax verwenden, um diese Einschränkung zu lockern:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --abschneiden--
}
<span class="boring">}</span></code></pre></pre>
<p>Eine Merkmalsabgrenzung durch <code>?Sized</code> bedeutet „<code>T</code> kann <code>Sized</code> sein oder
nicht“ und diese Notation hebt die Vorgabe auf, dass generische Typen zur
Kompilierzeit eine bekannte Größe haben müssen. Die Syntax <code>?Trait</code> mit dieser
Bedeutung ist nur für <code>Sized</code> verfügbar, nicht für andere Merkmale.</p>
<p>Beachte auch, dass wir den Typ des Parameters <code>t</code> von <code>T</code> auf <code>&amp;T</code> geändert
haben. Da der Typ möglicherweise nicht <code>Sized</code> ist, müssen wir ihn hinter einer
Art Zeiger verwenden. In diesem Fall haben wir eine Referenz gewählt.</p>
<p>Als nächstes werden wir über Funktionen und Funktionsabschlüsse sprechen!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-02-advanced-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-04-advanced-functions-and-closures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-02-advanced-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-04-advanced-functions-and-closures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
