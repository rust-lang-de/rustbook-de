<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Anwenden von Nebenläufigkeit mit async - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="anwenden-von-nebenläufigkeit-mit-async"><a class="header" href="#anwenden-von-nebenläufigkeit-mit-async">Anwenden von Nebenläufigkeit mit async</a></h2>
<p>In diesem Abschnitt werden wir async auf einige Nebenläufigkeitsprobleme
anwenden, die wir in Kapitel 16 mit Strängen (threads) angegangen sind. Da wir
dort bereits über viele Schlüsselideen gesprochen haben, werden wir uns in
diesem Abschnitt auf die Unterschiede zwischen Strängen und Futures
konzentrieren.</p>
<p>In vielen Fällen sind die APIs für den Umgang mit Nebenläufigkeit mittels async
sehr ähnlich zu denen mit Strängen. In anderen Fällen sind sie am Ende ganz
anders. Selbst wenn die APIs von Strängen und async <em>ähnlich</em> aussehen, haben
sie oft ein anderes Verhalten und fast immer unterschiedliche
Leistungsmerkmale.</p>
<h3 id="erstellen-einer-neuen-aufgabe-mit-spawn_task"><a class="header" href="#erstellen-einer-neuen-aufgabe-mit-spawn_task">Erstellen einer neuen Aufgabe mit <code>spawn_task</code></a></h3>
<p>Die erste Operation, die wir in <a href="ch16-01-threads.html#erstellen-eines-neuen-strangs-mit-spawn">„Erstellen eines neuen Strangs mit
<code>spawn</code>“</a> in Angriff genommen haben, war das Hochzählen in zwei
separaten Strängen. Lass uns das Gleiche mit async machen. Die Kiste <code>trpl</code>
enthält eine Funktion <code>spawn_task</code>, die der API <code>thread::spawn</code> sehr ähnlich
ist, und eine Funktion <code>sleep</code>, die eine async-Version der API <code>thread::sleep</code>
ist. Wir können diese zusammen verwenden, um das Zählbeispiel zu
implementieren, siehe Codeblock 17-6.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span>use std::time::Duration;

fn main() {
    trpl::run(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("Hallo Nummer {i} von der ersten Aufgabe!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("Hallo Nummer {i} von der zweiten Aufgabe!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre></pre>
<p><span class="caption">Codeblock 17-6: Erstellen einer neuen Aufgabe, die etwas
ausgibt, während die Hauptaufgabe etwas anderes ausgibt</span></p>
<p>Als Ausgangspunkt rufen wir in unserer Funktion <code>main</code> <code>trpl::run</code> auf, sodass
unsere Top-Level-Funktion asynchron sein kann.</p>
<blockquote>
<p>Hinweis: Im weiteren Verlauf dieses Kapitels wird jedes Beispiel genau den
gleichen Rahmen-Code mit <code>trpl::run</code> in <code>main</code> enthalten, also werden wir ihn
oft auslassen, genau wie wir es mit <code>main</code> tun. Vergiss nicht, ihn in
deinem Code einzubauen!</p>
</blockquote>
<p>Dann schreiben wir zwei Schleifen innerhalb dieses Blocks, jede mit einem
<code>trpl::sleep</code>-Aufruf, der eine halbe Sekunde (500 Millisekunden) wartet, bevor
die nächste Nachricht gesendet wird. Wir platzieren die eine Schleife in den
Rumpf des <code>trpl::spawn_task</code>-Aufrufs und die andere in eine <code>for</code>-Schleife auf
oberster Ebene. Wir fügen auch ein <code>await</code> nach den <code>sleep</code>-Aufrufen ein.</p>
<p>Dieser Code funktioniert ähnlich wie die Strang-basierte Implementierung
– einschließlich der Tatsache, dass die Meldungen in deinem Terminal in
einer anderen Reihenfolge erscheinen, wenn du es ausführst:</p>
<pre><code class="language-text">Hallo Nummer 1 von der zweiten Aufgabe!
Hallo Nummer 1 von der ersten Aufgabe!
Hallo Nummer 2 von der ersten Aufgabe!
Hallo Nummer 2 von der zweiten Aufgabe!
Hallo Nummer 3 von der ersten Aufgabe!
Hallo Nummer 3 von der zweiten Aufgabe!
Hallo Nummer 4 von der ersten Aufgabe!
Hallo Nummer 4 von der zweiten Aufgabe!
Hallo Nummer 5 von der ersten Aufgabe!
</code></pre>
<p>Diese Version beendet sich, sobald die <code>for</code>-Schleife im Rumpf des asynchronen
Blocks beendet ist, da die von <code>spawn_task</code> erzeugte Aufgabe beendet wird, wenn
die Funktion <code>main</code> endet. Wenn du die Aufgabe bis zum Ende ausführen willst,
musst du <code>JoinHandle</code> verwenden, um auf das Ende der ersten Aufgabe zu warten.
Bei Strängen haben wir die Methode <code>join</code> verwendet, um zu „blockieren“, bis
der Strang fertig ist. In Codeblock 17-7 können wir <code>await</code> verwenden, um
dasselbe zu tun, weil <code>JoinHandle</code> selbst ein Future ist. Sein <code>Output</code>-Typ ist
<code>Result</code>, also entpacken wir es ebenfalls, nachdem wir darauf gewartet haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("Hallo Nummer {i} von der ersten Aufgabe!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("Hallo Nummer {i} von der zweiten Aufgabe!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-7: Verwenden von <code>await</code> mit einem
<code>JoinHandle</code>, um eine Aufgabe bis zum Ende auszuführen</span></p>
<p>Diese aktualisierte Version läuft, bis <em>beide</em> Schleifen beendet sind.</p>
<pre><code class="language-text">Hallo Nummer 1 von der zweiten Aufgabe!
Hallo Nummer 1 von der ersten Aufgabe!
Hallo Nummer 2 von der ersten Aufgabe!
Hallo Nummer 2 von der zweiten Aufgabe!
Hallo Nummer 3 von der ersten Aufgabe!
Hallo Nummer 3 von der zweiten Aufgabe!
Hallo Nummer 4 von der ersten Aufgabe!
Hallo Nummer 4 von der zweiten Aufgabe!
Hallo Nummer 5 von der ersten Aufgabe!
Hallo Nummer 6 von der ersten Aufgabe!
Hallo Nummer 7 von der ersten Aufgabe!
Hallo Nummer 8 von der ersten Aufgabe!
Hallo Nummer 9 von der ersten Aufgabe!
</code></pre>
<p>Bisher sieht es so aus, als ob async und Stränge zu den gleichen Ergebnissen
führen, nur mit einer anderen Syntax: Verwenden von <code>await</code> anstelle des
Aufrufs von <code>join</code> auf <code>JoinHandle</code> und Abwarten der <code>sleep</code>-Aufrufe.</p>
<p>Der größere Unterschied ist, dass wir dafür keinen weiteren
Betriebssystem-Strang starten müssen. Tatsächlich brauchen wir hier nicht
einmal eine Aufgabe zu starten. Da asynchrone Blöcke zu anonymen Futures
kompiliert werden, können wir beide Schleifen in einen asynchronen Block packen
und von der Laufzeitumgebung mittels der Funktion <code>trpl::join</code> bis zum Ende
ausführen lassen.</p>
<p>Im Abschnitt <a href="ch16-01-threads.html#warten-auf-das-ende-aller-str%C3%A4nge-mit-join">„Warten auf das Ende aller Stränge mit <code>join</code>“</a>
haben wir gezeigt, wie man die Methode <code>join</code> auf den Typ <code>JoinHandle</code>
anwendet, der beim Aufruf von <code>std::thread::spawn</code> zurückgegeben wird. Die
Funktion <code>trpl::join</code> ist ähnlich, aber für Futures. Wenn du ihr zwei Futures
gibst, erzeugt sie ein neues Future, dessen Ausgabe ein Tupel mit der Ausgabe
der beiden übergebenen Futures ist, sobald <em>beide</em> abgeschlossen sind. In
Codeblock 17-8 verwenden wir also <code>trpl::join</code>, um darauf zu warten, dass
sowohl <code>fut1</code> als auch <code>fut2</code> fertig sind. Wir warten <em>nicht</em> auf <code>fut1</code> und
<code>fut2</code>, sondern auf das neue Future, das von <code>trpl::join</code> erzeugt wurde. Wir
ignorieren die Ausgabe, da es sich nur um ein Tupel mit zwei Einheitswerten
handelt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("Hallo Nummer {i} von der ersten Aufgabe!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("Hallo Nummer {i} von der zweiten Aufgabe!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-8: Verwenden von <code>trpl::join</code>, um auf zwei
anonyme Futures zu warten</span></p>
<p>Wenn wir dies ausführen, sehen wir, dass beide Futures bis zum Ende laufen:</p>
<pre><code class="language-text">Hallo Nummer 1 von der ersten Aufgabe!
Hallo Nummer 1 von der zweiten Aufgabe!
Hallo Nummer 2 von der ersten Aufgabe!
Hallo Nummer 2 von der zweiten Aufgabe!
Hallo Nummer 3 von der ersten Aufgabe!
Hallo Nummer 3 von der zweiten Aufgabe!
Hallo Nummer 4 von der ersten Aufgabe!
Hallo Nummer 4 von der zweiten Aufgabe!
Hallo Nummer 5 von der ersten Aufgabe!
Hallo Nummer 6 von der ersten Aufgabe!
Hallo Nummer 7 von der ersten Aufgabe!
Hallo Nummer 8 von der ersten Aufgabe!
Hallo Nummer 9 von der ersten Aufgabe!
</code></pre>
<p>Nun siehst du jedes Mal genau dieselbe Reihenfolge, was sich sehr von dem
unterscheidet, was wir bei Strängen gesehen haben. Das liegt daran, dass die
Funktion <code>trpl::join</code> <em>fair</em> ist, d.h. sie prüft jedes Future gleich oft,
wechselt zwischen ihnen ab und lässt nie eines vorauslaufen, wenn das andere
bereit ist. Bei Strängen entscheidet das Betriebssystem, welcher Strang geprüft
wird und wie lange er laufen darf. Bei asynchronem Rust entscheidet die
Laufzeitumgebung, welche Aufgabe geprüft werden soll. (In der Praxis sind die
Details komplizierter, weil eine asynchrone Laufzeitumgebung unter der Haube
Betriebssystem-Stränge für die Verwaltung der Nebenläufigkeit verwenden könnte,
sodass das Einhalten der Fairness mehr Aufwand für eine Laufzeitumgebung sein
kann – aber es ist immer noch möglich!) Laufzeitumgebungen müssen nicht
für jede beliebige Operation Fairness garantieren, und sie stellen oft mehrere
APIs bereit, mit denen du wählen kannst, ob du Fairness wünschst oder nicht.</p>
<p>Probiere einige dieser Varianten des Wartens auf das Future aus und sieh, was
sie bewirken:</p>
<ul>
<li>Entferne den asynchronen Block um eine oder beide Schleifen.</li>
<li>Warte auf jeden asynchronen Block sofort nach seiner Definition.</li>
<li>Packe nur die erste Schleife in einen asynchronen Block und warte auf das
resultierende Future nach dem Rumpf der zweiten Schleife.</li>
</ul>
<p>Eine zusätzliche Herausforderung ist es, herauszufinden, wie die Ausgabe in
jedem Fall aussehen wird, <em>bevor</em> du den Code ausführst!</p>
<h3 id="hochzählen-in-zwei-aufgaben-mit-nachrichtenübermittlung"><a class="header" href="#hochzählen-in-zwei-aufgaben-mit-nachrichtenübermittlung">Hochzählen in zwei Aufgaben mit Nachrichtenübermittlung</a></h3>
<p>Auch die gemeinsame Nutzung von Daten zwischen Futures wird uns vertraut sein:
Wir werden wieder die Nachrichtenübermittlung verwenden, diesmal jedoch mit
asynchronen Versionen der Typen und Funktionen. Wir werden einen etwas anderen
Weg einschlagen als in <a href="ch16-02-message-passing.html">„Nachrichtenaustausch zwischen Strängen
(threads)“</a>, um einige der wichtigsten Unterschiede
zwischen Strang-basierter und Future-basierter Nebenläufigkeit zu
veranschaulichen. In Codeblock 17-9 beginnen wir mit einem einzigen asynchronen
Block – <em>ohne</em> eine separate Aufgabe zu erstellen, da wir einen separaten
Strang erstellt haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("Erhalten: {received}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-9: Erstellen eines asynchronen Kanals und
Zuweisen der beiden Enden an <code>tx</code> und <code>rx</code></span></p>
<p>Hier verwenden wir <code>trpl::channel</code>, eine asynchrone Version des Kanals wie mit
Strängen in Kapitel 16. Die asynchrone Version der API unterscheidet sich nur
geringfügig von der Strang-basierten Version: Sie verwendet einen veränderbaren
statt eines unveränderbaren Empfängers <code>rx</code>, und ihre Methode <code>recv</code> erzeugt
ein Future, auf das wir warten müssen, anstatt den Wert direkt zu erzeugen.
Jetzt können wir Nachrichten vom Sender zum Empfänger senden. Beachte, dass wir
keinen separaten Strang oder gar eine Aufgabe erzeugen müssen; wir müssen
lediglich auf den Aufruf von <code>rx.recv</code> warten.</p>
<p>Die synchrone Methode <code>Receiver::recv</code> in <code>std::mpsc::channel</code> blockiert, bis
sie eine Nachricht erhält. Die Methode <code>trpl::Receiver::recv</code> tut dies nicht,
da sie asynchron ist. Anstatt zu blockieren, übergibt sie die Kontrolle zurück
an die Laufzeitumgebung, bis entweder eine Nachricht empfangen wird oder die
Sendeseite des Kanals geschlossen wurde. Im Gegensatz dazu warten wir nicht auf
den <code>send</code>-Aufruf, weil er nicht blockiert. Das ist auch nicht nötig, denn der
Kanal, in den wir die Nachricht senden, ist unlimitiert.</p>
<blockquote>
<p>Anmerkung: Da der gesamte asynchrone Code in einem asynchronen Block in einem
<code>trpl::run</code>-Aufruf läuft, kann alles innerhalb dieses Blocks ein Blockieren
vermeiden. Allerdings wird der Code <em>außerhalb</em> des Blocks blockieren, wenn
die Funktion <code>run</code> zurückkehrt. Das ist der ganze Sinn der Funktion
<code>trpl::run</code>: Sie lässt dich <em>wählen</em>, wo du bei einer Menge von asynchronem
Code blockieren willst, und somit wo du zwischen synchronem und asynchronem
Code wechseln willst. In den meisten asynchronen Laufzeitumgebungen wird
<code>run</code> aus genau diesem Grund <code>block_on</code> genannt.</p>
</blockquote>
<p>Beachte bei diesem Beispiel zwei Dinge. Erstens: Die Nachricht wird sofort
ankommen! Zweitens: Obwohl wir hier ein Future verwenden, gibt es noch keine
Nebenläufigkeit. Alles im Codeblock geschieht der Reihe nach, so wie es auch
geschehen würde, wenn keine Futures beteiligt wären.</p>
<p>Der erste Teil besteht darin, eine Reihe von Nachrichten zu senden und
dazwischen zu schlafen, wie in Codeblock 17-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("Hallo"),
            String::from("aus"),
            String::from("dem"),
            String::from("Future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("Erhalten: '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-10: Senden und Empfangen mehrerer
Nachrichten über den asynchronen Kanal und Schlafen mit einem <code>await</code> zwischen
jeder Nachricht</span></p>
<p>Wir müssen die Nachrichten nicht nur senden, sondern auch empfangen. In diesem
Fall könnten wir das manuell tun, indem wir einfach <code>rx.recv().await</code> viermal
ausführen, weil wir wissen, wie viele Nachrichten ankommen werden. In der
realen Welt werden wir jedoch im Allgemeinen auf eine <em>unbekannte</em> Anzahl von
Nachrichten warten, wir müssen also so lange warten, bis wir feststellen, dass
es keine weiteren Nachrichten mehr gibt.</p>
<p>In Codeblock 16-10 haben wir eine <code>for</code>-Schleife verwendet, um alle Elemente zu
verarbeiten, die von einem synchronen Kanal empfangen wurden. In Rust gibt es
jedoch noch keine Möglichkeit, eine <code>for</code>-Schleife über eine <em>asynchrone</em> Reihe
von Elementen zu schreiben. Stattdessen müssen wir eine neue Schleifenart
verwenden, die wir bisher noch nicht gesehen haben: die <code>while let</code>-Schleife
mit Bedingungen. Dies ist die Schleifenvariante des <code>if let</code>-Konstrukts, das
wir in <a href="ch06-03-if-let.html">„Prägnanter Kontrollfluss mit <code>if let</code> und <code>let else</code>“</a> gesehen
haben. Die Schleife wird so lange ausgeführt, wie das angegebene Muster zum
Wert passt.</p>
<p>Der Aufruf <code>rx.recv</code> erzeugt ein Future, auf das wir warten. Die
Laufzeitumgebung pausiert das Future, bis es bereit ist. Sobald eine Nachricht
eintrifft, wird das Future zu <code>Some(message)</code> aufgelöst, so oft wie eine
Nachricht eintrifft. Wenn der Kanal geschlossen wird, unabhängig davon, ob
<em>irgendwelche</em> Nachrichten eingetroffen sind, wird das Future stattdessen zu
<code>None</code> aufgelöst, um anzuzeigen, dass es keine weiteren Werte gibt und wir
daher mit dem Polling aufhören können, d.h. aufhören zu warten.</p>
<p>Die <code>while let</code>-Schleife fasst all dies zusammen. Wenn das Ergebnis des Aufrufs
von <code>rx.recv().await</code> den Wert <code>Some(message)</code> hat, erhalten wir Zugriff auf
die Nachricht und können sie im Schleifenrumpf verwenden, genauso wie wir es
mit <code>if let</code> könnten. Wenn das Ergebnis <code>None</code> ist, endet die Schleife. Jedes
Mal, wenn die Schleife durchlaufen wird, trifft sie erneut auf den await-Punkt,
sodass die Laufzeitumgebung die Schleife erneut unterbricht, bis eine weitere
Nachricht eintrifft.</p>
<p>Der Code sendet und empfängt nun erfolgreich alle Nachrichten. Leider gibt es
immer noch ein paar Probleme. Zum einen kommen die Nachrichten nicht in
Abständen von einer halben Sekunde an. Sie kommen alle auf einmal an, und zwar
zwei Sekunden (2.000 Millisekunden) nach dem Start des Programms. Zum anderen
beendet sich dieses Programm nie! Stattdessen wartet es ewig auf neue
Nachrichten. Du musst es mit <kbd>Strg</kbd>+<kbd>c</kbd> beenden.</p>
<p>Beginnen wir damit, herauszufinden, warum die Nachrichten alle auf einmal nach
der vollen Verzögerung eintreffen, anstatt mit Verzögerungen zwischen den
einzelnen Nachrichten. Innerhalb eines bestimmten asynchronen Blocks ist die
Reihenfolge, in der die Schlüsselwörter <code>await</code> im Code erscheinen, auch die
Reihenfolge, in der sie bei der Ausführung des Programms auftreten.</p>
<p>In Codeblock 17-10 gibt es nur einen asynchronen Block, sodass alles darin
linear abläuft. Es gibt immer noch keine Nebenläufigkeit. Alle Aufrufe von
<code>tx.send</code> finden statt, unterbrochen von allen <code>trpl::sleep</code>-Aufrufen und
ihren zugehörigen Wartepunkten. Erst dann durchläuft die <code>while let</code>-Schleife
einen der <code>await</code> Punkte nach dem Aufruf von <code>recv</code>.</p>
<p>Um die gewünschte Verzögerung zwischen dem Empfang jeder Nachricht zu
erreichen, müssen wir die Operationen <code>tx</code> und <code>rx</code> in eigene asynchrone Blöcke
packen, wie in Codeblock 17-11 gezeigt. Dann kann die Laufzeitumgebung jede
dieser Operationen separat mit <code>trpl::join</code> ausführen, genau wie im
Zählbeispiel. Auch hier warten wir auf das Ergebnis des Aufrufs von
<code>trpl::join</code>, nicht auf die einzelnen Futures. Würden wir auf die einzelnen
Futures nacheinander warten, hätten wir wieder einen sequenziellen Ablauf
– genau das, was wir <em>nicht</em> wollen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("Hallo"),
                String::from("aus"),
                String::from("dem"),
                String::from("Future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("Erhalten: '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-11: Aufteilen von <code>send</code> und <code>recv</code> in
separate <code>async</code>-Blöcke und Warten auf die Futures dieser Blöcke</span></p>
<p>Mit dem aktualisierten Code in Codeblock 17-11 werden die Nachrichten in
Abständen von 500 Millisekunden ausgegeben und nicht mehr alle auf einmal nach
zwei Sekunden.</p>
<p>Das Programm beendet sich aber trotzdem nicht, weil die <code>while let</code>-Schleife
mit <code>trpl::join</code> interagiert:</p>
<ul>
<li>Das von <code>trpl::join</code> zurückgegebene Future ist erst erledigt, wenn <em>beide</em>
übergebene Futures erledigt sind.</li>
<li>Das Future <code>tx</code> ist erledigt, sobald es die Pause nach dem Senden der letzten
Nachricht in <code>vals</code> beendet hat.</li>
<li>Das Future <code>rx</code> ist erst nach dem Ende der <code>while let</code>-Schleife erledigt.</li>
<li>Die <code>while let</code>-Schleife endet erst, wenn das Ergebnis von <code>rx.recv</code> <code>None</code>
ist.</li>
<li>Das Ergebnis von <code>rx.recv</code> ist nur dann <code>None</code>, wenn das andere Ende des
Kanals geschlossen wurde.</li>
<li>Der Kanal wird nur geschlossen, wenn wir <code>rx.close</code> aufrufen oder wenn die
Senderseite <code>tx</code> aufgeräumt (dropped) wird.</li>
<li>Wir rufen nirgendwo <code>rx.close</code> auf, und <code>tx</code> wird nicht aufgeräumt, bis der
äußerste asynchrone Block, der an <code>trpl::run</code> übergeben wurde, endet.</li>
<li>Der Block kann nicht enden, weil er auf <code>trpl::join</code> wartet, was uns wieder
an den Anfang dieser Liste bringt.</li>
</ul>
<p>Wir könnten <code>rx</code> manuell schließen, indem wir irgendwo <code>rx.close</code> aufrufen,
aber das macht nicht viel Sinn. Das Beenden nach der Verarbeitung einer
bestimmten Anzahl von Nachrichten würde das Programm herunterfahren, aber wir
könnten Nachrichten verpassen. Wir brauchen einen anderen Weg, um
sicherzustellen, dass <code>tx</code> <em>vor</em> dem Ende der Funktion aufgeräumt wird.</p>
<p>Im Moment leiht sich der async-Block, in dem wir die Nachrichten senden, nur
<code>tx</code> aus, weil das Senden einer Nachricht keine Eigentümerschaft erfordert.
Wenn wir <code>tx</code> aber in den async-Block verschieben könnten, würde es aufgeräumt
werden, sobald der Block endet. In <a href="ch13-01-closures.html#erfassen-von-referenzen-oder-verschieben-der-eigent%C3%BCmerschaft">„Erfassen von Referenzen oder Verschieben
der Eigentümerschaft“</a> in Kapitel 13 haben wir gelernt, wie
man das Schlüsselwort <code>move</code> mit Funktionsabschlüssen verwendet, und in
<a href="ch16-01-threads.html#verwenden-von-move-funktionsabschl%C3%BCssen-mit-str%C3%A4ngen">„Verwenden von <code>move</code>-Funktionsabschlüssen mit Strängen“</a> in
Kapitel 16 haben wir gesehen, dass wir oft Daten in Funktionsabschlüsse
verschieben müssen, wenn wir mit Strängen arbeiten. Für asynchrone Blöcke gilt
dieselbe grundlegende Dynamik, sodass das Schlüsselwort <code>move</code> mit asynchronen
Blöcken genauso funktioniert wie mit Funktionsabschlüssen.</p>
<p>In Codeblock 17-12 ändern wir den Block zum Senden von Nachrichten von <code>async</code>
zu <code>async move</code>. Wenn wir <em>diese</em> Version des Codes ausführen, beendet sie sich
ordnungsgemäß, nachdem die letzte Nachricht gesendet und empfangen wurde.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            let vals = vec![
                String::from("Hallo"),
                String::from("aus"),
                String::from("dem"),
                String::from("Future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                eprintln!("Erhalten: '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-12: Eine Überarbeitung des Codes aus
Codeblock 17-11, die den Code korrekt beendet, wenn er fertig ist</span></p>
<p>Dieser asynchrone Kanal ist auch ein Kanal für mehrere Erzeuger, sodass wir
<code>clone</code> auf <code>tx</code> aufrufen können, wenn wir Nachrichten von mehreren Futures
senden wollen, wie in Codeblock 17-13 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl;
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("Hallo"),
                String::from("aus"),
                String::from("dem"),
                String::from("Future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("Erhalten: '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("Weitere"),
                String::from("Nachrichten"),
                String::from("für"),
                String::from("dich"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 17-13: Verwenden mehrerer Produzenten mit
asynchronen Blöcken</span></p>
<p>Zuerst klonen wir <code>tx</code> und erstellen <code>tx1</code> außerhalb des ersten asynchronen
Blocks. Wir verschieben <code>tx1</code> in diesen Block, genau wie wir es zuvor mit <code>tx</code>
gemacht haben. Dann verschieben wir das ursprüngliche <code>tx</code> in einen <em>neuen</em>
asynchronen Block, wo wir mehr Nachrichten mit einer etwas größeren Verzögerung
senden. Wir setzen diesen neuen asynchronen Block nach dem asynchronen Block
für den Empfang von Nachrichten, aber er könnte genauso gut vor ihm stehen. Der
Schlüssel ist die Reihenfolge, in der auf die Futures gewartet wird, nicht die
Reihenfolge, in der sie erstellt werden.</p>
<p>Die beiden asynchronen Blöcke zum Senden von Nachrichten müssen <code>async move</code>-Blöcke sein, sodass sowohl <code>tx</code> als auch <code>tx1</code> aufgeräumt werden, wenn
diese Blöcke zu Ende sind. Sonst landen wir wieder in der gleichen
Endlosschleife, mit der wir angefangen haben. Schließlich wechseln wir von
<code>trpl::join</code> zu <code>trpl::join3</code>, um das zusätzliche Future zu behandeln.</p>
<p>Jetzt sehen wir alle Nachrichten der beiden sendenden Futures. Da die sendenden
Futures leicht unterschiedliche Verzögerungen nach dem Senden verwenden, werden
die Nachrichten auch in diesen unterschiedlichen Intervallen empfangen.</p>
<pre><code class="language-text">Erhalten: 'Hallo'
Erhalten: 'Weitere'
Erhalten: 'aus'
Erhalten: 'dem'
Erhalten: 'Nachrichten'
Erhalten: 'Future'
Erhalten: 'für'
Erhalten: 'dich'
</code></pre>
<p>Das ist ein guter Anfang, aber es schränkt uns auf eine Handvoll Futures ein:
Zwei mit <code>join</code> und drei mit <code>join3</code>. Schauen wir uns an, wie wir mit mehr
Futures arbeiten können.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-01-futures-and-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-03-more-futures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-01-futures-and-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-03-more-futures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
