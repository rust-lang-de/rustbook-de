<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Anwenden von Nebenläufigkeit mit async - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris-d33b75bf.css">
        <link rel="stylesheet" href="theme/2018-edition-4e126c62.css">
        <link rel="stylesheet" href="theme/semantic-notes-9b5766c0.css">
        <link rel="stylesheet" href="theme/listing-cab26221.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5070249d.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h2 id="anwenden-von-nebenläufigkeit-mit-async"><a class="header" href="#anwenden-von-nebenläufigkeit-mit-async">Anwenden von Nebenläufigkeit mit async</a></h2>
<p>In diesem Abschnitt werden wir async auf einige Nebenläufigkeitsprobleme
anwenden, die wir in Kapitel 16 mit Strängen (threads) angegangen sind. Da wir
dort bereits über viele Schlüsselideen gesprochen haben, werden wir uns in
diesem Abschnitt auf die Unterschiede zwischen Strängen und Futures
konzentrieren.</p>
<p>In vielen Fällen sind die APIs für den Umgang mit Nebenläufigkeit mittels async
sehr ähnlich zu denen mit Strängen. In anderen Fällen sind sie am Ende ganz
anders. Selbst wenn die APIs von Strängen und async <em>ähnlich</em> aussehen, haben
sie oft ein anderes Verhalten und fast immer unterschiedliche
Leistungsmerkmale.</p>
<h3 id="erstellen-einer-neuen-aufgabe-mit-spawn_task"><a class="header" href="#erstellen-einer-neuen-aufgabe-mit-spawn_task">Erstellen einer neuen Aufgabe mit <code>spawn_task</code></a></h3>
<p>Die erste Operation, die wir im Abschnitt <a href="ch16-01-threads.html#erstellen-eines-neuen-strangs-mit-spawn">„Erstellen eines neuen Strangs mit
<code>spawn</code>“</a> in Kapitel 16 in Angriff genommen haben, war das
Hochzählen in zwei separaten Strängen. Lass uns das Gleiche mit async machen.
Die Kiste <code>trpl</code> enthält eine Funktion <code>spawn_task</code>, die der API
<code>thread::spawn</code> sehr ähnlich ist, und eine Funktion <code>sleep</code>, die eine
async-Version der API <code>thread::sleep</code> ist. Wir können diese zusammen verwenden,
um das Zählbeispiel zu implementieren, siehe Codeblock 17-6.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">use std::time::Duration;

fn main() {
    trpl::block_on(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("Hallo Nummer {i} von der ersten Aufgabe!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("Hallo Nummer {i} von der zweiten Aufgabe!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre>
<p><span class="caption">Codeblock 17-6: Erstellen einer neuen Aufgabe, die etwas
ausgibt, während die Hauptaufgabe etwas anderes ausgibt</span></p>
<p>Als Ausgangspunkt rufen wir in unserer Funktion <code>trpl::block_on</code> auf, sodass
unsere Top-Level-Funktion asynchron sein kann.</p>
<blockquote>
<p>Hinweis: Im weiteren Verlauf dieses Kapitels wird jedes Beispiel genau den
gleichen Rahmen-Code mit <code>trpl::block_on</code> in <code>main</code> enthalten, also werden
wir ihn oft auslassen, genau wie wir es mit <code>main</code> tun. Denke daran, ihn in
deinem Code einzubauen!</p>
</blockquote>
<p>Dann schreiben wir zwei Schleifen innerhalb dieses Blocks, jede mit einem
<code>trpl::sleep</code>-Aufruf, der eine halbe Sekunde (500 Millisekunden) wartet, bevor
die nächste Nachricht gesendet wird. Wir platzieren die eine Schleife in den
Rumpf des <code>trpl::spawn_task</code>-Aufrufs und die andere in eine <code>for</code>-Schleife auf
oberster Ebene. Wir fügen auch ein <code>await</code> nach den <code>sleep</code>-Aufrufen ein.</p>
<p>Dieser Code funktioniert ähnlich wie die Strang-basierte Implementierung
– einschließlich der Tatsache, dass die Meldungen in deinem Terminal in
einer anderen Reihenfolge erscheinen, wenn du es ausführst:</p>
<pre><code class="language-text">Hallo Nummer 1 von der zweiten Aufgabe!
Hallo Nummer 1 von der ersten Aufgabe!
Hallo Nummer 2 von der ersten Aufgabe!
Hallo Nummer 2 von der zweiten Aufgabe!
Hallo Nummer 3 von der ersten Aufgabe!
Hallo Nummer 3 von der zweiten Aufgabe!
Hallo Nummer 4 von der ersten Aufgabe!
Hallo Nummer 4 von der zweiten Aufgabe!
Hallo Nummer 5 von der ersten Aufgabe!
</code></pre>
<p>Diese Version beendet sich, sobald die <code>for</code>-Schleife im Rumpf des asynchronen
Blocks beendet ist, da die von <code>spawn_task</code> erzeugte Aufgabe beendet wird, wenn
die Funktion <code>main</code> endet. Wenn du die Aufgabe bis zum Ende ausführen willst,
musst du <code>JoinHandle</code> verwenden, um auf das Ende der ersten Aufgabe zu warten.
Bei Strängen haben wir die Methode <code>join</code> verwendet, um zu „blockieren“, bis
der Strang fertig ist. In Codeblock 17-7 können wir <code>await</code> verwenden, um
dasselbe zu tun, weil <code>JoinHandle</code> selbst ein Future ist. Sein <code>Output</code>-Typ ist
<code>Result</code>, also entpacken wir es ebenfalls, nachdem wir darauf gewartet haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("Hallo Nummer {i} von der ersten Aufgabe!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("Hallo Nummer {i} von der zweiten Aufgabe!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-7: Verwenden von <code>await</code> mit einem
<code>JoinHandle</code>, um eine Aufgabe bis zum Ende auszuführen</span></p>
<p>Diese aktualisierte Version läuft, bis <em>beide</em> Schleifen beendet sind:</p>
<pre><code class="language-text">Hallo Nummer 1 von der zweiten Aufgabe!
Hallo Nummer 1 von der ersten Aufgabe!
Hallo Nummer 2 von der ersten Aufgabe!
Hallo Nummer 2 von der zweiten Aufgabe!
Hallo Nummer 3 von der ersten Aufgabe!
Hallo Nummer 3 von der zweiten Aufgabe!
Hallo Nummer 4 von der ersten Aufgabe!
Hallo Nummer 4 von der zweiten Aufgabe!
Hallo Nummer 5 von der ersten Aufgabe!
Hallo Nummer 6 von der ersten Aufgabe!
Hallo Nummer 7 von der ersten Aufgabe!
Hallo Nummer 8 von der ersten Aufgabe!
Hallo Nummer 9 von der ersten Aufgabe!
</code></pre>
<p>Bisher sieht es so aus, als ob async und Stränge zu ähnlichen Ergebnissen
führen, nur mit einer anderen Syntax: Verwenden von <code>await</code> anstelle des
Aufrufs von <code>join</code> auf <code>JoinHandle</code> und Abwarten der <code>sleep</code>-Aufrufe.</p>
<p>Der größere Unterschied ist, dass wir dafür keinen weiteren
Betriebssystem-Strang starten müssen. Tatsächlich brauchen wir hier nicht
einmal eine Aufgabe zu starten. Da asynchrone Blöcke zu anonymen Futures
kompiliert werden, können wir beide Schleifen in einen asynchronen Block packen
und von der Laufzeitumgebung mittels der Funktion <code>trpl::join</code> bis zum Ende
ausführen lassen.</p>
<p>Im Abschnitt <a href="ch16-01-threads.html#warten-auf-das-ende-aller-stränge">„Warten auf das Ende aller Stränge“</a> in Kapitel 16
haben wir gezeigt, wie man die Methode <code>join</code> auf den Typ <code>JoinHandle</code>
anwendet, der beim Aufruf von <code>std::thread::spawn</code> zurückgegeben wird. Die
Funktion <code>trpl::join</code> ist ähnlich, aber für Futures. Wenn du ihr zwei Futures
gibst, erzeugt sie ein neues Future, dessen Ausgabe ein Tupel mit der Ausgabe
der beiden übergebenen Futures ist, sobald <em>beide</em> abgeschlossen sind. In
Codeblock 17-8 verwenden wir also <code>trpl::join</code>, um darauf zu warten, dass
sowohl <code>fut1</code> als auch <code>fut2</code> fertig sind. Wir warten <em>nicht</em> auf <code>fut1</code> und
<code>fut2</code>, sondern auf das neue Future, das von <code>trpl::join</code> erzeugt wurde. Wir
ignorieren die Ausgabe, da es sich nur um ein Tupel mit zwei Einheitswerten
handelt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("Hallo Nummer {i} von der ersten Aufgabe!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("Hallo Nummer {i} von der zweiten Aufgabe!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-8: Verwenden von <code>trpl::join</code>, um auf zwei
anonyme Futures zu warten</span></p>
<p>Wenn wir dies ausführen, sehen wir, dass beide Futures bis zum Ende laufen:</p>
<pre><code class="language-text">Hallo Nummer 1 von der ersten Aufgabe!
Hallo Nummer 1 von der zweiten Aufgabe!
Hallo Nummer 2 von der ersten Aufgabe!
Hallo Nummer 2 von der zweiten Aufgabe!
Hallo Nummer 3 von der ersten Aufgabe!
Hallo Nummer 3 von der zweiten Aufgabe!
Hallo Nummer 4 von der ersten Aufgabe!
Hallo Nummer 4 von der zweiten Aufgabe!
Hallo Nummer 5 von der ersten Aufgabe!
Hallo Nummer 6 von der ersten Aufgabe!
Hallo Nummer 7 von der ersten Aufgabe!
Hallo Nummer 8 von der ersten Aufgabe!
Hallo Nummer 9 von der ersten Aufgabe!
</code></pre>
<p>Nun siehst du jedes Mal genau dieselbe Reihenfolge, was sich sehr von dem
unterscheidet, was wir bei Strängen und mit <code>trpl::spawn_task</code> in Codeblock
17-7 gesehen haben. Das liegt daran, dass die Funktion <code>trpl::join</code> <em>fair</em> ist,
d.h. sie prüft jedes Future gleich oft, wechselt zwischen ihnen ab und lässt
nie eines vorauslaufen, wenn das andere bereit ist. Bei Strängen entscheidet
das Betriebssystem, welcher Strang geprüft wird und wie lange er laufen darf.
Bei asynchronem Rust entscheidet die Laufzeitumgebung, welche Aufgabe geprüft
werden soll. (In der Praxis sind die Details komplizierter, weil eine
asynchrone Laufzeitumgebung unter der Haube Betriebssystem-Stränge für die
Verwaltung der Nebenläufigkeit verwenden könnte, sodass das Einhalten der
Fairness mehr Aufwand für eine Laufzeitumgebung sein kann – aber es ist
immer noch möglich!) Laufzeitumgebungen müssen nicht für jede beliebige
Operation Fairness garantieren, und sie stellen oft mehrere APIs bereit, mit
denen du wählen kannst, ob du Fairness wünschst oder nicht.</p>
<p>Probiere einige dieser Varianten des Wartens auf das Future aus und sieh, was
sie bewirken:</p>
<ul>
<li>Entferne den asynchronen Block um eine oder beide Schleifen.</li>
<li>Warte auf jeden asynchronen Block sofort nach seiner Definition.</li>
<li>Packe nur die erste Schleife in einen asynchronen Block und warte auf das
resultierende Future nach dem Rumpf der zweiten Schleife.</li>
</ul>
<p>Eine zusätzliche Herausforderung ist es, herauszufinden, wie die Ausgabe in
jedem Fall aussehen wird, <em>bevor</em> du den Code ausführst!</p>
<h3 id="datenaustausch-zwischen-zwei-aufgaben-mit-nachrichtenübermittlung"><a class="header" href="#datenaustausch-zwischen-zwei-aufgaben-mit-nachrichtenübermittlung">Datenaustausch zwischen zwei Aufgaben mit Nachrichtenübermittlung</a></h3>
<p>Auch die gemeinsame Nutzung von Daten zwischen Futures wird uns vertraut sein:
Wir werden wieder die Nachrichtenübermittlung (message passing) verwenden,
diesmal jedoch mit asynchronen Versionen der Typen und Funktionen. Wir werden
einen etwas anderen Weg einschlagen als im Abschnitt <a href="ch16-02-message-passing.html">„Nachrichtenaustausch
zwischen Strängen (threads)“</a> in Kapitel 16, um einige
der wichtigsten Unterschiede zwischen Strang-basierter und Future-basierter
Nebenläufigkeit zu veranschaulichen. In Codeblock 17-9 beginnen wir mit einem
einzigen asynchronen Block – <em>ohne</em> eine separate Aufgabe zu erstellen,
da wir einen separaten Strang erstellt haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("Erhalten: {received}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-9: Erstellen eines asynchronen Kanals und
Zuweisen der beiden Enden an <code>tx</code> und <code>rx</code></span></p>
<p>Hier verwenden wir <code>trpl::channel</code>, eine asynchrone Version des Kanals wie mit
Strängen in Kapitel 16. Die asynchrone Version der API unterscheidet sich nur
geringfügig von der Strang-basierten Version: Sie verwendet einen veränderbaren
statt eines unveränderbaren Empfängers <code>rx</code>, und ihre Methode <code>recv</code> erzeugt
ein Future, auf das wir warten müssen, anstatt den Wert direkt zu erzeugen.
Jetzt können wir Nachrichten vom Sender zum Empfänger senden. Beachte, dass wir
keinen separaten Strang oder gar eine Aufgabe erzeugen müssen; wir müssen
lediglich auf den Aufruf von <code>rx.recv</code> warten.</p>
<p>Die synchrone Methode <code>Receiver::recv</code> in <code>std::mpsc::channel</code> blockiert, bis
sie eine Nachricht erhält. Die Methode <code>trpl::Receiver::recv</code> tut dies nicht,
da sie asynchron ist. Anstatt zu blockieren, übergibt sie die Kontrolle zurück
an die Laufzeitumgebung, bis entweder eine Nachricht empfangen wird oder die
Sendeseite des Kanals geschlossen wurde. Im Gegensatz dazu warten wir nicht auf
den <code>send</code>-Aufruf, weil er nicht blockiert. Das ist auch nicht nötig, denn der
Kanal, in den wir die Nachricht senden, ist unlimitiert.</p>
<blockquote>
<p>Anmerkung: Da der gesamte asynchrone Code in einem asynchronen Block in einem
<code>trpl::block_on</code>-Aufruf läuft, kann alles innerhalb dieses Blocks ein
Blockieren vermeiden. Allerdings wird der Code <em>außerhalb</em> des Blocks
blockieren, wenn die Funktion <code>block_on</code> zurückkehrt. Das ist der ganze Sinn
der Funktion<code>trpl::block_on</code>: Sie lässt dich <em>wählen</em>, wo du bei einer Menge
von asynchronem Code blockieren willst, und somit wo du zwischen synchronem
und asynchronem Code wechseln willst.</p>
</blockquote>
<p>Beachte bei diesem Beispiel zwei Dinge. Erstens: Die Nachricht wird sofort
ankommen! Zweitens: Obwohl wir hier ein Future verwenden, gibt es noch keine
Nebenläufigkeit. Alles im Codeblock geschieht der Reihe nach, so wie es auch
geschehen würde, wenn keine Futures beteiligt wären.</p>
<p>Der erste Teil besteht darin, eine Reihe von Nachrichten zu senden und
dazwischen zu schlafen, wie in Codeblock 17-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("Hallo"),
            String::from("aus"),
            String::from("dem"),
            String::from("Future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("Erhalten: '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-10: Senden und Empfangen mehrerer
Nachrichten über den asynchronen Kanal und Schlafen mit einem <code>await</code> zwischen
jeder Nachricht</span></p>
<p>Wir müssen die Nachrichten nicht nur senden, sondern auch empfangen. In diesem
Fall könnten wir das manuell tun, indem wir einfach <code>rx.recv().await</code> viermal
ausführen, weil wir wissen, wie viele Nachrichten ankommen werden. In der
realen Welt werden wir jedoch im Allgemeinen auf eine <em>unbekannte</em> Anzahl von
Nachrichten warten, wir müssen also so lange warten, bis wir feststellen, dass
es keine weiteren Nachrichten mehr gibt.</p>
<p>In Codeblock 16-10 haben wir eine <code>for</code>-Schleife verwendet, um alle Elemente zu
verarbeiten, die von einem synchronen Kanal empfangen wurden. In Rust gibt es
jedoch noch keine Möglichkeit, eine <code>for</code>-Schleife mit einer <em>asynchron
erzeugten</em> Liste von Elementen zu verwenden. Stattdessen müssen wir eine neue
Schleifenart verwenden, die wir bisher noch nicht gesehen haben: die <code>while let</code>-Schleife mit Bedingungen. Dies ist die Schleifenvariante des <code>if let</code>-Konstrukts, das wir im Abschnitt <a href="ch06-03-if-let.html">„Prägnanter Kontrollfluss mit <code>if let</code>
und <code>let...else</code>“</a> in Kapitel 6 gesehen haben. Die Schleife wird so
lange ausgeführt, wie das angegebene Muster zum Wert passt.</p>
<p>Der Aufruf <code>rx.recv</code> erzeugt ein Future, auf das wir warten. Die
Laufzeitumgebung pausiert das Future, bis es bereit ist. Sobald eine Nachricht
eintrifft, wird das Future zu <code>Some(message)</code> aufgelöst, so oft wie eine
Nachricht eintrifft. Wenn der Kanal geschlossen wird, unabhängig davon, ob
<em>irgendwelche</em> Nachrichten eingetroffen sind, wird das Future stattdessen zu
<code>None</code> aufgelöst, um anzuzeigen, dass es keine weiteren Werte gibt und wir
daher mit dem Polling aufhören können, d.h. aufhören zu warten.</p>
<p>Die <code>while let</code>-Schleife fasst all dies zusammen. Wenn das Ergebnis des Aufrufs
von <code>rx.recv().await</code> den Wert <code>Some(message)</code> hat, erhalten wir Zugriff auf
die Nachricht und können sie im Schleifenrumpf verwenden, genauso wie wir es
mit <code>if let</code> könnten. Wenn das Ergebnis <code>None</code> ist, endet die Schleife. Jedes
Mal, wenn die Schleife durchlaufen wird, trifft sie erneut auf den await-Punkt,
sodass die Laufzeitumgebung die Schleife erneut unterbricht, bis eine weitere
Nachricht eintrifft.</p>
<p>Der Code sendet und empfängt nun erfolgreich alle Nachrichten. Leider gibt es
immer noch ein paar Probleme. Zum einen kommen die Nachrichten nicht in
Abständen von einer halben Sekunde an. Sie kommen alle auf einmal an, und zwar
zwei Sekunden (2.000 Millisekunden) nach dem Start des Programms. Zum anderen
beendet sich dieses Programm nie! Stattdessen wartet es ewig auf neue
Nachrichten. Du musst es mit <kbd>Strg</kbd>+<kbd>c</kbd> beenden.</p>
<h4 id="code-innerhalb-eines-asynchronen-blocks-wird-linear-ausgeführt"><a class="header" href="#code-innerhalb-eines-asynchronen-blocks-wird-linear-ausgeführt">Code innerhalb eines asynchronen Blocks wird linear ausgeführt</a></h4>
<p>Beginnen wir damit, herauszufinden, warum die Nachrichten alle auf einmal nach
der vollen Verzögerung eintreffen, anstatt mit Verzögerungen zwischen den
einzelnen Nachrichten. Innerhalb eines bestimmten asynchronen Blocks ist die
Reihenfolge, in der die Schlüsselwörter <code>await</code> im Code erscheinen, auch die
Reihenfolge, in der sie bei der Ausführung des Programms auftreten.</p>
<p>In Codeblock 17-10 gibt es nur einen asynchronen Block, sodass alles darin
linear abläuft. Es gibt immer noch keine Nebenläufigkeit. Alle Aufrufe von
<code>tx.send</code> finden statt, unterbrochen von allen <code>trpl::sleep</code>-Aufrufen und
ihren zugehörigen Wartepunkten. Erst dann durchläuft die <code>while let</code>-Schleife
einen der <code>await</code> Punkte nach dem Aufruf von <code>recv</code>.</p>
<p>Um die gewünschte Verzögerung zwischen dem Empfang jeder Nachricht zu
erreichen, müssen wir die Operationen <code>tx</code> und <code>rx</code> in eigene asynchrone Blöcke
packen, wie in Codeblock 17-11 gezeigt. Dann kann die Laufzeitumgebung jede
dieser Operationen separat mit <code>trpl::join</code> ausführen, genau wie in Codeblock
17-8. Auch hier warten wir auf das Ergebnis des Aufrufs von <code>trpl::join</code>, nicht
auf die einzelnen Futures. Würden wir auf die einzelnen Futures nacheinander
warten, hätten wir wieder einen sequenziellen Ablauf – genau das, was wir
<em>nicht</em> wollen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("Hallo"),
                String::from("aus"),
                String::from("dem"),
                String::from("Future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("Erhalten: '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-11: Aufteilen von <code>send</code> und <code>recv</code> in
separate <code>async</code>-Blöcke und Warten auf die Futures dieser Blöcke</span></p>
<p>Mit dem aktualisierten Code in Codeblock 17-11 werden die Nachrichten in
Abständen von 500 Millisekunden ausgegeben und nicht mehr alle auf einmal nach
zwei Sekunden.</p>
<h4 id="verschieben-der-eigentümerschaft-in-einen-asynchronen-block"><a class="header" href="#verschieben-der-eigentümerschaft-in-einen-asynchronen-block">Verschieben der Eigentümerschaft in einen asynchronen Block</a></h4>
<p>Das Programm beendet sich aber trotzdem nicht, weil die <code>while let</code>-Schleife
mit <code>trpl::join</code> interagiert:</p>
<ul>
<li>Das von <code>trpl::join</code> zurückgegebene Future ist erst erledigt, wenn <em>beide</em>
übergebene Futures erledigt sind.</li>
<li>Das Future <code>tx_fut</code> ist erledigt, sobald es die Pause nach dem Senden der
letzten Nachricht in <code>vals</code> beendet hat.</li>
<li>Das Future <code>tx_fut</code> ist erst nach dem Ende der <code>while let</code>-Schleife erledigt.</li>
<li>Die <code>while let</code>-Schleife endet erst, wenn das Ergebnis von <code>rx.recv</code> <code>None</code>
ist.</li>
<li>Das Ergebnis von <code>rx.recv</code> ist nur dann <code>None</code>, wenn das andere Ende des
Kanals geschlossen wurde.</li>
<li>Der Kanal wird nur geschlossen, wenn wir <code>rx.close</code> aufrufen oder wenn die
Senderseite <code>tx</code> aufgeräumt (dropped) wird.</li>
<li>Wir rufen nirgendwo <code>rx.close</code> auf, und <code>tx</code> wird nicht aufgeräumt, bis der
äußerste asynchrone Block, der an <code>trpl::block_on</code> übergeben wurde, endet.</li>
<li>Der Block kann nicht enden, weil er auf <code>trpl::join</code> wartet, was uns wieder
an den Anfang dieser Liste bringt.</li>
</ul>
<p>Im Moment <em>leiht</em> sich der async-Block, in dem wir die Nachrichten senden, nur
<code>tx</code> aus, weil das Senden einer Nachricht keine Eigentümerschaft erfordert.
Wenn wir <code>tx</code> aber in den async-Block <em>verschieben</em> könnten, würde es
aufgeräumt werden, sobald der Block endet. Im Abschnitt <a href="ch13-01-closures.html#erfassen-von-referenzen-oder-verschieben-der-eigentümerschaft">„Erfassen von
Referenzen oder Verschieben der Eigentümerschaft“</a> in Kapitel
13 haben wir gelernt, wie man das Schlüsselwort <code>move</code> mit Funktionsabschlüssen
verwendet, und im Abschnitt <a href="ch16-01-threads.html#verwenden-von-move-funktionsabschlüssen-mit-strängen">„Verwenden von <code>move</code>-Funktionsabschlüssen mit
Strängen“</a> in Kapitel 16 haben wir gesehen, dass wir oft Daten in
Funktionsabschlüsse verschieben müssen, wenn wir mit Strängen arbeiten. Für
asynchrone Blöcke gilt dieselbe grundlegende Dynamik, sodass das Schlüsselwort
<code>move</code> mit asynchronen Blöcken genauso funktioniert wie mit
Funktionsabschlüssen.</p>
<p>In Codeblock 17-12 ändern wir den Block zum Senden von Nachrichten von <code>async</code>
zu <code>async move</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            // --abschneiden--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("Hallo"),
</span><span class="boring">                String::from("aus"),
</span><span class="boring">                String::from("dem"),
</span><span class="boring">                String::from("Future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_millis(500)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                eprintln!("Erhalten: '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        trpl::join(tx_fut, rx_fut).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-12: Eine Überarbeitung des Codes aus
Codeblock 17-11, die den Code korrekt beendet, wenn er fertig ist</span></p>
<p>Wenn wir <em>diese</em> Version des Codes ausführen, beendet sie sich ordnungsgemäß,
nachdem die letzte Nachricht gesendet und empfangen wurde. Als Nächstes wollen
wir uns ansehen, was geändert werden müsste, um Daten aus mehr als ein Future
zu senden.</p>
<h4 id="auf-mehrere-futures-warten-mit-dem-makro-join"><a class="header" href="#auf-mehrere-futures-warten-mit-dem-makro-join">Auf mehrere Futures warten mit dem Makro <code>join!</code></a></h4>
<p>Dieser asynchrone Kanal ist auch ein Kanal für mehrere Erzeuger, sodass wir
<code>clone</code> auf <code>tx</code> aufrufen können, wenn wir Nachrichten von mehreren Futures
senden wollen, wie in Codeblock 17-13 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("Hallo"),
                String::from("aus"),
                String::from("dem"),
                String::from("Future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("Erhalten: '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("Weitere"),
                String::from("Nachrichten"),
                String::from("für"),
                String::from("dich"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 17-13: Verwenden mehrerer Produzenten mit
asynchronen Blöcken</span></p>
<p>Zuerst klonen wir <code>tx</code> und erstellen <code>tx1</code> außerhalb des ersten asynchronen
Blocks. Wir verschieben <code>tx1</code> in diesen Block, genau wie wir es zuvor mit <code>tx</code>
gemacht haben. Dann verschieben wir das ursprüngliche <code>tx</code> in einen <em>neuen</em>
asynchronen Block, wo wir mehr Nachrichten mit einer etwas größeren Verzögerung
senden. Wir setzen diesen neuen asynchronen Block nach dem asynchronen Block
für den Empfang von Nachrichten, aber er könnte genauso gut vor ihm stehen. Der
Schlüssel ist die Reihenfolge, in der auf die Futures gewartet wird, nicht die
Reihenfolge, in der sie erstellt werden.</p>
<p>Die beiden asynchronen Blöcke zum Senden von Nachrichten müssen <code>async move</code>-Blöcke sein, sodass sowohl <code>tx</code> als auch <code>tx1</code> aufgeräumt werden, wenn
diese Blöcke zu Ende sind. Sonst landen wir wieder in der gleichen
Endlosschleife, mit der wir angefangen haben. Schließlich wechseln wir von
<code>trpl::join</code> zu <code>trpl::join!</code>, um das zusätzliche Future zu behandeln: Das
Makro <code>join!</code> wartet auf eine beliebige Anzahl von Futures, wobei die Anzahl
der Futures zum Zeitpunkt der Kompilierung bekannt sein muss. Das Warten auf
eine Sammlung von Futures mit unbekannter Anzahl wird später in diesem Kapitel
behandelt.</p>
<p>Jetzt sehen wir alle Nachrichten der beiden sendenden Futures. Da die sendenden
Futures leicht unterschiedliche Verzögerungen nach dem Senden verwenden, werden
die Nachrichten auch in diesen unterschiedlichen Intervallen empfangen:</p>
<pre><code class="language-text">Erhalten: 'Hallo'
Erhalten: 'Weitere'
Erhalten: 'aus'
Erhalten: 'dem'
Erhalten: 'Nachrichten'
Erhalten: 'Future'
Erhalten: 'für'
Erhalten: 'dich'
</code></pre>
<p>Wir haben untersucht, wie man mit Nachrichtenübermittlung Daten zwischen
Futures sendet, wie Code innerhalb eines asynchronen Blocks sequenziell
ausgeführt wird, wie man die Eigentümerschaft in einen asynchronen Block
verschiebt und wie man auf mehrere Futures wartet. Als Nächstes wollen wir uns
damit befassen, wie und warum man der Laufzeitumgebung mitteilt, dass sie zu
einer anderen Aufgabe wechseln kann.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-01-futures-and-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="ch17-03-more-futures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-01-futures-and-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="ch17-03-more-futures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris-2317480c.js"></script>



    </div>
    </body>
</html>
