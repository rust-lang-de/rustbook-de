<!DOCTYPE HTML>
<html lang="de" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Eine Reihe von Elementen verarbeiten mit Iteratoren - Die Programmiersprache Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/ferris.css">
        
        <link rel="stylesheet" href="theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Die Programmiersprache Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Vorwort</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Einführung</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Erste Schritte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hallo Welt</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hallo Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Ein Ratespiel programmieren</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Allgemeine Programmierkonzepte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variablen und Veränderlichkeit</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Datentypen</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funktionen</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Kommentare</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrollfluss</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Eigentümerschaft (ownership) verstehen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Was ist Eigentümerschaft (ownership)?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referenzen und Ausleihen (borrowing)</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Der Anteilstyp (slice)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Strukturen (structs) für zusammenhängende Daten verwenden</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Strukturen (structs) definieren und instanziieren</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Beispielprogramm mit Strukturen (structs)</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Methodensyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Aufzählungen (enums) und Musterabgleich (pattern matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Eine Aufzählung (enum) definieren</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Der Kontrollflussoperator match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Prägnanter Kontrollfluss mit if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Wachsende Projekte verwalten mit Paketen (packages), Kisten (crates) und Modulen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Pakete (packages) und Kisten (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Mit Modulen den Kontrollumfang und Datenschutz steuern</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Mit Pfaden auf ein Element im Modulbaum verweisen</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Pfade in den Gültigkeitsbereich bringen mit dem Schlüsselwort use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Module in verschiedene Dateien aufteilen</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Allgemeine Kollektionen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Wertlisten in Vektoren ablegen</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8-kodierten Text in Zeichenketten (strings) ablegen</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Schlüssel mit zugehörigen Werten in Hashtabellen ablegen</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Fehlerbehandlung</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Nicht behebbare Fehler mit panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Behebbare Fehler mit Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Wann panic! aufrufen und wann nicht?</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generische Typen, Merkmale (traits) und Lebensdauer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generische Datentypen</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Merkmale (traits): Gemeinsames Verhalten definieren</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referenzen validieren mit Lebensdauern</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Automatisierte Tests schreiben</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Tests schreiben</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Steuern wie Tests ausgeführt werden</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Testverwaltung</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Ein E/A-Projekt: Ein Kommandozeilenprogramm erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Kommandozeilenargumente entgegennehmen</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Eine Datei einlesen</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Bibliotheksfunktionalität mit testgetriebener Entwicklung erstellen</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Mit Umgebungsvariablen arbeiten</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Fehlermeldungen in die Standardfehlerausgabe anstatt der Standardausgabe schreiben</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Funktionale Sprachelemente: Iteratoren und Funktionsabschlüsse (closures)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Funktionsabschlüsse (closures): Anonyme Funktionen die ihre Umgebung erfassen können</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html" class="active"><strong aria-hidden="true">13.2.</strong> Eine Reihe von Elementen verarbeiten mit Iteratoren</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Unser E/A-Projekt verbessern</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performanzvergleich: Schleifen vs. Iteratoren</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Mehr über Cargo und Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Bauvorgang anpassen mit Freigabeprofilen (release profiles)</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Kisten (crate) auf crates.io veröffentlichen</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo-Arbeitsbereiche</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Kommandozeilenwerkzeuge von crates.io installieren mit cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Cargo um benutzerdefinierte Befehle erweitern</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Intelligente Zeiger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Mit Box&lt;T&gt; auf Daten im Haldenspeicher zeigen</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Programmcode beim Aufräumen ausführen mit dem Merkmal (trait) Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Der referenzzählende intelligente Zeiger Rc&lt;T&gt;</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; und das innere Veränderlichkeitsmuster</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referenzzyklen können zu einem Speicherleck führen</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Furchtlose Nebenläufigkeit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Mit Strängen (threads) Programmcode gleichzeitig ausführen</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Nachrichtenaustausch zwischen Strängen (threads)</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Nebenläufigkeit mit gemeinsamem Zustand</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) Sync und Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Objektorientierte Sprachelemente von Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Charakteristiken objektorientierter Sprachen</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen erlauben</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Ein objektorientiertes Entwurfsmuster implementieren</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Muster (patterns) und Abgleich (matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Alle Stellen an denen Muster (patterns) verwendet werden können</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Abweisbarkeit: Falls ein Muster (pattern) mal nicht passt</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Mustersyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Fortgeschrittene Sprachelemente</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsicheres (unsafe) Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Fortgeschrittene Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Fortgeschrittene Typen</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Erweiterte Funktionen und Funktionsabschlüsse (closures)</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Abschlussprojekt: Einen mehrsträngigen (multi-threaded) Webserver erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Einen einsträngigen (single-threaded) Webserver erstellen</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Unseren einsträngigen (single-threaded) Webserver in einen mehrsträngigen (multi-threaded) Webserver verwandeln</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Kontrolliertes Beenden und Aufräumen</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Anhang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Schlüsselwörter</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatoren und Symbole</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Ableitbare Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Nützliche Entwicklungswerkzeuge</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ausgaben</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Übersetzungen des Buchs</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Wie Rust erstellt wird und „nächtliches Rust“</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="eine-reihe-von-elementen-verarbeiten-mit-iteratoren"><a class="header" href="#eine-reihe-von-elementen-verarbeiten-mit-iteratoren">Eine Reihe von Elementen verarbeiten mit Iteratoren</a></h2>
<p>Iteratoren ermöglichen dir, nacheinander eine Aufgabe für eine Folge von
Elementen auszuführen. Der Iterator ist für die Logik verantwortlich, die
Elemente zu durchlaufen und zu bestimmen, wann eine Sequenz beendet ist.
Durch die Verwendung von Iteratoren ist es nicht notwendig, diese Logik selbst
neu zu implementieren.</p>
<p>Die Iteratoren in Rust sind <em>faul</em> (lazy), das bedeutet, dass sie erst durch
Methodenaufrufe verbraucht werden müssen, um einen Effekt zu haben. Der Programmcode in
Codeblock 13-13 erstellt beispielsweise einen Iterator über die Elemente im
Vektor <code>v1</code> indem die in <code>Vec&lt;T&gt;</code> definierte Methode <code>iter</code> aufgerufen wird.
Dieser Programmcode macht nichts Sinnvolles.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-13: Einen Iterator erstellen</span></p>
<p>Ein Iterator kann nach Erstellung auf verschiedene Weise verwendet werden. In
Codeblock 3-5 in Kapitel 3 haben wir Iteratoren mit <code>for</code>-Schleifen verwendet,
um Programmcode für jedes Element auszuführen, wenngleich wir dadurch nur den
Aufruf von <code>iter</code> schöngefärbt haben.</p>
<p>In Codeblock 13-14 wird die Erstellung des Iterators von dessen Verwendung in
der <code>for</code>-Schleife getrennt. Der Iterator wird in der Variable <code>v1_iter</code>
gespeichert und es findet noch keine Iteration statt. Erst wenn die
<code>for</code>-Schleife mit dem Iterator in <code>v1_iter</code> aufgerufen wird, wird jedes
Element von <code>v1_iter</code> in einer Iteration der Schleife verwendet, die den
jeweiligen Wert ausgibt.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Erhielt: {}&quot;, val);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-14: Verwendung eines Iterators in einer
<code>for</code>-Schleife</span></p>
<p>In Sprachen, deren Standardbibliotheken Iteratoren nicht bereitstellen, würde
man diese Funktionalität bereitstellen, indem man eine Variable bei Index 0
startet und diese zum Indizieren im Vektor verwendet und den Wert der 
Indexvariable bei jedem Schleifendurchlauf erhöht bis die Gesamtzahl der
Elemente im Vektor erreicht ist.</p>
<p>Iteratoren übernehmen derartige Logik für dich und reduzieren dadurch sich
wiederholenden Code, der zusätzliche Fehlerquellen beinhalten kann. Iteratoren
geben dir mehr Flexibilität bei der Verwendung derselben Logik für viele
verschiedene Arten von Sequenzen, nicht nur für Datenstrukturen, die du wie
Vektoren indizieren kannst. Lass uns herausfinden, wie Iteratoren das
bewerkstelligen.</p>
<h3 id="das-merkmal-trait-iterator-und-die-methode-next"><a class="header" href="#das-merkmal-trait-iterator-und-die-methode-next">Das Merkmal (trait) <code>Iterator</code> und die Methode <code>next</code></a></h3>
<p>Alle Iteratoren implementieren ein Merkmal namens <code>Iterator</code> das in der
Standardbibliothek definiert ist. Die Definition dieses Merkmals sieht wie folgt
aus:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // Methoden mit Standardimplementierung wurden elidiert
}
<span class="boring">}
</span></code></pre></pre>
<p>Beachte, dass in der Definition eine neue Syntax verwendet wird: <code>type Item</code> und
<code>Self::Item</code> die einen <em>zugeordneten Typ</em> (associated type) mit diesem Merkmal 
definieren. Wir werden zugeordnete Typen im Kapitel 19 besprechen. Im Moment
musst du nur wissen, dass dieser Programmcode bedeutet, dass die Implementierung
des <code>Iterator</code>-Merkmals erfordert, dass du auch einen <code>Item</code>-Typ definierst und
dieser <code>Item</code>-Typ im Rückgabetyp der <code>next</code>-Methode benutzt wird. Mit anderen
Worten wird der <code>Item</code>-Typ der vom Iterator zurückgegebene Typ sein.</p>
<p>Für das <code>Iterator</code>-Merkmal muss man bei der Implementierung nur eine Methode
definieren: Die <code>next</code>-Methode, die jeweils ein Element des Iterators verpackt
in <code>Some</code> zurückgibt und nach Beendigung der Iteration <code>None</code> zurückgibt.</p>
<p>Wir können für Iteratoren die <code>next</code>-Methode direkt aufrufen. Codeblock 13-15
zeigt, welche Werte bei wiederholten Aufrufen von <code>next</code> auf einen aus einem
Vektor erstellten Iterator zurückgegeben werden:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 13-15: Iterator mit der <code>next</code>-Methode aufrufen</span></p>
<p>Beachte, dass wir <code>v1_iter</code> veränderlich (mutable) machen mussten: Beim Aufrufen
der <code>next</code>-Methode auf einen Iterator wird dessen interner Status geändert, der
verwendet wird, um festzustellen, wo sich der Iterator in der Sequenz befindet.
Mit anderen Worten <em>verbraucht</em> dieser Programmcode den Iterator. Jeder Aufruf
von <code>next</code> isst ein Element des Iterators auf. Als wir die <code>for</code>-Schleife
benutzten, mussten wir <code>v1_iter</code> nicht veränderlich machen, da dies schon hinter
den Kulissen geschah, als die Schleife die Eigentümerschaft (ownership) von
<code>v1_iter</code> übernahm.</p>
<p>Merke auch, dass die Werte, die wir von den Aufrufen von <code>next</code> erhalten,
unveränderliche Referenzen (immutable references) auf die Werte im Vektor sind.
Die <code>iter</code>-Methode erzeugt einen Iterator über unveränderliche Referenzen. Wenn
wir einen Iterator erzeugen möchten der die Eigentümerschaft von <code>v1</code> übernimmt
und angeeignete Werte (owned values) zurückgibt, können wir die
<code>into_iter</code>-Methode anstelle von <code>iter</code> benutzen, und wenn wir über veränderliche
Referenzen iterieren möchten, können wir <code>iter_mut</code> statt <code>iter</code> aufrufen.</p>
<h3 id="methoden-die-den-iterator-verbrauchen"><a class="header" href="#methoden-die-den-iterator-verbrauchen">Methoden die den Iterator verbrauchen</a></h3>
<p>Das <code>Iterator</code>-Merkmal verfügt über eine Vielzahl von Methoden, die in der
Standardbibliothek bereitgestellt werden. Du kannst dich über diese Methoden
informieren, indem du in der Standardbibliothek-API-Dokumentation (standard
library API documentation) nach dem <code>Iterator</code>-Merkmal suchst. Einige dieser
Methoden rufen in ihrer Definition die <code>next</code>-Methode auf, daher musst du die
<code>next</code>-Methode bei der Implementierung des <code>Iterator</code>-Merkmals einbauen.</p>
<p>Methoden die <code>next</code> aufrufen werden als <em>konsumierende Adapter</em> (consuming
adaptors) bezeichnet, da deren Aufruf den Iterator verbraucht. Ein Beispiel ist
die Methode <code>sum</code>, sie übernimmt die Eigentümerschaft des Iterators und
durchläuft die Elemente durch wiederholtes Aufrufen von <code>next</code>, wodurch der
Iterator verbraucht wird. Jedes Element wird während der Iteration zu einer
Summe hinzugefügt, die zurückgegeben wird, sobald die Iteration abgeschlossen
ist. Codeblock 13-16 enthält einen Test, der die <code>sum</code>-Methode veranschaulicht:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 13-16: Aufruf der <code>sum</code>-Methode um den Wert der
Summe aller Elemente zu erhalten</span></p>
<p>Man kann <code>v1_iter</code> nach dem Aufruf von <code>sum</code> nicht verwenden, da <code>sum</code> die
Eigentümerschaft des Iterators übernimmt, auf dem sie aufgerufen wird.</p>
<h3 id="methoden-die-andere-iteratoren-erzeugen"><a class="header" href="#methoden-die-andere-iteratoren-erzeugen">Methoden die andere Iteratoren erzeugen</a></h3>
<p>Andere Methoden die im <code>Iterator</code>-Merkmal definiert sind werden als
<em>Iteratoradapter</em> (iterator adaptors) bezeichnet, sie ermöglichen dir Iteratoren
in andere Arten von Iteratoren zu ändern. Man kann mehrere Aufrufe von
Iteratoradaptern verketten und dadurch komplexe Handlungen auf lesbare Art
ausführen. Da alle Iteratoren jedoch faul sind, ist es notwendig, eine der
konsumierenden Adapter-Methoden aufzurufen, um Ergebnisse zu erhalten.</p>
<p>Codeblock 13-17 zeigt ein Beispiel von einen Aufruf der <code>map</code>-Methode, die einen
Funktionsabschluss auf jedes Element anwendet, um einen neuen Iterator zu
erstellen. Dieser Funktionsabschluss inkrementiert den Wert jedes Elementes des
Vektors um 1. Dieser Programmcode erzeugt jedoch eine Warnung:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-17: Aufruf des Iteratoradapters <code>map</code> um
einen neuen Iterator zu erzeugen</span></p>
<p>Wir erhalten folgende Warnung:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

warning: 1 warning emitted

    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>Der Programmcode in Codeblock 13-17 hat keine Wirkung, der Funktionsabschluss
wird nie aufgerufen. Die Warnung erinnert uns daran, dass Iteratoradapter faul
sind und dass wir den Iterator verwenden müssen, um etwas zu bewirken.</p>
<p>Um das zu beheben, werden wir die <code>collect</code>-Methode verwenden, die wir im Kapitel
12 mit <code>env::args</code> im Codeblock 12-1 benutzt haben. Diese Methode konsumiert den
Iterator und sammelt die Ergebniswerte in einen Kollektionsdatentyp (collection
data type).</p>
<p>In Codeblock 13-18 sammeln wir die Resultate der Iterationen über den Iterator,
der vom Aufruf der <code>map</code>-Methode zurückgegeben wird, in einem Vektor. Dieser
Vektor wird dann alle Elemente vom Originalvektor erhöht um 1 beinhalten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-18: Aufruf der <code>map</code>-Methode um einen
Iterator zu erzeugen und anschließend der <code>collect</code>-Methode um den
Iterator zu verbrauchen und einen Vektor zu erzeugen</span></p>
<p>Da <code>map</code> einen Funktionsabschluss als Parameter annimmt, können wir eine
beliebige Operation spezifizieren, die wir auf jedes Element anwenden wollen.
Dies ist ein gutes Beispiel dafür, wie man mit Funktionsabschlüssen ein
Verhalten anpassen kann, während das vom <code>Iterator</code>-Merkmal bereitgestellte 
Iterationsverhalten wiederverwendet wird.</p>
<h3 id="verwendung-von-funktionsabschlüssen-die-ihre-umgebung-erfassen"><a class="header" href="#verwendung-von-funktionsabschlüssen-die-ihre-umgebung-erfassen">Verwendung von Funktionsabschlüssen die ihre Umgebung erfassen</a></h3>
<p>Nun, da wir uns ein wenig mit Iteratoren befasst haben, werden wir anhand
des <code>filter</code>-Iteratoradapters eine häufige Verwendung von Funktionsabschlüssen
die ihre Umgebung erfassen zeigen. Die <code>filter</code>-Methode eines Iterators nimmt
einen Funktionsabschluss als Argument, der für jedes Element des Iterators
einen booleschen Wert zurückgibt. Wenn der Funktionsabschluss <code>true</code>
zurückgibt, wird der Wert in den von <code>filter</code> erzeugten Iterator aufgenommen,
wird <code>false</code> zurückgegeben, ist der Wert im resultierenden Iterator nicht
enthalten.</p>
<p>Im Codeblock 13-19 benutzen wir <code>filter</code> mit einem Funktionsabschluss, der die
Variable <code>shoe_size</code> aus seiner Umgebung erfasst, um über eine Kollektion von
<code>shoe</code>-Strukturinstanzen zu iterieren. Er wird nur Schuhe (shoes) einer
bestimmten Größe zurückgeben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from(&quot;sneaker&quot;),
            },
            Shoe {
                size: 13,
                style: String::from(&quot;sandal&quot;),
            },
            Shoe {
                size: 10,
                style: String::from(&quot;boot&quot;),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from(&quot;sneaker&quot;)
                },
                Shoe {
                    size: 10,
                    style: String::from(&quot;boot&quot;)
                },
            ]
        );
    }
}
</code></pre>
<p><span class="caption">Codeblock 13-19: Die <code>filter</code>-Methode mit einen
Funktionsabschluss benutzen der <code>shoe_size</code> erfasst</span></p>
<p>Die <code>shoes_in_size</code>-Funktion übernimmt die Eigentümerschaft über einen Vektor
aus Schuhen mit der Schuhgröße als Parameter und gibt einen Vektor zurück, der
nur Schuhe einer bestimmten Größe enthält.</p>
<p>Im Funktionsrumpf von <code>shoes_in_size</code> rufen wir <code>into_iter</code> auf, um einen
Iterator zu erzeugen, der die Eigentümerschaft vom Vektor übernimmt. Im Anschluss
rufen wir den <code>filter</code>-Adapter auf, um einen neuen Iterator zu erzeugen, der nur
Elemente enthält, für die der Funktionsabschluss <code>true</code> zurückgibt.</p>
<p>Der Funktionsabschluss erfasst den <code>shoe_size</code>-Parameter aus seiner Umgebung und
vergleicht dessen Wert mit der jeweiligen Schuhgröße und behält nur Schuhe der
gewählten Größe. Zuletzt sammelt der Aufruf der <code>collect</code>-Methode die
zurückgegeben Werte des angeschlossenen Adapters in den Vektor, der von der
Funktion zurückgegeben wird.</p>
<p>Der Test zeigt, wenn wir <code>shoes_in_size</code> aufrufen, bekommen wir nur Schuhe
der spezifizierten Größe zurück.</p>
<h3 id="mit-dem-iterator-merkmal-eigene-iteratoren-erstellen"><a class="header" href="#mit-dem-iterator-merkmal-eigene-iteratoren-erstellen">Mit dem <code>Iterator</code>-Merkmal eigene Iteratoren erstellen</a></h3>
<p>Wir haben bereits gezeigt, wie man mit <code>iter</code>, <code>into_iter</code> und <code>iter_mut</code> einen
Iterator zu einem Vektor erstellen kann. Du kannst Iteratoren
auch aus anderen Kollektion-Typen der Standardbibliothek wie zum Beispiel einer 
Hashtabelle (hash map) herstellen. Du kannst auch beliebige Iteratoren
durch Implementierung des <code>Iterator</code>-Merkmals auf eigene Typen erstellen. 
Wie bereits erwähnt ist die einzige Methode, für die du eine Definition angeben
musst, die <code>next</code>-Methode. Sobald man das getan hat, kann man alle anderen
Methoden verwenden, die die Standardimplementierung des <code>Iterator</code>-Merkmals
bereitstellt.</p>
<p>Erstellen wir nun einen Iterator zur Demonstration, der immer nur von 1 bis 5 zählt.
Zunächst erstellen wir eine Struktur, die einige Werte enthält, anschließend
machen wir aus dieser Struktur einen Iterator, indem wir das <code>Iterator</code>-Merkmal
implementieren und die Werte in dieser Implementierung benutzen.</p>
<p>Codeblock 13-20 enthält die Definition einer <code>Counter</code>-Struktur und eine
zugehörige <code>new</code>-Funktion zur Erstellung von Instanzen von <code>Counter</code>:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
</code></pre>
<p><span class="caption">Codeblock 13-20: Definition einer <code>Counter</code>-Struktur und einer
Funktion <code>new</code> die Instanzen von <code>Counter</code> mit einem Startwert 0 für <code>count</code> erstellt</span></p>
<p>Die <code>Counter</code>-Struktur beinhaltet ein Feld <code>count</code>, dieses Feld hält einen
<code>u32</code>-Wert der den aktuellen Status der Iteration von 1 bis 5 wiedergibt. Das
Feld <code>count</code> ist privat, da wir möchten, das die Implementierung von <code>Counter</code>
den Wert verwaltet. Die <code>new</code>-Funktion erzwingt, dass neue Instanzen stets mit
einem Wert 0 im <code>count</code>-Feld beginnen.</p>
<p>Als Nächstes werden wir das <code>Iterator</code>-Merkmal für unseren <code>Counter</code>-Typ
implementieren, indem wir den Rumpf der <code>next</code>-Methode so definieren, das er
beinhaltet was wir geschehen lassen möchten, wenn der Iterator benutzt wird.
Siehe Codeblock 12-21:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">struct Counter {
</span><span class="boring">   count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">   fn new() -&gt; Counter {
</span><span class="boring">       Counter { count: 0 }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
</code></pre>
<p><span class="caption">Codeblock 13-21: Implementierung des <code>Iterator</code>-Merkmals für
die <code>Counter</code>-Struktur</span></p>
<p>Wir setzen den zugehörigen Typ unseres Iterators auf <code>u32</code>, was bedeutet, dass 
der Iterator <code>u32</code>-Werte zurückgibt. Nochmals, kümmere dich derzeit nicht um 
zugehörige Typen, wir werden sie in Kapitel 19 behandeln.</p>
<p>Wir möchten, dass unser Iterator 1 zum aktuellen Wert hinzufügt, daher haben wir 
<code>count</code> mit 0 initialisiert. Damit er zuerst 1 zurückgibt, wenn der Wert von
<code>count</code> kleiner als 5 ist, erhöht <code>next</code> <code>count</code> und gibt den aktuellen Wert
zurück, der in <code>Some</code> eingeschlossen ist. Wenn <code>count</code> gleich 5 ist, stoppt
unser Iterator das Inkrementieren und gibt immer <code>None</code> zurück.</p>
<h4 id="verwendung-der-next-methode-unseres-counter-iterators"><a class="header" href="#verwendung-der-next-methode-unseres-counter-iterators">Verwendung der <code>next</code>-Methode unseres <code>Counter</code>-Iterators</a></h4>
<p>Sobald wir das <code>Iterator</code>-Merkmal implementiert haben, verfügen wir über einen
Iterator! Codeblock 13-22 zeigt mittels Test, dass wir die
<code>Iterator</code>-Funktionalität unserer <code>Counter</code>-Funktion benutzen können, indem wir
die <code>next</code>-Methode direkt auf ihn verwenden, so wie wir es mit dem von einem
Vektor erzeugten Iterator im Codeblock 13-15 gemacht haben.</p>
<p><span class="filename">Codeblock: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn calling_next_directly() {
        let mut counter = Counter::new();

        assert_eq!(counter.next(), Some(1));
        assert_eq!(counter.next(), Some(2));
        assert_eq!(counter.next(), Some(3));
        assert_eq!(counter.next(), Some(4));
        assert_eq!(counter.next(), Some(5));
        assert_eq!(counter.next(), None);
    }
<span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 13-22: Testen der Funktionalität der
Implementierung der <code>next</code>-Methode</span></p>
<p>Dieser Test erstellt eine neue Instanz von <code>Counter</code> in der <code>counter</code>-Variable
und ruft dann wiederholt <code>next</code> auf, um zu überprüfen, ob wir das Verhalten
entsprechend implementiert haben und der Iterator die Werte von 1 bis 5
zurückgibt.</p>
<h4 id="verwendung-anderer-iterator-merkmalsmethoden"><a class="header" href="#verwendung-anderer-iterator-merkmalsmethoden">Verwendung anderer <code>Iterator</code>-Merkmalsmethoden</a></h4>
<p>Da wir das <code>Iterator</code>-Merkmal durch implementieren der <code>next</code>-Methode
eingerichtet haben, können wir nun beliebige Methoden der
Standardimplementierung des <code>Iterator</code>-Merkmals benutzen, da sie alle die
Funktionalität der <code>next</code>-Methode verwenden.</p>
<p>Wenn wir beispielsweise die Werte übernehmen  und sie mit den Werten
einer anderen <code>Counter</code>-Instanz koppeln wollen und nach dem Überspringen des
ersten Wertes der anderen Instanz jedes Zahlenpaar miteinander multiplizieren
dabei allerdings nur die Werte behalten, die durch 3 teilbar sind, und diese dann
summieren möchten, können wir das wie im Codeblock 13-23 beschrieben erreichen:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn calling_next_directly() {
</span><span class="boring">        let mut counter = Counter::new();
</span><span class="boring">
</span><span class="boring">        assert_eq!(counter.next(), Some(1));
</span><span class="boring">        assert_eq!(counter.next(), Some(2));
</span><span class="boring">        assert_eq!(counter.next(), Some(3));
</span><span class="boring">        assert_eq!(counter.next(), Some(4));
</span><span class="boring">        assert_eq!(counter.next(), Some(5));
</span><span class="boring">        assert_eq!(counter.next(), None);
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn using_other_iterator_trait_methods() {
        let sum: u32 = Counter::new()
            .zip(Counter::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, sum);
    }
<span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 13-23: Benutzung einer Auswahl von <code>Iterator</code>-Merkmal
Methoden auf unseren <code>Counter</code>-Iterator</span></p>
<p>Beachte, dass <code>zip</code> nur vier Paare erzeugt. Das theoretische fünfte Paar <code>(5, None)</code> wird nicht erzeugt da <code>zip</code> <code>None</code> zurückgibt wenn einer seiner
Eingabeiteratoren <code>None</code> zurückgibt.</p>
<p>Alle diese Methodenaufrufe sind möglich, da wir angegeben haben wie die
<code>next</code>-Methode in <code>Counter</code> funktioniert und die Standardbibliothek für andere
Methoden, die <code>next</code> aufrufen, Standardimplementierungen bereitstellt.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch13-01-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch13-03-improving-our-io-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch13-01-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch13-03-improving-our-io-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="theme/ferris.js"></script>
        

        

    </body>
</html>
