<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Charakteristiken objektorientierter Sprachen - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="charakteristiken-objektorientierter-sprachen"><a class="header" href="#charakteristiken-objektorientierter-sprachen">Charakteristiken objektorientierter Sprachen</a></h2>
<p>Es gibt in der Programmierergemeinschaft keinen Konsens darüber, welche
Funktionalitäten eine Sprache haben muss, um als objektorientiert zu gelten.
Rust wird von vielen Programmierparadigmen beeinflusst, einschließlich OOP; zum
Beispiel haben wir in Kapitel 13 die Funktionalitäten untersucht, die aus der
funktionalen Programmierung stammen. Die OOP-Sprachen haben wohl bestimmte
gemeinsame Charakteristiken, nämlich Objekte, Kapselung (encapsulation) und
Vererbung (inheritance). Schauen wir uns an, was jedes dieser Charakteristiken
bedeutet und ob Rust es unterstützt.</p>
<h3 id="objekte-enthalten-daten-und-verhalten"><a class="header" href="#objekte-enthalten-daten-und-verhalten">Objekte enthalten Daten und Verhalten</a></h3>
<p>Das Buch <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> von
Erich Gamma, Richard Helm, Ralph Johnson und John Vlissides (Addison-Wesley,
1994), umgangssprachlich als <em>The Gang of Four</em>-Buch bezeichnet, ist ein
Katalog von objektorientierten Entwurfsmustern. Es definiert OOP auf folgende
Weise:</p>
<blockquote>
<p>Objektorientierte Programme setzen sich aus Objekten zusammen. Ein <strong>Objekt</strong>
verpackt sowohl Daten als auch Prozeduren, die auf diesen Daten operieren.
Die Prozeduren werden normalerweise <strong>Methoden</strong> oder <strong>Operationen</strong>
genannt.</p>
</blockquote>
<p>Mit dieser Definition ist Rust objektorientiert: Strukturen (structs) und
Aufzählungen (enums) haben Daten, und <code>impl</code>-Blöcke stellen Methoden auf
Strukturen und Aufzählungen zur Verfügung. Auch wenn Strukturen und
Aufzählungen mit Methoden keine <em>aufgerufenen</em> Objekte sind, bieten sie
dieselbe Funktionalität gemäß der Definition von Objekten der Gang of Four.</p>
<h3 id="kapselung-die-implementierungsdetails-verbirgt"><a class="header" href="#kapselung-die-implementierungsdetails-verbirgt">Kapselung, die Implementierungsdetails verbirgt</a></h3>
<p>Ein weiterer Aspekt, der gemeinhin mit OOP in Verbindung gebracht wird, ist die
Idee der <em>Kapselung</em> (encapsulation), was bedeutet, dass die
Implementierungsdetails eines Objekts nicht zugänglich sind für Code, der
dieses Objekt verwendet. Daher ist die einzige Möglichkeit, mit einem Objekt zu
interagieren, seine öffentliche API; Code, der das Objekt verwendet, sollte
nicht in der Lage sein, in die Interna des Objekts einzudringen und Daten oder
Verhalten direkt zu ändern. Dies ermöglicht es dem Programmierer, die Interna
eines Objekts zu ändern und umzugestalten, ohne Code ändern zu müssen, der das
Objekt verwendet.</p>
<p>Wie man die Kapselung steuert, haben wir in Kapitel 7 besprochen: Wir können
das Schlüsselwort <code>pub</code> benutzen, um zu entscheiden, welche Module, Typen,
Funktionen und Methoden in unserem Code öffentlich sein sollen, alles andere
ist standardmäßig privat. Zum Beispiel können wir eine Struktur
<code>AveragedCollection</code> definieren, die ein Feld hat, das einen Vektor mit
<code>i32</code>-Werten enthält. Die Struktur kann auch ein Feld haben, das den Mittelwert
der Werte im Vektor enthält, was bedeutet, dass der Mittelwert nicht auf
Anfrage berechnet werden muss, wenn jemand ihn braucht. Mit anderen Worten:
<code>AveragedCollection</code> wird den errechneten Durchschnitt für uns
zwischenspeichern. Codeblock 18-1 zeigt die Definition der Struktur
<code>AveragedCollection</code>:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-1: Eine Struktur <code>AveragedCollection</code>, die
eine Liste von ganzen Zahlen und den Durchschnitt der Elemente in der
Kollektion verwaltet</span></p>
<p>Die Struktur wird als <code>pub</code> markiert, damit anderer Code sie verwenden kann,
aber die Felder innerhalb der Struktur bleiben privat. Dies ist in diesem Fall
wichtig, weil wir sicherstellen wollen, dass immer dann, wenn ein Wert
hinzugefügt oder aus der Liste entfernt wird, auch der Durchschnitt
aktualisiert wird. Wir tun dies, indem wir die Methoden <code>add</code>, <code>remove</code> und
<code>average</code> auf der Struktur implementieren, wie in Codeblock 18-2 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 18-2: Implementierungen der öffentlichen
Methoden <code>add</code>, <code>remove</code> und <code>average</code> auf  <code>AveragedCollection</code></span></p>
<p>Die öffentlichen Methoden <code>add</code>, <code>remove</code> und <code>average</code> sind die einzigen
Möglichkeiten, auf Daten in einer <code>AveragedCollection</code>-Instanz zuzugreifen oder
sie zu ändern. Wenn ein Eintrag mit der Methode <code>add</code> zu <code>list</code> hinzugefügt
oder mit der Methode <code>remove</code> entfernt wird, rufen die Implementierungen der
einzelnen Methoden die private Methode <code>update_average</code> auf, die auch das
Aktualisieren des Feldes <code>average</code> übernimmt.</p>
<p>Wir lassen die Felder <code>list</code> und <code>average</code> privat, sodass es keine Möglichkeit
für externen Code gibt, Elemente direkt zum Feld <code>list</code> hinzuzufügen oder zu
entfernen; andernfalls könnte das Feld <code>average</code> inkonsistent werden, wenn sich
<code>list</code> ändert. Die Methode <code>average</code> gibt den Wert im Feld <code>average</code> zurück,
sodass externer Code den Wert <code>average</code> lesen, aber nicht verändern kann.</p>
<p>Da wir die Implementierungsdetails der Struktur <code>AveragedCollection</code> gekapselt
haben, können wir Aspekte, z.B. die Datenstruktur, in Zukunft leicht ändern.
Zum Beispiel könnten wir ein <code>HashSet&lt;i32&gt;</code> anstelle eines <code>Vec&lt;i32&gt;</code> für das
<code>list</code>-Feld verwenden. Solange die Signaturen der öffentlichen Methoden <code>add</code>,
<code>remove</code> und <code>average</code> gleich bleiben, würde Code, der <code>AveragedCollection</code>
verwendet, nicht geändert werden müssen damit er kompiliert. Wenn wir
stattdessen <code>list</code> öffentlich machen würden, wäre dies nicht unbedingt der
Fall: <code>HashSet&lt;i32&gt;</code> und <code>Vec&lt;i32&gt;</code> haben unterschiedliche Methoden zum
Hinzufügen und Entfernen von Elementen, sodass externer Code wahrscheinlich
geändert werden müsste, wenn er <code>list</code> direkt modifizieren würde.</p>
<p>Wenn die Kapselung ein erforderlicher Aspekt ist, damit eine Sprache als
objektorientiert betrachtet werden kann, dann erfüllt Rust diese Anforderung.
Die Möglichkeit, <code>pub</code> für verschiedene Teile des Codes zu verwenden oder auch
nicht, ermöglicht die Kapselung von Implementierungsdetails.</p>
<h3 id="vererbung-als-typsystem-und-für-gemeinsamen-code"><a class="header" href="#vererbung-als-typsystem-und-für-gemeinsamen-code">Vererbung als Typsystem und für gemeinsamen Code</a></h3>
<p><em>Vererbung</em> ist ein Mechanismus, mit dem ein Objekt Elemente von der Definition
eines anderen Objekts erben kann und so die Daten und das Verhalten des
übergeordneten Objekts erhält, ohne dass du diese erneut definieren musst.</p>
<p>Wenn eine Programmiersprache Vererbung haben muss, um objektorientiert zu sein,
dann ist Rust keine solche Sprache. Es gibt keine Möglichkeit, eine Struktur zu
definieren, die die Felder und Methodenimplementierungen der Elternstruktur
erbt, ohne ein Makro zu benutzen.</p>
<p>Wenn du jedoch daran gewöhnt bist, Vererbung in deinem
Programmierwerkzeugkasten zu haben, kannst du in Rust andere Lösungen
verwenden, je nachdem, warum du überhaupt zu Vererbung gegriffen hast.</p>
<p>Du würdest dich aus zwei Hauptgründen für die Vererbung entscheiden. Einer ist
die Wiederverwendung von Code: Du kannst ein bestimmtes Verhalten für einen Typ
implementieren und die Vererbung ermöglicht es dir, diese Implementierung für
einen anderen Typ wiederzuverwenden. Du kannst das auf begrenzte Weise in
Rust-Code unter Verwendung von Standard-Merkmalsmethoden-Implementierungen tun,
was du in Codeblock 10-14 gesehen hast, als wir eine Standard-Implementierung
der Methode <code>summarize</code> für das Merkmal (trait) <code>Summary</code> hinzugefügt haben.
Jeder Typ, der das Merkmal <code>Summary</code> implementiert, hätte die Methode
<code>summarize</code> ohne weiteren Code darauf zur Verfügung. Dies ist vergleichbar mit
einer Elternklasse, die eine Implementierung einer Methode hat, und einer
erbenden Kindklasse, die ebenfalls die Implementierung der Methode hat. Wir
können auch die Standard-Implementierung der Methode <code>summarize</code> außer Kraft
setzen, wenn wir das Markmal <code>Summary</code> implementieren, die einer Kindklasse
ähnelt, die die Implementierung einer von einer Elternklasse geerbten Methode
außer Kraft setzt.</p>
<p>Der andere Grund, Vererbung zu verwenden, bezieht sich auf das Typsystem: Ein
untergeordneter Typ soll an den gleichen Stellen wie der übergeordnete Typ
verwendet werden können. Dies wird auch <em>Polymorphismus</em> (polymorphism)
genannt, d.h. du kannst mehrere Objekte zur Laufzeit gegeneinander austauschen,
wenn sie bestimmte Eigenschaften gemeinsam haben.</p>
<blockquote>
<h3 id="polymorphismus"><a class="header" href="#polymorphismus">Polymorphismus</a></h3>
<p>Für viele Menschen ist Polymorphismus gleichbedeutend mit Vererbung. Aber es
ist eigentlich ein allgemeinerer Begriff, der sich auf Code bezieht, der mit
Daten unterschiedlichen Typs arbeiten kann. Für die Vererbung sind diese
Typen im Allgemeinen Unterklassen.</p>
<p>Rust verwendet stattdessen generische Datentypen (generics), um über
verschiedene mögliche Typen und Merkmalsabgrenzungen (trait bounds) zu
abstrahieren, um Beschränkungen für das aufzuerlegen, was diese Typen bieten
müssen. Dies wird manchmal als <em>begrenzter parametrischer Polymorphismus</em>
(bounded parametric polymorphism) bezeichnet.</p>
</blockquote>
<p>Die Vererbung ist in letzter Zeit als Lösung für das Programmierdesign in
vielen Programmiersprachen in Ungnade gefallen, da sie oft das Risiko birgt,
mehr Code als nötig zu teilen. Unterklassen sollten nicht immer alle
Charakteristiken ihrer Elternklasse teilen, bei Vererbung tun sie es aber. Dies
kann den Programmentwurf weniger flexibel machen. Es wird auch die Möglichkeit
eingeführt, Methoden auf Unterklassen aufzurufen, die keinen Sinn machen oder
die Fehler verursachen, weil die Methoden nicht auf die Unterklasse zutreffen.
Darüber hinaus lassen einige Sprachen nur Einfachvererbung zu (d.h. eine
Unterklasse kann nur von einer Klasse erben), was die Flexibilität des
Programmdesigns weiter einschränkt.</p>
<p>Aus diesen Gründen verfolgt Rust den anderen Ansatz durch Verwendung von
Merkmalsobjekten (trait objects) anstelle der Vererbung. Schauen wir uns an,
wie Merkmalsobjekte Polymorphismus in Rust ermöglichen.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-00-oop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch18-02-trait-objects.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-00-oop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch18-02-trait-objects.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
