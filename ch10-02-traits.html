<!DOCTYPE HTML>
<html lang="de" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Merkmale (traits): Gemeinsames Verhalten definieren - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Die Programmiersprache Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Vorwort</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Einführung</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Erste Schritte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hallo Welt</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hallo Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Ein Ratespiel programmieren</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Allgemeine Programmierkonzepte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variablen und Veränderlichkeit</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Datentypen</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funktionen</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Kommentare</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrollfluss</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Eigentümerschaft (ownership) verstehen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Was ist Eigentümerschaft (ownership)?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referenzen und Ausleihen (borrowing)</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Der Anteilstyp (slice)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Strukturen (structs) für zusammenhängende Daten verwenden</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Strukturen (structs) definieren und instanziieren</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Beispielprogramm mit Strukturen (structs)</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Methodensyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Aufzählungen (enums) und Musterabgleich (pattern matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Eine Aufzählung (enum) definieren</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Der Kontrollflussoperator match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Prägnanter Kontrollfluss mit if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Wachsende Projekte verwalten mit Paketen (packages), Kisten (crates) und Modulen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Pakete (packages) und Kisten (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Mit Modulen den Kontrollumfang und Datenschutz steuern</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Mit Pfaden auf ein Element im Modulbaum verweisen</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Pfade in den Gültigkeitsbereich bringen mit dem Schlüsselwort use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Module in verschiedene Dateien aufteilen</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Allgemeine Kollektionen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Wertlisten in Vektoren ablegen</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8-kodierten Text in Zeichenketten (strings) ablegen</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Schlüssel mit zugehörigen Werten in Hashtabellen ablegen</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Fehlerbehandlung</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Nicht behebbare Fehler mit panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Behebbare Fehler mit Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Wann panic! aufrufen und wann nicht?</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generische Typen, Merkmale (traits) und Lebensdauer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generische Datentypen</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html" class="active"><strong aria-hidden="true">10.2.</strong> Merkmale (traits): Gemeinsames Verhalten definieren</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referenzen validieren mit Lebensdauern</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Automatisierte Tests schreiben</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Tests schreiben</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Steuern wie Tests ausgeführt werden</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Testverwaltung</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Ein E/A-Projekt: Ein Kommandozeilenprogramm erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Kommandozeilenargumente entgegennehmen</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Eine Datei einlesen</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Bibliotheksfunktionalität mit testgetriebener Entwicklung erstellen</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Mit Umgebungsvariablen arbeiten</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Fehlermeldungen in die Standardfehlerausgabe anstatt der Standardausgabe schreiben</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Funktionale Sprachelemente: Iteratoren und Funktionsabschlüsse (closures)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Funktionsabschlüsse (closures): Anonyme Funktionen die ihre Umgebung erfassen können</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Eine Reihe von Elementen verarbeiten mit Iteratoren</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Unser E/A-Projekt verbessern</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performanzvergleich: Schleifen vs. Iteratoren</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Mehr über Cargo und Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Bauvorgang anpassen mit Freigabeprofilen (release profiles)</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Kisten (crate) auf crates.io veröffentlichen</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo-Arbeitsbereiche</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Kommandozeilenwerkzeuge von crates.io installieren mit cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Cargo um benutzerdefinierte Befehle erweitern</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Intelligente Zeiger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Mit Box&lt;T&gt; auf Daten im Haldenspeicher zeigen</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Programmcode beim Aufräumen ausführen mit dem Merkmal (trait) Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Der referenzzählende intelligente Zeiger Rc&lt;T&gt;</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; und das innere Veränderlichkeitsmuster</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referenzzyklen können zu einem Speicherleck führen</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Furchtlose Nebenläufigkeit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Mit Strängen (threads) Programmcode gleichzeitig ausführen</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Nachrichtenaustausch zwischen Strängen (threads)</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Nebenläufigkeit mit gemeinsamem Zustand</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) Sync und Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Objektorientierte Sprachelemente von Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Charakteristiken objektorientierter Sprachen</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen erlauben</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Ein objektorientiertes Entwurfsmuster implementieren</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Muster (patterns) und Abgleich (matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Alle Stellen an denen Muster (patterns) verwendet werden können</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Abweisbarkeit: Falls ein Muster (pattern) mal nicht passt</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Mustersyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Fortgeschrittene Sprachelemente</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsicheres (unsafe) Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Fortgeschrittene Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Fortgeschrittene Typen</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Erweiterte Funktionen und Funktionsabschlüsse (closures)</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Abschlussprojekt: Einen mehrsträngigen (multi-threaded) Webserver erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Einen einsträngigen (single-threaded) Webserver erstellen</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Unseren einsträngigen (single-threaded) Webserver in einen mehrsträngigen (multi-threaded) Webserver verwandeln</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Kontrolliertes Beenden und Aufräumen</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Anhang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Schlüsselwörter</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatoren und Symbole</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Ableitbare Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Nützliche Entwicklungswerkzeuge</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ausgaben</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Übersetzungen des Buchs</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Wie Rust erstellt wird und „nächtliches Rust“</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="merkmale-traits-gemeinsames-verhalten-definieren"><a class="header" href="#merkmale-traits-gemeinsames-verhalten-definieren">Merkmale (traits): Gemeinsames Verhalten definieren</a></h2>
<p>Ein <em>Merkmal</em> (trait) teilt dem Rust-Compiler mit, welche Funktionalität ein
bestimmter Typ hat und mit anderen Typen teilen kann. Wir können Merkmale
verwenden, um gemeinsames Verhalten auf abstrakte Weise zu definieren. Wir
können Merkmalsabgrenzungen (trait bounds) verwenden, um anzugeben, dass ein
generischer Typ jeder Typ sein kann, der ein bestimmtes Verhalten aufweist.</p>
<blockquote>
<p>Anmerkung: Merkmale sind einer Funktionalität recht ähnlich, die in anderen
Sprachen oft <em>Schnittstelle</em> (interface) genannt wird, wenn auch mit einigen
Unterschieden.</p>
</blockquote>
<h3 id="ein-merkmal-definieren"><a class="header" href="#ein-merkmal-definieren">Ein Merkmal definieren</a></h3>
<p>Das Verhalten eines Typs besteht aus den Methoden, die wir auf diesen Typ
anwenden können. Verschiedene Typen haben das gleiche Verhalten, wenn wir bei
allen die gleichen Methoden aufrufen können. Merkmalsdefinitionen sind eine
Möglichkeit, Methodensignaturen zu gruppieren, um eine Reihe von
Verhaltensweisen zu definieren, die zum Erreichen eines bestimmten Zwecks
erforderlich sind.</p>
<p>Nehmen wir zum Beispiel an, wir haben mehrere Strukturen (structs), die
verschiedene Arten und Mengen von Text enthalten: Eine Struktur <code>NewsArticle</code>,
die eine Nachricht enthält, die sich auf einen bestimmten Ort bezieht, und ein
<code>Tweet</code>, der maximal 280 Zeichen umfassen kann, sowie Metadaten, die angeben,
ob es sich um eine neue Kurznachricht, eine Wiederholung oder eine Antwort auf
eine andere Kurznachricht handelt.</p>
<p>Wir wollen eine Medienaggregator-Bibliothek erstellen, die Zusammenfassungen
von Daten anzeigen kann, die in einer <code>NewsArticle</code>- oder <code>Tweet</code>-Instanz
gespeichert sind. Dazu benötigen wir eine Zusammenfassung für jeden Typ und wir
wollen diese Zusammenfassung anfordern, indem wir eine Methode <code>summarize</code> der
Instanz aufrufen. Codeblock 10-12 zeigt die Definition eines Merkmals
<code>Summary</code>, das dieses Verhalten zum Ausdruck bringt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-12: Ein Merkmal <code>Summary</code>, dessen Verhalten
aus der Methode <code>summarize</code> besteht</span></p>
<p>Hier deklarieren wir ein Merkmal mit dem Schlüsselwort <code>trait</code> und dann den
Namen des Merkmals, der in diesem Fall <code>Summary</code> lautet. Innerhalb der
geschweiften Klammern deklarieren wir die Methodensignaturen, die das Verhalten
der Typen beschreiben, die dieses Merkmal implementieren, was in diesem Fall
<code>fn summarize(&amp;self) -&gt; String</code> ist.</p>
<p>Nach der Methodensignatur verwenden wir statt einer Implementierung in
geschweiften Klammern ein Semikolon. Jeder Typ, der dieses Merkmal
implementiert, muss sein eigenes benutzerdefiniertes Verhalten für den
Methodenrumpf bereitstellen. Der Compiler wird sicherstellen, dass jeder
Typ, der das Merkmal <code>Summary</code> hat, die Methode <code>summarize</code> mit genau dieser
Signatur hat.</p>
<p>Ein Merkmal kann mehrere Methoden umfassen: Die Methodensignaturen werden
zeilenweise aufgelistet und jede Zeile endet mit einem Semikolon.</p>
<h3 id="ein-merkmal-für-einen-typ-implementieren"><a class="header" href="#ein-merkmal-für-einen-typ-implementieren">Ein Merkmal für einen Typ implementieren</a></h3>
<p>Da wir nun das gewünschte Verhalten mithilfe des Merkmals <code>Summary</code> definiert
haben, können wir es für die Typen unseres Medienaggregators implementieren. 
Codeblock 10-13 zeigt eine Implementierung des Merkmals <code>Summary</code> für die
Struktur <code>NewsArticle</code>, die die Überschrift, den Autor und den Ort verwendet,
um den Rückgabewert von <code>summarize</code> zu erzeugen. Für die Struktur <code>Tweet</code>
definieren wir <code>summarize</code> als den Benutzernamen, gefolgt vom gesamten Text der
Kurznachricht, wobei wir davon ausgehen, dass der Inhalt der Kurznachricht
bereits auf 280 Zeichen begrenzt ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, von {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-13: Implementierung des Merkmals <code>Summary</code>
für die Typen <code>NewsArticle</code> und <code>Tweet</code></span></p>
<p>Die Implementierung eines Merkmals für einen Typ ist ähnlich zur
Implementierung regulärer Methoden. Der Unterschied besteht darin, dass wir
nach <code>impl</code> den Namen des Merkmals schreiben, das wir implementieren wollen,
dann das Schlüsselwort <code>for</code> gefolgt vom Namen des Typs angeben, für den wir
das Merkmal implementieren wollen. Innerhalb des <code>impl</code>-Blocks geben wir die
Methodensignaturen an, die das Merkmal vorgibt. Anstatt nach jeder Signatur ein
Semikolon zu schreiben, verwenden wir geschweifte Klammern und füllen den
Methodenrumpf mit dem spezifischen Verhalten, das die Methoden des Merkmals für
den jeweiligen Typ haben sollen.</p>
<p>Nachdem wir das Merkmal implementiert haben, können wir die Methoden der
<code>NewsArticle</code>- und <code>Tweet</code>-Instanzen auf die gleiche Weise aufrufen, wie wir
reguläre Methoden aufrufen, etwa so:</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;natürlich, wie du wahrscheinlich schon weißt&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 neue Kurznachricht: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>Dieser Code gibt <code>1 neue Kurznachricht: horse_ebooks: natürlich, wie du wahrscheinlich schon weißt</code> aus.</p>
<p>Beachte, dass wir in Codeblock 10-13 das Merkmal <code>Summary</code> und die Typen
<code>NewsArticle</code> und <code>Tweet</code> in der gleichen Datei <em>lib.rs</em> definiert haben,
sodass sie alle im gleichen Gültigkeitsbereich liegen. Nehmen wir an, diese
Datei <em>lib.rs</em> ist für eine Kiste (crate), die wir <code>aggregator</code> genannt haben,
und jemand anderes möchte die Funktionalität unserer Kiste nutzen, um das
Merkmal <code>Summary</code> für eine Struktur innerhalb des Gültigkeitsbereichs seiner
Bibliothek zu implementieren. Dann muss er das Merkmal erst in seinen
Gültigkeitsbereich bringen. Er würde dies durch Angeben von
<code>use aggregator::Summary;</code> tun, was es ihm dann ermöglichen würde,<code>Summary</code> für
seinen Typ zu implementieren. Das Merkmal <code>Summary</code> müsste auch ein
öffentliches Merkmal für eine andere Kiste sein, um sie zu implementieren, was
auch der Fall ist, weil wir in Codeblock 10-12 das Schlüsselwort <code>pub</code> vor das
Merkmal <code>trait</code> gestellt haben.</p>
<p>Eine Einschränkung, die bei der Implementierung von Merkmalen zu beachten ist,
ist, dass wir ein Merkmal für einen Typ nur dann implementieren können, wenn
entweder das Merkmal oder der Typ lokal in unserer Kiste vorhanden ist. Zum
Beispiel können wir Standard-Bibliotheksmerkmale wie <code>Display</code> auf einem
benutzerdefinierten Typ wie <code>Tweet</code> als Teil unserer
<code>aggregator</code>-Kistenfunktionalität implementieren, weil der Typ <code>Tweet</code> lokal zu
unserer <code>aggregator</code>-Kiste gehört. Wir können auch <code>Summary</code> auf <code>Vec&lt;T&gt;</code> in
unserer <code>aggregator</code>-Kiste implementieren, weil das Merkmal <code>Summary</code> lokal zu
unserer <code>aggregator</code>-Kiste gehört.</p>
<p>Aber wir können externe Merkmale nicht auf externe Typen anwenden. Zum Beispiel
können wir das Merkmal <code>Display</code> auf <code>Vec&lt;T&gt;</code> in unserer <code>aggregator</code>-Kiste
nicht implementieren, weil <code>Display</code> und <code>Vec&lt;T&gt;</code> in der Standardbibliothek
definiert sind und nicht lokal zu unserer <code>aggregator</code>-Kiste gehören. Diese
Beschränkung ist Teil einer Eigenschaft von Programmen namens <em>Kohärenz</em>
(coherence), genauer gesagt der <em>Waisenregel</em> (orphan rule), die so genannt
wird, weil der übergeordnete Typ nicht vorhanden ist. Diese Regel stellt
sicher, dass der Code anderer Personen deinen Code nicht brechen kann und
umgekehrt. Ohne diese Regel könnten zwei Kisten dasselbe Merkmal für denselben
Typ implementieren und Rust wüsste nicht, welche Implementierung es verwenden
sollte.</p>
<h3 id="standard-implementierungen"><a class="header" href="#standard-implementierungen">Standard-Implementierungen</a></h3>
<p>Manchmal ist es nützlich, ein Standardverhalten für einige oder alle Methoden
eines Merkmals zu haben, anstatt Implementierungen für alle Methoden für jeden
Typ zu verlangen. Wenn wir dann das Merkmal für einen bestimmten Typ
implementieren, können wir das Standardverhalten jeder Methode beibehalten oder
überschreiben.</p>
<p>Codeblock 10-14 zeigt, wie man eine Standard-Zeichenkette für die Methode
<code>summarize</code> des Merkmals <code>Summary</code> angibt, anstatt nur die Methodensignatur zu
definieren, wie wir es in Codeblock 10-12 getan haben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Lies mehr ...)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-14: Definition eines Merkmals <code>Summary</code> mit
einer Standard-Implementierung der Methode <code>summarize</code></span></p>
<p>Um eine Standard-Implementierung zu verwenden, um Instanzen von <code>NewsArticle</code>
zusammenzufassen, anstatt eine benutzerdefinierte Implementierung zu
definieren, geben wir einen leeren <code>impl</code>-Block mit <code>impl Summary for NewsArticle {}</code> an.</p>
<p>Auch wenn wir die Methode <code>summarize</code> nicht mehr direkt für <code>NewsArticle</code>
definieren, haben wir eine Standard-Implementierung bereitgestellt und
festgelegt, dass <code>NewsArticle</code> das Merkmal <code>Summary</code> implementiert.
Infolgedessen können wir immer noch die Methode <code>summarize</code> einer
<code>NewsArticle</code>-Instanz aufrufen, etwa so:</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from(&quot;Pinguine gewinnen die Stanley-Cup-Meisterschaft!&quot;),
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        author: String::from(&quot;Iceburgh&quot;),
        content: String::from(&quot;Die Pittsburgh Penguins sind erneut die beste \
                               Eishockeymannschaft in der NHL.&quot;,
        ),
    };

    println!(&quot;Neuer Artikel verfügbar! {}&quot;, article.summarize());
<span class="boring">}
</span></code></pre>
<p>Dieser Code gibt <code>Neuer Artikel verfügbar! (Lies mehr ...)</code> aus.</p>
<p>Das Erstellen einer Standard-Implementierung für <code>summarize</code> erfordert nicht,
dass wir an der Implementierung von <code>Summary</code> für <code>Tweet</code> in Codeblock 10-13
etwas ändern. Der Grund dafür ist, dass die Syntax für das Überschreiben einer
Standard-Implementierung die gleiche ist wie die Syntax für die Implementierung
einer Merkmalsmethode, die keine Standard-Implementierung hat.</p>
<p>Standard-Implementierungen können andere Methoden desselben Merkmals aufrufen,
selbst wenn diese anderen Methoden keine Standard-Implementierung haben. Auf
diese Weise kann ein Merkmal eine Menge nützlicher Funktionalität bereitstellen
und von den Implementierern nur die Angabe eines kleinen Teils verlangen. Zum
Beispiel könnten wir das Merkmal <code>Summary</code> so definieren, dass wir eine Methode
<code>summarize_author</code> haben, deren Implementierung erforderlich ist, und dann eine
Methode <code>summarize</code> definieren, die eine Standard-Implementierung hat und die
Methode <code>summarize_author</code> aufruft:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Lies mehr von {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Um diese Version von <code>Summary</code> zu verwenden, müssen wir <code>summarize_author</code> nur
dann definieren, wenn wir das Merkmal für einen Typ implementieren:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Lies mehr von {}...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nachdem wir <code>summarize_author</code> definiert haben, können wir <code>summarize</code> auf
Instanzen der <code>Tweet</code>-Struktur aufrufen, und die Standard-Implementierung von
<code>summarize</code> wird die Definition von <code>summarize_author</code> aufrufen, die wir
bereitgestellt haben. Da wir <code>summarize_author</code> implementiert haben, hat uns
das Merkmal <code>Summary</code> das Verhalten der <code>summarize</code>-Methode mitgeliefert, ohne
dass wir weiteren Code schreiben müssen. </p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;natürlich, wie du wahrscheinlich schon weißt&quot;),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 neue Kurznachricht: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>Dieser Code gibt <code>1 neue Kurznachricht: (Lies mehr von @horse_ebooks...)</code> aus.</p>
<p>Beachte, dass es nicht möglich ist, die Standardimplementierung von einer
übergeordneten Implementierung derselben Methode aus aufzurufen.</p>
<h3 id="merkmale-als-parameter"><a class="header" href="#merkmale-als-parameter">Merkmale als Parameter</a></h3>
<p>Da du jetzt weißt, wie man Merkmale definiert und implementiert, können wir
untersuchen, wie man Merkmale zur Definition von Funktionen verwendet, die
viele verschiedene Typen akzeptieren.</p>
<p>Beispielsweise haben wir in Codeblock 10-13 das Merkmal <code>Summary</code> für die Typen
<code>NewsArticle</code> und <code>Tweet</code> implementiert. Wir können eine Funktion <code>notify</code>
definieren, die die Methode <code>summarize</code> ihres <code>item</code>-Parameters aufruft, der
einen Typ hat, der das Merkmal <code>Summary</code> implementiert. Um dies zu tun, können
wir die Syntax <code>impl Trait</code> verwenden, etwa so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: impl Summary) {
    println!(&quot;Eilmeldung! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>Anstelle eines konkreten Typs für den Parameter <code>item</code> geben wir das
Schlüsselwort <code>impl</code> und den Merkmalsnamen an. Dieser Parameter akzeptiert
jeden Typ, der das angegebene Merkmal implementiert. Im Rumpf von <code>notify</code>
können wir alle Methoden von <code>item</code> aufrufen, die vom Merkmal <code>Summary</code>
herrühren, zum Beispiel <code>summarize</code>. Wir können <code>notify</code> aufrufen und jede
Instanz von <code>NewsArticle</code> und <code>Tweet</code> angeben. Code, der die Funktion mit einem
anderen Typ aufruft, z.B. <code>String</code> oder <code>i32</code>, lässt sich nicht kompilieren, da
diese Typen kein <code>Summary</code> implementieren.</p>
<h4 id="merkmalsabgrenzungs-syntax"><a class="header" href="#merkmalsabgrenzungs-syntax">Merkmalsabgrenzungs-Syntax</a></h4>
<p>Die Syntax <code>impl Trait</code> funktioniert für einfache Fälle, ist aber eigentlich
syntaktischer Zucker für eine längere Form, die <em>Merkmalsabgrenzung</em> (trait
bound) genannt wird; sie sieht so aus:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Eilmeldung! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>Diese längere Form entspricht dem Beispiel im vorigen Abschnitt, ist aber
wortreicher. Wir platzieren Merkmalsabgrenzungen in der Deklaration des
generischen Typparameters nach einem Doppelpunkt und innerhalb spitzer
Klammern.</p>
<p>Die Syntax <code>impl Trait</code> ist bequem und ermöglicht in einfachen Fällen einen
prägnanteren Code. Die Merkmalsabgrenzungs-Syntax kann andererseits mehr
Komplexität ausdrücken. Zum Beispiel können wir zwei Parameter haben, die
<code>Summary</code> implementieren. Das Verwenden der Syntax <code>impl Trait</code> sieht
folgendermaßen aus:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
<p>Wenn wir wollten, dass diese Funktion bei <code>item1</code> und <code>item2</code> unterschiedliche
Typen haben kann, wäre das Verwenden von <code>impl Trait</code> dafür geeignet (solange
beide Typen <code>Summary</code> implementieren). Wenn beide Parameter aber den gleichen
Typ haben sollten, dann kann man das nur durch eine Merkmalsabgrenzung
ausdrücken, so wie hier:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
<p>Der als Parametertyp für <code>item1</code> und <code>item2</code> angegebene generische Typ <code>T</code>
schränkt die Funktion so ein, dass der konkrete Typ der als Argument für
<code>item1</code> und <code>item2</code> übergebenen Werte derselbe sein muss.</p>
<h4 id="angeben-mehrerer-merkmalsabgrenzungen-mit-der-syntax-"><a class="header" href="#angeben-mehrerer-merkmalsabgrenzungen-mit-der-syntax-">Angeben mehrerer Merkmalsabgrenzungen mit der Syntax <code>+</code></a></h4>
<p>Wir können auch mehr als eine Merkmalsabgrenzung angeben. Nehmen wir an, wir
wollen, dass sowohl <code>notify</code> als auch die Methode <code>summarize</code> die
Bildschirmausgabe für <code>item</code> formatieren: Spezifizieren wir in der
<code>notify</code>-Definition, dass <code>item</code> sowohl <code>Display</code> als auch <code>Summary</code>
implementieren muss. Wir können dies mit der Syntax <code>+</code> tun:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
<p>Die Syntax <code>+</code> ist auch bei Merkmalsabgrenzungen mit generischen Typen gültig:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
<p>Mit den beiden angegebenen Merkmalsabgrenzungen kann der Rumpf von <code>notify</code> die
Methode <code>summarize</code> aufrufen und <code>{}</code> verwenden, um <code>item</code> zu formatieren.</p>
<h4 id="klarere-merkmalsabgrenzungen-mit-where-klauseln"><a class="header" href="#klarere-merkmalsabgrenzungen-mit-where-klauseln">Klarere Merkmalsabgrenzungen mit <code>where</code>-Klauseln</a></h4>
<p>Zu viele Merkmalsabgrenzungen zu verwenden, hat seine Schattenseiten. Jeder
generische Datentyp hat seine eigenen Merkmalsabgrenzungen, sodass Funktionen
mit mehreren generischen Typparametern viele Merkmalsabgrenzungsangaben
zwischen Funktionsname und Parameterliste enthalten können, wodurch die
Funktionssignatur schwer lesbar wird. Aus diesem Grund hat Rust für die Angabe
von Merkmalsabgrenzungen eine alternative Syntax in Form einer <code>where</code>-Klausel
nach der Funktionssignatur. Anstatt das hier zu schreiben:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<p>können wir eine <code>where</code>-Klausel wie folgt verwenden:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>Die Signatur dieser Funktion ist übersichtlicher: Der Funktionsname, die
Parameterliste und der Rückgabetyp liegen nahe beieinander, ähnlich wie bei
einer Funktion ohne viele Merkmalsabgrenzungen.</p>
<h3 id="rückgabetypen-die-merkmale-implementieren"><a class="header" href="#rückgabetypen-die-merkmale-implementieren">Rückgabetypen, die Merkmale implementieren</a></h3>
<p>Wir können die Syntax <code>impl Trait</code> auch für den Rückgabetyp verwenden, wie hier
gezeigt:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;natürlich, wie du wahrscheinlich schon weißt&quot;),
        reply: false,
        retweet: false,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Durch Verwenden von <code>impl Summary</code> für den Rückgabetyp legen wir fest, dass die
Funktion <code>returns_summarizable</code> einen Typ zurückgibt, der das Merkmal <code>Summary</code>
implementiert, ohne den konkreten Typ zu nennen. In diesem Fall gibt
<code>returns_summarizable</code> einen <code>Tweet</code> zurück, aber der Code, der diese Funktion
aufruft, weiß das nicht.</p>
<p>Die Fähigkeit, einen Typ zurückzugeben, der nur durch das Merkmal spezifiziert
ist, das er implementiert, ist besonders nützlich im Zusammenhang mit
Funktionsabschlüssen und Iteratoren, die wir in Kapitel 13 behandeln.
Funktionsabschlüsse und Iteratoren erzeugen Typen, die nur der Compiler
kennt oder deren Spezifikation sehr lang ist. Mit der Syntax <code>impl Trait</code>
kannst du prägnant angeben, dass eine Funktion einen Typ zurückgibt, der das
Merkmal <code>Iterator</code> implementiert, ohne dass du einen sehr langen Typ schreiben
musst.</p>
<p>Du kannst <code>impl Trait</code> jedoch nur verwenden, wenn du einen einzigen Typ
zurückgibst. Beispielsweise würde dieser Code, der entweder einen <code>NewsArticle</code>
oder einen <code>Tweet</code> mit dem Rückgabetyp <code>impl Summary</code> zurückgibt, nicht
funktionieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, von {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Pinguine gewinnen die Stanley-Cup-Meisterschaft!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;Die Pittsburgh Penguins sind erneut die beste \
                 Eishockeymannschaft in der NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;natürlich, wie du wahrscheinlich schon weißt&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Die Rückgabe entweder eines <code>NewsArticle</code> oder eines <code>Tweet</code> ist aufgrund von
Einschränkungen hinsichtlich der Implementierung der Syntax <code>impl Trait</code> im
Compiler nicht erlaubt. Wie man eine Funktion mit diesem Verhalten schreibt,
wird im Abschnitt <a href="ch17-02-trait-objects.html">„Merkmalsobjekte (trait objects) die Werte unterschiedlicher
Typen erlauben“</a>
in Kapitel 17 behandelt.</p>
<h3 id="korrigieren-der-funktion-largest-mit-merkmalsabgrenzungen"><a class="header" href="#korrigieren-der-funktion-largest-mit-merkmalsabgrenzungen">Korrigieren der Funktion <code>largest</code> mit Merkmalsabgrenzungen</a></h3>
<p>Da du nun weißt, wie du das gewünschte Verhalten mit generischer
Typparameterabgrenzung spezifizieren kannst, kehren wir zu Codeblock 10-5
zurück, um die Definition der Funktion <code>largest</code>, die einen generischen
Typparameter verwendet, zu korrigieren! Als wir das letzte Mal versuchten,
den Code auszuführen, erhielten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Im Rumpf von <code>largest</code> wollten wir zwei Werte vom Typ <code>T</code> mit dem Operator
größer als (<code>&gt;</code>) vergleichen. Da dieser Operator als Standardmethode für das
Standardbibliotheks-Merkmal <code>std::cmp::PartialOrd</code> definiert ist, müssen wir
<code>PartialOrd</code> als Merkmalsabgrenzung für <code>T</code> angeben, damit die Funktion
<code>largest</code> auf Anteilstypen beliebiger Typen arbeiten kann, die wir vergleichen
können. Wir brauchen <code>PartialOrd</code> nicht in den Gültigkeitsbereich zu bringen,
weil das automatisch erfolgt. Ändere die Signatur von <code>largest</code> wie folgt:</p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
<span class="boring">    let mut largest = list[0];
</span><span class="boring">
</span><span class="boring">    for &amp;item in list {
</span><span class="boring">        if item &gt; largest {
</span><span class="boring">            largest = item;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    largest
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let number_list = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;number_list);
</span><span class="boring">    println!(&quot;Die größte Zahl ist {}&quot;, result);
</span><span class="boring">
</span><span class="boring">    let char_list = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;char_list);
</span><span class="boring">    println!(&quot;Das größte Zeichen ist {}&quot;, result);
</span><span class="boring">}
</span></code></pre></pre>
<p>Wenn wir den Code kompilieren, erhalten wir nun andere Fehlermeldungen:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&amp;list[0]`

error[E0507]: cannot move out of a shared reference
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Die Schlüsselzeile bei diesem Fehler ist <code>cannot move out of type [T], a non-copy slice</code>. Mit unseren nicht-generischen Versionen der Funktion <code>largest</code>
versuchten wir nur, die größte <code>i32</code> oder <code>char</code> zu finden. Wie im Abschnitt
<a href="ch04-01-what-is-ownership.html#nur-stapelspeicher-daten-kopieren-copy">„Nur Stapelspeicher-Daten: Kopieren (copy)“</a> in Kapitel
4 besprochen, können Typen wie <code>i32</code> und <code>char</code>, die eine bekannte Größe haben,
auf dem Stapelspeicher gespeichert werden, sodass sie das Merkmal <code>Copy</code>
implementieren. Aber als wir die Funktion <code>largest</code> generisch gemacht haben,
wurde es möglich, dass der Parameter <code>list</code> Typen enthält, die das Merkmal
<code>Copy</code> nicht implementieren. Folglich wären wir nicht in der Lage, den Wert aus
<code>list[0]</code> in die Variable <code>largest</code> zu verschieben, was zu diesem Fehler führt.</p>
<p>Um diesen Code nur mit den Typen aufzurufen, die das Merkmal <code>Copy</code>
implementieren, können wir <code>Copy</code> zu den Merkmalsabgrenzungen von <code>T</code>
hinzufügen! Codeblock 10-15 zeigt den vollständigen Code einer generischen
Funktion <code>largest</code>, die kompiliert, solange die Typen der Werte im Anteilstyp,
die wir der Funktion übergeben, die Merkmale <code>PartialOrd</code> <em>und</em> <code>Copy</code>
implementieren, wie <code>i32</code> und <code>char</code> es tun.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;Das größte Zeichen ist {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-15: Eine funktionierende Definition der
Funktion <code>largest</code>, die mit jedem generischen Typ funktioniert, der die
Merkmale <code>PartialOrd</code> und <code>Copy</code> implementiert</span></p>
<p>Wenn wir die Funktion <code>largest</code> nicht auf Typen beschränken wollen, die das
Merkmal <code>Copy</code> implementieren, könnten wir angeben, dass <code>T</code> die
Merkmalsabgrenzung <code>Clone</code> anstelle von <code>Copy</code> verwendet. Dann könnten wir
jeden Wert des Anteilstyps klonen, wenn wir wollen, dass die Funktion <code>largest</code>
die Eigentümerschaft übernimmt. Das Verwenden der Funktion <code>clone</code> bedeutet,
dass wir potenziell mehr Allokationen im Haldenspeicher im Falle von
Typen vornehmen, die Haldenspeicherdaten wie <code>String</code> besitzen. Und
Allokationen im Haldenspeicher können langsam sein, wenn wir mit großen
Datenmengen arbeiten.</p>
<p>Eine andere Möglichkeit, wie wir <code>largest</code> implementieren könnten, besteht
darin, dass die Funktion eine Referenz auf einen <code>T</code>-Wert im Anteilstyp
zurückgibt. Wenn wir den Rückgabetyp in <code>&amp;T</code> anstelle von <code>T</code> ändern und
dadurch den Funktionsrumpf ändern, um eine Referenz zurückzugeben, bräuchten
wir die Merkmalsabgrenzungen <code>Clone</code> oder <code>Copy</code> nicht und könnten Allokationen
im Haldenspeicher vermeiden. Versuche, diese alternativen Lösungen selbst
zu implementieren! Wenn du bei Fehlern, die mit Lebensdauern zu tun haben,
hängen bleibst, lese weiter: Der Abschnitt „Referenzen validieren mit
Lebensdauern“ wird dies erläutern, aber Lebensdauern sind nicht erforderlich,
um diese Probleme zu lösen.</p>
<h3 id="verwenden-von-merkmalsabgrenzungen-zur-bedingten-implementierung-von-methoden"><a class="header" href="#verwenden-von-merkmalsabgrenzungen-zur-bedingten-implementierung-von-methoden">Verwenden von Merkmalsabgrenzungen zur bedingten Implementierung von Methoden</a></h3>
<p>Durch Verwenden einer Merkmalsabgrenzung mit einem <code>impl</code>-Block, der generische
Typparameter verwendet, können wir Methoden bedingt für Typen implementieren,
die das angegebene Merkmal implementieren. Beispielsweise implementiert der Typ
<code>Pair&lt;T&gt;</code> in Codeblock 10-16 immer die Funktion <code>new</code>. Aber <code>Pair&lt;T&gt;</code>
implementiert die Methode <code>cmp_display</code> nur, wenn ihr innerer Typ <code>T</code> die
Merkmale <code>PartialOrd</code> <em>und</em> <code>Display</code> implementiert, die den Vergleich bzw.
eine Ausgabe ermöglichen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;Das größte Element ist x = {}&quot;, self.x);
        } else {
            println!(&quot;Das größte Element ist y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-16: Bedingte Implementierung von Methoden
für einen generischen Typ in Abhängigkeit von Merkmalsabgrenzungen</span></p>
<p>Wir können auch ein Merkmal für beliebige Typen bedingt implementieren, die ein
anderes Merkmal implementieren. Implementierungen eines Merkmals für Typen, die
Merkmalsabgrenzungen erfüllen, werden als <em>Pauschal-Implementierungen</em> (blanket
implementations) bezeichnet und kommen in der Rust-Standardbibliothek ausgiebig
zur Anwendung. Beispielsweise implementiert die Standardbibliothek das Merkmal
<code>ToString</code> für jeden Typ, der das Merkmal <code>Display</code> implementiert. Der
<code>impl</code>-Block in der Standardbibliothek sieht in etwa so aus:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --abschneiden--
}
</code></pre>
<p>Da die Standardbibliothek diese Pauschal-Implementierungen hat, können wir die
<code>to_string</code>-Methode, die durch das Merkmal <code>ToString</code> definiert ist, bei jedem
Typ aufrufen, der das Merkmal <code>Display</code> implementiert. Zum Beispiel können wir
ganze Zahlen in ihre entsprechenden <code>String</code>-Werte umwandeln, weil ganze
Zahlen <code>Display</code> implementieren:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>Pauschal-Implementierungen erscheinen in der Dokumentation des Merkmals im
Abschnitt „Implementierer“ (implementors).</p>
<p>Mithilfe von Merkmalen und Merkmalsabgrenzungen können wir Code schreiben, der
generische Typparameter verwendet, um Duplikationen zu reduzieren, aber auch
dem Compiler gegenüber angeben, dass der generische Typ ein bestimmtes
Verhalten haben soll. Der Compiler kann dann die Merkmalsabgrenzungen
verwenden, um zu überprüfen, ob alle konkreten Typen, die von unserem Code
verwendet werden, das richtige Verhalten aufweisen. In dynamisch typisierten
Sprachen würden wir einen Laufzeitfehler erhalten, wenn wir eine Methode bei
einem Typ aufrufen, der die Methode nicht definiert hat. Rust verschiebt diese
Fehler jedoch in die Kompilierzeit und verlangt damit, dass wir die Probleme
beheben, bevor unser Code überhaupt lauffähig ist. Außerdem müssen wir keinen
Code schreiben, der das Verhalten zur Laufzeit überprüft, da wir es bereits zur
Kompilierungszeit überprüft haben. Auf diese Weise wird die Performanz
verbessert, ohne die Flexibilität der generischen Datentypen aufgeben zu
müssen.</p>
<p>Eine weitere generische Funktionalität, die wir bereits verwendet haben, heißt
<em>Lebensdauer</em> (lifetimes). Anstatt sicherzustellen, dass ein Typ das von uns
gewünschte Verhalten hat, stellen wir durch die Lebensdauer sicher, dass
Referenzen so lange gültig sind, wie wir sie brauchen. Schauen wir uns an, wie
Lebensdauern das tun.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/ferris.js"></script>


    </body>
</html>
