<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mit Umgebungsvariablen arbeiten - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="mit-umgebungsvariablen-arbeiten"><a class="header" href="#mit-umgebungsvariablen-arbeiten">Mit Umgebungsvariablen arbeiten</a></h2>
<p>Wir werden <code>minigrep</code> verbessern, indem wir eine zusätzliche Funktionalität
hinzufügen: Eine Option für die Suche unabhängig von der Groß-/Kleinschreibung,
die der Benutzer über eine Umgebungsvariable einschalten kann. Wir könnten
diese Funktion zu einer Kommandozeilenoption machen und verlangen, dass die
Benutzer sie jedes Mal eingeben müssen, wenn sie angewendet werden soll, aber
stattdessen werden wir eine Umgebungsvariable verwenden. Auf diese Weise können
unsere Benutzer die Umgebungsvariable einmal setzen und alle Suchvorgänge in
dieser Terminalsitzung ohne Berücksichtigung der Groß-/Kleinschreibung
durchführen.</p>
<h3 id="schreiben-eines-fehlschlagenden-tests-für-die-suche-unabhängig-von-der-groß-kleinschreibung"><a class="header" href="#schreiben-eines-fehlschlagenden-tests-für-die-suche-unabhängig-von-der-groß-kleinschreibung">Schreiben eines fehlschlagenden Tests für die Suche unabhängig von der Groß-/Kleinschreibung</a></h3>
<p>Wir fügen zuerst eine neue Funktion <code>search_case_insensitive</code> hinzu, die
aufgerufen wird, wenn die Umgebungsvariable einen Wert hat. Wir werden die
TDD-Methode weiter verfolgen, sodass der erste Schritt wieder darin besteht,
einen fehlschlagenden Test zu schreiben. Wir werden einen neuen Test für die
neue Funktion <code>search_case_insensitive</code> hinzufügen und unseren alten Test von
<code>one_result</code> in <code>case_sensitive</code> umbenennen, um die Unterschiede zwischen den
beiden Tests zu verdeutlichen, wie in Codeblock 12-20 gezeigt wird.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "dukt";
        let contents = "\
Rust:
sicher, schnell, produktiv.
Nimm drei.
PRODUKTION.";

        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
sicher, schnell, produktiv.
Nimm drei.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
<p><span class="caption">Codeblock 12-20: Hinzufügen eines neuen fehlschlagenden
Tests für die Funktion <code>search_case_insensitive</code>, die wir gleich hinzufügen
werden</span></p>
<p>Beachte, dass wir auch den Inhalt des alten Tests bearbeitet haben. Wir haben
eine neue Zeile mit dem Text <code>"PRODUKTION."</code> in Großbuchstaben hinzugefügt,
die nicht mit dem Abfragetext <code>"dukt"</code> übereinstimmen sollte, wenn wir bei der
Suche die Groß-/Kleinschreibung beachten. Wenn wir den alten Test auf diese
Weise ändern, stellen wir sicher, dass wir nicht versehentlich die bereits
implementierte Suchfunktionalität unter Berücksichtigung der
Groß-/Kleinschreibung kaputt machen. Dieser Test sollte jetzt erfolgreich sein
und er sollte es auch bleiben, während wir an der Suche unabhängig von der
Groß-/Kleinschreibung arbeiten.</p>
<p>Der neue Test <code>case_insensitive</code> verwendet <code>"rUsT"</code> als Suchabfrage. In der
Funktion <code>search_case_insensitive</code>, die wir gerade hinzufügen wollen, sollte
der Abfragetext <code>"rUsT"</code> zur Zeile, die <code>"Rust:"</code> mit einem großen R enthält,
passen und zur Zeile <code>"Trust me."</code>, obwohl beide eine andere Schreibweise haben
als der Abfragetext. Dies ist unser fehlschlagender Test und er wird sich nicht
kompilieren lassen, weil wir die Funktion <code>search_case_insensitive</code> noch nicht
definiert haben. Es steht dir frei, eine Skelett-Implementierung hinzuzufügen,
die immer einen leeren Vektor zurückgibt, ähnlich wie wir es für die Funktion
<code>search</code> in Codeblock 12-16 getan haben, um zu sehen, wie der Test kompilieren
wird und fehlschlägt.</p>
<h3 id="implementieren-der-funktion-search_case_insensitive"><a class="header" href="#implementieren-der-funktion-search_case_insensitive">Implementieren der Funktion <code>search_case_insensitive</code></a></h3>
<p>Die Funktion <code>search_case_insensitive</code>, die in Codeblock 12-21 gezeigt wird,
wird fast die gleiche sein wie die Funktion <code>search</code>. Der einzige Unterschied
besteht darin, dass wir <code>query</code> und <code>line</code> in Kleinbuchstaben umwandeln, sodass
sie unabhängig von der Groß-/Kleinschreibung der Eingabe-Argumente sind, wenn
wir prüfen, ob die Zeile die Abfrage enthält.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 12-21: Definieren der Funktion
<code>search_case_insensitive</code>, um den Abfragetext und die Zeile vor dem Vergleich
in Kleinbuchstaben umzuwandeln</span></p>
<p>Zuerst wandeln wir die Zeichenkette <code>query</code> in Kleinbuchstaben um und speichern
ihn in einer neuen Variablen mit dem gleichen Namen, die die ursprüngliche
Variable <code>query</code> verschattetet. Der Aufruf von <code>to_lowercase</code> beim Abfragetext
ist notwendig, sodass wir unabhängig davon, ob die Abfrage des Benutzers
<code>"rust"</code>, <code>"RUST"</code>, <code>"RUST"</code> oder <code>"rUsT"</code> ist, die Abfrage so behandeln, als
ob sie <code>"rust"</code> wäre, und die Groß-/Kleinschreibung nicht beachten. Obwohl
<code>to_lowercase</code> mit einfachem Unicode umgehen kann, wird es nicht 100% genau
sein. Wenn wir eine echte Anwendung schreiben würden, würden wir hier etwas
mehr Arbeit spendieren wollen, aber in diesem Abschnitt geht es um
Umgebungsvariablen, nicht um Unicode, also belassen wir es hier dabei.</p>
<p>Beachte, dass <code>query</code> jetzt ein <code>String</code> und nicht mehr ein
Zeichenkettenanteilstyp ist, weil der Aufruf von <code>to_lowercase</code> neue Daten
erzeugt, anstatt auf bestehende Daten zu referenzieren. Nehmen wir als Beispiel
an, der Abfragetext sei <code>"rUsT"</code>, dieser Zeichenkettenanteilstyp enthält kein
kleingeschriebenes <code>u</code> oder <code>t</code>, das wir verwenden könnten, also müssen wir
einen neuen <code>String</code> zuweisen, der <code>"rust"</code> enthält. Wenn wir nun <code>query</code> als
Argument an die Methode <code>contains</code> übergeben, müssen wir ein <code>&amp;</code>-Zeichen
angeben, weil die Signatur von <code>contains</code> so definiert ist, dass sie einen
Zeichenkettenanteilstyp nimmt.</p>
<p>Als nächstes fügen wir einen Aufruf von <code>to_lowercase</code> für jede <code>line</code> ein,
um alle Zeichen kleinzuschreiben. Da wir nun <code>line</code> und <code>query</code> in
Kleinbuchstaben umgewandelt haben, werden wir passende Zeilen finden, egal wie
die Groß-/Kleinschreibung der Abfrage ist.</p>
<p>Warten wir ab, ob diese Implementierung die Tests besteht:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Großartig! Sie haben bestanden. Lass uns nun die neue Funktion
<code>search_case_insensitive</code> von der Funktion <code>run</code> aufrufen. Zuerst fügen wir
eine Konfigurationsoption zur <code>Config</code>-Struktur hinzu, um zwischen der Suche
mit und ohne Berücksichtigung der Groß- und Kleinschreibung umzuschalten. Das
Hinzufügen dieses Feldes führt zu Kompilierfehlern, da wir dieses Feld noch
nirgendwo initialisiert haben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Wir haben das Feld <code>ignore_case</code> hinzugefügt, das ein Boolean enthält. Als
Nächstes benötigen wir die Funktion <code>run</code>, um den Wert des Feldes <code>ignore_case</code>
auszuwerten, und verwenden diese, um zu entscheiden, ob die Funktion <code>search</code>
oder die Funktion <code>search_case_insensitive</code> aufgerufen werden soll, wie in
Codeblock 12-22 gezeigt. Dies kompiliert noch immer nicht.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("Nicht genügend Argumente");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 12-22: Aufruf von entweder <code>search</code> oder
<code>search_case_insensitive</code> basierend auf dem Wert in <code>config.ignore_case</code></span></p>
<p>Schließlich müssen wir nach der Umgebungsvariablen suchen. Die Funktionen zum
Arbeiten mit Umgebungsvariablen befinden sich im Modul <code>env</code> in der
Standardbibliothek, daher bringen wir dieses Modul am Anfang von <em>src/lib.rs</em>
in den Gültigkeitsbereich. Dann werden wir die Funktion <code>var</code> aus dem Modul
<code>env</code> verwenden, um zu prüfen ob eine Umgebungsvariable namens <code>IGNORE_CASE</code>
einen Wert hat, wie in Codeblock 12-23 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::env;
// --abschneiden--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("Nicht genügend Argumente");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "dukt";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["sicher, schnell, produktiv."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Codeblock 12-23: Prüfen, ob eine Umgebungsvariable namens
<code>IGNORE_CASE</code> einen Wert hat</span></p>
<p>Hier erstellen wir eine neue Variable <code>ignore_case</code>. Um ihren Wert zu setzen,
rufen wir die Funktion <code>env::var</code> auf und übergeben ihr den Namen der
Umgebungsvariablen <code>IGNORE_CASE</code>. Die Funktion <code>env::var</code> gibt ein <code>Result</code>
zurück, das die erfolgreiche <code>Ok</code>-Variante ist, die den Wert der
Umgebungsvariablen enthält, wenn die Umgebungsvariable einen Wert hat. Sie gibt
die Variante <code>Err</code> zurück, wenn die Umgebungsvariable nicht gesetzt ist.</p>
<p>Wir benutzen die Methode <code>is_ok</code> auf <code>Result</code>, um zu prüfen, ob die
Umgebungsvariable gesetzt ist, was bedeutet, dass das Programm die Suche
ohne Berücksichtigung der Groß-/Kleinschreibung durchführen soll. Wenn
die Umgebungsvariable <code>IGNORE_CASE</code> keinen Wert hat, gibt <code>is_ok</code> den Wert
<code>false</code> zurück und das Programm führt eine Suche mit Berücksichtigung der
Groß-/Kleinschreibung durch. Wir kümmern uns nicht um den <em>Wert</em> der
Umgebungsvariablen, nur darum, ob sie gesetzt ist oder nicht, also prüfen wir
mit <code>is_ok</code>, anstatt mit <code>unwrap</code>, <code>expect</code> oder einer der anderen Methoden,
die wir bei <code>Result</code> gesehen haben.</p>
<p>Wir übergeben den Wert in der Variablen <code>ignore_case</code> an die
<code>Config</code>-Instanz, sodass die Funktion <code>run</code> diesen Wert lesen und entscheiden
kann, ob sie <code>search_case_insensitive</code> oder <code>search</code> aufrufen soll, wie wir es
in Codeblock 12-22 implementiert haben.</p>
<p>Lass es uns versuchen! Zuerst führen wir unser Programm ohne die gesetzte
Umgebungsvariable und mit dem Abfragetext <code>to</code> aus, die zu den Zeilen passen
sollte, die das Wort <em>to</em> in Kleinbuchstaben enthalten:</p>
<pre><code class="language-console">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Sieht so aus, als ob das immer noch funktioniert! Lass uns nun das Programm mit
<code>IGNORE_CASE</code> auf <code>1</code> gesetzt ausführen, aber mit dem gleichen Abfragetext
<em>to</em>.</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>Wenn du die PowerShell verwendest, sind das Setzen der Umgebungsvariable und
das Ausführen des Programms separate Befehle:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run to poem.txt
</code></pre>
<p>Dadurch bleibt <code>IGNORE_CASE</code> für den Rest deiner Shell-Sitzung bestehen. Sie
kann mit <code>Remove-Item</code> zurückgesetzt werden:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>Wir sollten Zeilen erhalten, die <em>to</em> enthalten, die Großbuchstaben haben
könnten:</p>
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Ausgezeichnet, wir haben auch Zeilen mit <em>To</em>! Unser <code>minigrep</code>-Programm kann
jetzt ohne Berücksichtigung von Groß-/Kleinschreibung suchen, gesteuert durch
eine Umgebungsvariable. Jetzt weißt du, wie man Optionen verwaltet, die
entweder mit Kommandozeilenargumenten oder Umgebungsvariablen gesetzt werden.</p>
<p>Einige Programme erlauben Argumente <em>und</em> Umgebungsvariablen für die gleiche
Konfiguration. In diesen Fällen entscheiden die Programme, dass das eine oder
das andere Vorrang hat. Versuche für eine weitere eigene Übung, die Steuerung,
ob die Groß-/Kleinschreibung berücksichtigt werden soll, entweder über ein
Kommandozeilenargument oder eine Umgebungsvariable zu ermöglichen. Entscheide,
ob das Kommandozeilenargument oder die Umgebungsvariable Vorrang haben soll,
wenn das Programm mit widersprüchlichen Optionen ausgeführt wird.</p>
<p>Das Modul <code>std::env</code> enthält viele weitere nützliche Funktionalitäten für den
Umgang mit Umgebungsvariablen: Schaue in seine Dokumentation, um zu sehen, was
verfügbar ist.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-06-writing-to-stderr-instead-of-stdout.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-06-writing-to-stderr-instead-of-stdout.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
