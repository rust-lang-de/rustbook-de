<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unsicheres (unsafe) Rust - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="unsicheres-unsafe-rust"><a class="header" href="#unsicheres-unsafe-rust">Unsicheres (unsafe) Rust</a></h2>
<p>Bei allem Code, den wir bisher besprochen haben, wurden Rusts
Speichersicherheitsgarantien zur Kompilierzeit erzwungen. Allerdings ist in
Rust eine zweite Sprache versteckt, die diese Speichersicherheitsgarantien
nicht erzwingt: Sie heißt <em>unsicheres Rust</em> (unsafe Rust) und funktioniert
genau wie das normale Rust, gibt uns aber zusätzliche Superkräfte.</p>
<p>Unsicheres Rust existiert, weil die statische Analyse von Natur aus konservativ
ist. Wenn der Compiler versucht festzustellen, ob der Code die Garantien
einhält oder nicht, ist es besser für ihn, einige gültige Programme
zurückzuweisen, als einige ungültige Programme zu akzeptieren. Obwohl der Code
<em>möglicherweise</em> in Ordnung ist, wird der Rust-Compiler den Code ablehnen, wenn
er nicht genügend Informationen hat, um sicher zu sein. In diesen Fällen kannst
du unsicheren Code verwenden, um dem Compiler zu sagen: „Vertraue mir, ich
weiß, was ich tue.“ Sei jedoch gewarnt, dass du unsicheres Rust auf eigenes
Risiko verwendest: Wenn du unsicheren Code falsch verwendest, können Probleme
aufgrund von Speicherunsicherheiten auftreten, z.B. Dereferenzierung von
Null-Zeigern.</p>
<p>Ein weiterer Grund, warum Rust ein unsicheres zweites Ich hat, ist, dass die
zugrunde liegende Computer-Hardware von Natur aus unsicher ist. Wenn Rust dich
keine unsicheren Operationen durchführen ließe, könntest du bestimmte Aufgaben
nicht ausführen. Rust muss es dir ermöglichen, Low-Level-Systemprogrammierung
zu machen, z.B. direkt mit dem Betriebssystem zu interagieren oder sogar dein
eigenes Betriebssystem zu schreiben. Arbeiten mit
Low-Level-Systemprogrammierung ist eines der Ziele der Sprache. Lass uns
untersuchen, was wir mit unsicherem Rust tun können und wie wir es tun können.</p>
<h3 id="unsichere-superkräfte"><a class="header" href="#unsichere-superkräfte">Unsichere Superkräfte</a></h3>
<p>Um auf unsicheres Rust umzuschalten, verwendest du das Schlüsselwort <code>unsafe</code>
und startest dann einen neuen Block, der den unsicheren Code enthält. In
unsicherem Rust kannst du fünf Aktionen ausführen, die du in sicherem Rust
nicht ausführen kannst, die wir <em>unsichere Superkräfte</em> nennen. Zu diesen
Superkräften gehören folgende Fähigkeiten:</p>
<ul>
<li>Dereferenzieren eines Rohzeigers</li>
<li>Aufrufen einer unsicheren Funktion oder Methode</li>
<li>Zugreifen auf oder Ändern einer veränderbaren statischen Variablen</li>
<li>Implementieren eines unsicheren Merkmals (trait)</li>
<li>Zugreifen auf Feldern in <code>union</code></li>
</ul>
<p>Es ist wichtig zu verstehen, dass <code>unsafe</code> weder den Ausleihenprüfer (borrow
checker) abschaltet noch andere Sicherheitsprüfungen von Rust deaktiviert: Wenn
du eine Referenz in einem unsicheren Code verwendest, wird diese trotzdem
geprüft. Das Schlüsselwort <code>unsafe</code> gibt dir nur Zugriff auf diese fünf
Funktionalitäten, die dann vom Compiler nicht auf Speichersicherheit geprüft
werden. In einem unsicheren Block erhältst du immer noch ein gewisses Maß an
Sicherheit.</p>
<p>Darüber hinaus bedeutet <code>unsafe</code> nicht, dass der Code innerhalb des Blocks
notwendigerweise gefährlich ist oder dass er definitiv
Speichersicherheitsprobleme haben wird: Das Ziel ist, dass du als Programmierer
sicherstellst, dass der Code innerhalb eines <code>unsafe</code>-Blocks auf gültige Weise
auf den Speicher zugreifen wird.</p>
<p>Menschen sind fehlbar und Fehler werden passieren, aber wenn du verlangst, dass
diese fünf unsicheren Operationen innerhalb von Blöcken mit dem Vermerk
<code>unsafe</code> durchgeführt werden müssen, weißt du, dass alle Fehler im Zusammenhang
mit der Speichersicherheit innerhalb eines <code>unsafe</code>-Blocks liegen müssen. Halte
<code>unsafe</code>-Blöcke klein; du wirst später dankbar sein, wenn du Speicherfehler
untersuchst.</p>
<p>Um unsicheren Code so weit wie möglich zu isolieren, ist es am besten, solchen
Code in eine sichere Abstraktion einzupacken und eine sichere API
bereitzustellen, auf die wir später im Kapitel eingehen werden, wenn wir
unsichere Funktionen und Methoden untersuchen. Teile der Standardbibliothek
sind als sichere Abstraktionen über unsicheren, geprüften Code implementiert.
Das Einpacken von unsicherem Code in eine sichere Abstraktion verhindert, dass
sich die Verwendung von <code>unsafe</code> auf alle Stellen auswirkt, an denen du oder
deine Benutzer die mit <code>unsafe</code>-Code implementierte Funktionalität verwenden
möchtest, da das Verwenden einer sicheren Abstraktion sicher ist.</p>
<p>Betrachten wir der Reihe nach jede der fünf unsicheren Superkräfte. Wir werden
uns auch einige Abstraktionen ansehen, die eine sichere Schnittstelle zu
unsicheren Codes bieten.</p>
<h3 id="dereferenzieren-eines-rohzeigers"><a class="header" href="#dereferenzieren-eines-rohzeigers">Dereferenzieren eines Rohzeigers</a></h3>
<p>In <a href="ch04-02-references-and-borrowing.html#h%C3%A4ngende-referenzen">„Hängende Referenzen“</a> in Kapitel 4 haben wir erwähnt,
dass der Compiler sicherstellt, dass Referenzen immer gültig sind. Unsicheres
Rust hat zwei neue Typen namens <em>Rohzeiger</em> (raw pointers), die ähnlich wie
Referenzen sind. Wie bei Referenzen können Rohzeiger unveränderbar oder
veränderbar sein und werden als <code>_const T</code> bzw. <code>_mut T</code> geschrieben. Das
Sternchen ist nicht der Dereferenzierungsoperator (dereference operator); es
ist Teil des Typnamens. Im Zusammenhang mit Rohzeigern bedeutet <em>unveränderbar</em>
(immutable), dass der Zeiger nach der Dereferenzierung nicht direkt zugewiesen
werden kann.</p>
<p>Rohzeiger sind anders als Referenzen und intelligente Zeiger:</p>
<ul>
<li>Sie dürfen die Ausleihregeln ignorieren, indem sie sowohl unveränderbare als
auch veränderbare Zeiger oder mehrere veränderbare Zeiger auf die gleiche
Stelle haben.</li>
<li>Sie zeigen nicht garantiert auf gültigen Speicher.</li>
<li>Sie dürfen null sein.</li>
<li>Sie implementieren kein automatisches Aufräumen.</li>
</ul>
<p>Wenn du dich dagegen entscheidest, diese Garantien von Rust erzwingen zu
lassen, kannst du auf garantierte Sicherheit verzichten und stattdessen eine
höhere Performanz oder die Möglichkeit der Interaktion mit einer anderen
Sprache oder Hardware erhalten, für die die Rust-Garantien nicht gelten.</p>
<p>Codeblock 20-1 zeigt, wie man aus Referenzen einen unveränderbaren und einen
veränderbaren Rohzeiger erzeugt.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-1: Erstellen von Rohzeigern aus
Referenzen</span></p>
<p>Beachte, dass wir das Schlüsselwort <code>unsafe</code> in diesem Code nicht verwenden.
Wir können Rohzeiger in sicherem Code erzeugen; wir können nur keine Rohzeiger
außerhalb eines unsicheren Blocks dereferenzieren, wie du gleich sehen wirst.</p>
<p>Wir haben Rohzeiger mit Hilfe des Operators <code>&amp;raw</code> erstellt: <code>&amp;raw const num</code>
erzeugt einen unveränderbaren Rohzeiger <code>*const i32</code>, und <code>&amp;raw mut num</code>
erzeugt einen veränderbaren Rohzeiger <code>*mut i32</code>. Da wir sie direkt aus
lokalen Variablen erstellt haben, wissen wir, dass diese speziellen Rohzeiger
gültig sind, aber wir können diese Annahme nicht für jeden beliebigen Rohzeiger
treffen.</p>
<p>Um dies zu demonstrieren, werden wir als Nächstes einen Rohzeiger erstellen,
dessen Gültigkeit wir nicht so sicher sein können. Wir verwenden <code>as</code> anstelle
des Operators <code>&amp;raw</code>, um einen Wert umzuwandeln (cast). Codeblock 20-2 zeigt,
wie man einen Rohzeiger auf eine willkürliche Stelle im Speicher erstellt. Der
Versuch, willkürlichen Speicher zu verwenden, ist undefiniert: Es könnten Daten
an dieser Adresse vorhanden sein oder auch nicht, der Compiler könnte den Code
so optimieren, dass es keinen Speicherzugriff gibt, oder das Programm könnte
mit einer Schutzverletzung (segmentation fault) abbrechen. Normalerweise gibt
es keinen guten Grund, solchen Code zu schreiben, vor allem, wenn man
stattdessen den Operator <code>&amp;raw</code> verwenden kann, aber es ist möglich.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-2: Erzeugen eines Rohzeigers auf eine
willkürliche Speicheradresse</span></p>
<p>Erinnere dich, dass wir Rohzeiger in sicherem Code erstellen können, aber wir
können keine Rohzeiger <em>dereferenzieren</em> und die Daten lesen, auf die gezeigt
wird. In Codeblock 20-3 wenden wir den Dereferenzierungsoperator <code>*</code> auf einen
Rohzeiger an, was einen <code>unsafe</code>-Block erfordert.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!("r1 ist: {}", *r1);
        println!("r2 ist: {}", *r2);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-3: Dereferenzieren von Rohzeigern innerhalb
eines <code>unsafe</code>-Blocks</span></p>
<p>Das Erstellen eines Zeigers schadet nicht; erst wenn wir versuchen, auf den
Wert zuzugreifen, auf den er zeigt, könnten wir es am Ende mit einem ungültigen
Wert zu tun haben.</p>
<p>Beachte auch, dass wir in Codeblock 20-1 und 20-3 die Rohzeiger <code>*const i32</code>
und <code>*mut i32</code> erstellt haben, die beide auf die gleiche Speicherstelle
zeigten, in der <code>num</code> gespeichert ist. Wenn wir stattdessen versucht hätten,
eine unveränderbare und einen veränderbare Referenz auf <code>num</code> zu erstellen,
hätte sich der Code nicht kompilieren lassen, weil die Eigentumsregeln von Rust
eine veränderbare Referenz nicht gleichzeitig mit unveränderbaren Referenzen
zulassen. Mit Rohzeigern können wir einen veränderbaren und einen
unveränderbaren Zeiger auf denselben Ort erstellen und Daten über den
veränderbaren Zeiger ändern, wodurch möglicherweise eine
Daten-Wettlaufsituation (data race) entsteht. Sei vorsichtig!</p>
<p>Warum solltest du bei all diesen Gefahren jemals Rohzeiger verwenden? Ein
Hauptanwendungsfall ist die Kopplung mit C-Code, wie du im nächsten Abschnitt
<a href="#aufrufen-einer-unsicheren-funktion-oder-methode">„Aufrufen einer unsicheren Funktion oder Methode“</a> sehen wirst.
Ein anderer Fall ist der Aufbau von sicheren Abstraktionen, die der
Ausleihenprüfer nicht versteht. Wir stellen unsichere Funktionen vor und
betrachten dann ein Beispiel für eine sichere Abstraktion, die unsicheren
Code verwendet.</p>
<h3 id="aufrufen-einer-unsicheren-funktion-oder-methode"><a class="header" href="#aufrufen-einer-unsicheren-funktion-oder-methode">Aufrufen einer unsicheren Funktion oder Methode</a></h3>
<p>Die zweite Art von Operationen, die du in einem unsicheren Block ausführen
kannst, sind Aufrufe von unsicheren Funktionen. Unsichere Funktionen und
Methoden sehen genau wie reguläre Funktionen und Methoden aus, aber sie haben
ein zusätzliches <code>unsafe</code> vor dem Rest der Definition. Das Schlüsselwort
<code>unsafe</code> weist in diesem Zusammenhang darauf hin, dass die Funktion
Anforderungen hat, die wir einhalten müssen, wenn wir diese Funktion aufrufen,
denn Rust kann nicht garantieren, dass wir diese Anforderungen erfüllt haben.
Indem wir eine unsichere Funktion innerhalb eines <code>unsafe</code>-Blocks aufrufen,
sagen wir, dass wir die Dokumentation dieser Funktion gelesen haben und wir die
Verantwortung für die Einhaltung der Verträge der Funktion übernehmen.</p>
<p>Hier ist eine unsichere Funktion namens <code>dangerous</code>, die in ihrem Rumpf nichts
tut:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>Wir müssen die Funktion <code>dangerous</code> innerhalb eines separaten <code>unsafe</code>-Blocks
aufrufen. Wenn wir versuchen, <code>dangerous</code> ohne den <code>unsafe</code>-Block aufzurufen,
erhalten wir einen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>Mit dem <code>unsafe</code>-Block versichern wir Rust, dass wir die Dokumentation der
Funktion gelesen haben, dass wir verstehen, wie sie richtig zu benutzen ist,
und dass wir überprüft haben, dass wir den Vertrag der Funktion erfüllen.</p>
<p>Um unsichere Operationen im Rumpf einer unsicheren Funktion auszuführen, musst
du wie bei einer regulären Funktion einen <code>unsafe</code>-Block verwenden, und der
Compiler wird dich warnen, wenn du dies vergisst. Dies hilft dabei,
<code>unsafe</code>-Blöcke so klein wie möglich zu halten, da unsichere Operationen
möglicherweise nicht im gesamten Funktionsrumpf benötigt werden.</p>
<h4 id="erstellen-einer-sicheren-abstraktion-von-unsicherem-code"><a class="header" href="#erstellen-einer-sicheren-abstraktion-von-unsicherem-code">Erstellen einer sicheren Abstraktion von unsicherem Code</a></h4>
<p>Nur weil eine Funktion unsicheren Code enthält, bedeutet das nicht, dass wir
die gesamte Funktion als unsicher markieren müssen. Tatsächlich ist das
Einpacken von unsicherem Codes in eine sichere Funktion eine gängige
Abstraktion. Als Beispiel betrachten wir die Funktion <code>split_at_mut</code> aus der
Standardbibliothek, die unsicheren Code verwendet. Wir untersuchen, wie wir sie
implementieren könnten. Diese sichere Methode ist auf veränderbaren
Anteilstypen definiert: Sie nimmt einen Anteilstyp und macht zwei daraus, indem
sie den Anteilstyp an dem als Argument angegebenen Index teilt. Codeblock 20-4
zeigt, wie man <code>split_at_mut</code> verwendet.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-4: Verwenden der sicheren Funktion
<code>split_at_mut</code></span></p>
<p>Wir können diese Funktion nicht nur mit sicherem Rust implementieren. Ein
Versuch könnte in etwa wie in Codeblock 20-5 aussehen, der sich nicht
kompilieren lässt. Der Einfachheit halber implementieren wir <code>split_at_mut</code> als
Funktion und nicht als Methode und nur für Anteilstypen von <code>i32</code>-Werten, nicht
für einen generischen Typ <code>T</code>.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-5: Versuch einer Implementierung von
<code>split_at_mut</code> unter ausschließlicher Verwendung von sicherem Rust</span></p>
<p>Diese Funktion ermittelt zunächst die Gesamtlänge des Anteilstypen. Dann stellt
sie fest, dass der als Parameter angegebene Index innerhalb des Anteilstypen
liegt, indem sie prüft, ob er kleiner oder gleich der Länge ist. Die
Zusicherung (assertion) bedeutet, dass die Funktion abstürzt, wenn wir einen
Index übergeben, der größer als die Länge ist, bei der der Anteilstyp geteilt
werden soll, bevor sie versucht, diesen Index zu verwenden.</p>
<p>Dann geben wir zwei veränderbare Anteilstypen in einem Tupel zurück: Einen vom
Anfang des ursprünglichen Anteilstyps bis zum Index <code>mid</code> und einen weiteren
von <code>mid</code> bis zum Ende des Anteilstyps.</p>
<p>Wenn wir versuchen, den Code in Codeblock 20-5 zu kompilieren, erhalten wir
einen Fehler.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>Der Ausleihenprüfer von Rust kann nicht verstehen, dass wir verschiedene Teile
des Anteilstyps ausleihen; er weiß nur, dass wir zweimal vom selben Anteilstyp
ausleihen. Das Ausleihen verschiedener Teile eines Anteilstyps ist
grundsätzlich in Ordnung, weil sich die beiden Anteilstypen nicht überlappen,
aber Rust ist nicht schlau genug, um das zu wissen. Wenn wir wissen, dass der
Code in Ordnung ist, Rust aber nicht, ist es an der Zeit, unsicheren Code zu
verwenden.</p>
<p>Codeblock 20-6 zeigt, wie man einen <code>unsafe</code>-Block, einen Rohzeiger und einige
Aufrufe unsicherer Funktionen verwendet, um die Implementierung von
<code>split_at_mut</code> zum Funktionieren zu bringen.</p>
<pre><pre class="playground"><code class="language-rust">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-6: Verwenden von unsicherem Codes bei der
Implementierung der Funktion <code>split_at_mut</code></span></p>
<p>Erinnere dich an <a href="ch04-03-slices.html">„Der Anteilstyp (slice)“</a> in Kapitel 4, dass
Anteilstypen Zeiger auf Daten und die Länge des Anteilstyps sind. Wir verwenden
die Methode <code>len</code>, um die Länge eines Anteilstyps zu erhalten, und die Methode
<code>as_mut_ptr</code>, um auf den Rohzeiger eines Anteilstyps zuzugreifen. Da wir in
diesem Fall einen veränderbaren Anteilstyp von <code>i32</code>-Werten haben, gibt
<code>as_mut_ptr</code> einen Rohzeiger vom Typ <code>*mut i32</code> zurück, den wir in der Variable
<code>ptr</code> gespeichert haben.</p>
<p>Wir halten an der Zusicherung fest, dass der Index <code>mid</code> innerhalb des
Anteilstyps liegt. Dann kommen wir zum unsicheren Code: Die Funktion
<code>slice::from_raw_parts_mut</code> nimmt einen Rohzeiger und eine Länge und erzeugt
einen Anteilstyp. Wir verwenden diese Funktion, um einen Anteilstyp zu
erstellen, der mit <code>ptr</code> beginnt und <code>mid</code> Elemente lang ist. Dann rufen wir
die Methode <code>add</code> auf <code>ptr</code> mit <code>mid</code> als Argument auf, um einen Rohzeiger
zu erhalten, der bei <code>mid</code> beginnt, und wir erzeugen einen Anteilstyp mit
diesem Zeiger und der verbleibenden Anzahl von Elementen nach <code>mid</code>.</p>
<p>Die Funktion <code>slice::from_raw_parts_mut</code> ist unsicher, weil sie einen Rohzeiger
nimmt und darauf vertrauen muss, dass dieser Zeiger gültig ist. Die Methode
<code>add</code> auf dem Rohzeiger ist ebenfalls unsicher, weil sie darauf vertrauen muss,
dass die Offset-Position ebenfalls ein gültiger Zeiger ist. Deshalb mussten wir
einen <code>unsafe</code>-Block um unsere Aufrufe von <code>slice::from_raw_parts_mut</code> und
<code>add</code> legen, damit wir sie aufrufen konnten. Wenn wir uns den Code ansehen und
die Zusicherung hinzufügen, dass <code>mid</code> kleiner oder gleich <code>len</code> sein muss,
können wir sagen, dass alle Rohzeiger innerhalb des <code>unsafe</code>-Blocks gültige
Zeiger auf Daten innerhalb des Anteilstyps sind. Dies ist eine akzeptable und
angemessene Verwendung von <code>unsafe</code>.</p>
<p>Beachte, dass wir die resultierende Funktion <code>split_at_mut</code> nicht als <code>unsafe</code>
markieren müssen, und wir können diese Funktion aus dem sicheren Rust aufrufen.
Wir haben eine sichere Abstraktion des unsicheren Codes mit einer
Implementierung der Funktion geschaffen, die <code>unsafe</code> Code auf sichere Weise
verwendet, weil sie nur gültige Zeiger aus den Daten erzeugt, auf die diese
Funktion Zugriff hat.</p>
<p>Im Gegensatz dazu würde die Verwendung von <code>slice::from_raw_parts_mut</code> in
Codeblock 20-7 wahrscheinlich abstürzen, wenn der Anteilstyp verwendet wird.
Dieser Code nimmt einen beliebigen Speicherplatz und erzeugt einen Anteilstyp
mit einer Länge von 10.000 Elementen.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 20-7: Erstellen eines Anteilstyps aus einer
beliebigen Speicherstelle</span></p>
<p>Wir besitzen den Speicher an dieser beliebigen Stelle nicht und es gibt keine
Garantie, dass der von diesem Code erzeugte Anteilstyp gültige <code>i32</code>-Werte
enthält. Der Versuch, <code>values</code> so zu benutzen, als ob er ein gültiger
Anteilstyp ist, führt zu undefiniertem Verhalten.</p>
<h4 id="verwenden-von-extern-funktionen-um-externen-code-aufzurufen"><a class="header" href="#verwenden-von-extern-funktionen-um-externen-code-aufzurufen">Verwenden von <code>extern</code>-Funktionen um externen Code aufzurufen</a></h4>
<p>Manchmal muss dein Rust-Code möglicherweise mit Code interagieren, der in einer
anderen Sprache geschrieben wurde. Hierfür hat Rust das Schlüsselwort <code>extern</code>,
das das Erstellen und Verwenden einer <em>Fremdfunktionsschnittstelle</em> (Foreign
Function Interface, kurz FFI) erleichtert. Eine FFI ist eine Möglichkeit für
eine Programmiersprache, Funktionen zu definieren und es einer anderen
(fremden) Programmiersprache zu ermöglichen, diese Funktionen aufzurufen.</p>
<p>In Codeblock 20-8 wird gezeigt, wie eine Integration der Funktion <code>abs</code> aus der
C-Standardbibliothek erfolgt. Funktionen, die in <code>extern</code>-Blöcken deklariert
sind, sind normalerweise unsicher, wenn sie aus Rust Code aufgerufen werden,
und müssen daher mit <code>unsafe</code> gekennzeichnet werden. Der Grund dafür ist, dass
andere Sprachen die Regeln und Garantien von Rust nicht erzwingen und Rust sie
nicht überprüfen kann, sodass die Verantwortung für die Sicherheit beim
Programmierer liegt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolutwert von -3 gemäß C: {}", abs(-3));
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 20-8: Deklarieren und Aufrufen einer
<code>extern</code>-Funktion, die in einer anderen Sprache definiert wurde</span></p>
<p>Innerhalb des Blocks <code>unsafe extern "C"</code> listen wir die Namen und Signaturen
von externen Funktionen aus einer anderen Sprache auf, die wir aufrufen wollen.
Der Teil <code>"C"</code> definiert, welche <em>Binärschnittstelle</em> (application binary
interface, kurz ABI) die externe Funktion benutzt: Die ABI definiert, wie die
Funktion auf der technischen Ebene (assembly level) aufgerufen wird. Die ABI
<code>"C"</code> ist die gebräuchlichste und folgt der ABI der Programmiersprache C.
Informationen über alle von Rust unterstützten ABIs finden Sie in der
<a href="https://doc.rust-lang.org/nightly/reference/items/external-blocks.html#abi">Rust-Referenz</a>.</p>
<p>Jedes Element, das innerhalb eines <code>unsafe extern</code>-Blocks deklariert wird, ist
implizit <code>unsafe</code>. Einige FFI-Funktionen sind jedoch <em>sicher aufrufbar</em>. Zum
Beispiel hat die Funktion <code>abs</code> aus der C-Standardbibliothek keine Überlegungen
zur Speichersicherheit und wir wissen, dass sie mit jedem <code>i32</code> aufgerufen
werden kann. In solchen Fällen können wir das Schlüsselwort <code>safe</code> verwenden,
um zu sagen, dass der Aufruf dieser speziellen Funktion sicher ist, obwohl sie
sich in einem <code>unsafe extern</code>-Block befindet. Sobald wir diese Änderung
vorgenommen haben, erfordert der Aufruf der Funktion keinen <code>unsafe</code>-Block
mehr, wie in Codeblock 20-9 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">unsafe extern "C" {
    safe fn abs(input: i32) -&gt; i32;
}

fn main() {
    println!("Absolutwert von -3 gemäß C: {}", abs(-3));
}</code></pre></pre>
<p><span class="caption">Codeblock 20-9: Explizite Kennzeichnung einer Funktion
mit <code>safe</code> innerhalb eines <code>unsafe extern</code>-Blocks und sicherer Aufruf dieser
Funktion</span></p>
<p>Die Kennzeichnung einer Funktion mit <code>safe</code> macht sie nicht von sich aus
sicher! Vielmehr ist es ein Versprechen, das du Rust gegenüber abgibst, dass
sie <em>sicher</em> ist. Es bleibt in deiner Verantwortung, dafür zu sorgen, dass
dieses Versprechen eingehalten wird!</p>
<blockquote>
<h4 id="aufrufen-von-rust-funktionen-aus-anderen-sprachen"><a class="header" href="#aufrufen-von-rust-funktionen-aus-anderen-sprachen">Aufrufen von Rust-Funktionen aus anderen Sprachen</a></h4>
<p>Wir können auch <code>extern</code> verwenden, um eine Schnittstelle zu schaffen, die es
anderen Sprachen erlaubt, Rust-Funktionen aufzurufen. Anstelle eines
<code>extern</code>-Blocks fügen wir das Schlüsselwort <code>extern</code> hinzu und geben die zu
verwendende ABI unmittelbar vor dem Schlüsselwort <code>fn</code> der relevanten
Funktion an. Wir müssen auch eine Annotation <code>#[unsafe(no_mangle)]</code>
hinzufügen, um dem Rust-Compiler mitzuteilen, dass er den Namen dieser
Funktion nicht verändern soll. <em>Mangling</em> bedeutet, dass ein Compiler den
Namen, den wir einer Funktion gegeben haben, in einen anderen Namen ändert,
der mehr Informationen für andere Teile des Kompiliervorgangs enthält, aber
weniger menschenlesbar ist. Jeder Programmiersprachen-Compiler verändert
Namen etwas anders. Damit eine Rust-Funktion von anderen Sprachen aufgerufen
werden kann, müssen wir also die Namensveränderung des Rust-Compilers
deaktivieren. Dies ist unsicher, da es ohne die eingebaute
Namensveränderung-Funktion zu Namenskollisionen in verschiedenen Bibliotheken
kommen kann. Es liegt also in unserer Verantwortung, sicherzustellen, dass
der von uns gewählte Name ohne Namensveränderung sicher exportiert werden
kann.</p>
<p>Im folgenden Beispiel machen wir die Funktion <code>call_from_c</code> von C-Code aus
zugänglich, nachdem sie in eine gemeinsame Bibliothek kompiliert und von C
gelinkt wurde:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Rust-Funktion von C aufgerufen!");
}
<span class="boring">}</span></code></pre></pre>
<p>Diese Verwendung von <code>extern</code> erfordert <code>unsafe</code> nur im Attribut, nicht im
<code>extern</code>-Block.</p>
</blockquote>
<h3 id="zugreifen-oder-Ändern-einer-veränderbaren-statischen-variable"><a class="header" href="#zugreifen-oder-Ändern-einer-veränderbaren-statischen-variable">Zugreifen oder Ändern einer veränderbaren, statischen Variable</a></h3>
<p>In diesem Buch haben wir noch nicht über <em>globale Variablen</em> gesprochen, die
Rust zwar unterstützt, die aber wegen der Eigentumsregeln von Rust
problematisch sein können. Wenn zwei Stränge (threads) auf dieselbe
veränderbare, globale Variable zugreifen, kann dies zu einer
Daten-Wettlaufsituation (data race) führen.</p>
<p>In Rust werden globale Variablen als <em>statische</em> Variablen bezeichnet.
Codeblock 20-10 zeigt ein Beispiel für die Deklaration und Verwendung einer
statischen Variablen mit einem Zeichenkettenanteilstyp als Wert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = "Hallo Welt!";

fn main() {
    println!("Name ist: {HELLO_WORLD}");
}</code></pre></pre>
<p><span class="caption">Codeblock 20-10: Definieren und Verwenden einer
unveränderbaren, statischen Variablen</span></p>
<p>Statische Variablen ähneln Konstanten, die wir in
<a href="ch03-01-variables-and-mutability.html#konstanten">„Konstanten“</a> in Kapitel 3
besprochen haben. Die Namen von statischen Variablen stehen per Konvention in
<code>SCHREIENDER_SCHLANGENSCHRIFT</code>. Statische Variablen können nur Referenzen mit
der Lebensdauer <code>'static</code> speichern, was bedeutet, dass der Rust-Compiler die
Lebensdauer herausfinden kann, und wir brauchen sie nicht explizit anzugeben.
Der Zugriff auf eine unveränderbare, statische Variable ist sicher.</p>
<p>Ein feiner Unterschied zwischen Konstanten und unveränderbaren, statischen
Variablen besteht darin, dass Werte in einer statischen Variable eine feste
Adresse im Speicher haben. Beim Verwenden des Wertes wird immer auf die
gleichen Daten zugegriffen. Konstanten hingegen dürfen ihre Daten duplizieren,
wann immer sie verwendet werden. Ein weiterer Unterschied besteht darin, dass
statische Variablen veränderbar sein können. Der Zugriff auf und die Änderung
von veränderbaren, statischen Variablen ist <em>unsicher</em>. Codeblock 20-11 zeigt,
wie man eine veränderbare, statische Variable namens <code>COUNTER</code> deklariert, auf
sie zugreift und sie modifiziert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

/// SAFETY: Calling this from more than a single thread at a time is undefined
/// behavior, so you *must* guarantee you only call it from a single thread at
/// a time.
unsafe fn add_to_count(inc: u32) {
    COUNTER += inc;
}

fn main() {
    unsafe {
        // SAFETY: This is only called from a single thread in `main`.
        add_to_count(3);
        println!("COUNTER: {}", COUNTER);
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 20-11: Lesen von und Schreiben in eine
veränderbare, statische Variable ist unsicher</span></p>
<p>Wie bei regulären Variablen spezifizieren wir die Veränderbarkeit mit dem
Schlüsselwort <code>mut</code>. Jeder Code, der <code>COUNTER</code> liest oder schreibt, muss
innerhalb eines <code>unsafe</code>-Blocks liegen. Dieser Code kompiliert und gibt
<code>COUNTER: 3</code> so, wie wir es erwarten würden, weil er nur einen einzigen Strang
hat. Wenn mehrere Stränge auf <code>COUNTER</code> zugreifen, würde dies wahrscheinlich zu
einer Daten-Wettlaufsituation führen, es handelt sich also um ein undefiniertes
Verhalten. Daher müssen wir die gesamte Funktion als <code>unsafe</code> kennzeichnen und
die Sicherheitseinschränkung dokumentieren, damit jeder, der die Funktion
aufruft, weiß, was er sicher tun darf und was nicht.</p>
<p>Immer wenn wir eine <code>unsafe</code>-Funktion schreiben, ist es idiomatisch, einen
Kommentar anzugeben, der mit <code>SAFETY</code> beginnt und erklärt, was der Aufrufer tun
muss, um die Funktion sicher aufzurufen. Ebenso ist es idiomatisch, beim Aufruf
einer <code>unsafe</code>-Operation einen Kommentar zu schreiben, der mit <code>SAFETY</code>
beginnt, um zu erklären, wie die Sicherheitsregeln eingehalten werden.</p>
<p>Außerdem erlaubt der Compiler nicht, Referenzen auf eine veränderbare statische
Variable zu erstellen. Du kannst nur über einen Rohzeiger darauf zugreifen, der
mit einem der Roh-Ausleihen-Operatoren erstellt wurde. Das gilt auch für Fälle,
in denen die Referenz unsichtbar erstellt wird, wie bei der Verwendung von
<code>println!</code> in diesem Codeblock. Die Anforderung, dass Referenzen auf statische
veränderbare Variablen nur über Rohzeiger erstellt werden können, trägt dazu
bei, die Sicherheitsanforderungen deutlicher zu machen.</p>
<p>Bei veränderbaren Daten, die global zugänglich sind, ist es schwierig,
sicherzustellen, dass es keine Daten-Wettlaufsituationen gibt, weshalb Rust
veränderbare, statische Variablen als unsicher betrachtet. Wann immer möglich,
ist es vorzuziehen, die in Kapitel 16 besprochenen Nebenläufigkeitstechniken
und Strang-sicheren, intelligenten Zeiger zu verwenden, damit der Compiler
prüft, ob der Datenzugriff von verschiedenen Strängen sicher ist.</p>
<h3 id="implementieren-eines-unsicheren-merkmals"><a class="header" href="#implementieren-eines-unsicheren-merkmals">Implementieren eines unsicheren Merkmals</a></h3>
<p>Wir können <code>unsafe</code> zum Implementieren eines unsicheren Merkmals (unsafe trait)
verwenden. Ein Merkmal ist unsicher, wenn mindestens eine ihrer Methoden eine
Invariante hat, die der Compiler nicht verifizieren kann. Wir können erklären,
dass ein Merkmal <code>unsafe</code> ist, indem wir das Schlüsselwort <code>unsafe</code> vor <code>trait</code>
einfügen und die Implementierung des Merkmals ebenfalls mit <code>unsafe</code> markieren,
wie in Codeblock 20-12 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // Methoden kommen hierhin
}

unsafe impl Foo for i32 {
    // Methoden-Implementierungen kommen hierhin
}

fn main() {}</code></pre></pre>
<p><span class="caption">Codeblock 20-12: Definition und Implementierung eines
unsicheren Merkmals</span></p>
<p>Indem wir <code>unsafe impl</code> verwenden, versprechen wir, dass wir die Invarianten
aufrechterhalten, die der Compiler nicht verifizieren kann.</p>
<p>Erinnere dich als Beispiel an die Marker-Merkmale <code>Sync</code> und <code>Send</code>, die wir in
<a href="ch16-04-extensible-concurrency-sync-and-send.html">„Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) <code>Sync</code> und
<code>Send</code>“</a> in Kapitel 16
besprochen haben: Der Compiler implementiert diese Merkmale automatisch, wenn
unsere Typen vollständig aus anderen Typen zusammengesetzt sind, die <code>Send</code> und
<code>Sync</code> implementieren. Wenn wir einen Typ implementieren, der einen Typ
enthält, der nicht <code>Send</code> oder <code>Sync</code> implementiert, z.B. Rohzeiger, und wir
diesen Typ als <code>Send</code> oder <code>Sync</code> markieren wollen, müssen wir <code>unsafe</code>
verwenden. Rust kann nicht überprüfen, ob unser Typ die Garantien
aufrechterhält, dass er sicher über Stränge gesendet oder von mehreren Strängen
aus zugegriffen werden kann; daher müssen wir diese Prüfungen manuell
durchführen und als solche mit <code>unsafe</code> kennzeichnen.</p>
<h3 id="zugreifen-auf-felder-einer-vereinigung-union"><a class="header" href="#zugreifen-auf-felder-einer-vereinigung-union">Zugreifen auf Felder einer Vereinigung (union)</a></h3>
<p>Die letzte Aktion, die nur mit <code>unsafe</code> funktioniert, ist der Zugriff auf
Felder einer <code>union</code>, die ähnlich zu einer <code>struct</code> ist, bei der aber immer nur
ein deklariertes Feld in einer bestimmten Instanz verwendet wird. Vereinigungen
werden hauptsächlich als Schnittstelle zu Vereinigungen in C-Code verwendet.
Der Zugriff auf Vereinigungsfelder ist unsicher, da Rust den Typ der Daten, die
derzeit in der Vereinigungsinstanz gespeichert sind, nicht garantieren kann.
Weitere Informationen über Vereinigung findest du in der
<a href="https://doc.rust-lang.org/reference/items/unions.html">Rust-Referenz</a>.</p>
<h3 id="miri-zur-Überprüfung-von-unsafe-code-verwenden"><a class="header" href="#miri-zur-Überprüfung-von-unsafe-code-verwenden">Miri zur Überprüfung von <code>unsafe</code>-Code verwenden</a></h3>
<p>Wenn du unsicheren Code schreibst, möchtest du vielleicht überprüfen, ob das,
was du geschrieben hast, tatsächlich sicher und korrekt ist. Eine der besten
Möglichkeiten, dies zu tun, ist die Verwendung von Miri, einem offiziellen
Rust-Werkzeug zur Erkennung von undefiniertem Verhalten. Während der
Ausleihenprüfer ein <em>statisches</em> Werkzeug ist, das zur Kompilierzeit arbeitet,
ist Miri ein <em>dynamisches</em> Werkzeug, das zur Laufzeit arbeitet. Es prüft deinen
Code, indem es dein Programm oder deine Testfälle ausführt und erkennt, ob du
Rust-Regeln verletzt.</p>
<p>Die Verwendung von Miri erfordert einen Nightly-Build von Rust (über das wir in
<a href="appendix-07-nightly-rust.html">Anhang G: Wie Rust erstellt wird und „nächtliches Rust“</a> sprechen).
Du kannst sowohl eine nächtliche Version von Rust als auch das Miri-Tool
installieren, indem du <code>rustup +nightly component add miri</code> ausführst. Dies
ändert nicht die Rust-Version deines Projekts, sondern fügt das Werkzeug nur zu
deinem System hinzu, damit du es verwenden kannst, wenn du willst. Du kannst
Miri für ein Projekt ausführen, indem du <code>cargo +nightly miri run</code> oder <code>cargo  +nightly miri test</code> eingibst.</p>
<p>Ein Beispiel dafür, wie hilfreich dies sein kann, siehst du beim Ausführen mit
Codeblock 20-11:</p>
<pre><code class="language-console">$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `/Users/chris/.rustup/toolchains/nightly-aarch64-apple-darwin/bin/cargo-miri runner target/miri/aarch64-apple-darwin/debug/unsafe-example`
warning: creating a shared reference to mutable static is discouraged
  --&gt; src/main.rs:14:33
   |
14 |         println!("COUNTER: {}", COUNTER);
   |                                 ^^^^^^^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
   = note: `#[warn(static_mut_refs)]` on by default

COUNTER: 3
</code></pre>
<p>Miri warnt uns richtigerweise, dass wir gemeinsame Referenzen auf veränderbare
Daten haben. Hier gibt Miri nur eine Warnung aus, da in diesem Fall nicht
garantiert ist, dass es sich um undefiniertes Verhalten handelt, und es sagt
uns nicht, wie wir das Problem beheben können. In einigen Fällen kann Miri auch
eindeutige Fehler erkennen – Codemuster, die <em>mit Sicherheit</em> falsch sind
– und Empfehlungen geben, wie diese Fehler behoben werden können.</p>
<p>Miri deckt nicht alles auf, was man beim Schreiben von unsicherem Code falsch
machen könnte. Miri ist ein dynamisches Analysewerkzeug, d.h. es erkennt nur
Probleme mit Code, der tatsächlich ausgeführt wird. Das bedeutet, dass du es in
Verbindung mit guten Testverfahren verwenden musst, um dein Vertrauen in den
von dir geschriebenen unsicheren Code zu erhöhen. Miri deckt auch nicht alle
Möglichkeiten ab, in denen dein Code unsauber sein kann.</p>
<p>Mit anderen Worten: Wenn Miri ein Problem <em>findet</em>, weißt du, dass es einen
Fehler gibt, aber nur weil Miri <em>keinen</em> Fehler findet, heißt das nicht, dass
kein Problem vorhanden ist. Es kann allerdings eine Menge finden. Versuche, es
auf die anderen Beispiele mit unsicherem Code in diesem Kapitel anzuwenden und
sieh, was es sagt!</p>
<p>Mehr über Miri erfährst du in seinem <a href="https://github.com/rust-lang/miri">GitHub-Repository</a>.</p>
<h3 id="wann-unsicheren-code-verwenden"><a class="header" href="#wann-unsicheren-code-verwenden">Wann unsicheren Code verwenden?</a></h3>
<p>Die Verwendung von <code>unsafe</code> für eine der fünf gerade besprochenen Superkräfte
ist nicht falsch oder gar verpönt, aber es ist kniffliger, <code>unsafe</code> Code
korrekt zu schreiben, weil der Compiler nicht helfen kann, die
Speichersicherheit aufrechtzuerhalten. Wenn du einen Grund hast, <code>unsafe</code> Code
zu verwenden, kannst du dies tun, und die explizite <code>unsafe</code>-Annotation macht
es einfacher, die Quelle von Problemen aufzuspüren, wenn sie auftreten. Wann
immer du unsicheren Code schreibst, kannst du Miri verwenden, um dich zu
vergewissern, dass der von dir geschriebene Code die Rust-Regeln einhält.</p>
<p>Wenn du dich eingehender mit der effektiven Arbeit mit unsicherem Rust befassen
möchtest, lies den offiziellen Rust-Leitfaden zum Thema
<a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-00-advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-02-advanced-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-00-advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-02-advanced-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
