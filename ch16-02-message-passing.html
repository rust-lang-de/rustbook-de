<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nachrichtenaustausch zwischen Strängen (threads) - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="nachrichtenaustausch-zwischen-strängen-threads"><a class="header" href="#nachrichtenaustausch-zwischen-strängen-threads">Nachrichtenaustausch zwischen Strängen (threads)</a></h2>
<p>Ein immer beliebter werdender Ansatz zur Gewährleistung einer sicheren
Nebenläufigkeit (safe concurrency) ist der <em>Nachrichtenaustausch</em> (message
passing), bei dem Stränge oder Akteure kommunizieren, indem sie sich
gegenseitig Nachrichten mit Daten senden. Hier ist die Idee in einem Slogan aus
der <a href="https://golang.org/doc/effective_go.html#concurrency">Go-Sprachdokumentation</a>: „Kommuniziere nicht, indem du
Arbeitsspeicher teilst; teile stattdessen Arbeitsspeicher durch Kommunikation.“</p>
<p>Um Nebenläufigkeit beim Senden von Nachrichten zu erreichen, bietet die
Standardbibliothek von Rust eine Implementierung für Kanäle. Ein <em>Kanal</em>
(channel) ist ein allgemeines Programmierkonzept, mit dem Daten von einem
Strang zu einem anderen gesendet werden.</p>
<p>Du kannst dir einen Kanal in der Programmierung wie einen gerichteten
Wasserkanal vorstellen, z.B. einen Bach oder einen Fluss. Wenn du etwas wie
eine Gummiente in einen Fluss setzt, wird sie stromabwärts bis zum Ende des
Wasserwegs reisen.</p>
<p>Ein Kanal hat zwei Hälften: Einen Sender und einen Empfänger. Die Senderhälfte
ist die stromaufwärts gelegene Stelle, an der du die Gummiente in den Fluss
setzt, und die Empfängerhälfte ist die Stelle, an der die Gummiente
stromabwärts ankommt. Ein Teil deines Codes ruft Methoden auf dem Sender mit
den Daten auf, die du senden möchtest, und ein anderer Teil überprüft die
Empfangsseite auf ankommende Nachrichten. Ein Kanal gilt als <em>geschlossen</em>
(closed), wenn entweder die Sender- oder die Empfängerhälfte aufgeräumt
(dropped) wird.</p>
<p>Hier erarbeiten wir uns ein Programm, das einen Strang hat, um Werte zu
generieren und sie über einen Kanal zu senden, und einen anderen Strang, der
die Werte empfängt und ausgibt. Wir werden einfache Werte zwischen den Strängen
über einen Kanal senden, um die Funktionalität zu veranschaulichen. Sobald du
mit der Technik vertraut bist, kannst du Kanäle für alle Stränge verwenden, die
miteinander kommunizieren müssen, z.B. für ein Chatsystem oder ein System, in
dem viele Stränge Teile einer Berechnung durchführen und die Teile an einen
Strang senden, der die Ergebnisse zusammenfasst.</p>
<p>Erstens werden wir in Codeblock 16-6 einen Kanal erstellen, aber nichts damit
machen. Beachte, dass sich dieser Code noch nicht kompilieren lässt, weil Rust
nicht sagen kann, welchen Typ von Werten wir über den Kanal senden wollen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre></pre>
<p><span class="caption">Codeblock 16-6: Erstellen eines Kanals und Zuweisen der
beiden Hälften zu <code>tx</code> und <code>rx</code></span></p>
<p>Wir erstellen einen neuen Kanal mit der Funktion <code>mpsc::channel</code>; <code>mpsc</code> steht
für <em>mehrfacher Produzent, einzelner Konsument</em> (multiple producer, single
consumer). Kurz gesagt, die Art und Weise, wie die Standardbibliothek von Rust
Kanäle implementiert, bedeutet, dass ein Kanal mehrere <em>sendende</em> Enden haben
kann, die Werte produzieren, aber nur ein <em>empfangendes</em> Ende, das diese Werte
konsumiert. Stell dir vor, mehrere Bäche würden zu einem großen Fluss
zusammenfließen: Alles, was in einem der Bäche hinuntergeschickt wird, landet
am Ende in einem Fluss. Wir fangen zunächst mit einem einzigen Produzenten an,
aber wir fügen mehrere Produzenten hinzu, wenn dieses Beispiel funktioniert.</p>
<p>Die Funktion <code>mpsc::channel</code> gibt ein Tupel zurück, dessen erstes Element die
sendende Seite und dessen zweites Element die empfangende Seite ist. Die
Abkürzungen <code>tx</code> und <code>rx</code> werden traditionell in vielen Feldern für <em>Sender</em>
(transmitter) bzw. <em>Empfänger</em> (receiver) verwendet, daher benennen wir unsere
Variablen als solche, um jedes Ende anzugeben. Wir verwenden eine
<code>let</code>-Anweisung mit einem Muster, das die Tupel destrukturiert; wir werden die
Verwendung von Mustern in <code>let</code>-Anweisungen und die Destrukturierung in Kapitel
19 besprechen. Für den Moment solltest du wissen, dass die Verwendung einer
<code>let</code>-Anweisung auf diese Weise ein bequemer Ansatz ist, um die Teile des
Tupels zu extrahieren, die von <code>mpsc::channel</code> zurückgegeben werden.</p>
<p>Verschieben wir das sendende Ende in einen erzeugten Strang und lassen es eine
Zeichenkette senden, sodass der erzeugte Strang mit dem Hauptstrang
kommuniziert, wie in Codeblock 16-7 gezeigt. Das ist so, als würde man eine
Gummiente flussaufwärts in den Fluss setzen oder eine Chat-Nachricht von einem
Strang zum anderen senden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hallo");
        tx.send(val).unwrap();
    });
}</code></pre></pre>
<p><span class="caption">Codeblock 16-7: Verschieben von <code>tx</code> in einen erzeugten
Strang und Senden von „hallo“</span></p>
<p>Wieder verwenden wir <code>thread::spawn</code>, um einen neuen Strang zu erstellen, und
dann <code>move</code>, um <code>tx</code> in den Funktionsabschluss zu verschieben, sodass der
erzeugte Strang <code>tx</code> besitzt. Der erzeugte Strang muss den Sender besitzen, um
in der Lage zu sein, Nachrichten durch den Kanal zu senden.</p>
<p>Der Sender hat eine Methode <code>send</code>, die den Wert entgegennimmt, den wir senden
wollen. Die Methode <code>send</code> gibt ein <code>Result&lt;T, E&gt;</code> zurück; wenn also die
empfangende Seite bereits aufgeräumt wurde und es keinen Ort gibt, an den ein
Wert gesendet werden kann, wird die Sendeoperation einen Fehler zurückgeben. In
diesem Beispiel rufen wir <code>unwrap</code> auf, um im Falle eines Fehlers abzubrechen.
Aber in einer echten Anwendung würden wir es ordentlich handhaben: Kehre zu
Kapitel 9 zurück, um Strategien für eine korrekte Fehlerbehandlung anzusehen.</p>
<p>In Codeblock 16-8 erhalten wir den Wert vom Empfänger im Hauptstrang. Das ist
so, als würde man die Gummiente am Ende des Flusses aus dem Wasser holen oder
eine Chat-Nachricht erhalten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hallo");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Erhalten: {received}");
}</code></pre></pre>
<p><span class="caption">Codeblock 16-8: Empfangen des Wertes „hallo“ im
Hauptstrang und Ausgeben des Wertes</span></p>
<p>Das Empfänger hat zwei nützliche Methoden: <code>recv</code> und <code>try_recv</code>. Wir benutzen
<code>recv</code>, kurz für <em>empfangen</em> (receive), was die Ausführung des Hauptstrangs
blockiert und wartet, bis ein Wert in den Kanal geschickt wird. Sobald ein Wert
gesendet wurde, wird er von <code>recv</code> in einem <code>Result&lt;T, E&gt;</code> zurückgegeben. Wenn
der Sender geschlossen ist, gibt <code>recv</code> einen Fehler zurück, um zu
signalisieren, dass keine weiteren Werte mehr kommen werden.</p>
<p>Die Methode <code>try_recv</code> blockiert nicht, sondern gibt stattdessen sofort ein
<code>Result&lt;T, E&gt;</code> zurück: Einen <code>Ok</code>-Wert, der eine Nachricht enthält, wenn eine
verfügbar ist, und einen <code>Err</code>-Wert, wenn gerade keine Nachricht vorhanden ist.
Die Verwendung von <code>try_recv</code> ist nützlich, wenn dieser Strang während des
Wartens auf Nachrichten andere Arbeiten zu erledigen hat: Wir könnten eine
Schleife schreiben, die <code>try_recv</code> ab und zu aufruft, eine Nachricht
verarbeitet, wenn eine verfügbar ist, und ansonsten für eine Weile andere
Arbeiten erledigt, bis sie erneut überprüft wird.</p>
<p>Wir haben in diesem Beispiel der Einfachheit halber <code>recv</code> verwendet; wir haben
keine andere Arbeit für den Hauptstrang zu erledigen, außer auf Nachrichten zu
warten, daher ist es angebracht, den Hauptstrang zu blockieren.</p>
<p>Wenn wir den Code in Codeblock 16-8 ausführen, sehen wir den durch den
Hauptstrang ausgegebenen Wert:</p>
<pre><code class="language-text">Erhalten: hallo
</code></pre>
<p>Perfekt!</p>
<h3 id="kanäle-und-eigentümerschaftsübertragung"><a class="header" href="#kanäle-und-eigentümerschaftsübertragung">Kanäle und Eigentümerschaftsübertragung</a></h3>
<p>Die Eigentumsregeln spielen beim Nachrichtenversand eine entscheidende Rolle,
da sie dir helfen, sicheren, nebenläufigen Code zu schreiben. Die Vermeidung
von Fehlern bei der nebenläufigen Programmierung ist der Vorteil, den du durch
Berücksichtigen der Eigentümerschaft in deinen Rust-Programmen erhältst. Lass
uns ein Experiment machen, um zu zeigen, wie Kanäle und Eigentümerschaft
zusammenwirken, um Probleme zu vermeiden: Wir versuchen, einen Wert <code>val</code> im
erzeugten Strang zu verwenden, <em>nachdem</em> wir ihn in den Kanal geschickt haben.
Versuche, den Code in Codeblock 16-9 zu kompilieren, um zu sehen, warum dieser
Code nicht erlaubt ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hallo");
        tx.send(val).unwrap();
        println!("val ist {val}");
    });

    let received = rx.recv().unwrap();
    println!("Erhalten: {received}");
}</code></pre></pre>
<p><span class="caption">Codeblock 16-9: Versuch, <code>val</code> zu benutzen, nachdem wir
es in den Kanal geschickt haben</span></p>
<p>Hier versuchen wir, <code>val</code> auszugeben, nachdem wir es per <code>tx.send</code> in den Kanal
geschickt haben. Dies zuzulassen wäre eine schlechte Idee: Sobald der Wert an
einen anderen Strang gesendet wurde, könnte dieser Strang ihn ändern oder
aufräumen, bevor wir versuchen, den Wert erneut zu verwenden. Möglicherweise
können die Änderungen des anderen Strangs aufgrund inkonsistenter oder nicht
vorhandener Daten zu Fehlern oder unerwarteten Ergebnissen führen. Rust gibt
uns jedoch einen Fehler, wenn wir versuchen, den Code in Codeblock 16-9 zu
kompilieren:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {val}");
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
</code></pre>
<p>Unser Nebenläufigkeitsfehler hat einen Kompilierzeitfehler verursacht. Die
Funktion <code>send</code> übernimmt die Eigentümerschaft an ihrem Parameter und wenn der
Wert verschoben wird, übernimmt der Empfänger die Eigentümerschaft an ihm.
Dadurch wird verhindert, dass wir den Wert nach dem Senden versehentlich wieder
verwenden; das Eigentumssystem prüft, ob alles in Ordnung ist.</p>
<h3 id="mehrere-werte-senden-und-den-empfänger-warten-sehen"><a class="header" href="#mehrere-werte-senden-und-den-empfänger-warten-sehen">Mehrere Werte senden und den Empfänger warten sehen</a></h3>
<p>Der Code in Codeblock 16-8 wurde kompiliert und ausgeführt, aber er zeigte uns
nicht eindeutig, dass zwei getrennte Stränge über den Kanal miteinander
sprachen. In Codeblock 16-10 haben wir einige Änderungen vorgenommen, die
beweisen, dass der Code in Codeblock 16-8 nebenläufig ausgeführt wird: Der
erzeugte Strang sendet nun mehrere Nachrichten und macht dazwischen eine Pause
von einer Sekunde.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hallo"),
            String::from("aus"),
            String::from("dem"),
            String::from("Strang"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Erhalten: {received}");
    }
}</code></pre></pre>
<p><span class="caption">Codeblock 16-10: Senden mehrerer Nachrichten mit Pausen
dazwischen</span></p>
<p>Diesmal verwendet der erzeugte Strang einen Vektor von Zeichenketten, die wir
an den Hauptstrang senden wollen. Wir iterieren über diese Zeichenketten,
senden jede einzeln und pausieren dazwischen, indem wir die Funktion
<code>thread::sleep</code> mit einem <code>Duration</code>-Wert von einer Sekunde aufrufen.</p>
<p>Im Hauptstrang rufen wir die Funktion <code>recv</code> nicht mehr explizit auf:
Stattdessen behandeln wir <code>rx</code> als Iterator. Jeden empfangenen Wert geben wir
aus. Wenn der Kanal geschlossen wird, wird die Iteration beendet.</p>
<p>Wenn du den Code in Codeblock 16-10 ausführst, solltest du die folgende Ausgabe
mit einer Ein-Sekunden-Pause zwischen jeder Zeile sehen:</p>
<pre><code class="language-text">Erhalten: hallo
Erhalten: aus
Erhalten: dem
Erhalten: Strang
</code></pre>
<p>Da wir keinen Code haben, der die <code>for</code>-Schleife im Hauptstrang pausiert oder
verzögert, können wir sagen, dass der Hauptstrang darauf wartet, Werte vom
erzeugten Strang zu erhalten.</p>
<h3 id="erstellen-mehrerer-produzenten-durch-klonen-des-senders"><a class="header" href="#erstellen-mehrerer-produzenten-durch-klonen-des-senders">Erstellen mehrerer Produzenten durch Klonen des Senders</a></h3>
<p>Vorhin haben wir erwähnt, dass <code>mpsc</code> ein Akronym für <em>mehrfacher Produzent,
einzelner Konsument</em> ist. Lass uns <code>mpsc</code> verwenden und den Code in Codeblock
16-10 erweitern, um mehrere Stränge zu erzeugen, die alle Werte an den gleichen
Empfänger senden. Wir können dies tun, indem wir den Sender klonen, wie in
Codeblock 16-11 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --abschneiden--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hallo"),
            String::from("aus"),
            String::from("dem"),
            String::from("Strang"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("mehr"),
            String::from("Nachrichten"),
            String::from("für"),
            String::from("dich"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Erhalten: {received}");
    }

    // --abschneiden--
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 16-11: Senden mehrerer Nachrichten von mehreren
Produzenten</span></p>
<p>Bevor wir den ersten Strang erzeugen, rufen wir dieses Mal <code>clone</code> auf dem
Sender auf. Dadurch erhalten wir einen weiteren Sender, das wir an den ersten
erzeugten Strang weitergeben können. Wir übergeben den ursprüngliche Sender an
einen zweiten erzeugten Strang. Dadurch erhalten wir zwei Stränge, die jeweils
unterschiedliche Nachrichten an den Empfänger senden.</p>
<p>Wenn du den Code ausführst, sollte deine Ausgabe in etwa so aussehen:</p>
<pre><code class="language-text">Erhalten: hallo
Erhalten: mehr
Erhalten: aus
Erhalten: Nachrichten
Erhalten: für
Erhalten: dem
Erhalten: Strang
Erhalten: dich
</code></pre>
<p>Möglicherweise siehst du die Werte in einer anderen Reihenfolge, dies hängt von
deinem System ab. Das macht die Nebenläufigkeit sowohl interessant als auch
schwierig. Wenn du mit <code>thread::sleep</code> experimentierst und ihm verschiedene
Werte in den verschiedenen Strängen gibst, wird jeder Durchlauf
nicht-deterministischer sein und jedes Mal eine andere Ausgabe erzeugen.</p>
<p>Nachdem wir uns nun angesehen haben, wie Kanäle funktionieren, wollen wir uns
eine andere Methode der Nebenläufigkeit ansehen.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-01-threads.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-03-shared-state.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-01-threads.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-03-shared-state.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
