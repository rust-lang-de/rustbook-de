<!DOCTYPE HTML>
<html lang="de" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Funktionsabschlüsse (closures): Anonyme Funktionen, die ihre Umgebung erfassen können - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Die Programmiersprache Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Vorwort</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Einführung</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Erste Schritte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hallo Welt</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hallo Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Ein Ratespiel programmieren</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Allgemeine Programmierkonzepte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variablen und Veränderlichkeit</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Datentypen</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funktionen</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Kommentare</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrollfluss</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Eigentümerschaft (ownership) verstehen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Was ist Eigentümerschaft (ownership)?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referenzen und Ausleihen (borrowing)</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Der Anteilstyp (slice)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Strukturen (structs) für zusammenhängende Daten verwenden</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Strukturen (structs) definieren und instanziieren</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Beispielprogramm mit Strukturen (structs)</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Methodensyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Aufzählungen (enums) und Musterabgleich (pattern matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Eine Aufzählung (enum) definieren</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Das Kontrollflusskonstrukt match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Prägnanter Kontrollfluss mit if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Wachsende Projekte verwalten mit Paketen (packages), Kisten (crates) und Modulen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Pakete (packages) und Kisten (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Mit Modulen den Kontrollumfang und Datenschutz steuern</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Mit Pfaden auf ein Element im Modulbaum verweisen</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Pfade in den Gültigkeitsbereich bringen mit dem Schlüsselwort use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Module in verschiedene Dateien aufteilen</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Allgemeine Kollektionen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Wertlisten in Vektoren ablegen</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8-kodierten Text in Zeichenketten (strings) ablegen</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Schlüssel mit zugehörigen Werten in Hashtabellen ablegen</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Fehlerbehandlung</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Nicht behebbare Fehler mit panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Behebbare Fehler mit Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Wann panic! aufrufen und wann nicht?</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generische Typen, Merkmale (traits) und Lebensdauer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generische Datentypen</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Merkmale (traits): Gemeinsames Verhalten definieren</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referenzen validieren mit Lebensdauern</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Automatisierte Tests schreiben</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Tests schreiben</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Steuern wie Tests ausgeführt werden</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Testverwaltung</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Ein E/A-Projekt: Ein Kommandozeilenprogramm erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Kommandozeilenargumente entgegennehmen</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Eine Datei einlesen</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Bibliotheksfunktionalität mit testgetriebener Entwicklung erstellen</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Mit Umgebungsvariablen arbeiten</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Fehlermeldungen in die Standardfehlerausgabe anstatt der Standardausgabe schreiben</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Funktionale Sprachelemente: Iteratoren und Funktionsabschlüsse (closures)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html" class="active"><strong aria-hidden="true">13.1.</strong> Funktionsabschlüsse (closures): Anonyme Funktionen, die ihre Umgebung erfassen können</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Eine Reihe von Elementen verarbeiten mit Iteratoren</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Unser E/A-Projekt verbessern</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performanzvergleich: Schleifen vs. Iteratoren</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Mehr über Cargo und Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Bauvorgang anpassen mit Freigabeprofilen (release profiles)</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Kisten (crate) auf crates.io veröffentlichen</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo-Arbeitsbereiche</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Kommandozeilenwerkzeuge von crates.io installieren mit cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Cargo um benutzerdefinierte Befehle erweitern</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Intelligente Zeiger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Mit Box&lt;T&gt; auf Daten im Haldenspeicher zeigen</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Programmcode beim Aufräumen ausführen mit dem Merkmal (trait) Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Der referenzzählende intelligente Zeiger Rc&lt;T&gt;</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; und das innere Veränderlichkeitsmuster</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referenzzyklen können zu einem Speicherleck führen</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Furchtlose Nebenläufigkeit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Mit Strängen (threads) Programmcode gleichzeitig ausführen</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Nachrichtenaustausch zwischen Strängen (threads)</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Nebenläufigkeit mit gemeinsamem Zustand</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) Sync und Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Objektorientierte Sprachelemente von Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Charakteristiken objektorientierter Sprachen</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen erlauben</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Ein objektorientiertes Entwurfsmuster implementieren</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Muster (patterns) und Abgleich (matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Alle Stellen an denen Muster (patterns) verwendet werden können</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Abweisbarkeit: Falls ein Muster (pattern) mal nicht passt</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Mustersyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Fortgeschrittene Sprachelemente</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsicheres (unsafe) Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Fortgeschrittene Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Fortgeschrittene Typen</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Erweiterte Funktionen und Funktionsabschlüsse (closures)</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Abschlussprojekt: Einen mehrsträngigen (multi-threaded) Webserver erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Einen einsträngigen (single-threaded) Webserver erstellen</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Unseren einsträngigen (single-threaded) Webserver in einen mehrsträngigen (multi-threaded) Webserver verwandeln</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Kontrolliertes Beenden und Aufräumen</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Anhang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Schlüsselwörter</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatoren und Symbole</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Ableitbare Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Nützliche Entwicklungswerkzeuge</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ausgaben</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Übersetzungen des Buchs</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Wie Rust erstellt wird und „nächtliches Rust“</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="funktionsabschlüsse-closures-anonyme-funktionen-die-ihre-umgebung-erfassen-können"><a class="header" href="#funktionsabschlüsse-closures-anonyme-funktionen-die-ihre-umgebung-erfassen-können">Funktionsabschlüsse (closures): Anonyme Funktionen, die ihre Umgebung erfassen können</a></h2>
<p>Rusts Funktionsabschlüsse sind anonyme Funktionen, die du in einer Variable
speichern oder anderen Funktionen als Argument übergeben kannst. Du kannst einen 
Funktionsabschluss erstellen und dann in einem anderen Zusammenhang aufrufen
und auswerten. Im Gegensatz zu Funktionen können Funktionsabschlüsse auf Werte 
(values) im Gültigkeitsbereich (scope) zugreifen, in dem sie erstellt wurden.
Wir werden im Folgenden zeigen, wie die Funktionalität von Funktionsabschlüssen
die Wiederverwendung von Code erlaubt und sein Verhalten anpassen kann.</p>
<h3 id="mit-funktionsabschlüssen-verhaltensabstraktion-erzeugen"><a class="header" href="#mit-funktionsabschlüssen-verhaltensabstraktion-erzeugen">Mit Funktionsabschlüssen Verhaltensabstraktion erzeugen</a></h3>
<p>Lass uns eine Beispielsituation betrachten, in der es nützlich ist, einen
Funktionsabschluss zu speichern, um ihn später auszuführen. Nebenbei werden
wir über Typableitung, Merkmale (traits) und die Syntax von Funktionsabschlüssen
sprechen.</p>
<p>Stell Dir die folgende hypothetische Situation vor: Wir arbeiten für ein Start-up
und entwickeln eine App zur Erstellung die kundenspezifischer Trainingspläne.
Das Backend ist in Rust geschrieben und der verwendete Algorithmus zur Erzeugung 
der Trainingspläne nutzt viele Einflussfaktoren: das Alter des Benutzers, dessen 
Body Mass Index und Trainingsvorlieben, die zuletzt erfolgten Work-outs sowie 
deren Intensitätslevel. 
Der eigentliche Algorithmus ist für unser Beispiel nicht
entscheidend; lediglich wichtig ist, dass die Ausführungsdauer ein paar Sekunden 
beträgt.
Um die Wartezeit für den Benutzer zu verkürzen, wollen wir den Algorithmus nur 
bei Bedarf und lediglich einmal aufrufen.</p>
<p>Den Aufruf des hypothetischen Algorithmus simulieren wir mit der Funktion
<code>simulated_expensive_calculation</code> (siehe Codeblock 13-1). Diese Funktion gibt 
den Text <code>rechnet langsam...</code> aus, wartet zwei Sekunden lang und gibt dann die 
Nummer zurück, die wir übergeben haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!(&quot;rechnet langsam...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-1: Eine Funktion, die für eine hypothetische
Berechnung steht, die etwa 2 Sekunden Laufzeit benötigt.</span></p>
<p>Als Nächstes betrachten wir die Hauptfunktion <code>main</code>, welche die für unser Beispiel
relevanten Teile der App beinhaltet. 
Diese Funktion stellt den Code dar, den die App
aufrufen wird, wenn ein Benutzer einen Trainingsplan anfordert. 
Da die Interaktion mit dem Frontend für die Benutzung von Funktionsabschlüssen
nicht von Bedeutung ist, werden die Eingabewerte (inputs) fest einprogrammiert 
(hardcoded) und die Ausgaben (outputs) einfach mit <code>print</code> ausgegeben.</p>
<p>Das sind die benötigten Eingaben:</p>
<ul>
<li>Eine Intensitätszahl, über die der Benutzer angibt, ob sein Training
von leichter oder hoher Intensität sein soll.</li>
<li>Eine Zufallszahl, die für Abwechslung im Trainingsplan sorgt.</li>
</ul>
<p>Ausgegeben wird der empfohlene Trainingsplan. Codeblock 13-2 zeigt die
Funktion <code>main</code>, die wir benutzen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
</span><span class="boring">   println!(&quot;rechnet langsam...&quot;);
</span><span class="boring">   thread::sleep(Duration::from_secs(2));
</span><span class="boring">   intensity
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {}
</span><span class="boring">
</span>fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
</code></pre></pre>
<p><span class="caption">Codeblock 13-2: Eine Funktion <code>main</code> mit fest
einprogrammierten Werten, um Eingaben zu simulieren und Zufallszahlen zu
erzeugen</span></p>
<p>Zur Vereinfachung haben wir die Variablen <code>simulated_user_specified_value</code> auf 
den Wert 10 und <code>simulated_random_number</code> auf den Wert 7 fest kodiert.
Im tatsächlichen Programm würden wir die Intensitäts-Zahl vom App-Frontend 
erhalten und die Kiste (crate) <code>rand</code> benutzen, um eine Zufallszahl zu
erzeugen, so wie wir es im Ratespiel-Beispiel in Kapitel 2 bereits durchgeführt
haben. Die Hauptfunktion <code>main</code> ruft eine Funktion <code>generate_workout</code> mit
simulierten Eingabewerten auf.</p>
<p>Da wir nun die Zusammenhänge kennen, können wir uns dem Algorithmus zuwenden.
Die Funktion <code>generate_workout</code> im Codeblock 13-3 beinhaltet die Anwendungslogik 
der App, mit der wir uns in diesem Beispiel am meisten beschäftigen. Die folgenden
Codeänderungen werden diese Funktion betreffen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
</span><span class="boring">   println!(&quot;rechnet langsam...&quot;);
</span><span class="boring">   thread::sleep(Duration::from_secs(2));
</span><span class="boring">   intensity
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        println!(
            &quot;Mach heute {} Liegestütze!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Als nächstes {} Sit-ups!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
        } else {
            println!(
                &quot;Heute, {} Minuten Lauftrainig!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span><span class="boring">
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-3: Die Anwendungslogik, die Trainingspläne anhand
der Eingaben und durch Aufrufe der Funktion <code>simulated_expensive_calculation</code>
ausgibt</span></p>
<p>Der Code im Codeblock 13-3 ruft die langsame Berechnungsfunktion mehrfach auf.
Der erste <code>if</code>-Block ruft <code>simulated_expensive_calculation</code> zweimal auf, das
<code>if</code> im äußeren <code>else</code>-Block verwendet die Berechnung gar nicht und der Code im
zweiten <code>else</code> einmal.</p>
<p>Als Erstes soll die Funktion <code>generate_workout</code> überprüfen,
ob der Benutzer ein Training mit niedriger Intensität 
(gekennzeichnet durch eine Zahl kleiner 25) oder mit hoher
Intensität (eine Zahl größer oder gleich 25) wünscht. </p>
<p>Trainingspläne mit niedriger Intensität empfehlen eine Anzahl von Liegestützen 
und Sit-ups, die mit dem simulierten komplexen Algorithmus ermittelt werden.</p>
<p>Falls der Benutzer ein Training mit hoher Intensität anfordert, gibt es eine 
zusätzliche Logik: Ergibt der Wert der ermittelten Zufallszahl 3, wird die App
dem Benutzer eine Trinkpause empfehlen. Andernfalls werden dem Benutzer einige 
Minuten Lauftraining empfohlen, berechnet durch den simulierten 
komplexen Algorithmus.</p>
<p>Lass uns nun annehmen, dass das Datenforschungsteam einige Änderungen anordnet.
Das Programm funktioniert zwar soweit wie gewünscht, aber
<code>simulated_expensive_calculation</code> wird unnötigerweise mehrfach aufgerufen.
Wir sollen daher den Programmcode umformen und vereinfachen, damit die Funktion
nur noch einmal aufgerufen wird, wenn es notwendig ist.</p>
<h4 id="umformen-refactoring-mit-funktionen"><a class="header" href="#umformen-refactoring-mit-funktionen">Umformen (refactoring) mit Funktionen</a></h4>
<p>Wir könnten den Programmcode auf viele Arten umstrukturieren. Als erstes werden
wir die Funktion <code>simulated_expensive_calculation</code> verschieben, den Rückgabewert
in einer Variablen speichern und so den doppelten Aufruf vermeiden 
(siehe Codeblock 13-4).</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
</span><span class="boring">   println!(&quot;rechnet langsam...&quot;);
</span><span class="boring">   thread::sleep(Duration::from_secs(2));
</span><span class="boring">   intensity
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result = simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_result);
        println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_result);
    } else {
        if random_number == 3 {
            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
        } else {
            println!(&quot;Heute, {} Minuten Lauftrainig!&quot;, expensive_result);
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-4: Verschieben des Aufrufs der Funktion
<code>simulated_expensive_calculation</code> und Speichern des Rückgabewerts in
der Variable <code>expensive_result</code></span></p>
<p>Diese Änderung vereinigt alle Aufrufe von <code>simulated_expensive_calculation</code> und
löst im ersten <code>if</code>-Block das Problem mit dem unnötigen zweifachen Funktionsaufruf.
Leider rufen wir nun die Funktion in jeden Fall auf und warten auf das Ergebnis,
auch im inneren <code>if</code>-Block, der den Ergebniswert überhaupt nicht benötigt.</p>
<p>Wir wollen in <code>generate_workout</code> nur ein Mal auf
<code>simulated_expensive_calculation</code> zugreifen, aber trotzdem die teure Berechnung nur
dort durchführen, wo wir das Ergebnis tatsächlich benötigen. Dies ist ein
Anwendungsfall für Funktionsabschlüsse!</p>
<h4 id="umformen-mit-funktionsabschlüssen-zum-abspeichern-von-programmcode"><a class="header" href="#umformen-mit-funktionsabschlüssen-zum-abspeichern-von-programmcode">Umformen mit Funktionsabschlüssen zum Abspeichern von Programmcode</a></h4>
<p>Anstatt die Funktion <code>simulated_expensive_calculation</code> stets vor den <code>if</code>-Blöcken
aufzurufen, können wir einen <em>Funktionsabschluss</em> definieren und diesen
Funktionsabschluss anstatt des Funktionsrückgabewerts in einer Variable (wie im 
Codeblock 13-5) abspeichern. Wir können sogar den gesamten Inhalt von
<code>simulated_expensive_calculation</code> in einen Funktionsabschluss verschieben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num| {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">   if intensity &lt; 25 {
</span><span class="boring">       println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_closure(intensity));
</span><span class="boring">       println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_closure(intensity));
</span><span class="boring">   } else {
</span><span class="boring">       if random_number == 3 {
</span><span class="boring">           println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
</span><span class="boring">       } else {
</span><span class="boring">           println!(
</span><span class="boring">               &quot;Heute, {} Minuten Lauftrainig!&quot;,
</span><span class="boring">               expensive_closure(intensity)
</span><span class="boring">           );
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-5: Definition eines Funktionsabschlusses 
und dessen Speicherung in der Variable <code>expensive_closure</code></span></p>
<p>Das '=' weist der Variablen <code>expensive_closure</code>den Funktionsabschlusses zu. Die 
Definition des Funktionsabschlusses folgt mit einem Paar vertikaler
Pipes (<code>|</code>), zwischen denen wir die Parameter des Funktionsabschlusses angeben.
Diese Syntax wurde von der Funktionsabschluss-Definition in 
Smalltalk und Ruby beeinflusst. Unser Funktionsabschluss hat einen
Parameter <code>num</code>. Mehrere Parameter trennen wir mit
Kommata: <code>|param1, param2|</code>.</p>
<p>Den Parameter folgen geschweifte Klammern <code>{}</code>, die den Rumpf des
Funktionsabschlusses enthalten. Enhält der Rumpf nur einen Ausdruck, sind
diese Klammern optional. Nach den geschweiften Klammern benötigen wir ein 
Semikolon zum Abschluss der <code>let</code>-Anweisung. Der Rückgabewert des
Funktionsabschlusses ist der Wert der letzten Rumpf-Zeile (<code>num</code>).
Wie bei Funktionsrümpfen endet diese Zeile nicht mit einem Semikolon.</p>
<p>Beachte, die <code>let</code>-Anweisung bedeutet, dass <code>expensive_closure</code> die <em>Definition</em>
einer anonymen Funktion enzhält und nicht den <em>Ergebniswert</em> des
Aufrufs der anonymen Funktion. Wir benutzen einen
Funktionsabschluss, um Programmcode an einer Stelle
zu definieren und abzuspeichern, und um ihn später an einer anderen Stelle 
aufzurufen. Unser Programmteil ist nun in
<code>expensive_closure</code> gespeichert.</p>
<p>Da wir nun einen Funktionsabschluss definiert haben, können wir den Code so anpassen,
dass der Funktionsabschluss im<code>if</code>-Block aufgerufen wird. Dadurch wird der zugehörige 
Code ausgeführt und der Ergebniswert zurückgeliefert. Der Aufruf eines
Funktionsabschlusses gleicht dem einer Funktion: Wir geben den Variablennamen
an, der den Funktionsabschluss enthält, gefolgt von den Argumentwerten in
Klammern, die wir übergeben möchten, wie in Codeblock 13-6 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_closure(intensity));
        println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
        } else {
            println!(
                &quot;Heute, {} Minuten Lauftrainig!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-6: Aufruf der neu definierten
<code>expensive_closure</code></span></p>
<p>Nun wird die langsame Berechnung an einer Stelle definiert und nur noch dort
ausgeführt, wo wir das Ergebnis benötigen.</p>
<p>Wir haben jedoch eines der Probleme von Codeblock 13-3 wieder eingeführt.
Im ersten <code>if</code>-Block rufen wir den Funktionsabschluss zweimal auf und lassen
somit den Benutzer doppelt solange warten als notwendig. Wir könnten das Problem
beheben, indem wir eine lokale Variable definieren, die das Ergebnis des
Funktionsabschluss-Aufrufs hält. Funktionsabschlüsse bieten uns eine andere
Lösung. Wir werden diese Lösung in Kürze erklären, aber lass uns zuerst über die
fehlenden Typzuweisungen in der Definition des Funktionsabschlusses und den
Merkmalen (traits) von Funktionsabschlüssen sprechen.</p>
<h3 id="typableitung-und-zuweisung-bei-funktionsabschlüssen"><a class="header" href="#typableitung-und-zuweisung-bei-funktionsabschlüssen">Typableitung und Zuweisung bei Funktionsabschlüssen</a></h3>
<p>Bei Funktionsabschlüssen musst du die Datentypen der Parameter und Rückgabewerte nicht,
wie bei Funktionen, ausdrücklich angeben. Für Funktionen sind Datentypangaben 
erforderlich, da sie Bestandteil einer expliziten Benutzerschnittstelle sind.
Die starre Festlegung dieser Schnittstelle ist wichtig, damit sichergestellt
ist, dass jedem eindeutig klar ist, welche Arten von Werten von der Funktion
entgegengenommen und zurückgegeben werden. Funktionsabschlüsse werden hingegen nicht
in einer Schnittstelle verwendet, sie werden in einer Variable gespeichert und 
aufgerufen, ohne sie zu benennen und Benutzern unserer Bibliothek (library)
zugänglich zu machen.</p>
<p>Funktionsabschlüsse sind für gewöhnlich kurz und eher in einem begrenzten Kontext
relevant, als in einem beliebigen Anwendungsfall. Innerhalb dieses beschränkten
Einsatzbereichs ist der Compiler verlässlich in der Lage, die Datentypen der Parameter und
Rückgabewerte abzuleiten, ähnlich wie er dies meistens bei Variablen kann.</p>
<p>Den Programmierer die Typen in diesen kurzen, anonymen Funktionen angeben zu
lassen, wäre störend und überflüssig, da der Compiler bereits über die
dafür notwendigen Informationen verfügt.</p>
<p>Wie bei Variablen können wir die Datentypen angeben, wenn wir die Klarheit
und Deutlichkeit mehr als notwendig erhöhen möchten.
Wollen wir die Datentypen für dem Funktionsabschluss aus Codeblock 13-5 angeben,
würde die Definition wie in Codeblock 13-7 aussehen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span><span class="boring">   
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring"> 
</span><span class="boring">
</span><span class="boring">   if intensity &lt; 25 {
</span><span class="boring">       println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_closure(intensity));
</span><span class="boring">       println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_closure(intensity));
</span><span class="boring">   } else {
</span><span class="boring">       if random_number == 3 {
</span><span class="boring">           println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
</span><span class="boring">       } else {
</span><span class="boring">           println!(
</span><span class="boring">               &quot;Heute, {} Minuten Lauftrainig!&quot;,
</span><span class="boring">               expensive_closure(intensity)
</span><span class="boring">           );
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">  let simulated_user_specified_value = 10;
</span><span class="boring">  let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">  generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-7: Hinzufügen optionaler Datentypangabe
der Parameter- und Rückgabewert-Typen im Funktionsabschluss
</span></p>
<p>Mit Datentypangabe ähnelt die Syntax eines Funktionsabschlusses sehr der Syntax 
einer Funktion. Im Folgenden vergleichen wir die Syntax einer
Funktionsdefinition, die zu ihrem Parameter den Wert 1 addiert, und die eines
Funktionsabschlusses mit identischem Verhalten.
Zur besseren Darstellung der relevanten Teile haben wir einige Leerzeichen eingefügt.
Dies zeigt, wie ähnlich die Syntax
von Funktionen der von Funktionsabschlüssen ist, abgesehen von Pipes und der 
Möglichkeit, einen Teil der Syntax wegzulassen:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>Die erste Zeile zeigt eine Funktionsdefinition und die zweite eine Definition
eines Funktionsabschlusses mit allen Datentypangaben. Bei der dritten Zeile
werden die Datentypangaben in der Definition des Funktionsabschlusses weggelassen.
Zusätzlich entfällt in der vierten Zeile die optionalen geschweiften Klammern, 
da der
Rumpf des Funktionsabschlusses nur einen Ausdruck beinhaltet. Alle diese Ausdrücke
sind gültig und verhalten sich beim Aufruf gleich. Von <code>add_one_v3</code> und
<code>add_one_v4</code> wird ein Aufruf zum Kompilieren des Codes benötigt, da hier die Typen
abhängig von der Verwendung abgeleitet werden.</p>
<p>Bei Funktionsabschlüssen wird für jeden Parameter und für den Rückgabewert ein
konkreter Typ abgeleitet. Codeblock 13-8 zeigt zum Beispiel die Definition eines
kurzen Funktionsabschlusses, der nur den Wert des übergebenen Parameters 
zurückgibt. Dieser Funktionsabschluss ist außer für diese Beispiel 
nicht weiter nützlich. Beachte, dass wir der Definition keine
Datentypangaben hinzugefügt haben. Wenn wir nun versuchen, den Funktionsabschluss zweimal
aufzurufen, einmal mit <code>String</code> und einmal mit <code>u32</code>, erhalten wir eine
Fehlermeldung.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-8: Versuchter Aufruf eines Funktionsabschlusses,
dem zwei unterschiedliche Typen zugewiesen wurden</span></p>
<p>Der Compiler gibt diesen Fehler aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^
  |                             |
  |                             expected struct `String`, found integer
  |                             help: try using a conversion method: `5.to_string()`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
</code></pre>
<p>Beim ersten Aufruf von <code>example_closure</code> wird dem Typ von <code>x</code> und dem
Rückgabewert des Funktionsabschlusses der Typ <code>String</code> zugewiesen. Diese Typen
sind dann für den Funktionsabschluss <code>example_closure</code> festgeschrieben. Daher
bekommen wir eine Fehlermeldung, wenn wir versuchen einen anderen Typ mit dem
gleichen Funktionsabschluss zu benutzen.</p>
<h3 id="speichern-von-funktionsabschlüssen-unter-verwendung-generischer-parameter-und-fn-merkmalen-traits"><a class="header" href="#speichern-von-funktionsabschlüssen-unter-verwendung-generischer-parameter-und-fn-merkmalen-traits">Speichern von Funktionsabschlüssen unter Verwendung generischer Parameter und <code>Fn</code>-Merkmalen (traits)</a></h3>
<p>Lass uns auf unser Trainingsplan-Erstellungsprogramm zurückkommen. Im Codeblock
13-6 hat unser Programm, noch immer häufiger als notwendig, den
Funktionsabschluss <code>expensive_closure</code> aufgerufen. Eine Möglichkeit, dieses
Problem zu beheben, besteht darin, das Ergebnis des Funktionsabschlusses in
einer Variable zu speichern und diese Variable zu benutzen, wann immer wir das
Resultat brauchen. Diese Methode würde allerdings zu ziemlich viel wiederholtem
Code führen.</p>
<p>Glücklicherweise steht uns eine andere Lösung zur Verfügung. Wir können eine
Struktur (struct) anlegen die den Funktionsabschluss und dessen Rückgabewert
hält. Die Struktur wird den Funktionsabschluss nur dann ausführen, wenn
wir ein Ergebnis benötigen, und sie wird unseren Rückgabewert zwischenspeichern
damit der Rest unseres Programmcodes nicht mehr für das Speichern und 
Wiederverwenden verantwortlich ist. Dieses Muster (pattern) ist dir vielleicht
als <em>Memoisation</em> (memoization) oder <em>Lazy Evaluation</em> bekannt.</p>
<p>Um eine Struktur für unseren Funktionsabschluss zu erstellen, müssen wir dessen
Typ spezifizieren, da die Definition einer Struktur den Typ aller ihrer Felder
kennen muss. Jede Instanz eines Funktionsabschlusses besitzt ihren einzigartigen
anonymen Typ, der selbst wenn zwei Funktionsabschlüsse identische Signaturen
haben, immer noch als verschieden betrachtet wird. Um Strukturen, Aufzählungen
(enums) oder Funktionen zu definieren, die Funktionsabschlüsse verwenden,
benutzen wir generische Datentypen (generics) und Merkmalsabgrenzungen (trait bounds),
die wir bereits im Kapitel 10 besprochen haben.</p>
<p>Die <code>Fn</code>-Merkmale werden von der Standardbibliothek (standard library) zur
Verfügung gestellt. Alle Funktionsabschlüsse implementieren mindestens eines der
Merkmale: <code>Fn</code>, <code>FnMut</code> oder <code>FnOnce</code>. Wir werden den Unterschied dieser
Merkmale im Abschnitt <a href="#mit-funktionsabschl%C3%BCssen-die-umgebung-erfassen">„Mit Funktionsabschlüssen die Umgebung
erfassen“</a> besprechen. 
Für unser Beispiel können wir das <code>Fn</code>-Merkmal benutzen.</p>
<p>Den <code>Fn</code>-Merkmalsabgrenzungen fügen wir Typanmerkungen für die Typen, die mit dem
Funktionsabschluss übereinstimmen müssen, hinzu. In diesem Fall hat unser
Funktionsabschluss einen Parameter vom Typ <code>u32</code> und gibt einen <code>u32</code> zurück,
daher spezifizieren wir die Merkmalsabgrenzung mit <code>Fn(u32) -&gt; u32</code>.</p>
<p>Codeblock 13-9 zeigt die Definition der Struktur <code>Cacher</code>, die einen
Funktionsabschluss und optional einen Rückgabewert hält.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-9: Definition einer Struktur <code>Cacher</code>, die
einen Funktionsabschluss in <code>calculation</code> enthält und in <code>value</code> optional ein
Resultat</span></p>
<p>Die Struktur <code>Cacher</code> hat ein Feld <code>calculation</code> vom generischen Datentyp <code>T</code>.
Die Merkmalsabgrenzungen auf <code>T</code> legen das <code>Fn</code>-Merkmal für den
Funktionsabschluss fest. Jeder Funktionsabschluss, den wir im Feld <code>calculation</code>
speichern, muss einen <code>u32</code>-Parameter (spezifiziert innerhalb runder Klammern
hinter <code>Fn</code>) haben und ein <code>u32</code> (festgelegt nach dem <code>-&gt;</code>) zurückgeben.</p>
<blockquote>
<p>Merke: Auch Funktionen können alle drei <code>Fn</code>-Merkmale implementieren.
Falls eine Problemstellung das Erfassen eines Wertes der Umgebung nicht erfordert,
können wir eine Funktion anstatt eines Funktionsabschlusses benutzen, der etwas
benötigt, um für ihn das <code>Fn</code>-Merkmal zu implementieren.</p>
</blockquote>
<p>Das Feld <code>value</code> hat den Typ <code>Option&lt;u32&gt;</code>. Bevor wir den Funktionsabschluss
ausführen, hat <code>value</code> den Wert <code>None</code>. Wenn Programmcode mit einem <code>Cacher</code> nach dem
<em>Ergebnis</em> des Funktionsabschlusses fragt, wird der <code>Cacher</code> zu diesem Zeitpunkt
den Funktionsabschluss ausführen und das Ergebnis in einer <code>Some</code>-Variante im
Feld <code>value</code> speichern. Wenn der Code später wieder nach dem Resultat des
Funktionsabschlusses fragt, wird anstatt der erneuten Ausführung der Berechnung
der <code>Cacher</code> den Wert zurückgeben, der in der <code>Some</code>-Variante enthalten ist.</p>
<p>Im Codeblock 13-10, wird die Logik um das soeben beschriebene Feld <code>value</code>
definiert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   calculation: T,
</span><span class="boring">   value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-10: Die Zwischenspeicherungs-Logik von <code>Cacher</code></span></p>
<p>Wir möchten, dass <code>Cacher</code> die Felder der Struktur verwaltet, anstatt den
aufrufenden Code die Werte unter Umständen direkt ändern zu lassen, sodass diese
Felder privat sind.</p>
<p>Die Funktion <code>Cacher::new</code> nimmt einen generischen Datentyp-Parameter <code>T</code>,
welchen wir so definiert haben, dass er dieselbe Merkmalsabgrenzung wie die
<code>Cacher</code>-Struktur hat. Anschließend gibt <code>Cacher::new</code> eine <code>Cacher</code>-Instanz aus
die den Funktionsabschluss enthält der im <code>calculation</code>-Feld spezifiziert wurde
und den Wert <code>None</code> in seinem <code>value</code>-Feld enthält da wir den Funktionsabschluss
bisher noch nicht ausgeführt haben.</p>
<p>Wenn der aufrufende Code das Auswertungsergebnis des Funktionsabschlusses
benötigt, ruft er die Methode <code>value</code> auf, anstatt direkt den Funktionsabschluss.
Diese Methode überprüft, ob wir bereits einen Rückgabewert in <code>self.value</code>
in einen <code>Some</code> gespeichert haben, falls ja, gibt es den Wert, der in <code>Some</code>
enthalten ist zurück ohne den Funktionsabschluss erneut auszuführen.</p>
<p>Falls <code>self.value</code> ein <code>None</code> ist, ruft der Programmcode den Funktionsabschluss
auf, der in <code>self.calculation</code> gespeichert ist, speichert das Resultat in
<code>self.value</code> für seine zukünftige Verwendung und gibt den Wert zurück.</p>
<p>Codeblock 13-11 zeigt wie wir die <code>Cacher</code>-Struktur in der Funktion
<code>generate_workout</code> vom Codeblock 13-6 verwenden können.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   calculation: T,
</span><span class="boring">   value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
</span><span class="boring">       Cacher {
</span><span class="boring">           calculation,
</span><span class="boring">           value: None,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   fn value(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">       match self.value {
</span><span class="boring">           Some(v) =&gt; v,
</span><span class="boring">           None =&gt; {
</span><span class="boring">               let v = (self.calculation)(arg);
</span><span class="boring">               self.value = Some(v);
</span><span class="boring">               v
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_result.value(intensity));
        println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_result.value(intensity));
    } else {
        if random_number == 3 {
            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
        } else {
            println!(
                &quot;Heute, {} Minuten Lauftrainig!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-11: Die Verwendung von <code>Cacher</code> in der
Funktion <code>generate_workout</code> zur Abstraktion der Zwischenspeicherungs-Logik</span></p>
<p>Anstatt den Funktionsabschluss direkt in einer Variable zu speichern, speichern
wir eine neue Instanz von <code>Cacher</code> die den Funktionsabschluss beinhaltet. An
jeder Stelle, an der wir ein Resultat benötigen, rufen wir dann die Methode
<code>value</code> an der <code>Cacher</code>-Instanz auf. Egal ob wir nun die Methode <code>value</code>
mehrmals aufrufen oder gar nicht wird die aufwendige Berechnung nur einmal 
ausgeführt.</p>
<h3 id="einschränkungen-der-cacher-implementierung"><a class="header" href="#einschränkungen-der-cacher-implementierung">Einschränkungen der <code>Cacher</code>-Implementierung</a></h3>
<p>Das Zwischenspeichern von Werten ist allgemein eine nützliche Vorgehensweise,
die wir möglicherweise auch an anderen Programmteilen mit verschieden
Funktionsabschlüssen verwenden möchten. Jedoch gibt es zwei Probleme der aktuellen
Implementierung von <code>Cacher</code>, die eine Wiederverwendung in verschiedenen Kontexten
erschweren würden.</p>
<p>Das erste Problem ist, dass eine <code>Cacher</code>-Instanz davon ausgeht, dass sie immer
den gleichen Wert für den <code>arg</code>-Parameter der Methode <code>value</code> bekommt. Das
bedeutet, dass dieser Test fehlschlagen wird:</p>
<pre><pre class="playground"><code class="language-rust panics">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   calculation: T,
</span><span class="boring">   value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
</span><span class="boring">       Cacher {
</span><span class="boring">           calculation,
</span><span class="boring">           value: None,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   fn value(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">       match self.value {
</span><span class="boring">           Some(v) =&gt; v,
</span><span class="boring">           None =&gt; {
</span><span class="boring">               let v = (self.calculation)(arg);
</span><span class="boring">               self.value = Some(v);
</span><span class="boring">               v
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use super::*;
</span><span class="boring">
</span>    #[test]
    fn call_with_different_values() {
        let mut c = Cacher::new(|a| a);

        let v1 = c.value(1);
        let v2 = c.value(2);

        assert_eq!(v2, 2);
    }
<span class="boring">}    
</span><span class="boring">}
</span></code></pre></pre>
<p>Dieser Test erzeugt eine neue <code>Cacher</code>-Instanz mit einem Funktionsabschluss, der
den Wert zurückgibt, den er erhalten hat. Wir rufen nun die <code>Cacher</code>-Instanz
mit der Methode <code>value</code> auf, zuerst mit dem <code>arg</code>-Wert 1 und dann mit dem
<code>arg</code>-Wert 2 und erwarten, dass beim zweiten Aufruf 2 zurückgegeben wird.</p>
<p>Führe diesen Test mit der Implementierung von <code>Cacher</code> vom Codeblock 13-9 und
13-10 durch und der Test wird an <code>assert_eq!</code> mit folgender Meldung
fehlschlagen:</p>
<pre><code class="language-console">$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/cacher-4116485fb32b3fff

running 1 test
test tests::call_with_different_values ... FAILED

failures:

---- tests::call_with_different_values stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::call_with_different_values

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Das Problem ist, dass die <code>Cacher</code>-Instanz beim ersten Aufruf von <code>c.value</code> mit 1
den Wert <code>Some(1)</code> in <code>self.value</code> gespeichert hat. Egal was wir danach der
<code>value</code>-Methode als Wert  mitgeben, wir werden immer 1 zurückbekommen.</p>
<p>Versuche <code>Cacher</code> so zu verändern, dass es anstatt eines Wertes eine Hash-Tabelle
(hash map) enthält. Die Schlüssel (keys) der Hash-Tabelle werden die <code>arg</code>-Werte
die mitgegeben werden sein und die Werte der Hash-Tabelle werden das Resultat des Aufrufs des
Funktionsabschlusses mit dem jeweiligen Schlüssel sein. Anstatt <code>value</code> direkt
zu betrachten, ob es einen <code>Some</code> oder <code>None</code> enthält, wird die <code>value</code>-Funktion
nach <code>arg</code> in der Hash-Tabelle suchen und den Wert, falls vorhanden, zurückgeben.
Falls der Wert nicht vorhanden ist, wird der <code>Cacher</code> den Funktionsabschluss
aufrufen und den Rückgabewert in der Hash-Tabelle zusammen mit seinem <code>arg</code>-Wert
speichern.</p>
<p>Das zweite Problem mit der derzeitigen Implementierung von <code>Cacher</code> ist, dass
sie nur Funktionsabschlüsse annimmt die einen Parameter vom Typ <code>u32</code> haben und 
ein <code>u32</code> zurückgeben. Möglicherweise möchten wir zum Beispiel Ergebnisse von
Funktionsabschlüssen zwischenspeichern die einen Zeichenketten-Anteilstyp (string
slice) nehmen und <code>usize</code>-Werte zurückgeben. Um dieses Problem zu beheben,
versuche generische Datentypen zu verwenden, um die <code>Cacher</code>-Funktionalität
flexibler zu machen.</p>
<h3 id="mit-funktionsabschlüssen-die-umgebung-erfassen"><a class="header" href="#mit-funktionsabschlüssen-die-umgebung-erfassen">Mit Funktionsabschlüssen die Umgebung erfassen</a></h3>
<p>Im Trainingsplan-Erstellungs-Beispiel haben wir Funktionsabschlüsse nur als
anonyme Inline-Funktionen verwendet, Funktionsabschlüsse verfügen jedoch über
eine Fähigkeit die Funktionen nicht haben: Sie können ihre Umgebung erfassen und
auf Variablen die im selben Gültigkeitsbereich definiert wurden zugreifen.</p>
<p>Codeblock 13-12 beinhaltet ein Beispiel eines Funktionsabschlusses der in einer
Variable <code>equal_to_x</code> gespeichert ist und eine Variable <code>x</code> aus ihrer Umgebung
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p><span class="caption">Codeblock 13-12: Beispiel eines Funktionsabschlusses, der
sich auf eine Variable im umgebenden Gültigkeitsbereich bezieht.</span></p>
<p>Auch wenn <code>x</code> hier keiner der Parameter von <code>equal_to_x</code> ist, darf der
Funktionsabschluss <code>equal_to_x</code> die Variable <code>x</code> benutzen, die im gleichen
Gültigkeitsbereich definiert wurde wie <code>equal_to_x</code>.</p>
<p>Mit Funktionen können wir dasselbe nicht machen. Wenn wir es wie im folgenden
Beispiel versuchen wird der Programmcode nicht kompilieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool {
        z == x
    }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p>Wir bekommen eine Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0434]: can't capture dynamic environment in a fn item
 --&gt; src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead
</code></pre>
<p>Der Compiler erinnert uns sogar daran, dass dies nur mit Funktionsabschlüssen
funktioniert!</p>
<p>Wenn ein Funktionsabschluss einen Wert aus seiner Umgebung erfasst, benutzt er
Speicher, um die Werte im Funktionsabschluss-Rumpf für die Benutzung zu halten.
Diesen zusätzlichen Aufwand der Speichernutzung wollen wir, wenn wir
Code ausführen möchten der seine Umgebung nicht erfasst, nicht verursachen. Da
Funktionen ihre Umgebung niemals erfassen können, kann das Definieren und
Ausführen von Funktionen auch nie diesen Speichernutzungsmehraufwand
verursachen.</p>
<p>Es gibt drei Möglichkeiten wie Funktionsabschlüsse ihre Umgebung erfassen
können, den drei Möglichkeiten entsprechend wie Funktionen ein Parameter
erhalten können: Eigentümerschaft übernehmen (taking ownership), veränderliches
Ausleihen (borrowing mutably) und unveränderliches Ausleihen (borrowing immutably).
Diese sind wie folgt, in den drei <code>Fn</code>-Merkmalen codiert:</p>
<ul>
<li><code>FnOnce</code> verbraucht die Variablen, die vom umgebenden Gültigkeitsbereich
erfasst werden, dieser Bereich wird als Funktionsabschluss-Umgebung
(closure's <em>enviroment</em>) bezeichnet. Um die erfassten Variablen verbrauchen
zu können, muss der Funktionsabschluss die Eigentümerschaft dieser Variablen
übernehmen und sie bei dessen Definition, in den Funktionsabschluss verschieben
(move). Der Namensteil <code>Once</code> repräsentiert die Tatsache, dass der
Funktionsabschluss nur einmal die Eigentümerschaft der gleichen Variablen
übernehmen kann, daher kann er nur einmal aufgerufen werden.</li>
<li><code>FnMut</code> kann die Funktionsabschluss-Umgebung verändern, da es Werte
veränderlich ausleiht.</li>
<li><code>Fn</code> leiht Werte des umgebenden Gültigkeitsbereiches unveränderlich aus.</li>
</ul>
<p>Wenn du einen Funktionsabschluss erstellst, schließt Rust, welches Merkmal
verwendet werden soll, aus der Verwendungsweise der vom Funktionsabschluss 
erfassten Variablen. Alle Funktionsabschlüsse implementieren <code>FnOnce</code>, da sie
mindestens einmal aufgerufen werden können. Funktionsabschlüsse, die erfasste
Variablen nicht verschieben, implementieren zusätzlich <code>FnMut</code> und
Funktionsabschlüsse, die keinen veränderlichen Zugriff auf die erfassten Werte
benötigen, implementieren des weiteren <code>Fn</code>. Im Codeblock 13-12, leiht der
Funktionsabschluss <code>equal_to_x</code> den Parameter <code>x</code> unveränderlich (dadurch hat
<code>equal_to_x</code> das <code>Fn</code>-Merkmal), da der Funktionsabschluss-Rumpf den
Variablenwert <code>x</code> nur liest.</p>
<p>Falls du erzwingen möchtest, dass ein Funktionsabschluss die Eigentümerschaft
der aus dem umgebenden Gültigkeitsbereich verwendeten Werte übernimmt, kannst du
vor der Parameterliste das Schlüsselwort <code>move</code> verwenden. Diese Technik ist vor
allem dann nützlich, wenn ein Funktionsabschluss an einen neuen Strang (thread) 
übergeben wird, um die Daten so zu verschieben, dass sie dem neuen Strang
gehören.</p>
<blockquote>
<p>Hinweis: <code>move</code>-Funktionsabschlüsse können immer noch <code>Fn</code> oder <code>FnMut</code>
implementieren, auch wenn sie Variablen verschieben. Das liegt daran, dass
die von einem Funktionsabschluss-Typ implementierten Merkmale dadurch
bestimmt werden, was der Funktionsabschluss mit den erfassten Werten macht,
nicht wie es sie erfasst. Das Schlüsselwort <code>move</code> legt nur Letzteres fest.</p>
</blockquote>
<p>Weitere Beispiele für <code>move</code> bei Funktionsabschlüssen folgen in Kapitel 16, wenn
wir über Parallelität sprechen. Einstweilen ist hier der Programmcode von
Codeblock 13-12 mit dem Schlüsselwort <code>move</code>, das der Funktionsabschlussdefinition
hinzugefügt wurde und Vektoren statt Ganzzahlen (integers) verwendet, da
Ganzzahlen kopiert und nicht verschoben werden. Beachte, dass dieser Programmcode
noch nicht kompiliert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;kann x hier nicht verwenden: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p>Wir erhalten folgende Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0382]: borrow of moved value: `x`
 --&gt; src/main.rs:6:40
  |
2 |     let x = vec![1, 2, 3];
  |         - move occurs because `x` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
3 | 
4 |     let equal_to_x = move |z| z == x;
  |                      --------      - variable moved due to use in closure
  |                      |
  |                      value moved into closure here
5 | 
6 |     println!(&quot;kann x hier nicht verwenden: {:?}&quot;, x);
  |                                                   ^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `equal-to-x` due to previous error

</code></pre>
<p>Der Wert <code>x</code> wurde bei der Funktionsabschlussdefinition in diesen hineinbewegt,
da wir das Schlüsselwort <code>move</code> angegeben haben. Der Funktionsabschluss hat
dadurch die Eigentümerschaft von <code>x</code> und <code>main</code> kann daher <code>x</code> nicht mehr 
im <code>println!</code>-Statement benutzen. Durch Entfernen von <code>println!</code> wird dieser
Fehler behoben.</p>
<p>Wenn du eine <code>Fn</code>-Merkmalsabgrenzung spezifizierst, reicht es zumeist wenn du
mit <code>Fn</code> beginnst. Der Compiler wird dir mitteilen, wenn es notwendig ist
<code>FnMut</code> oder <code>FnOnce</code> anzugeben, basierend auf dem was im
Funktionsabschluss-Rumpf passiert. </p>
<p>Um Situationen zu veranschaulichen, die die Nützlichkeit von
Umgebung erfassenden Funktionsabschlüssen als Funktionsparameter demonstrieren,
fahren wir mit unserem nächsten Thema fort: Iteratoren.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-00-functional-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch13-02-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-00-functional-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch13-02-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/ferris.js"></script>


    </body>
</html>
