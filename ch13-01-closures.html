<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Funktionsabschlüsse (closures): Anonyme Funktionen, die ihre Umgebung erfassen - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="funktionsabschlüsse-closures-anonyme-funktionen-die-ihre-umgebung-erfassen"><a class="header" href="#funktionsabschlüsse-closures-anonyme-funktionen-die-ihre-umgebung-erfassen">Funktionsabschlüsse (closures): Anonyme Funktionen, die ihre Umgebung erfassen</a></h2>
<p>Rusts Funktionsabschlüsse sind anonyme Funktionen, die du in einer Variable
speichern oder anderen Funktionen als Argument übergeben kannst. Du kannst einen
Funktionsabschluss erstellen und dann in einem anderen Zusammenhang aufrufen
und auswerten. Im Gegensatz zu Funktionen können Funktionsabschlüsse auf Werte
(values) im Gültigkeitsbereich (scope) zugreifen, in dem sie erstellt wurden.
Wir werden im Folgenden zeigen, wie die Funktionalität von Funktionsabschlüssen
die Wiederverwendung von Code erlaubt und sein Verhalten anpassen kann.</p>
<h3 id="erfassen-der-umgebung-mit-funktionsabschlüssen"><a class="header" href="#erfassen-der-umgebung-mit-funktionsabschlüssen">Erfassen der Umgebung mit Funktionsabschlüssen</a></h3>
<p>Wir werden zunächst untersuchen, wie wir Funktionsabschlüsse verwenden können,
um Werte aus der Umgebung, in der sie definiert sind, zur späteren Verwendung
zu erfassen. Hier ist das Szenario: Von Zeit zu Zeit verschenkt unsere
T-Shirt-Firma ein exklusives T-Shirt in limitierter Auflage an jemanden aus
unserer Mailingliste als Werbeaktion. Die Personen auf der Mailingliste können
optional ihre Lieblingsfarbe zu ihrem Profil hinzufügen. Wenn die Person, die
das kostenlose Shirt erhalten soll, ihre Lieblingsfarbe in ihrem Profil
angegeben hat, erhält sie das Hemd in dieser Farbe. Wenn die Person keine
Lieblingsfarbe angegeben hat, erhält sie die Farbe, in der das Unternehmen
derzeit die meisten Exemplare hat.</p>
<p>Es gibt viele Möglichkeiten, dies zu implementieren. Für dieses Beispiel werden
wir eine Aufzählung namens <code>ShirtColor</code> verwenden, die die Varianten <code>Red</code> und
<code>Blue</code> hat (der Einfachheit halber wird die Anzahl der verfügbaren Farben
begrenzt). Das Inventar des Unternehmens wird durch eine Struktur <code>Inventory</code>
repräsentiert, die ein Feld mit dem Namen <code>shirts</code> hat, das ein
<code>Vec&lt;ShirtColor&gt;</code> mit den derzeit vorrätigen Hemden enthält. Die Methode
<code>giveaway</code>, die auf <code>Inventory</code> definiert ist, erhält die optionale
Shirtfarbe der Person, die das kostenlose Shirt erhält, und gibt die Shirtfarbe
zurück, die die Person erhalten wird. Dies wird in Codeblock 13-1 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!("Der Benutzer mit Präferenz {user_pref1:?} erhält {giveaway1:?}");

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!("Der Benutzer mit Präferenz {user_pref2:?} erhält {giveaway2:?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 13-1: Werbegeschenk der Shirtfirma</span></p>
<p>Der in <code>main</code> definierte <code>store</code> hat zwei blaue Shirts und ein rotes Shirt
übrig, die für diese limitierte Aktion verteilt werden sollen. Wir rufen die
Methode <code>giveaway</code> für einen Benutzer mit einer Präferenz für ein rotes Hemd
und einen Benutzer ohne jegliche Präferenz auf.</p>
<p>Auch dieser Code könnte auf viele Arten implementiert werden. Um uns auf
Funktionsabschlüsse zu konzentrieren, haben wir uns an die Konzepte gehalten,
die du bereits gelernt hast, mit Ausnahme des Methodenrumpfs von <code>giveaway</code>,
der einen Funktionsabschluss verwendet. In der Methode <code>giveaway</code> erhalten wir
die Benutzerpräferenz als einen Parameter vom Typ <code>Option&lt;ShirtColor&gt;</code> und
rufen die Methode <code>unwrap_or_else</code> auf <code>user_preference</code> auf. Die <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else">Methode
<code>unwrap_or_else</code> auf <code>Option&lt;T&gt;</code></a> ist in der Standardbibliothek
definiert. Sie nimmt ein Argument entgegen: Einen Funktionsabschluss ohne
Argument, der einen Wert <code>T</code> zurückgibt (denselben Typ, der in der Variante
<code>Some</code> von <code>Option&lt;T&gt;</code> gespeichert ist, in diesem Fall <code>ShirtColor</code>). Wenn
<code>Option&lt;T&gt;</code> die Variante <code>Some</code> ist, gibt <code>unwrap_or_else</code> den Wert aus <code>Some</code>
zurück. Wenn <code>Option&lt;T&gt;</code> die Variante <code>None</code> ist, ruft <code>unwrap_or_else</code> den
Funktionsabschluss auf und gibt den Wert zurück, der vom Funktionsabschluss
zurückgegeben wurde.</p>
<p>Wir geben den Funktionsabschluss-Ausdruck <code>|| self.most_stocked()</code> als Argument
bei <code>unwrap_or_else</code> an. Dies ist ein Funktionsabschluss, die selbst keine
Parameter hat (wenn der Funktionsabschluss Parameter hätte, würden sie zwischen
den beiden vertikalen Strichen erscheinen). Der Rumpf des Funktionsabschlusses
ruft <code>self.most_stocked()</code> auf. Wir definieren den Funktionsabschluss hier, und
die Implementierung von <code>unwrap_or_else</code> wird den Funktionsabschluss später
auswerten, wenn das Ergebnis benötigt wird.</p>
<p>Die Ausführung dieses Codes gibt aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
Der Benutzer mit Präferenz Some(Red) erhält Red
Der Benutzer mit Präferenz None erhält Blue
</code></pre>
<p>Ein interessanter Aspekt ist hier, dass wir einen Funktionsabschluss übergeben
haben, der <code>self.most_stocked()</code> für die aktuelle <code>Inventory</code>-Instanz aufruft.
Die Standardbibliothek musste nichts über die von uns definierten Typen
<code>Inventory</code> oder <code>ShirtColor</code> oder die Logik, die wir in diesem Szenario
verwenden wollen, wissen. Der Funktionsabschluss hat eine unveränderbare
Referenz auf die <code>self</code>-Instanz von <code>Inventory</code> erfasst und sie mit dem von uns
angegebenen Code an die Methode <code>unwrap_or_else</code> übergeben. Funktionen sind
andererseits nicht in der Lage, ihre Umgebung auf diese Weise zu erfassen.</p>
<h3 id="funktionsabschluss-typinferenz-und-annotation"><a class="header" href="#funktionsabschluss-typinferenz-und-annotation">Funktionsabschluss-Typinferenz und Annotation</a></h3>
<p>Es gibt weitere Unterschiede zwischen Funktionen und Funktionsabschlüssen. Bei
Funktionsabschlüssen ist es normalerweise nicht erforderlich, die Typen der
Parameter oder des Rückgabewertes zu annotieren, wie es bei <code>fn</code>-Funktionen der
Fall ist. Typ-Annotationen sind bei Funktionen erforderlich, weil die Typen
Teil einer expliziten Schnittstelle sind, die für deine Benutzer sichtbar ist.
Die strikte Definition dieser Schnittstelle ist wichtig, um sicherzustellen,
dass alle Beteiligten sich darüber einig sind, welche Arten von Werten eine
Funktion verwendet und zurückgibt. Funktionsabschlüsse werden hingegen nicht in
einer offengelegten Schnittstelle wie dieser verwendet: Sie werden in Variablen
gespeichert und verwendet, ohne sie zu benennen und den Benutzern unserer
Bibliothek offenzulegen.</p>
<p>Funktionsabschlüsse sind in der Regel kurz und nur in einem engen Kontext und
nicht in jedem beliebigen Szenario relevant. Innerhalb dieser begrenzten
Kontexte kann der Compiler die Typen der Parameter und des Rückgabetyps
ableiten, ähnlich wie er die Typen der meisten Variablen ableiten kann (es gibt
seltene Fälle, in denen der Compiler auch Funktionsabschluss-Typannotationen
benötigt).</p>
<p>Wie bei Variablen können wir Typ-Annotationen hinzufügen, wenn wir die
Explizitheit und Klarheit erhöhen wollen, auch wenn wir dafür ausführlicher
sind als unbedingt nötig. Die Annotation der Typen für einen Funktionsabschluss
würde wie die in Codeblock 13-2 gezeigte Definition aussehen. In diesem
Beispiel definieren wir einen Funktionsabschluss und speichern ihn in einer
Variablen, anstatt den Funktionsabschluss an der Stelle zu definieren, an der
wir ihn als Argument übergeben, wie wir es in Codeblock 13-1 getan haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!("rechnet langsam...");
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("Mach heute {} Liegestütze!", expensive_closure(intensity));
</span><span class="boring">        println!("Als nächstes {} Sit-ups!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Mach heute eine Pause! Denk daran, ausreichend zu trinken!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "Heute, {} Minuten Lauftraining!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-2: Hinzufügen optionaler Datentypangabe der
Parameter- und Rückgabewert-Typen im Funktionsabschluss</span></p>
<p>Mit Typ-Annotationen ähnelt die Syntax eines Funktionsabschlusses sehr der
Syntax einer Funktion. Hier definieren wir eine Funktion, die zu ihrem
Parameter den Wert 1 addiert, und zum Vergleich einen Funktionsabschluss mit
identischem Verhalten. Zur besseren Darstellung der relevanten Teile haben wir
einige Leerzeichen eingefügt. Dies zeigt, wie ähnlich die Syntax von Funktionen
der von Funktionsabschlüssen ist, abgesehen von den senkrechten Strichen und
der Möglichkeit, einen Teil der Syntax wegzulassen:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>Die erste Zeile zeigt eine Funktionsdefinition und die zweite eine Definition
eines Funktionsabschlusses mit allen Datentypangaben. In der dritten Zeile
werden die Datentypangaben aus der Funktionsabschluss-Definition entfernt,
und in der vierten Zeile werden die geschweiften Klammern weggelassen, die
optional sind, da der Funktionsabschluss-Rumpf nur einen Ausdruck beinhaltet.
All diese Ausdrücke sind gültig und verhalten sich beim Aufruf gleich. Von
<code>add_one_v3</code> und <code>add_one_v4</code> wird ein Aufruf zum Kompilieren des Codes
benötigt, da hier die Typen abhängig von der Verwendung abgeleitet werden. Dies
ist vergleichbar mit <code>let v = Vec::new();</code>, bei dem entweder Typ-Annotationen
oder Werte eines bestimmten Typs in den <code>Vec</code> eingefügt werden müssen, damit
Rust den Typ ableiten kann.</p>
<p>Bei Funktionsabschlussdefinitionen wird für jeden Parameter und für den
Rückgabewert ein konkreter Typ abgeleitet. Codeblock 13-3 zeigt zum Beispiel
die Definition eines kurzen Funktionsabschlusses, der nur den Wert des
übergebenen Parameters zurückgibt. Dieser Funktionsabschluss ist außer für
dieses Beispiel nicht weiter nützlich. Beachte, dass wir der Definition keine
Datentypangaben hinzugefügt haben. Da es keine Typ-Annotationen gibt, können
wir den Funktionsabschluss mit einem beliebigen Typ aufrufen, was wir hier mit
<code>String</code> das erste Mal getan haben. Wenn wir dann versuchen, <code>example_closure</code>
mit einer Ganzzahl aufzurufen, erhalten wir einen Fehler.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let example_closure = |x| x;

let s = example_closure(String::from("hallo"));
let n = example_closure(5);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Codeblock 13-3: Versuchter Aufruf eines
Funktionsabschlusses, dem zwei unterschiedliche Typen übergeben wurden</span></p>
<p>Der Compiler gibt diesen Fehler aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
</code></pre>
<p>Beim ersten Aufruf von <code>example_closure</code> wird dem Typ von <code>x</code> und dem
Rückgabewert des Funktionsabschlusses der Typ <code>String</code> zugewiesen. Diese Typen
sind dann für den Funktionsabschluss <code>example_closure</code> festgeschrieben. Daher
bekommen wir eine Fehlermeldung, wenn wir versuchen einen anderen Typ mit dem
gleichen Funktionsabschluss zu benutzen.</p>
<h3 id="erfassen-von-referenzen-oder-verschieben-der-eigentümerschaft"><a class="header" href="#erfassen-von-referenzen-oder-verschieben-der-eigentümerschaft">Erfassen von Referenzen oder Verschieben der Eigentümerschaft</a></h3>
<p>Funktionsabschlüsse können Werte aus ihrer Umgebung auf drei Arten erfassen,
die direkt den drei Möglichkeiten entsprechen, wie eine Funktion einen
Parameter aufnehmen kann: Unveränderbare Ausleihen (borrowing immutably),
veränderbare Ausleihen (borrowing mutably) und Eigentümerschaft übernehmen
(taking ownership). Der Funktionsabschluss entscheidet, welche dieser
Möglichkeiten verwendet wird, je nachdem, was der Rumpf der Funktion mit den
erfassten Werten macht.</p>
<p>In Codeblock 13-4 definieren wir einen Funktionsabschluss, der eine
unveränderbare Referenz an den Vektor mit dem Namen <code>list</code> erfasst, weil er
nur eine unveränderbare Referenz benötigt, um den Wert auszugeben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let list = vec![1, 2, 3];
    println!("Vor der Funktionsabschlussdefinition: {list:?}");

    let only_borrows = || println!("Im Funktionsabschluss: {list:?}");

    println!("Vor dem Funktionsabschluss-Aufruf: {list:?}");
    only_borrows();
    println!("Nach dem Funktionsabschluss-Aufruf: {list:?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 13-4: Definieren und Aufrufen eines
Funktionsabschlusses, der eine unveränderbare Referenz erfasst</span></p>
<p>Dieses Beispiel veranschaulicht auch, dass eine Variable an eine
Funktionsabschlussdefinition gebunden werden kann, und wir den
Funktionsabschluss später aufrufen können, indem wir den Variablennamen und die
Klammern verwenden, als ob der Variablenname ein Funktionsname wäre.</p>
<p>Da wir mehrere unveränderbare Referenzen auf <code>list</code> zur gleichen Zeit haben
können, ist <code>list</code> immer noch vom Code vor der Funktionsabschlussdefinition
zugreifbar, sowie nach der Funktionsabschlussdefinition und vor dem Aufruf des
Funktionsabschlusses, und nach dem Aufruf des Funktionsabschlusses. Dieser Code
kompiliert, läuft und gibt folgendes aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Vor der Funktionsabschlussdefinition: [1, 2, 3]
Vor dem Funktionsabschluss-Aufruf: [1, 2, 3]
Im Funktionsabschluss: [1, 2, 3]
Nach dem Funktionsabschluss-Aufruf: [1, 2, 3]
</code></pre>
<p>In Codeblock 13-5 wird die Definition des Funktionsabschlusses so geändert,
dass er ein Element zum Vektor <code>list</code> hinzufügt. Der Funktionsabschluss erfasst
nun eine veränderbare Referenz:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut list = vec![1, 2, 3];
    println!("Vor der Funktionsabschlussdefinition: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("Nach dem Funktionsabschluss-Aufruf: {list:?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 13-5: Definieren und Aufrufen eines
Funktionsabschlusses, der eine veränderbare Referenz erfasst</span></p>
<p>Dieser Code kompiliert, läuft und gibt aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Vor der Funktionsabschlussdefinition: [1, 2, 3]
Nach dem Funktionsabschluss-Aufruf: [1, 2, 3, 7]
</code></pre>
<p>Beachte, dass es kein <code>println!</code> mehr zwischen der Definition und dem Aufruf
des Funktionsabschlusses <code>borrows_mutably</code> gibt: Wenn <code>borrows_mutably</code>
definiert ist, erfasst es eine veränderbare Referenz auf <code>list</code>. Der
Funktionsabschluss wird nicht mehr verwendet, nachdem er aufgerufen wurde,
daher endet die veränderbare Ausleihe. Zwischen der
Funktionsabschlussdefinition und dem Funktionsabschluss-Aufruf ist eine
unveränderbare Ausleihe für die Ausgabe nicht erlaubt, weil keine anderen
Ausleihen erlaubt sind, wenn es eine veränderbare Ausleihe gibt. Versuche,
dort ein <code>println!</code> hinzuzufügen, um zu sehen, welche Fehlermeldung du
erhältst!</p>
<p>Wenn du den Funktionsabschluss zwingen willst, die Eigentümerschaft der Werte,
die er in der Umgebung verwendet, zu übernehmen, obwohl der Rumpf des
Funktionsabschlusses nicht unbedingt Eigentümer sein muss, kannst du das
Schlüsselwort <code>move</code> vor der Parameterliste verwenden.</p>
<p>Diese Technik ist vor
allem nützlich, wenn ein Funktionsabschluss an einen neuen Strang (thread)
übergeben wird, um die Daten zu verschieben, sodass sie dem neuen Strang
gehören. Wir werden in Kapitel 16, wenn wir über Nebenläufigkeit (concurrency)
sprechen, detailliert auf Stränge eingehen und erläutern, warum man sie
verwenden sollte, aber jetzt wollen wir uns kurz mit dem Erzeugen eines neuen
Strangs mithilfe eines Funktionsabschlusses befassen, der das Schlüsselwort
<code>move</code> benötigt. Codeblock 13-6 zeigt Codeblock 13-4 modifiziert, um den Vektor
in einem neuen Strang statt im Hauptstrang auszugeben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Vor der Funktionsabschlussdefinition: {list:?}");

    thread::spawn(move || println!("Im Strang: {list:?}"))
        .join()
        .unwrap();
}</code></pre></pre>
<p><span class="caption">Codeblock 13-6: Verwenden von <code>move</code>, um den
Funktionsabschluss des Strangs zu erzwingen, die Eigentümerschaft an <code>list</code> zu
übernehmen</span></p>
<p>Wir starten einen neuen Strang und geben ihm einen Funktionsabschluss als
Argument mit. Der Rumps des Funktionsabschlusses gibt die Liste aus. In
Codeblock 13-4 hat der Funktionsabschluss nur <code>list</code> mit einer unveränderbaren
Referenz erfasst, weil das die kleinste Zugriffmenge auf <code>list</code> ist, die
benötigt wird, um sie auszugeben. In diesem Beispiel müssen wir, obwohl der
Funktionsabschluss-Rumpf nur eine unveränderbare Referenz benötigt, angeben,
dass <code>list</code> in den Funktionsabschluss verschoben werden soll, indem wir das
Schlüsselwort <code>move</code> an den Anfang der Funktionsabschlussdefinition setzen.
Der neue Strang könnte beendet werden, bevor der Rest des Hauptstrangs beendet
wird, oder der Hauptstrang könnte zuerst beendet werden. Wenn der Hauptstrang
die Eigentümerschaft von <code>list</code> beibehält, aber vor dem neuen Strang endet und
<code>list</code> aufräumt, wäre die unveränderbare Referenz im Strang ungültig. Daher
verlangt der Compiler, dass <code>list</code> in den Funktionsabschluss im neuen Strang
verschoben wird, damit die Referenz gültig bleibt. Versuche, das Schlüsselwort
<code>move</code> zu entfernen oder <code>list</code> im Hauptstrang zu verwenden, nachdem der
Funktionsabschluss definiert wurde, um zu sehen, welche Compilerfehler du
erhältst!</p>
<h3 id="verschieben-erfasster-werte-aus-funktionsabschlüssen-und-fn-merkmalen"><a class="header" href="#verschieben-erfasster-werte-aus-funktionsabschlüssen-und-fn-merkmalen">Verschieben erfasster Werte aus Funktionsabschlüssen und <code>Fn</code>-Merkmalen</a></h3>
<p>Sobald ein Funktionsabschluss eine Referenz oder die Eigentümerschaft eines
Werts aus der Umgebung, in der der Funktionsabschluss definiert ist, erfasst
hat (und damit beeinflusst, was <em>in</em> den Funktionsabschluss verschoben wird),
definiert der Code im Rumpf des Funktionsabschlusses, was mit den Referenzen
oder Werten passiert, wenn der Funktionsabschluss später ausgewertet wird (und
damit beeinflusst, was <em>aus</em> dem Funktionsabschluss verschoben wird). Ein
Funktionsabschluss-Rumpf kann eine der folgenden Aktionen ausführen: Einen
erfassten Wert aus dem Funktionsabschluss herausbewegen, den erfassten Wert
verändern, den Wert weder bewegen noch verändern oder zunächst nichts aus der
Umgebung erfassen.</p>
<p>Die Art und Weise, wie ein Funktionsabschluss Werte aus der Umgebung erfasst
und verarbeitet, wirkt sich darauf aus, welche Merkmale (traits) der
Funktionsabschluss implementiert, und mit Hilfe von Merkmalen können Funktionen
und Strukturen angeben, welche Arten von Funktionsabschlüssen sie verwenden
können. Funktionsabschlüsse implementieren automatisch eine, zwei oder alle
drei dieser <code>Fn</code>-Merkmale, und zwar in additiver Weise, je nachdem, wie der
Rumpf des Funktionsabschlusses die Werte behandelt:</p>
<ol>
<li><code>FnOnce</code> gilt für Funktionsabschlüsse, die einmal aufgerufen
werden können. Alle Funktionsabschlüsse implementieren zumindest dieses
Merkmal, weil alle Funktionsabschlüsse aufgerufen werden können. Ein
Funktionsabschluss, der erfasste Werte aus seinem Rumpf herausverschiebt,
implementiert nur <code>FnOnce</code> und keine der anderen <code>Fn</code>-Merkmale, weil er nur
einmal aufgerufen werden kann.</li>
<li><code>FnMut</code> gilt für Funktionsabschlüsse, die die erfassten Werte nicht aus
ihrem Rumpf herausverschieben, aber die erfassten Werte möglicherweise
verändern. Diese Funktionsabschlüsse können mehr als einmal aufgerufen
werden.</li>
<li><code>Fn</code> gilt für Funktionsabschlüsse, die die erfassten Werte nicht aus ihrem
Rumpf herausverschieben und die erfassten Werte nicht verändern, sowie
Funktionsabschlüsse, die nichts aus ihrer Umgebung erfassen. Diese
Funktionsabschlüsse können mehr als einmal aufgerufen werden, ohne ihre
Umgebung zu verändern, was wichtig ist, wenn z.B. ein Funktionsabschluss
mehrere Male gleichzeitig aufgerufen wird.</li>
</ol>
<p>Schauen wir uns die Definition der Methode <code>unwrap_or_else</code> auf <code>Option&lt;T&gt;</code> an,
die wir in Codeblock 13-1 verwendet haben:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Erinnere dich, dass <code>T</code> der generische Typ ist, der den Typ des Wertes in der
<code>Some</code>-Variante einer <code>Option</code> darstellt. Dieser Typ <code>T</code> ist auch der
Rückgabetyp der Funktion <code>unwrap_or_else</code>: Code, der <code>unwrap_or_else</code> auf einer
<code>Option&lt;String&gt;</code> aufruft, erhält zum Beispiel einen <code>String</code>.</p>
<p>Als Nächstes ist zu beachten, dass die Funktion <code>unwrap_or_else</code> den
zusätzlichen generischen Typ-Parameter <code>F</code> hat. Der Typ <code>F</code> ist der Typ des
Parameters namens <code>f</code>, der der Funktionsabschluss ist, den wir beim Aufruf von
<code>unwrap_or_else</code> bereitstellen.</p>
<p>Die für den generischen Typ <code>F</code> spezifizierte Merkmalsabgrenzung ist <code>FnOnce() -&gt; T</code>, was bedeutet, dass <code>F</code> mindestens einmal aufgerufen werden können muss,
keine Argumente annimmt und ein <code>T</code> zurückgeben muss. Die Verwendung von
<code>FnOnce</code> in der Merkmalsabgrenzung drückt die Einschränkung aus, dass
<code>unwrap_or_else</code> <code>f</code> höchstens ein Mal aufrufen wird. Im Rumpf von
<code>unwrap_or_else</code> können wir sehen, dass, wenn die <code>Option</code> <code>Some</code> ist, <code>f</code>
nicht aufgerufen wird. Wenn die <code>Option</code> <code>None</code> ist, wird <code>f</code> einmal
aufgerufen. Da alle Funktionsabschlüsse <code>FnOnce</code> implementieren, akzeptiert
<code>unwrap_or_else</code> alle drei Arten von Funktionsabschlüssen und ist so flexibel
wie nur möglich.</p>
<blockquote>
<p>Anmerkung: Wenn das, was wir tun wollen, keine Erfassung eines Wertes aus der
Umgebung erfordert, können wir den Namen einer Funktion anstelle eines
Funktionsabschlüsses verwenden. Zum Beispiel könnten wir
<code>unwrap_or_else(Vec::new)</code> auf einem <code>Option&lt;Vec&lt;T&gt;&gt;</code>-Wert aufrufen, um einen
neuen, leeren Vektor zu erhalten, wenn der Wert <code>None</code> ist. Der Compiler
implementiert automatisch die <code>Fn</code>-Merkmale, die für eine Funktionsdefinition
anwendbar sind.</p>
</blockquote>
<p>Schauen wir uns nun die Standard-Bibliotheksmethode <code>sort_by_key</code> an, die auf
Anteilstypen (slices) definiert ist, um zu sehen, wie sie sich von <code>unwrap_or_else</code>
unterscheidet und warum <code>sort_by_key</code> <code>FnMut</code> statt <code>FnOnce</code> für die
Mermalsabgrenzung verwendet. Der Funktionsabschluss erhält ein Argument, eine
Referenz auf das aktuelle Element im betrachteten Anteilstyp, und gibt einen
Wert vom Typ <code>K</code> zurück, der geordnet werden kann. Diese Funktion ist nützlich,
wenn man einen Anteilstyp nach einem bestimmten Attribut der einzelnen Elemente
sortieren will. In Codeblock 13-7 haben wir eine Liste von
<code>Rectangle</code>-Instanzen und benutzen <code>sort_by_key</code>, um sie nach ihrem
<code>width</code>-Attribut von niedrig nach hoch zu sortieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 13-7: Verwenden von <code>sort_by_key</code> um Rechtecke
nach ihrer Breite zu sortieren</span></p>
<p>Dieser Code gibt aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>Der Grund, warum <code>sort_by_key</code> so definiert ist, dass es einen
<code>FnMut</code>-Funktionsabschluss nimmt, ist, dass es den Funktionsabschluss mehrfach
aufruft: Einmal für jedes Element im Anteilstyp. Der Funktionsabschluss <code>|r| r.width</code> erfasst, verändert oder verschiebt nichts aus seiner Umgebung, sodass
er die Anforderungen der Merkmalsabgrenzung erfüllt.</p>
<p>Im Gegensatz dazu zeigt Codeblock 13-8 ein Beispiel für einen
Funktionsabschluss, der nur das Merkmal <code>FnOnce</code> implementiert, weil er einen
Wert aus der Umgebung verschiebt. Der Compiler lässt uns diesen
Funktionsabschluss nicht mit <code>sort_by_key</code> verwenden:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("Funktionsabschluss aufgerufen");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}</code></pre></pre>
<p><span class="caption">Codeblock 13-8: Versuch, einen <code>FnOnce</code>-Funktionsabschluss
mit <code>sort_by_key</code> zu verwenden</span></p>
<p>Dies ist ein ausgeklügelter, verworrener Weg (der nicht funktioniert), der
versucht die Anzahl der Aufrufe des Funktionsabschlusses durch <code>sort_by_key</code>
beim Sortieren von <code>list</code> zu zählen. Dieser Code versucht diese Zählung
durchzuführen, indem er den <code>String</code> <code>value</code> aus der Umgebung des
Funktionsabschlusses in den Vektor <code>sort_operations</code> verschiebt. Der
Funktionsabschluss erfasst <code>value</code> und verschiebt dann <code>value</code> aus dem
Funktionsabschluss heraus, indem er die Eigentümerschaft von <code>value</code> an den
Vektor <code>sort_operations</code> überträgt. Dieser Funktionsabschluss kann einmal
aufgerufen werden; ein zweiter Aufruf würde nicht funktionieren, da <code>value</code>
nicht mehr in der Umgebung wäre, um erneut in <code>sort_operations</code> verschoben zu
werden! Daher implementiert dieser Funktionsabschluss nur <code>FnOnce</code>. Wenn wir
versuchen, diesen Code zu kompilieren, erhalten wir die Fehlermeldung, dass
<code>value</code> nicht aus dem Funktionsabschluss verschoben werden kann, weil der
Funktionsabschluss <code>FnMut</code> implementieren muss:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from("Funktionsabschluss aufgerufen");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
</code></pre>
<p>Der Fehler bezieht sich auf die Zeile im Funktionsabschluss-Rumpf, die <code>value</code>
aus der Umgebung verschiebt. Um dies zu beheben, müssen wir den Rumpf des
Funktionsabschlusses so ändern, dass er keine Werte aus der Umgebung
verschiebt. Es ist einfacher, einen Zähler in der Umgebung zu halten und seinen
Wert im Funktionsabschluss-Rumpf zu erhöhen, um zu zählen, wie oft
<code>sort_by_key</code> aufgerufen wurde. Der Funktionsabschluss in Codeblock 13-9
funktioniert mit <code>sort_by_key</code>, weil er nur eine veränderbare Referenz auf den
<code>num_sort_operations</code>-Zähler erfasst und daher mehr als einmal aufgerufen
werden kann:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sortiert in {num_sort_operations} Operationen");
}</code></pre></pre>
<p><span class="caption">Codeblock 13-9: Verwenden eines
<code>FnMut</code>-Funktionsabschlusses mit <code>sort_by_key</code> ist erlaubt</span></p>
<p>Die <code>Fn</code>-Merkmale sind wichtig bei der Definition oder Verwendung von
Funktionen oder Typen, die Funktionsabschlüsse verwenden. Im nächsten Abschnitt
besprechen wir Iteratoren. Viele Iterator-Methoden nehmen
Funktionsabschluss-Argumente entgegen, also behalte diese Details von
Funktionsabschlüssen im Kopf, wenn wir weitermachen!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-00-functional-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch13-02-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-00-functional-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch13-02-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>



    </div>
    </body>
</html>
